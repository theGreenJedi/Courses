1
00:00:00,140 --> 00:00:01,310
अब तक हम बात करते रहें हैं

2
00:00:01,640 --> 00:00:03,290
SVMs के बारे में संक्षेप में.

3
00:00:03,980 --> 00:00:05,030
इस वीडियो में मैं चाहूँगा

4
00:00:05,200 --> 00:00:06,460
बात करना कि क्या आपको वास्तव में चाहिए

5
00:00:06,740 --> 00:00:09,410
रन करने या इस्तेमाल करने के लिए एक SVM.

6
00:00:11,320 --> 00:00:12,300
सपोर्ट वेक्टर मशीन अल्गोरिद्म

7
00:00:12,850 --> 00:00:14,870
देता है एक ख़ास ऑप्टिमायज़ेशन प्रॉब्लम.

8
00:00:15,530 --> 00:00:16,940
लेकिन जैसे कि मैंने संक्षेप में उल्लेख किया है

9
00:00:17,120 --> 00:00:18,150
पहले के एक वीडियो में, मैं वास्तव में

10
00:00:18,380 --> 00:00:20,570
नहीं सलाह देता लिखने की आपका

11
00:00:20,630 --> 00:00:22,810
अपना सॉफ़्टवेयर हल करने के लिए पेरमिटर्स थीटा ख़ुद से.

12
00:00:23,950 --> 00:00:26,110
तो जैसे आजकल, बहुत

13
00:00:26,420 --> 00:00:27,730
कम हम में से, या शायद लगभग

14
00:00:28,090 --> 00:00:29,400
हम में से कोई भी नहीं सोचेगा

15
00:00:29,530 --> 00:00:31,680
लिखने का कोड ख़ुद से इन्वर्ट करने के लिए एक मेट्रिक्स

16
00:00:31,950 --> 00:00:33,940
या स्क्वेर रूट लेने के लिए एक नम्बर का, इत्यादि.

17
00:00:34,190 --> 00:00:36,570
हम सिर्फ़, आप जानते हैं, कॉल करते हैं कोई लाइब्रेरी फ़ंक्शन वह करने के लिए.

18
00:00:36,700 --> 00:00:38,090
उसी प्रकार,

19
00:00:38,850 --> 00:00:40,310
सॉफ्टवेयर हल करने के लिए SVM

20
00:00:40,620 --> 00:00:42,200
ऑप्टिमायज़ेशन प्रॉब्लम है बहुत

21
00:00:42,440 --> 00:00:43,880
जटिल, और हैं

22
00:00:43,990 --> 00:00:44,960
बहुत से शोधकर्ता जो कर रहे हैं

23
00:00:45,110 --> 00:00:47,560
कर रहे हैं अनिवार्यत: नूमेरिकल ऑप्टिमायज़ेशन रीसर्च कई वर्षों से.

24
00:00:47,850 --> 00:00:48,960
तो आप बनाते हैं अच्छी

25
00:00:49,150 --> 00:00:50,550
सॉफ़्टवेयर लाइब्रेरीज़ और बढ़िया सॉफ़्टवेयर

26
00:00:50,930 --> 00:00:52,270
पैकिजेज़ इसे करने के लिए.

27
00:00:52,470 --> 00:00:53,480
और मैं ज़ोर देकर रेकमेंड करूँगा कि सिर्फ़ इस्तेमाल करें

28
00:00:53,860 --> 00:00:55,260
कोई अधिक ऑप्टिमायज़्ड सॉफ़्टवेयर

29
00:00:55,710 --> 00:00:57,780
लाइब्रेरी बजाय कोशिश करने के इम्प्लमेंट करने की कुछ ख़ुद से.

30
00:00:58,730 --> 00:01:00,680
और हैं बहुत सी अच्छी इस तरह की लाइब्रेरीज़.

31
00:01:00,970 --> 00:01:02,060
टूल जो मैं

32
00:01:02,210 --> 00:01:03,220
इस्तेमाल करता हूँ अक्सर हैं

33
00:01:03,400 --> 00:01:05,000
लिनीअर SVM लेकिन वास्तव में हैं

34
00:01:05,410 --> 00:01:06,860
बहुत सी बढ़िया सॉफ़्टवेयर लाइब्रेरीज़

35
00:01:07,030 --> 00:01:08,430
करने के लिए इसे जो, आप जानते हैं, आप कर सकते हैं

36
00:01:08,600 --> 00:01:10,190
लिंक बहुत सी

37
00:01:10,450 --> 00:01:11,860
प्रमुख प्रोग्रामिंग लैंग्विजेज़ के साथ जो आप

38
00:01:11,950 --> 00:01:14,410
शायद इस्तेमाल कर रहे हों कोड करने के लिए लर्निंग अल्गोरिद्म.

39
00:01:15,280 --> 00:01:16,460
हालांकि आपको नहीं लिखना चाहिए

40
00:01:16,730 --> 00:01:18,330
आपका अपना SVM ऑप्टिमायज़ेशन सॉफ़्टवेयर,

41
00:01:19,120 --> 00:01:20,680
कुछ चीज़ें हैं आपको करनी चाहिए, फिर भी.

42
00:01:21,420 --> 00:01:23,130
पहला है कि बनाएँ

43
00:01:23,130 --> 00:01:24,230
कुछ विकल्प

44
00:01:24,320 --> 00:01:25,640
पेरामिटर C के लिए. हमने बात की थी

45
00:01:25,940 --> 00:01:26,930
थोड़ी बहुत बाइयस/वेरीयन्स गुणों की

46
00:01:27,040 --> 00:01:28,850
इसके पिछले वीडियो में.

47
00:01:30,290 --> 00:01:31,480
दूसरा, आप को ज़रूरत है

48
00:01:31,630 --> 00:01:33,040
चुनने की कर्नल या

49
00:01:33,410 --> 00:01:34,880
समानता फ़ंक्शन जो आप इस्तेमाल करना चाहते हैं.

50
00:01:35,730 --> 00:01:37,080
तो एक विकल्प हो सकता है

51
00:01:37,280 --> 00:01:38,980
कि हम तय करें कि कोई कर्नल नहीं लेना है.

52
00:01:40,560 --> 00:01:41,510
और कर्नल न लेने के विचार को

53
00:01:41,910 --> 00:01:43,600
लिनीअर कर्नल भी कहते हैं.

54
00:01:44,130 --> 00:01:45,320
तो यदि कोई कहता है, मैं इस्तेमाल करता हूँ

55
00:01:45,530 --> 00:01:46,760
एक SVM एक लिनीअर कर्नल के साथ,

56
00:01:47,180 --> 00:01:48,330
उसका क्या मतलब है, आप जानते हैं, कि वे इस्तेमाल करते हैं

57
00:01:48,490 --> 00:01:50,690
एक SVM बिना उपयोग किए

58
00:01:51,020 --> 00:01:52,250
एक कर्नल और यह

59
00:01:52,360 --> 00:01:53,410
था एक वर्ज़न SVM का

60
00:01:54,120 --> 00:01:55,870
जो सिर्फ़ इस्तेमाल करता है थीटा ट्रान्स्पोज़ X, ठीक है,

61
00:01:56,140 --> 00:01:57,620
जो प्रिडिक्ट करता हैं 1 थीटा 0

62
00:01:57,850 --> 00:01:59,420
प्लस थीटा 1 x1

63
00:01:59,740 --> 00:02:01,000
प्लस इसी प्रकार आगे प्लस थीटा

64
00:02:01,690 --> 00:02:04,160
n, Xn है बड़ा या बराबर 0 के.

65
00:02:05,520 --> 00:02:06,830
इस टर्म लिनीअर कर्नल को, आप

66
00:02:06,950 --> 00:02:08,250
सोच सकते हैं इसे आप जानते हैं यह

67
00:02:08,480 --> 00:02:09,290
है वर्ज़न SVM का

68
00:02:10,340 --> 00:02:12,320
जो सिर्फ़ देता है आपको एक स्टैंडर्ड लिनीअर क्लैसिफ़ायअर.

69
00:02:13,940 --> 00:02:14,700
तो वह होगा एक

70
00:02:15,040 --> 00:02:16,160
उचित विकल्प कुछ प्राब्लम्ज़ के लिए,

71
00:02:17,130 --> 00:02:18,080
और आप जानते हैं, ऐसे बहुत सी सॉफ़्टवेयर

72
00:02:18,470 --> 00:02:20,900
लाइब्रेरीज़ होंगी, जैसे लिनीअर SVM, था

73
00:02:21,210 --> 00:02:22,320
एक उदाहरण, कई में से एक,

74
00:02:22,840 --> 00:02:23,880
एक उदाहरण एक सोफ़्टवेयर लाइब्रेरी का

75
00:02:24,560 --> 00:02:25,620
जो कर सकती हैं ट्रेन एक SVM

76
00:02:25,980 --> 00:02:27,410
बिना इस्तेमाल किए एक कर्नल,

77
00:02:27,760 --> 00:02:29,470
जिसे लिनीअर कर्नल भी कहते हैं.

78
00:02:29,850 --> 00:02:31,340
तो, क्यों आप इसे करना चाहते हैं?

79
00:02:31,410 --> 00:02:32,820
यदि आपके पास हैं एक बड़ी संख्या

80
00:02:33,150 --> 00:02:34,280
फ़ीचर्ज़ की, यदि n है

81
00:02:34,430 --> 00:02:37,800
बड़ा, और m

82
00:02:37,990 --> 00:02:39,590
संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की है

83
00:02:39,670 --> 00:02:41,050
कम, तब आप जानते हैं

84
00:02:41,230 --> 00:02:42,300
आपके पास हैं एक बहुत बड़ी संख्या

85
00:02:42,360 --> 00:02:43,630
फ़ीचर्ज़ की जो यदि x है, यह है

86
00:02:43,710 --> 00:02:45,850
एक x, है एक Rn, Rn + 1.

87
00:02:46,010 --> 00:02:46,940
अत:, यदि आपके पास है एक

88
00:02:47,080 --> 00:02:48,700
बड़ी संख्या फ़ीचर्ज़ की पहले से ही,

89
00:02:48,800 --> 00:02:50,540
एक ट्रेनिंग सेट में, आप जानते हैं, शायद आप

90
00:02:50,610 --> 00:02:51,430
चाहेंगे सिर्फ़ फ़िट करना एक लिनीअर

91
00:02:51,710 --> 00:02:52,890
निर्णायक सीमा रेखा और नहीं प्रयास करेंगे

92
00:02:53,060 --> 00:02:54,420
फ़िट करने का एक बहुत जटिल नॉन-लिनीअर

93
00:02:54,860 --> 00:02:56,980
फ़ंक्शन, क्योंकि हमारे पास शायद पर्याप्त डेटा नहीं है.

94
00:02:57,560 --> 00:02:59,330
और शायद ओवरफ़िटिंग हो सकती है, यदि

95
00:02:59,470 --> 00:03:00,530
आप कोशिश करें फ़िट करने की एक बहुत जटिल फ़ंक्शन

96
00:03:01,540 --> 00:03:03,220
एक बड़ी डिमेन्शन कि फ़ीचर स्पेस में,

97
00:03:03,980 --> 00:03:04,990
लेकिन यदि आपका ट्रेनिंग सेट सैम्पल

98
00:03:05,040 --> 00:03:07,120
छोटा है. तो यह

99
00:03:07,340 --> 00:03:08,600
होगी एक उचित सेटिंग जहाँ

100
00:03:08,740 --> 00:03:09,950
आप शायद तय करें सिर्फ़

101
00:03:10,700 --> 00:03:11,960
नहीं लेना है एक कर्नल, या

102
00:03:12,250 --> 00:03:15,580
करना है इस्तेमाल जिसे कहते हैं एक लिनीअर कर्नल.

103
00:03:15,740 --> 00:03:16,740
दूसरा विकल्प कर्नल के लिए जो

104
00:03:16,820 --> 00:03:18,010
शायद आप ले, है यह गॉशियन

105
00:03:18,370 --> 00:03:19,920
कर्नल, और यह है जो हमारे पास था पहले.

106
00:03:21,270 --> 00:03:22,350
और यदि आप इसे करते हैं, तब

107
00:03:22,440 --> 00:03:23,130
दूसरा विकल्प जो आपको चुनना है

108
00:03:23,420 --> 00:03:25,980
कि चुनाव करने इस पेरामिटर सिगम स्क्वेर्ड का

109
00:03:26,850 --> 00:03:29,800
जब हमने बात की थोड़ी बहुत बाइयस/ वेरीयन्स ट्रेड ऑफ़ के बारे में

110
00:03:30,820 --> 00:03:32,360
कि कैसे, यदि सिग्मा स्क्वेर्ड है

111
00:03:32,600 --> 00:03:33,890
बड़ा, तब आपके

112
00:03:34,160 --> 00:03:35,580
पास है एक अपेक्षाकृत अधिक बाइयस, कम

113
00:03:35,770 --> 00:03:37,650
वेरीयन्स का क्लैसिफ़ायअर, लेकिन यदि

114
00:03:37,800 --> 00:03:39,700
सिग्मा स्क्वेर्ड है कम, तब आपके

115
00:03:40,060 --> 00:03:42,360
पास है एक अधिक वेरीयन्स, कम बाइयस क्लैसिफ़ायअर.

116
00:03:43,940 --> 00:03:45,350
तो कब आप चुनेंगे एक गॉशियन कर्नल?

117
00:03:46,210 --> 00:03:48,050
ठीक है, यदि आपकी डिमेन्शन

118
00:03:48,310 --> 00:03:49,540
फ़ीचर्ज़ x की, मेरा मतलब है

119
00:03:49,820 --> 00:03:51,370
Rn, और यदि n है

120
00:03:51,570 --> 00:03:53,890
छोटा, और वास्तव में, आप जानते हैं,

121
00:03:55,660 --> 00:03:57,110
यदि m है बड़ा, ठीक है,

122
00:03:58,470 --> 00:04:00,170
तो वह है, यदि, आप जानते हैं, हमारे पास है

123
00:04:00,550 --> 00:04:02,340
मान लो, एक दो-डिमेन्शन का ट्रेनिंग सेट,

124
00:04:03,130 --> 00:04:04,880
जैसे कि उदाहरण मैंने बनाया था पहले.

125
00:04:05,470 --> 00:04:08,320
तो यदि n है बराबर 2, लेकिन हमारे पास है एक काफ़ी बड़ा ट्रेनिंग सेट.

126
00:04:08,680 --> 00:04:09,770
तो, आप जानते हैं, मैंने बनाया है एक

127
00:04:09,950 --> 00:04:10,890
बड़ी संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की,

128
00:04:11,650 --> 00:04:12,410
तब शायद आप चाहते हैं इस्तेमाल करना

129
00:04:12,540 --> 00:04:14,400
एक कर्नल फ़िट करने के लिए एक अधिक

130
00:04:14,910 --> 00:04:16,260
जटिल नॉन-लिनीअर निर्णायक सीमा रेखा,

131
00:04:16,650 --> 00:04:18,750
और गॉशियन कर्नल होगा एक सही तरीक़ा करने का इसे.

132
00:04:19,480 --> 00:04:20,610
मैं इस बारे में और अधिक कहूँगा अंत में

133
00:04:20,720 --> 00:04:22,570
वीडियो के, थोड़ा

134
00:04:22,660 --> 00:04:23,760
और कि कब आप शायद चुने एक

135
00:04:23,970 --> 00:04:26,310
लिनीअर कर्नल, एक गॉशियन कर्नल इत्यादि.

136
00:04:27,860 --> 00:04:29,740
लेकिन वस्तुत:, यदि आप

137
00:04:30,040 --> 00:04:31,210
तय करते हैं इस्तेमाल करने का एक गॉशियन

138
00:04:31,720 --> 00:04:33,910
कर्नल, तब यहाँ जो आपको करने की ज़रूरत है.

139
00:04:35,380 --> 00:04:36,550
निर्भर करते हुए कि कौन सी सपोर्ट वेक्टर मशीन

140
00:04:37,280 --> 00:04:38,990
सॉफ़्टवेयर पैकिज आप इस्तेमाल करते हैं, यह

141
00:04:39,100 --> 00:04:40,960
आपको पूछ सकता है इम्प्लमेंट करने के लिए एक

142
00:04:41,070 --> 00:04:42,200
कर्नल फ़ंक्शन, या इम्प्लमेंट करने के लिए

143
00:04:43,060 --> 00:04:43,880
समानता फ़ंक्शन.

144
00:04:45,020 --> 00:04:46,750
तो यदि आप इस्तेमाल कर रहे हैं एक

145
00:04:47,010 --> 00:04:49,820
ओकटेव या मैटलैब इम्प्लमेंटेशन

146
00:04:50,000 --> 00:04:50,720
SVM की, यह आपको पूछ सकता है

147
00:04:50,810 --> 00:04:52,560
देने के लिए एक फ़ंक्शन जो

148
00:04:52,690 --> 00:04:54,680
कम्प्यूट करे एक विशेष फ़ीचर कर्नल का.

149
00:04:55,110 --> 00:04:56,480
तो यह है वास्तव में कम्प्यूट करना f

150
00:04:56,770 --> 00:04:57,890
सबस्क्रिप्ट i एक

151
00:04:58,220 --> 00:04:59,560
विशेष वैल्यू के लिए i की, जहाँ

152
00:05:00,570 --> 00:05:02,310
f यहाँ है सिर्फ़ एक

153
00:05:02,330 --> 00:05:03,570
रियल नम्बर, तो शायद

154
00:05:03,840 --> 00:05:05,060
मुझे शायद इसे लिखना चाहिए

155
00:05:05,250 --> 00:05:07,230
f(i), लेकिन क्या आपको

156
00:05:07,510 --> 00:05:08,130
ज़रूरत है करने की कि लिखें एक कर्नल

157
00:05:08,480 --> 00:05:09,530
फ़ंक्शन, जो लेता है यह इनपुट, आप जानते हैं,

158
00:05:10,610 --> 00:05:11,910
एक ट्रेनिंग इग्ज़ाम्पल या एक

159
00:05:12,020 --> 00:05:13,140
टेस्ट इग्ज़ाम्पल जो भी यह लेता है

160
00:05:13,280 --> 00:05:14,640
किसी वेक्टर x में और लेता है

161
00:05:14,990 --> 00:05:16,220
इनपुट कोई एक

162
00:05:16,370 --> 00:05:18,270
लैंडमार्क और लेकिन

163
00:05:18,880 --> 00:05:20,750
मैंने यह सिर्फ़ बनाए हैं x1 और

164
00:05:20,950 --> 00:05:21,810
x2 यहाँ, क्योंकि

165
00:05:21,900 --> 00:05:23,750
लैंडमार्क्स वास्तव में ट्रेनिंग इग्ज़ाम्पल्ज़ ही हैं.

166
00:05:24,470 --> 00:05:26,160
लेकिन क्या आपको

167
00:05:26,400 --> 00:05:27,490
करने की जरूरत है कि लिखें सॉफ्टवेयर जो

168
00:05:27,670 --> 00:05:28,960
लेता है यह इनपुट, आप जानते हैं, x1, x2

169
00:05:29,150 --> 00:05:30,320
और कम्प्यूट करता है इस तरह का

170
00:05:30,580 --> 00:05:31,950
समानता फ़ंक्शन दोनो में

171
00:05:32,530 --> 00:05:33,470
वापिस देता है एक रियल नम्बर.

172
00:05:36,180 --> 00:05:37,430
और तो जो सपोर्ट वेक्टर मशीन

173
00:05:37,580 --> 00:05:39,040
पैकिज करती है कि उम्मीद करती हैं कि

174
00:05:39,510 --> 00:05:40,860
आप दें यह कर्नल फ़ंक्शन

175
00:05:41,410 --> 00:05:44,580
जो लेता हैं यह इनपुट आप जानते हैं, x1, x2 और देता है एक रियल नम्बर.

176
00:05:45,580 --> 00:05:46,460
और फिर यह लेता है इसे वहाँ से

177
00:05:46,850 --> 00:05:49,070
और बना देता है अपने आप सारे फ़ीचर्ज़, और

178
00:05:49,410 --> 00:05:51,480
तो लेता है x और

179
00:05:51,600 --> 00:05:53,370
मैप करता हैं f1,

180
00:05:53,420 --> 00:05:54,420
f2 से f(m) तक इस्तेमाल करके

181
00:05:54,750 --> 00:05:56,200
यह फ़ंक्शन जो आप लिखते हैं, और

182
00:05:56,310 --> 00:05:57,190
बनाता है सारे फ़ीचर्ज़ और

183
00:05:57,650 --> 00:05:59,080
ट्रेन करता हैं सपोर्ट वेक्टर मशीन को उससे आगे.

184
00:05:59,870 --> 00:06:00,800
लेकिन कभी-कभी आपको देना पड़ता है

185
00:06:00,880 --> 00:06:04,710
यह फ़ंक्शन ख़ुद से.

186
00:06:05,680 --> 00:06:06,770
यदि आप इस्तेमाल कर रहे हैं गॉशियन कर्नल, कुछ SVM इम्प्लमेंटेशन्स में 
निहित होता है गॉशियन कर्नल

187
00:06:06,980 --> 00:06:09,950
और

188
00:06:10,040 --> 00:06:10,990
कुछ अन्य कर्नल्स भी, क्योंकि

189
00:06:11,230 --> 00:06:13,580
गॉशियन कर्नल शायद सबसे आम कर्नल है.

190
00:06:14,880 --> 00:06:16,290
गॉशियन तथा लिनीअर कर्नल हैं

191
00:06:16,380 --> 00:06:18,210
वास्तव में दो सबसे अधिक लोकप्रिय कर्नल अभी तक.

192
00:06:19,130 --> 00:06:20,230
सिर्फ़ एक इम्प्लमेंटेशन टिप्पणी.

193
00:06:20,750 --> 00:06:21,820
यदि आपके पास हैं फ़ीचर्ज़ बहुत

194
00:06:22,080 --> 00:06:23,620
भिन्न स्केल पर, यह महतवपूर्ण है

195
00:06:24,700 --> 00:06:26,270
करना फ़ीचर स्केलिंग

196
00:06:26,600 --> 00:06:27,780
इस्तेमाल करने से पहले गॉशियन कर्नल.

197
00:06:28,580 --> 00:06:29,180
और यहाँ है कि ऐसा क्यों.

198
00:06:30,150 --> 00:06:31,600
यदि आप कल्पना करें कम्प्यूट करने के

199
00:06:32,290 --> 00:06:33,570
नॉर्म x और

200
00:06:33,790 --> 00:06:34,890
I में, ठीक है, तो यह टर्म यहाँ,

201
00:06:35,390 --> 00:06:37,150
और नूमरेटर टर्म यहाँ.

202
00:06:38,300 --> 00:06:39,780
यह क्या कर रहा है, नॉर्म

203
00:06:40,070 --> 00:06:40,930
x और I में, वह वास्तव में

204
00:06:41,130 --> 00:06:42,140
बता रहा है, आप जानते हैं, चलो कम्प्यूटर करते हैं वेक्टर

205
00:06:42,450 --> 00:06:43,290
V, जो है बराबर

206
00:06:43,410 --> 00:06:44,980
x माइनस I. और फिर

207
00:06:45,250 --> 00:06:47,940
चलो कम्प्यूट करते हैं नॉर्म

208
00:06:48,130 --> 00:06:49,080
इस वेक्टर V का, जो है

209
00:06:49,170 --> 00:06:50,510
अंतर x और I में. तो

210
00:06:50,580 --> 00:06:51,510
नॉर्म V का है वास्तव में

211
00:06:53,360 --> 00:06:54,140
बराबर V1 स्क्वेर्ड

212
00:06:54,250 --> 00:06:55,610
प्लस V2 स्क्वेर्ड प्लस

213
00:06:55,830 --> 00:06:58,290
डॉट डॉट डॉट, प्लस Vn स्क्वेर्ड.

214
00:06:58,900 --> 00:07:00,320
क्योंकि यहाँ x है

215
00:07:01,060 --> 00:07:02,200
Rn में या Rn

216
00:07:02,290 --> 00:07:05,180
प्लस 1 में, लेकिन मैं अनदेखा करूँगा, आप जानते हैं x0 को.

217
00:07:06,540 --> 00:07:08,420
तो, चलो मान लेते हैं x है

218
00:07:08,510 --> 00:07:10,800
एक Rn, स्क्वेर

219
00:07:10,950 --> 00:07:12,320
बाईं तरफ़ है जो इसे सही बनाता है.

220
00:07:12,570 --> 00:07:14,090
तो यह है बराबर

221
00:07:14,400 --> 00:07:16,120
उसके, ठीक है?

222
00:07:17,210 --> 00:07:18,710
और तो लिखा है अलग ढंग से, यह

223
00:07:18,850 --> 00:07:20,100
होगा x1 - l1

224
00:07:20,290 --> 00:07:22,600
स्क्वेर्ड, प्लस x2

225
00:07:22,910 --> 00:07:24,590
माइनस l2 स्क्वेर्ड प्लस

226
00:07:24,910 --> 00:07:26,580
डॉट डॉट डॉट, प्लस xn माइनस

227
00:07:27,130 --> 00:07:28,540
ln स्क्वेर्ड.

228
00:07:29,720 --> 00:07:30,790
और अब यदि आपके फ़ीचर्ज़

229
00:07:31,850 --> 00:07:33,460
लेते हैं बहुत भिन्न भिन्न रेंज वैल्यूज़ की.

230
00:07:33,940 --> 00:07:35,150
तो लें एक घर की

231
00:07:35,360 --> 00:07:37,180
प्रिडिक्शन, उदाहरण के लिए, यदि

232
00:07:38,020 --> 00:07:40,490
आपका डेटा है कुछ डेटा घरों के बारे में.

233
00:07:41,420 --> 00:07:43,000
और यदि x है

234
00:07:43,140 --> 00:07:44,660
रेंज में हज़ारों स्क्वेर

235
00:07:44,950 --> 00:07:47,190
फ़ीट,

236
00:07:48,010 --> 00:07:48,840
पहले फ़ीचर x1 के लिए.

237
00:07:49,700 --> 00:07:51,630
लेकिन यदि आपका दूसरा फ़ीचर, x2 हैं संख्या शयन कक्षों की.

238
00:07:52,540 --> 00:07:53,610
तो यदि यह है

239
00:07:53,730 --> 00:07:56,720
रेंज में एक से पाँच शयन कक्ष, तो

240
00:07:57,810 --> 00:07:59,320
x1 माइनस l1 होगा बहुत बड़ा.

241
00:07:59,780 --> 00:08:00,820
यह हो सकता है एक हज़ार स्क्वेर्ड,

242
00:08:01,000 --> 00:08:02,880
जबकि x2 माइनस l2

243
00:08:03,200 --> 00:08:04,620
होगा बहुत छोटा और यदि

244
00:08:04,750 --> 00:08:06,800
वह केस हैं, तब इस टर्म में,

245
00:08:08,320 --> 00:08:09,660
वे दूरियाँ होगी लगभग

246
00:08:10,060 --> 00:08:12,060
अनिवार्यत: मुख्य रूप से

247
00:08:12,570 --> 00:08:13,280
घरों के साइज़ की

248
00:08:14,390 --> 00:08:15,760
और संख्या शयन कक्षों की काफ़ी हद तक नज़र अन्दाज़ हो जाएगी.

249
00:08:16,950 --> 00:08:18,060
अत: इससे बचने के लिए

250
00:08:18,230 --> 00:08:19,070
ताकि मशीन काम कर सके

251
00:08:19,360 --> 00:08:21,890
सही ढंग से, अवश्य करें फ़ीचर स्केलिंग.

252
00:08:23,420 --> 00:08:24,830
और यह सुनिश्चित करेगा कि SVM

253
00:08:25,810 --> 00:08:27,020
देता है, आप जानते हैं, तुलनीय ध्यान

254
00:08:27,950 --> 00:08:28,870
सारे आपके भिन्न फ़ीचर्ज़ पर,

255
00:08:29,190 --> 00:08:30,450
और न केवल

256
00:08:30,600 --> 00:08:31,870
जैसे इस उदाहरण में साइज़ पर

257
00:08:32,150 --> 00:08:33,440
घरों के, तो यह था फ़ीचर्ज़ में काफ़ी बड़ा परिवर्तन.

258
00:08:34,700 --> 00:08:35,810
जब आप अप्लाई करते हैं एक सपोर्ट वेक्टर

259
00:08:36,110 --> 00:08:38,760
मशीन सम्भावना है कि अभी तक

260
00:08:38,970 --> 00:08:40,000
तो सबसे अधिक आम

261
00:08:40,460 --> 00:08:41,750
कर्नल आप इस्तेमाल करेंगे होंगे

262
00:08:41,850 --> 00:08:43,120
लिनीअर कर्नल, अर्थात् कोई

263
00:08:43,320 --> 00:08:45,600
कर्नल नहीं, या गॉशियन कर्नल जिसकी हमने बात की थी.

264
00:08:46,520 --> 00:08:47,390
और बस चेतावनी का एक नोट

265
00:08:47,900 --> 00:08:49,070
जो है कि सारे समानता

266
00:08:49,580 --> 00:08:50,590
फ़ंक्शन्स जो आप बनाते है

267
00:08:50,770 --> 00:08:52,520
नहीं होगे वैध कर्नल्स.

268
00:08:53,450 --> 00:08:54,840
और गॉशियन कर्नल तथा लिनीअर

269
00:08:55,090 --> 00:08:56,410
कर्नल और अन्य कर्नल जो आप

270
00:08:56,710 --> 00:08:57,850
कभी कभी और लोग इस्तेमाल करेंगे, सारे

271
00:08:58,030 --> 00:08:59,840
वे संतुष करने चाहिएँ एक तकनीकी गुण.

272
00:09:00,380 --> 00:09:02,510
इसे कहते हैं मर्सरज़ थ्योरम और

273
00:09:02,630 --> 00:09:03,560
वजह कि आपको वह चाहिए है

274
00:09:03,710 --> 00:09:05,430
है क्योंकि सपोर्ट वेक्टर मशीन

275
00:09:06,380 --> 00:09:08,140
अल्गोरिद्म्स या इम्प्लमेंटेशन्स

276
00:09:08,480 --> 00:09:09,560
SVM की में हैं बहुत सी चतुर

277
00:09:10,050 --> 00:09:11,380
नूमेरिकल ऑप्टिमायज़ेशन तरकीबें.

278
00:09:12,110 --> 00:09:13,270
हल करने के लिए

279
00:09:13,340 --> 00:09:15,650
पेरमिटर्स थीटा के लिए कुशलता से और 

280
00:09:16,590 --> 00:09:18,840
परिकल्पित मूल डिजाइन में,

281
00:09:19,470 --> 00:09:21,010
वे हैं निर्णय लिए गए सीमित करने के लिए

282
00:09:21,540 --> 00:09:22,900
हमारा ध्यान सिर्फ़ कर्नल्स पर

283
00:09:23,510 --> 00:09:25,860
जो संतुष्ट करते हैं यह तकनीकी निर्देश जिसे कहते हैं मर्सरज़ थ्योरम.

284
00:09:26,280 --> 00:09:27,360
और वह क्या करता है कि, वह

285
00:09:27,570 --> 00:09:28,540
सुनिश्चित करता है कि सारे ये

286
00:09:28,820 --> 00:09:30,270
SVM पैकिज, सारे ये SVM

287
00:09:30,500 --> 00:09:32,210
सॉफ़्टवेयर पैकिज इस्तेमाल कर सके

288
00:09:32,310 --> 00:09:34,740
एक बड़ा वर्ग ऑप्टिमायज़ेशन का और

289
00:09:35,280 --> 00:09:37,470
जान पाएँ पेरामिटर थीटा जल्दी से.

290
00:09:39,320 --> 00:09:40,340
तो, क्या अधिकांश लोग करते हैं

291
00:09:40,840 --> 00:09:42,470
कि इस्तेमाल करते हैं लिनीअर

292
00:09:42,610 --> 00:09:44,210
या गॉशियन कर्नल, लेकिन हैं

293
00:09:44,430 --> 00:09:45,610
कुछ अन्य कर्नलज़ भी जो

294
00:09:45,940 --> 00:09:47,460
संतुष्ट करते हैं मर्सरज़ थ्योरम और

295
00:09:47,560 --> 00:09:48,690
जो शायद आपको मिलें अन्य

296
00:09:48,850 --> 00:09:50,050
लोग इस्तेमाल करते हुए, हालाँकि मैं स्वयं

297
00:09:50,880 --> 00:09:53,780
इस्तेमाल करता हूँ अन्य कर्नल्स, आप जानते है, कभी कभार ही, यदि करना ही पड़े.

298
00:09:54,160 --> 00:09:56,990
सिर्फ़ बताने के लिए कुछ अन्य कर्नलज़ जो शायद आपको मिलें.

299
00:09:57,990 --> 00:10:00,300
एक है पालिनोमीयल कर्नल.

300
00:10:01,570 --> 00:10:03,350
और उस समानता के लिए

301
00:10:03,800 --> 00:10:05,520
x और l में है

302
00:10:05,730 --> 00:10:06,760
परिभाषित, हैं

303
00:10:06,830 --> 00:10:07,880
बहुत से विकल्प, आप

304
00:10:08,640 --> 00:10:10,370
ले सकते हैं x ट्रान्स्पोज़ l स्क्वेर्ड.

305
00:10:10,960 --> 00:10:13,410
तो यह है एक माप कि कितने समान हैं x और l.

306
00:10:13,610 --> 00:10:14,930
यदि x और l है लगभग बराबर

307
00:10:15,500 --> 00:10:18,260
एक दूसरे के, तब इनर प्रोडक्ट होगा बड़ा.

308
00:10:20,200 --> 00:10:21,870
और इसलिए, आप जानते हैं, यह है थोड़ा

309
00:10:23,080 --> 00:10:23,520
असामान्य कर्नल.

310
00:10:24,000 --> 00:10:25,130
वह उतना अधिक इस्तेमाल नहीं होता, लेकिन

311
00:10:26,490 --> 00:10:29,190
आपको मिल सकते हैं लोग इसे इस्तेमाल करते हुए.

312
00:10:30,050 --> 00:10:31,810
यह है एक वर्ज़न पालिनोमीयल कर्नल का.

313
00:10:32,330 --> 00:10:35,090
दूसरा है x ट्रान्स्पोज़ l क्यूबड.

314
00:10:36,690 --> 00:10:38,780
ये सब हैं उदाहरण पालिनोमीयल कर्नल के.

315
00:10:39,040 --> 00:10:41,270
x ट्रान्स्पोज़ l प्लस 1 क्यूबड.

316
00:10:42,560 --> 00:10:43,620
X ट्रान्स्पोज़ l प्लस शायद

317
00:10:43,910 --> 00:10:44,930
एक संख्या भिन्न एक से 5

318
00:10:44,970 --> 00:10:46,680
और, आप जानते हैं, पॉवर 4 में और

319
00:10:47,700 --> 00:10:49,840
इसलिए पालिनोमीयल कर्नल के वास्तव में हैं दो पेरमिटर्स.

320
00:10:50,610 --> 00:10:53,020
एक है, क्या संख्या आप जोड़ते हैं वहाँ?

321
00:10:53,520 --> 00:10:53,920
यह हो सकती है 0.

322
00:10:54,430 --> 00:10:58,660
यह हैं वास्तव में प्लस 0 यहाँ, तथा जो है डिग्री पालिनोमीयल की वहाँ.

323
00:10:58,680 --> 00:11:01,670
अत: डिग्री पॉवर और ये संख्याएँ.

324
00:11:02,250 --> 00:11:04,140
और सामान्य रूप में,

325
00:11:04,280 --> 00:11:05,530
पालिनोमीयल कर्नल है x

326
00:11:05,720 --> 00:11:07,620
ट्रान्स्पोज़ l, प्लस कुछ

327
00:11:07,940 --> 00:11:11,510
कॉन्स्टंट और फिर

328
00:11:11,800 --> 00:11:14,850
कुछ डिग्री

329
00:11:15,060 --> 00:11:16,720
x1 और इसलिए दोनो

330
00:11:16,940 --> 00:11:19,650
ये हैं पेरमिटर्स पालिनोमीयल कर्नल के लिए.

331
00:11:20,510 --> 00:11:22,820
अत: पालिनोमीयल कर्नल लगभग हमेशा

332
00:11:23,350 --> 00:11:24,440
या अक्सर सही काम नहीं करते.

333
00:11:24,820 --> 00:11:25,950
और गॉशियन कर्नल नहीं करता

334
00:11:26,270 --> 00:11:28,370
उतना इस्तेमाल, लेकिन यह है कुछ जो शायद आपको मिले.

335
00:11:29,320 --> 00:11:30,480
आमतौर पर यह प्रयोग किया जाता है केवल

336
00:11:30,750 --> 00:11:31,710
डेटा के लिए जहाँ x और l

337
00:11:32,000 --> 00:11:33,180
सभी हैं नॉन-नेगेटिव,

338
00:11:33,740 --> 00:11:34,720
और इसलिए वह सुनिश्चित करता है कि ये

339
00:11:34,910 --> 00:11:36,710
इनर प्रोडक्ट कभी भी नेगेटिव नहीं हैं.

340
00:11:37,850 --> 00:11:40,010
और यह कैप्चर करता है अनुभव कि

341
00:11:40,390 --> 00:11:41,340
x और l काफ़ी समान हैं

342
00:11:41,540 --> 00:11:44,110
एक दूसरे के, तब शायद इनर प्रोडक्ट होगा बड़ा.

343
00:11:44,420 --> 00:11:45,590
फिर उनके कुछ अन्य गुण भी हैं

344
00:11:46,260 --> 00:11:48,080
लेकिन लोग इसे बहुत उपयोग नहीं करते हैं.

345
00:11:49,130 --> 00:11:50,150
और फिर, निर्भर करते हुए कि क्या आप

346
00:11:50,260 --> 00:11:51,210
कर रहे हैं, वहाँ अन्य, एक तरह से अधिक

347
00:11:52,330 --> 00:11:54,950
गूढ़ कर्नल भी हैं जो आपके सामने आ सकते हैं.

348
00:11:55,670 --> 00:11:57,180
आप जानते हैं, एक स्ट्रिंग कर्नल होता है, यह

349
00:11:57,340 --> 00:11:58,430
कभी-कभी इस्तेमाल होता है यदि आपका

350
00:11:58,550 --> 00:12:01,350
इनपुट डेटा हैं टेक्स्ट स्ट्रिंग्स या अन्य तरह की स्ट्रिंग्स.

351
00:12:02,270 --> 00:12:02,940
ऐसी चीज़ें भी हैं जैसे

352
00:12:03,260 --> 00:12:06,000
काई-स्क्वेर कर्नल, हिस्टोग्राम इंटर्सेक्शन कर्नल, इत्यादि.

353
00:12:06,690 --> 00:12:08,420
और भी एक तरह से अधिक गूढ़ कर्नल हैं जो

354
00:12:08,660 --> 00:12:09,840
आप इस्तेमाल कर सकते हैं मापने के लिए समानता

355
00:12:10,760 --> 00:12:12,030
विभिन्न वस्तुओं में.

356
00:12:12,660 --> 00:12:13,800
अत: उदाहरण के लिए, यदि आप प्रयास कर रहे हैं

357
00:12:14,380 --> 00:12:15,840
करने का किसी तरह का टेक्स्ट क्लैसिफ़िकेशन

358
00:12:16,170 --> 00:12:17,060
प्रॉब्लम, जहाँ इनपुट

359
00:12:17,200 --> 00:12:19,300
x है एक स्ट्रिंग तब

360
00:12:19,490 --> 00:12:20,490
शायद हम चाहते हैं जानना

361
00:12:20,550 --> 00:12:22,050
समानता दो स्ट्रिंग्स में

362
00:12:22,430 --> 00:12:24,240
इस्तेमाल करके स्ट्रिंग कर्नल, लेकिन मैं

363
00:12:24,520 --> 00:12:26,440
व्यक्तिगत रूप से आप जानते हैं, कभी-कभार ही,

364
00:12:26,990 --> 00:12:29,340
यदि करना ही पड़े, इस्तेमाल करता हूँ ये अधिक गूढ़ कर्नल्स. मैं

365
00:12:29,880 --> 00:12:30,970
सोचता हूँ शायद मैंने इस्तेमाल किया है काई-स्क्वेर

366
00:12:31,170 --> 00:12:32,270
कर्नल, शायद एक बार

367
00:12:32,340 --> 00:12:33,670
मेरी ज़िंदगी में और हिस्टोग्राम कर्नल,

368
00:12:34,240 --> 00:12:35,580
शायद एक या दो बार मेरी ज़िन्दगी में, मैंने

369
00:12:35,630 --> 00:12:38,500
वास्तव में कभी इस्तेमाल नहीं किया स्ट्रिंग कर्नल ख़ुद. लेकिन

370
00:12:39,350 --> 00:12:41,560
यदि आपको मिलता है यह अन्य ऐप्लिकेशन्स में, आप जानते हैं, यदि

371
00:12:42,700 --> 00:12:43,640
आप करते हैं एक तुरत वेब

372
00:12:43,860 --> 00:12:44,850
सर्च हम करते हैं एक तुरत गूगल

373
00:12:45,040 --> 00:12:46,000
सर्च या तुरत बिंग सर्च

374
00:12:46,590 --> 00:12:48,240
आपको मिल सकती हैं परिभाषाएँ कि ये भी कर्नल्स हैं. तो

375
00:12:51,480 --> 00:12:55,680
केवल आख़िरी दो जानकारी मैं देना चाहता हूँ इस वीडियो में. एक है मल्टीक्लास क्लैसिफ़िकेशन. तो आपके

376
00:12:56,370 --> 00:12:59,510
पास हैं चार क्लैसेज़ या आम तौर पर

377
00:12:59,800 --> 00:13:01,880
3 क्लैसेज़, आउटपुट करें कुछ उचित

378
00:13:02,530 --> 00:13:06,860
निर्णायक सीमा रेखा आपकी कई क्लैसेज़ में. अधिकांश SVM, बहुत सी SVM

379
00:13:07,220 --> 00:13:08,750
पैकिज में पहले से ही बिल्ट-इन है

380
00:13:09,030 --> 00:13:10,430
मल्टीक्लास क्लैसिफ़िकेशन कार्यक्षमता. तो

381
00:13:11,100 --> 00:13:12,060
यदि आप इस्तेमाल कर रहे हैं एक पैटर्न

382
00:13:12,270 --> 00:13:13,320
वैसा, आप सिर्फ़ इस्तेमाल क

383
00:13:13,540 --> 00:13:15,370
वह बिल्ट-इन कार्यक्षमता और वह

384
00:13:15,490 --> 00:13:16,940
काम करेगा सही. अन्यथा,

385
00:13:17,790 --> 00:13:18,790
एक ढंग उसे करने का है

386
00:13:19,000 --> 00:13:19,880
कि इस्तेमाल करें वन

387
00:13:20,000 --> 00:13:21,280
वर्सेस ऑल विधि जिसकी हमने

388
00:13:21,370 --> 00:13:23,690
बात की थी जब हम कर रहे थे लॉजिस्टिक रेग्रेशन. तो

389
00:13:24,680 --> 00:13:25,410
आप क्या करते हैं कि आप ट्रेन करते हैं

390
00:13:26,160 --> 00:13:27,550
k SVM यदि आपके पास हैं

391
00:13:27,700 --> 00:13:29,190
k क्लैसेज़, प्रत्येक अंतर करने के लिए

392
00:13:29,900 --> 00:13:31,060
हर एक क्लास को बाक़ी से.

393
00:13:31,850 --> 00:13:32,930
और यह देगा आपको k पेरामिटर

394
00:13:33,520 --> 00:13:34,530
वेक्टर्स, तो यह देगा

395
00:13:34,680 --> 00:13:36,210
आपको, थीटा 1, जो

396
00:13:36,530 --> 00:13:38,170
प्रयास करता हैं भेद करने का क्लास y बराबर

397
00:13:38,630 --> 00:13:39,980
एक को सभी

398
00:13:40,130 --> 00:13:41,340
अन्य क्लैसेज़ से, फिर आपको

399
00:13:41,420 --> 00:13:42,910
मिलता है दूसरा पेरामिटर, वेक्टर

400
00:13:42,970 --> 00:13:43,910
थीटा 2, वह है जो

401
00:13:44,020 --> 00:13:45,420
आपको मिलता है जब आपके, आप जानते हैं, पास है

402
00:13:45,720 --> 00:13:47,080
y बराबर 2 पॉज़िटिव क्लास के लिए

403
00:13:47,460 --> 00:13:48,680
और बाक़ी की सभी नेगेटिव क्लास हैं

404
00:13:49,260 --> 00:13:50,550
और इसी प्रकार आगे

405
00:13:50,800 --> 00:13:52,400
पेरामिटर वेक्टर थीटा k तक,

406
00:13:52,750 --> 00:13:54,520
जो है पेरामिटर वेक्टर

407
00:13:54,600 --> 00:13:56,770
अलग करने के लिए अंतिम क्लास

408
00:13:57,360 --> 00:13:59,380
k अन्य सभी क्लैसेज़ से, और

409
00:13:59,490 --> 00:14:00,590
फिर अंत में, यह है बिल्कुल

410
00:14:01,270 --> 00:14:02,040
वैसा है जैसे वन वर्सेस

411
00:14:02,420 --> 00:14:04,230
ऑल विधि हमारे पास थी लॉजिस्टिक रेग्रेशन के लिए.

412
00:14:04,760 --> 00:14:05,910
जहाँ हम सिर्फ़ प्रिडिक्ट करते हैं क्लास

413
00:14:06,390 --> 00:14:07,690
i जिसका है सबसे बड़ा थीटा

414
00:14:08,030 --> 00:14:11,840
ट्रान्स्पोज़ x. तो वह है मल्टीक्लास क्लैसिफ़िकेशन.

415
00:14:12,440 --> 00:14:13,750
अधिक समान्य केस के लिए

416
00:14:14,300 --> 00:14:15,090
एक अच्छी

417
00:14:15,180 --> 00:14:16,460
सम्भावना है कि जो सॉफ़्टवेयर पैकिज

418
00:14:16,780 --> 00:14:18,010
आप इस्तेमाल करते हैं, आप जानते हैं, होगी

419
00:14:18,340 --> 00:14:19,650
एक उचित सम्भावना कि उनमें पहले से ही

420
00:14:19,920 --> 00:14:21,740
बिल्ट-इन होगी मल्टीक्लास क्लैसिफ़िकेशन कार्यक्षमता,

421
00:14:21,920 --> 00:14:24,410
और इसलिए आपको इस परिणाम के बारे में चिंता करने की जरूरत नहीं है.

422
00:14:25,280 --> 00:14:27,010
अंत में, हमने बनाई सपोर्ट वेक्टर

423
00:14:27,210 --> 00:14:28,650
मशीन शुरू करके लॉजिसिटिक

424
00:14:29,090 --> 00:14:31,500
रेग्रेशन से और फिर परिवर्तित करके कॉस्ट फ़ंक्शन को थोड़ा.

425
00:14:31,910 --> 00:14:34,900
अंतिम चीज़ जो हम करना चाहते हैं इस वीडियो में है, सिर्फ़ कहूँगा थोड़ा सा इस बारे में.

426
00:14:35,550 --> 00:14:36,570
जब आप इस्तेमाल करेंगे एक

427
00:14:36,660 --> 00:14:38,840
इन दो अल्गोरिद्म्स से, तो मान

428
00:14:39,080 --> 00:14:40,000
लो कि n है संख्या

429
00:14:40,160 --> 00:14:42,000
फ़ीचर्ज़ की और m है संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की.

430
00:14:43,190 --> 00:14:45,250
तो, कब हमें इस्तेमाल करना चाहिए पहला और कब दूसरा?

431
00:14:47,130 --> 00:14:48,430
ठीक है, यदि n है बड़ा

432
00:14:48,980 --> 00:14:50,140
तुलना में आपके ट्रेनिंग सेट के

433
00:14:50,360 --> 00:14:51,390
साइज़ से, तो उदाहरण के लिए,

434
00:14:52,810 --> 00:14:53,990
यदि आप लेते हैं बहुत बड़ी

435
00:14:54,250 --> 00:14:55,180
संख्या फ़ीचर्ज़ की यह है

436
00:14:55,330 --> 00:14:56,870
काफ़ी बड़ा m से और यह

437
00:14:57,120 --> 00:14:58,210
हो सकता, उदाहरण के लिए, यदि आपके

438
00:14:58,320 --> 00:15:00,590
पास है एक टेक्स्ट क्लैसिफ़िकेशन प्रॉब्लम, जहाँ

439
00:15:01,550 --> 00:15:02,430
आप जानते हैं, डिमेन्शन फ़ीचर

440
00:15:02,700 --> 00:15:04,160
वेक्टर की है शायद, 10 हज़ार.

441
00:15:05,370 --> 00:15:06,350
और यदि आपका ट्रेनिंग

442
00:15:06,720 --> 00:15:08,290
सेट साइज़ है शायद 10

443
00:15:08,510 --> 00:15:10,250
आप जानते हैं, शायद, 1000 तक.

444
00:15:10,500 --> 00:15:12,140
तो कल्पना करें एक स्पैम

445
00:15:12,320 --> 00:15:14,250
क्लैसिफ़िकेशन प्रॉब्लम, जैसे ईमेल

446
00:15:14,510 --> 00:15:15,840
स्पैम, जहाँ आपके पास हैं 10,000

447
00:15:16,150 --> 00:15:18,010
फ़ीचर्ज़ जो कॉरेस्पॉंड करते हैं 10,000 शब्दों को

448
00:15:18,190 --> 00:15:19,550
लेकिन आपके पास है, आप जानते हैं, शायद 10

449
00:15:19,780 --> 00:15:21,150
ट्रेनिंग इग्ज़ाम्पल्ज़ या शायद 1,000 तक ट्रेनिंग इग्ज़ाम्पल्ज़.

450
00:15:22,450 --> 00:15:23,750
तो यदि n है बड़ा तुलना में

451
00:15:23,890 --> 00:15:25,090
m के, तब मैं क्या

452
00:15:25,250 --> 00:15:26,480
अक्सर करूँगा कि इस्तेमाल करूँगा लॉजिस्टिक

453
00:15:26,850 --> 00:15:27,990
रेग्रेशन या इस्तेमाल करूँगा SVM

454
00:15:28,100 --> 00:15:29,030
बिना कर्नल के या

455
00:15:29,460 --> 00:15:30,790
इस्तेमाल करूँगा इसे एक लिनीअर कर्नल के साथ.

456
00:15:31,620 --> 00:15:32,430
क्योंकि यदि आपके पास है इतने सारे

457
00:15:32,580 --> 00:15:33,830
फ़ीचर्ज़ और छोटा ट्रेनिंग सेट, आप जानते हैं,

458
00:15:34,530 --> 00:15:35,870
एक लिनीअर फ़ंक्शन शायद

459
00:15:36,330 --> 00:15:37,380
सही काम करेगा, और आपके पास नहीं है

460
00:15:37,640 --> 00:15:38,790
वास्तव में पर्याप्त डेटा

461
00:15:38,910 --> 00:15:40,760
फ़िट करने के लिए एक जटिल नॉन-लिनीअर फ़ंक्शन.

462
00:15:41,340 --> 00:15:42,410
अब यदि n है

463
00:15:42,520 --> 00:15:44,020
छोटा और m है

464
00:15:44,350 --> 00:15:45,890
मध्यवर्ती, मेरा क्या मतलब है

465
00:15:45,940 --> 00:15:47,450
उससे कि n है

466
00:15:48,040 --> 00:15:50,350
शायद कुछ 1 - 1000, 1 होगा बहुत छोटा

467
00:15:50,530 --> 00:15:51,470
लेकिन शायद 1000 तक

468
00:15:51,700 --> 00:15:54,270
फ़ीचर्ज़ और यदि

469
00:15:54,590 --> 00:15:56,180
संख्या ट्रेनिंग

470
00:15:56,330 --> 00:15:57,700
इग्ज़ाम्पल्ज़ की है शायद कहीं

471
00:15:58,210 --> 00:16:00,750
10, आप जानते हैं, 10 से शायद 10,000 इग्ज़ाम्पल्ज़ तक.

472
00:16:01,350 --> 00:16:03,160
शायद 50,000 इग्ज़ाम्पल्ज़ तक.

473
00:16:03,630 --> 00:16:06,490
यदि m है बड़ा शायद 10,000 तक लेकिन एक दस लाख तक नहीं.

474
00:16:06,760 --> 00:16:08,100
ठीक है? तो यदि m है एक

475
00:16:08,300 --> 00:16:09,950
मध्यवर्ती साइज़ का तब अक्सर

476
00:16:10,790 --> 00:16:12,980
एक SVM लिनीअर कर्नल के साथ अच्छा काम करेगा.

477
00:16:13,530 --> 00:16:14,580
हमने बात की थी इसकी पहले

478
00:16:14,710 --> 00:16:15,800
भी, एक ठोस उदाहरण के साथ,

479
00:16:16,350 --> 00:16:17,100
यह होगा यदि आपके पास है

480
00:16:17,520 --> 00:16:19,720
एक दो डिमेन्शन का ट्रेनिंग सेट. तो, यदि n

481
00:16:19,900 --> 00:16:21,010
है बराबर 2 जहाँ आपके

482
00:16:21,320 --> 00:16:23,710
पास है, आप जानते हैं, एक काफ़ी बड़ी संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की.

483
00:16:24,710 --> 00:16:25,860
तो गॉशियन कर्नल करेगा

484
00:16:26,130 --> 00:16:28,160
एक काफ़ी अच्छा काम अलग करने के लिए पॉज़िटिव या नेगेटिव क्लैसेज़ को.

485
00:16:29,770 --> 00:16:30,890
एक तीसरी सेटिंग जो है

486
00:16:30,980 --> 00:16:32,420
सम्बंधित है यदि n है

487
00:16:32,520 --> 00:16:34,270
छोटा लेकिन m है बड़ा.

488
00:16:34,890 --> 00:16:36,560
तो यदि n है, आप जानते है, फिर से शायद

489
00:16:37,390 --> 00:16:39,280
1 से 1000, हो सकता है बड़ा भी.

490
00:16:40,200 --> 00:16:42,750
लेकिन यदि m था, शायद

491
00:16:43,320 --> 00:16:46,400
50,000 और बड़ा शायद लाखों में.

492
00:16:47,520 --> 00:16:50,270
तो यदि, 50,000, एक 100,000, मिल्यन, ट्रिल्यन.

493
00:16:51,290 --> 00:16:54,020
आपके पास है एक बहुत बहुत बड़ा ट्रेनिंग सेट साइज़, ठीक है.

494
00:16:55,240 --> 00:16:56,160
तो यदि यह है केस,

495
00:16:56,380 --> 00:16:57,630
तब एक SVM

496
00:16:57,900 --> 00:16:59,850
गॉशियन कर्नल के साथ होगी कुछ हद तक धीमी.

497
00:17:00,160 --> 00:17:02,300
आजकल के SVM पैकिजेज़, यदि आप

498
00:17:02,410 --> 00:17:04,900
इस्तेमाल कर रहे हैं एक गॉशियन कर्नल, थोड़ा धीरे चलते हैं.

499
00:17:05,050 --> 00:17:06,250
यदि आपके पास है, आप जानते हैं, शायद 50

500
00:17:06,590 --> 00:17:07,530
हजार ठीक है, लेकिन अगर आपके

501
00:17:07,620 --> 00:17:10,250
पास हैं एक मिल्यन ट्रेनिंग इग्ज़ाम्पल्ज़, शायद

502
00:17:10,450 --> 00:17:11,950
यहाँ तक कि एक 100,000 जिसमें है एक

503
00:17:12,170 --> 00:17:13,730
बहुत बड़ी वैल्यू m की. आजकल के

504
00:17:14,180 --> 00:17:15,590
SVM पैकिज बहुत अच्छे हैं,

505
00:17:15,870 --> 00:17:17,100
लेकिन फिर भी उन्हें थोड़ी कठिनाई

506
00:17:17,600 --> 00:17:18,400
आ सकती है जब आपके पास है एक

507
00:17:19,010 --> 00:17:20,940
बड़ा, बहुत बड़ा ट्रेनिंग सेट साइज़ जब इस्तेमाल कर रहे हैं एक गॉशियन कर्नल.

508
00:17:22,050 --> 00:17:23,150
तो उस केस में, मैं क्या

509
00:17:23,350 --> 00:17:24,960
अक्सर करता हूँ कि प्रयास करता हूँ बस

510
00:17:25,330 --> 00:17:26,660
ख़ुद से बनाने के और

511
00:17:26,800 --> 00:17:28,600
फ़ीचर्ज़ और फिर इस्तेमाल करता हूँ

512
00:17:28,930 --> 00:17:30,340
लॉजिस्टिक रिग्रेशन या एक SVM

513
00:17:30,630 --> 00:17:32,060
बिना कर्नल के.

514
00:17:33,140 --> 00:17:34,030
और यदि आप देखें इस

515
00:17:34,230 --> 00:17:35,900
स्लाइड को और आप देखते हैं लॉजिसिटक रेग्रेशन

516
00:17:36,460 --> 00:17:37,750
या SVM बिना एक कर्नल के.

517
00:17:38,510 --> 00:17:39,890
इन दोनो स्थानों में, मैंने

518
00:17:39,980 --> 00:17:41,750
एक तरह से जोड़ दिया है उन्हें एक साथ. उसका

519
00:17:42,060 --> 00:17:43,050
एक कारण है, कि

520
00:17:43,900 --> 00:17:45,640
लॉजिस्टिक रिग्रेशन और SVM बिना

521
00:17:46,000 --> 00:17:47,130
कर्नल का, वे हैं काफ़ी

522
00:17:47,350 --> 00:17:49,450
समान अल्गोरिद्म्स और, आप जानते हैं, या

523
00:17:49,680 --> 00:17:51,170
लॉजिस्टिक रिग्रेशन या SVM

524
00:17:51,500 --> 00:17:53,230
बिना कर्नल का अक्सर करेंगे

525
00:17:53,380 --> 00:17:54,780
काफ़ी समान चीज़ें और देंगे

526
00:17:54,900 --> 00:17:56,690
काफ़ी समान पर्फ़ॉर्मन्स, लेकिन निर्भर करते हुए

527
00:17:57,060 --> 00:18:00,340
आपकी इम्प्लमेंटेशन की विस्तृत जानकारी पर, एक हो सकता है अधिक कुशल तुलना में दूसरे की.

528
00:18:00,930 --> 00:18:02,220
लेकिन, जहाँ एक

529
00:18:02,310 --> 00:18:03,530
इन अल्गोरिद्म्स में से अप्लाई करता है, लॉजिस्टिक

530
00:18:03,740 --> 00:18:05,190
रेग्रेशन या SVM बिना एक

531
00:18:05,420 --> 00:18:05,840
कर्नल के, दूसरा भी होगा सम्भावित

532
00:18:06,650 --> 00:18:07,600
बेहतर काम करने के लिए.

533
00:18:08,540 --> 00:18:09,660
लेकिन क्षमता

534
00:18:09,720 --> 00:18:11,610
SVM की है जब आप

535
00:18:11,810 --> 00:18:14,100
इस्तेमाल करते हैं भिन्न कर्नल्स लर्न करने के लिए

536
00:18:14,430 --> 00:18:15,860
जटिल नॉन-लिनीअर फ़ंक्शन्स.

537
00:18:16,680 --> 00:18:20,300
और यह काम करता है, आप जानते है, जब आपके

538
00:18:20,550 --> 00:18:22,530
पास हैं शायद 10,000 तक इग्ज़ाम्पल्ज़, शायद 50,000 तक.

539
00:18:22,610 --> 00:18:25,010
और आपकी संख्या फ़ीचर्ज़ की,

540
00:18:26,580 --> 00:18:27,540
यह यथोचित बड़ी है.

541
00:18:27,840 --> 00:18:29,230
यह है बहुत आम बात

542
00:18:29,670 --> 00:18:30,910
और शायद वह है एक क्षेत्र

543
00:18:31,430 --> 00:18:33,830
जहाँ एक सपोर्ट वेक्टर मशीन एक कर्नल के साथ बहुत अच्छा काम करती है.

544
00:18:34,320 --> 00:18:35,640
आप कर सकते हैं काम जो हैं बहुत

545
00:18:35,860 --> 00:18:39,850
कठिन करने के लिए जिन्हें चाहिए लॉजिसिटिक रेग्रेशन.

546
00:18:40,100 --> 00:18:40,930
और अंत में न्यूरल नेटवर्क कहाँ फ़िट होते हैं?

547
00:18:41,120 --> 00:18:42,230
ठीक है सारी इन

548
00:18:42,440 --> 00:18:43,890
प्राब्लम्ज़ के लिए, सभी

549
00:18:43,960 --> 00:18:46,310
इन भिन्न क्षेत्रों में, एक बेहतर

550
00:18:46,630 --> 00:18:49,110
डिज़ाइन किया गया न्यूरल नेटवर्क भी अच्छा काम कर सकता है.

551
00:18:50,320 --> 00:18:51,700
एक नुकसान, यह एक

552
00:18:51,830 --> 00:18:52,980
कारण कि वह कभी कभी नहीं इस्तेमाल करते

553
00:18:53,220 --> 00:18:54,690
न्यूरल नेटवर्क है कि,

554
00:18:54,920 --> 00:18:56,080
इनमें से कुछ प्राब्लम्ज़ के लिए,

555
00:18:56,180 --> 00:18:57,640
न्यूरल नेटवर्क शायद ट्रेन हो धीरे-धीरे.

556
00:18:58,250 --> 00:18:59,080
लेकिन यदि आपके पास है एक बहुत बढ़िया

557
00:18:59,350 --> 00:19:01,190
SVM इम्प्लमेंटेशन की पैकिज, जो

558
00:19:01,400 --> 00:19:04,120
तेज़ी से काम कर सकती है, काफ़ी तेज़ी से तुलना में आपके न्यूरल नेटवर्क के.

559
00:19:05,130 --> 00:19:06,130
और, हालांकि हमने नहीं दिखाया यह

560
00:19:06,350 --> 00:19:07,520
पहले, ऐसा होता है कि

561
00:19:07,630 --> 00:19:09,800
ऑप्टिमायज़ेशन प्रॉब्लम जो

562
00:19:10,070 --> 00:19:11,120
SVM की है, है एक कान्वेक्स

563
00:19:12,320 --> 00:19:13,830
ऑप्टिमायज़ेशन प्रॉब्लम और इसलिए

564
00:19:14,410 --> 00:19:15,800
बढ़िया SVM ऑप्टिमायज़ेशन सॉफ़्टवेयर

565
00:19:16,160 --> 00:19:17,870
पैकिजेज़ हमेशा ढूँढ पाती हैं

566
00:19:18,240 --> 00:19:21,370
ग्लोबल मिनिमम या कुछ उसके आस पास.

567
00:19:21,720 --> 00:19:24,100
और इसलिए SVM में आपको चिंता करने की जरूरत नहीं है लोकल ऑप्टिमा की.

568
00:19:25,280 --> 00:19:26,440
आमतौर पर लोकल ऑप्टिमा नहीं हैं

569
00:19:26,580 --> 00:19:27,920
एक बड़ी समस्या न्यूरल नेटवर्क्स में

570
00:19:28,090 --> 00:19:29,120
लेकिन वे सब हल कर लेते हैं, अत: यह

571
00:19:29,310 --> 00:19:31,520
है एक चीज़ कम चिंता करने की यदि आप इस्तेमाल कर रहे हैं एक SVM.

572
00:19:33,350 --> 00:19:34,560
और निर्भर करते हुए आपकी प्रॉब्लम पर, न्यूरल

573
00:19:34,910 --> 00:19:37,050
नेटवर्क धीरे काम कर सकते हैं, ख़ासकर

574
00:19:37,580 --> 00:19:41,020
इस तरह के क्षेत्र में SVM की तुलना में.

575
00:19:41,420 --> 00:19:42,200
यदि दिशा निर्देश जो दिए हैं

576
00:19:42,520 --> 00:19:43,500
यहाँ, लगते हैं थोड़े अस्पष्ट

577
00:19:43,860 --> 00:19:44,600
और आप ग़ौर कर रहे हैं कुछ प्राब्लम्ज़ पर, आप जानते हैं,

578
00:19:46,930 --> 00:19:48,050
दिशा निर्देश हैं थोड़े

579
00:19:48,170 --> 00:19:49,190
अस्पष्ट, मैं अभी भी पूरी तरह से नहीं हूँ

580
00:19:49,570 --> 00:19:50,730
निश्चित, कि इस्तेमाल करूँ यह

581
00:19:50,780 --> 00:19:52,690
अल्गोरिद्म या वह अल्गोरिद्म, वह वास्तव में ठीक है.

582
00:19:52,950 --> 00:19:54,100
जब हमारे सामने है एक मशीन लर्निंग

583
00:19:54,330 --> 00:19:55,570
प्रॉब्लम, आप जानते हैं, कभी कभी यह वास्तव में

584
00:19:55,730 --> 00:19:57,010
नहीं होता स्पष्ट कि वह है

585
00:19:57,150 --> 00:19:58,700
सबसे बढ़िया अल्गोरिद्म इस्तेमाल करने के लिए, लेकिन जैसे

586
00:19:59,540 --> 00:20:00,590
आपने देखा पहले के वीडियो में, वास्तव में,

587
00:20:01,200 --> 00:20:02,470
आप जानते हैं, अल्गोरिद्म अवश्य

588
00:20:02,700 --> 00:20:03,920
मायने रखता हैं, लेकिन अक्सर क्या मायने रखता हैं

589
00:20:04,250 --> 00:20:06,400
और भी अधिक कि कितना डेटा है आपके पास.

590
00:20:07,090 --> 00:20:08,280
और आप कितने कुशल है, कितने

591
00:20:08,450 --> 00:20:09,500
अच्छे हैं आप करने में एरर

592
00:20:09,750 --> 00:20:11,450
अनालिसिस और डीबग करने में लर्निंग

593
00:20:11,660 --> 00:20:13,090
अल्गोरिद्म्स को, समझने में कैसे

594
00:20:13,220 --> 00:20:15,120
डिज़ाइन करने हैं नए फ़ीचर्ज़ और

595
00:20:15,280 --> 00:20:17,540
समझने में कि कौन से अन्य फ़ीचर्ज़ देते हैं आपको लर्निंग अल्गोरिद्म्स इत्यादि.

596
00:20:17,960 --> 00:20:19,110
और अक्सर वे चीज़ें रखेंगी मायने

597
00:20:19,660 --> 00:20:20,700
अधिक तुलना में कि क्या आप

598
00:20:20,840 --> 00:20:22,370
कर रहे हैं लॉजिस्टिक रिग्रेशन या एक SVM.

599
00:20:23,280 --> 00:20:24,650
लेकिन ऐसा कहने के बाद,

600
00:20:25,010 --> 00:20:26,180
SVM अभी भी व्यापक रूप से

601
00:20:26,630 --> 00:20:27,890
मानी जाती है एक

602
00:20:27,950 --> 00:20:29,600
सबसे अधिक प्रभावशाली लर्निंग अल्गोरिद्म्स में से, और

603
00:20:29,740 --> 00:20:31,570
यह क्षेत्र है जब वहाँ है

604
00:20:31,790 --> 00:20:34,340
एक बहुत प्रभावशाली ढंग लर्न करने के लिए जटिल नॉन-लिनीअर फ़ंक्शन्स.

605
00:20:35,150 --> 00:20:36,840
और इसलिए मैं वास्तव में, साथ में

606
00:20:37,040 --> 00:20:38,930
लॉजिस्टिक रिग्रेशन, न्यूरल नेटवर्क्स, SVM के

607
00:20:39,090 --> 00:20:40,630
उन्हें इस्तेमाल करके बढ़ाने के गति

608
00:20:40,760 --> 00:20:42,170
लर्निंग अल्गोरिद्म की आप हैं, मैं सोचता हूँ,

609
00:20:42,440 --> 00:20:43,610
एक अच्छी स्थिति में बनाने के लिए

610
00:20:44,120 --> 00:20:45,120
अत्याधुनिक आप जानते हैं

611
00:20:45,310 --> 00:20:46,710
मशीन लर्निंग सिस्टम्स एक बड़े

612
00:20:46,960 --> 00:20:49,110
क्षेत्र में ऐप्लिकेशन्स के और यह

613
00:20:49,330 --> 00:20:52,460
है एक और शक्तिशाली टूल आपके पास.

614
00:20:53,160 --> 00:20:54,270
एक जो इस्तेमाल किया जाता है सभी

615
00:20:54,460 --> 00:20:55,850
स्थानों पर सिलिकॉन वैली में.

616
00:20:56,390 --> 00:20:58,030
या इंडस्ट्री में और

617
00:20:58,310 --> 00:20:59,860
शिक्षा के क्षेत्र में बनाने के लिए

618
00:21:00,120 --> 00:21:01,680
उच्च पर्फ़ॉर्मन्स के मशीन लर्निंग सिस्टम.