अब तक हम बात करते रहें हैं SVMs के बारे में संक्षेप में. इस वीडियो में मैं चाहूँगा बात करना कि क्या आपको वास्तव में चाहिए रन करने या इस्तेमाल करने के लिए एक SVM. सपोर्ट वेक्टर मशीन अल्गोरिद्म देता है एक ख़ास ऑप्टिमायज़ेशन प्रॉब्लम. लेकिन जैसे कि मैंने संक्षेप में उल्लेख किया है पहले के एक वीडियो में, मैं वास्तव में नहीं सलाह देता लिखने की आपका अपना सॉफ़्टवेयर हल करने के लिए पेरमिटर्स थीटा ख़ुद से. तो जैसे आजकल, बहुत कम हम में से, या शायद लगभग हम में से कोई भी नहीं सोचेगा लिखने का कोड ख़ुद से इन्वर्ट करने के लिए एक मेट्रिक्स या स्क्वेर रूट लेने के लिए एक नम्बर का, इत्यादि. हम सिर्फ़, आप जानते हैं, कॉल करते हैं कोई लाइब्रेरी फ़ंक्शन वह करने के लिए. उसी प्रकार, सॉफ्टवेयर हल करने के लिए SVM ऑप्टिमायज़ेशन प्रॉब्लम है बहुत जटिल, और हैं बहुत से शोधकर्ता जो कर रहे हैं कर रहे हैं अनिवार्यत: नूमेरिकल ऑप्टिमायज़ेशन रीसर्च कई वर्षों से. तो आप बनाते हैं अच्छी सॉफ़्टवेयर लाइब्रेरीज़ और बढ़िया सॉफ़्टवेयर पैकिजेज़ इसे करने के लिए. और मैं ज़ोर देकर रेकमेंड करूँगा कि सिर्फ़ इस्तेमाल करें कोई अधिक ऑप्टिमायज़्ड सॉफ़्टवेयर लाइब्रेरी बजाय कोशिश करने के इम्प्लमेंट करने की कुछ ख़ुद से. और हैं बहुत सी अच्छी इस तरह की लाइब्रेरीज़. टूल जो मैं इस्तेमाल करता हूँ अक्सर हैं लिनीअर SVM लेकिन वास्तव में हैं बहुत सी बढ़िया सॉफ़्टवेयर लाइब्रेरीज़ करने के लिए इसे जो, आप जानते हैं, आप कर सकते हैं लिंक बहुत सी प्रमुख प्रोग्रामिंग लैंग्विजेज़ के साथ जो आप शायद इस्तेमाल कर रहे हों कोड करने के लिए लर्निंग अल्गोरिद्म. हालांकि आपको नहीं लिखना चाहिए आपका अपना SVM ऑप्टिमायज़ेशन सॉफ़्टवेयर, कुछ चीज़ें हैं आपको करनी चाहिए, फिर भी. पहला है कि बनाएँ कुछ विकल्प पेरामिटर C के लिए. हमने बात की थी थोड़ी बहुत बाइयस/वेरीयन्स गुणों की इसके पिछले वीडियो में. दूसरा, आप को ज़रूरत है चुनने की कर्नल या समानता फ़ंक्शन जो आप इस्तेमाल करना चाहते हैं. तो एक विकल्प हो सकता है कि हम तय करें कि कोई कर्नल नहीं लेना है. और कर्नल न लेने के विचार को लिनीअर कर्नल भी कहते हैं. तो यदि कोई कहता है, मैं इस्तेमाल करता हूँ एक SVM एक लिनीअर कर्नल के साथ, उसका क्या मतलब है, आप जानते हैं, कि वे इस्तेमाल करते हैं एक SVM बिना उपयोग किए एक कर्नल और यह था एक वर्ज़न SVM का जो सिर्फ़ इस्तेमाल करता है थीटा ट्रान्स्पोज़ X, ठीक है, जो प्रिडिक्ट करता हैं 1 थीटा 0 प्लस थीटा 1 x1 प्लस इसी प्रकार आगे प्लस थीटा n, Xn है बड़ा या बराबर 0 के. इस टर्म लिनीअर कर्नल को, आप सोच सकते हैं इसे आप जानते हैं यह है वर्ज़न SVM का जो सिर्फ़ देता है आपको एक स्टैंडर्ड लिनीअर क्लैसिफ़ायअर. तो वह होगा एक उचित विकल्प कुछ प्राब्लम्ज़ के लिए, और आप जानते हैं, ऐसे बहुत सी सॉफ़्टवेयर लाइब्रेरीज़ होंगी, जैसे लिनीअर SVM, था एक उदाहरण, कई में से एक, एक उदाहरण एक सोफ़्टवेयर लाइब्रेरी का जो कर सकती हैं ट्रेन एक SVM बिना इस्तेमाल किए एक कर्नल, जिसे लिनीअर कर्नल भी कहते हैं. तो, क्यों आप इसे करना चाहते हैं? यदि आपके पास हैं एक बड़ी संख्या फ़ीचर्ज़ की, यदि n है बड़ा, और m संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की है कम, तब आप जानते हैं आपके पास हैं एक बहुत बड़ी संख्या फ़ीचर्ज़ की जो यदि x है, यह है एक x, है एक Rn, Rn + 1. अत:, यदि आपके पास है एक बड़ी संख्या फ़ीचर्ज़ की पहले से ही, एक ट्रेनिंग सेट में, आप जानते हैं, शायद आप चाहेंगे सिर्फ़ फ़िट करना एक लिनीअर निर्णायक सीमा रेखा और नहीं प्रयास करेंगे फ़िट करने का एक बहुत जटिल नॉन-लिनीअर फ़ंक्शन, क्योंकि हमारे पास शायद पर्याप्त डेटा नहीं है. और शायद ओवरफ़िटिंग हो सकती है, यदि आप कोशिश करें फ़िट करने की एक बहुत जटिल फ़ंक्शन एक बड़ी डिमेन्शन कि फ़ीचर स्पेस में, लेकिन यदि आपका ट्रेनिंग सेट सैम्पल छोटा है. तो यह होगी एक उचित सेटिंग जहाँ आप शायद तय करें सिर्फ़ नहीं लेना है एक कर्नल, या करना है इस्तेमाल जिसे कहते हैं एक लिनीअर कर्नल. दूसरा विकल्प कर्नल के लिए जो शायद आप ले, है यह गॉशियन कर्नल, और यह है जो हमारे पास था पहले. और यदि आप इसे करते हैं, तब दूसरा विकल्प जो आपको चुनना है कि चुनाव करने इस पेरामिटर सिगम स्क्वेर्ड का जब हमने बात की थोड़ी बहुत बाइयस/ वेरीयन्स ट्रेड ऑफ़ के बारे में कि कैसे, यदि सिग्मा स्क्वेर्ड है बड़ा, तब आपके पास है एक अपेक्षाकृत अधिक बाइयस, कम वेरीयन्स का क्लैसिफ़ायअर, लेकिन यदि सिग्मा स्क्वेर्ड है कम, तब आपके पास है एक अधिक वेरीयन्स, कम बाइयस क्लैसिफ़ायअर. तो कब आप चुनेंगे एक गॉशियन कर्नल? ठीक है, यदि आपकी डिमेन्शन फ़ीचर्ज़ x की, मेरा मतलब है Rn, और यदि n है छोटा, और वास्तव में, आप जानते हैं, यदि m है बड़ा, ठीक है, तो वह है, यदि, आप जानते हैं, हमारे पास है मान लो, एक दो-डिमेन्शन का ट्रेनिंग सेट, जैसे कि उदाहरण मैंने बनाया था पहले. तो यदि n है बराबर 2, लेकिन हमारे पास है एक काफ़ी बड़ा ट्रेनिंग सेट. तो, आप जानते हैं, मैंने बनाया है एक बड़ी संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की, तब शायद आप चाहते हैं इस्तेमाल करना एक कर्नल फ़िट करने के लिए एक अधिक जटिल नॉन-लिनीअर निर्णायक सीमा रेखा, और गॉशियन कर्नल होगा एक सही तरीक़ा करने का इसे. मैं इस बारे में और अधिक कहूँगा अंत में वीडियो के, थोड़ा और कि कब आप शायद चुने एक लिनीअर कर्नल, एक गॉशियन कर्नल इत्यादि. लेकिन वस्तुत:, यदि आप तय करते हैं इस्तेमाल करने का एक गॉशियन कर्नल, तब यहाँ जो आपको करने की ज़रूरत है. निर्भर करते हुए कि कौन सी सपोर्ट वेक्टर मशीन सॉफ़्टवेयर पैकिज आप इस्तेमाल करते हैं, यह आपको पूछ सकता है इम्प्लमेंट करने के लिए एक कर्नल फ़ंक्शन, या इम्प्लमेंट करने के लिए समानता फ़ंक्शन. तो यदि आप इस्तेमाल कर रहे हैं एक ओकटेव या मैटलैब इम्प्लमेंटेशन SVM की, यह आपको पूछ सकता है देने के लिए एक फ़ंक्शन जो कम्प्यूट करे एक विशेष फ़ीचर कर्नल का. तो यह है वास्तव में कम्प्यूट करना f सबस्क्रिप्ट i एक विशेष वैल्यू के लिए i की, जहाँ f यहाँ है सिर्फ़ एक रियल नम्बर, तो शायद मुझे शायद इसे लिखना चाहिए f(i), लेकिन क्या आपको ज़रूरत है करने की कि लिखें एक कर्नल फ़ंक्शन, जो लेता है यह इनपुट, आप जानते हैं, एक ट्रेनिंग इग्ज़ाम्पल या एक टेस्ट इग्ज़ाम्पल जो भी यह लेता है किसी वेक्टर x में और लेता है इनपुट कोई एक लैंडमार्क और लेकिन मैंने यह सिर्फ़ बनाए हैं x1 और x2 यहाँ, क्योंकि लैंडमार्क्स वास्तव में ट्रेनिंग इग्ज़ाम्पल्ज़ ही हैं. लेकिन क्या आपको करने की जरूरत है कि लिखें सॉफ्टवेयर जो लेता है यह इनपुट, आप जानते हैं, x1, x2 और कम्प्यूट करता है इस तरह का समानता फ़ंक्शन दोनो में वापिस देता है एक रियल नम्बर. और तो जो सपोर्ट वेक्टर मशीन पैकिज करती है कि उम्मीद करती हैं कि आप दें यह कर्नल फ़ंक्शन जो लेता हैं यह इनपुट आप जानते हैं, x1, x2 और देता है एक रियल नम्बर. और फिर यह लेता है इसे वहाँ से और बना देता है अपने आप सारे फ़ीचर्ज़, और तो लेता है x और मैप करता हैं f1, f2 से f(m) तक इस्तेमाल करके यह फ़ंक्शन जो आप लिखते हैं, और बनाता है सारे फ़ीचर्ज़ और ट्रेन करता हैं सपोर्ट वेक्टर मशीन को उससे आगे. लेकिन कभी-कभी आपको देना पड़ता है यह फ़ंक्शन ख़ुद से. यदि आप इस्तेमाल कर रहे हैं गॉशियन कर्नल, कुछ SVM इम्प्लमेंटेशन्स में 
निहित होता है गॉशियन कर्नल और कुछ अन्य कर्नल्स भी, क्योंकि गॉशियन कर्नल शायद सबसे आम कर्नल है. गॉशियन तथा लिनीअर कर्नल हैं वास्तव में दो सबसे अधिक लोकप्रिय कर्नल अभी तक. सिर्फ़ एक इम्प्लमेंटेशन टिप्पणी. यदि आपके पास हैं फ़ीचर्ज़ बहुत भिन्न स्केल पर, यह महतवपूर्ण है करना फ़ीचर स्केलिंग इस्तेमाल करने से पहले गॉशियन कर्नल. और यहाँ है कि ऐसा क्यों. यदि आप कल्पना करें कम्प्यूट करने के नॉर्म x और I में, ठीक है, तो यह टर्म यहाँ, और नूमरेटर टर्म यहाँ. यह क्या कर रहा है, नॉर्म x और I में, वह वास्तव में बता रहा है, आप जानते हैं, चलो कम्प्यूटर करते हैं वेक्टर V, जो है बराबर x माइनस I. और फिर चलो कम्प्यूट करते हैं नॉर्म इस वेक्टर V का, जो है अंतर x और I में. तो नॉर्म V का है वास्तव में बराबर V1 स्क्वेर्ड प्लस V2 स्क्वेर्ड प्लस डॉट डॉट डॉट, प्लस Vn स्क्वेर्ड. क्योंकि यहाँ x है Rn में या Rn प्लस 1 में, लेकिन मैं अनदेखा करूँगा, आप जानते हैं x0 को. तो, चलो मान लेते हैं x है एक Rn, स्क्वेर बाईं तरफ़ है जो इसे सही बनाता है. तो यह है बराबर उसके, ठीक है? और तो लिखा है अलग ढंग से, यह होगा x1 - l1 स्क्वेर्ड, प्लस x2 माइनस l2 स्क्वेर्ड प्लस डॉट डॉट डॉट, प्लस xn माइनस ln स्क्वेर्ड. और अब यदि आपके फ़ीचर्ज़ लेते हैं बहुत भिन्न भिन्न रेंज वैल्यूज़ की. तो लें एक घर की प्रिडिक्शन, उदाहरण के लिए, यदि आपका डेटा है कुछ डेटा घरों के बारे में. और यदि x है रेंज में हज़ारों स्क्वेर फ़ीट, पहले फ़ीचर x1 के लिए. लेकिन यदि आपका दूसरा फ़ीचर, x2 हैं संख्या शयन कक्षों की. तो यदि यह है रेंज में एक से पाँच शयन कक्ष, तो x1 माइनस l1 होगा बहुत बड़ा. यह हो सकता है एक हज़ार स्क्वेर्ड, जबकि x2 माइनस l2 होगा बहुत छोटा और यदि वह केस हैं, तब इस टर्म में, वे दूरियाँ होगी लगभग अनिवार्यत: मुख्य रूप से घरों के साइज़ की और संख्या शयन कक्षों की काफ़ी हद तक नज़र अन्दाज़ हो जाएगी. अत: इससे बचने के लिए ताकि मशीन काम कर सके सही ढंग से, अवश्य करें फ़ीचर स्केलिंग. और यह सुनिश्चित करेगा कि SVM देता है, आप जानते हैं, तुलनीय ध्यान सारे आपके भिन्न फ़ीचर्ज़ पर, और न केवल जैसे इस उदाहरण में साइज़ पर घरों के, तो यह था फ़ीचर्ज़ में काफ़ी बड़ा परिवर्तन. जब आप अप्लाई करते हैं एक सपोर्ट वेक्टर मशीन सम्भावना है कि अभी तक तो सबसे अधिक आम कर्नल आप इस्तेमाल करेंगे होंगे लिनीअर कर्नल, अर्थात् कोई कर्नल नहीं, या गॉशियन कर्नल जिसकी हमने बात की थी. और बस चेतावनी का एक नोट जो है कि सारे समानता फ़ंक्शन्स जो आप बनाते है नहीं होगे वैध कर्नल्स. और गॉशियन कर्नल तथा लिनीअर कर्नल और अन्य कर्नल जो आप कभी कभी और लोग इस्तेमाल करेंगे, सारे वे संतुष करने चाहिएँ एक तकनीकी गुण. इसे कहते हैं मर्सरज़ थ्योरम और वजह कि आपको वह चाहिए है है क्योंकि सपोर्ट वेक्टर मशीन अल्गोरिद्म्स या इम्प्लमेंटेशन्स SVM की में हैं बहुत सी चतुर नूमेरिकल ऑप्टिमायज़ेशन तरकीबें. हल करने के लिए पेरमिटर्स थीटा के लिए कुशलता से और परिकल्पित मूल डिजाइन में, वे हैं निर्णय लिए गए सीमित करने के लिए हमारा ध्यान सिर्फ़ कर्नल्स पर जो संतुष्ट करते हैं यह तकनीकी निर्देश जिसे कहते हैं मर्सरज़ थ्योरम. और वह क्या करता है कि, वह सुनिश्चित करता है कि सारे ये SVM पैकिज, सारे ये SVM सॉफ़्टवेयर पैकिज इस्तेमाल कर सके एक बड़ा वर्ग ऑप्टिमायज़ेशन का और जान पाएँ पेरामिटर थीटा जल्दी से. तो, क्या अधिकांश लोग करते हैं कि इस्तेमाल करते हैं लिनीअर या गॉशियन कर्नल, लेकिन हैं कुछ अन्य कर्नलज़ भी जो संतुष्ट करते हैं मर्सरज़ थ्योरम और जो शायद आपको मिलें अन्य लोग इस्तेमाल करते हुए, हालाँकि मैं स्वयं इस्तेमाल करता हूँ अन्य कर्नल्स, आप जानते है, कभी कभार ही, यदि करना ही पड़े. सिर्फ़ बताने के लिए कुछ अन्य कर्नलज़ जो शायद आपको मिलें. एक है पालिनोमीयल कर्नल. और उस समानता के लिए x और l में है परिभाषित, हैं बहुत से विकल्प, आप ले सकते हैं x ट्रान्स्पोज़ l स्क्वेर्ड. तो यह है एक माप कि कितने समान हैं x और l. यदि x और l है लगभग बराबर एक दूसरे के, तब इनर प्रोडक्ट होगा बड़ा. और इसलिए, आप जानते हैं, यह है थोड़ा असामान्य कर्नल. वह उतना अधिक इस्तेमाल नहीं होता, लेकिन आपको मिल सकते हैं लोग इसे इस्तेमाल करते हुए. यह है एक वर्ज़न पालिनोमीयल कर्नल का. दूसरा है x ट्रान्स्पोज़ l क्यूबड. ये सब हैं उदाहरण पालिनोमीयल कर्नल के. x ट्रान्स्पोज़ l प्लस 1 क्यूबड. X ट्रान्स्पोज़ l प्लस शायद एक संख्या भिन्न एक से 5 और, आप जानते हैं, पॉवर 4 में और इसलिए पालिनोमीयल कर्नल के वास्तव में हैं दो पेरमिटर्स. एक है, क्या संख्या आप जोड़ते हैं वहाँ? यह हो सकती है 0. यह हैं वास्तव में प्लस 0 यहाँ, तथा जो है डिग्री पालिनोमीयल की वहाँ. अत: डिग्री पॉवर और ये संख्याएँ. और सामान्य रूप में, पालिनोमीयल कर्नल है x ट्रान्स्पोज़ l, प्लस कुछ कॉन्स्टंट और फिर कुछ डिग्री x1 और इसलिए दोनो ये हैं पेरमिटर्स पालिनोमीयल कर्नल के लिए. अत: पालिनोमीयल कर्नल लगभग हमेशा या अक्सर सही काम नहीं करते. और गॉशियन कर्नल नहीं करता उतना इस्तेमाल, लेकिन यह है कुछ जो शायद आपको मिले. आमतौर पर यह प्रयोग किया जाता है केवल डेटा के लिए जहाँ x और l सभी हैं नॉन-नेगेटिव, और इसलिए वह सुनिश्चित करता है कि ये इनर प्रोडक्ट कभी भी नेगेटिव नहीं हैं. और यह कैप्चर करता है अनुभव कि x और l काफ़ी समान हैं एक दूसरे के, तब शायद इनर प्रोडक्ट होगा बड़ा. फिर उनके कुछ अन्य गुण भी हैं लेकिन लोग इसे बहुत उपयोग नहीं करते हैं. और फिर, निर्भर करते हुए कि क्या आप कर रहे हैं, वहाँ अन्य, एक तरह से अधिक गूढ़ कर्नल भी हैं जो आपके सामने आ सकते हैं. आप जानते हैं, एक स्ट्रिंग कर्नल होता है, यह कभी-कभी इस्तेमाल होता है यदि आपका इनपुट डेटा हैं टेक्स्ट स्ट्रिंग्स या अन्य तरह की स्ट्रिंग्स. ऐसी चीज़ें भी हैं जैसे काई-स्क्वेर कर्नल, हिस्टोग्राम इंटर्सेक्शन कर्नल, इत्यादि. और भी एक तरह से अधिक गूढ़ कर्नल हैं जो आप इस्तेमाल कर सकते हैं मापने के लिए समानता विभिन्न वस्तुओं में. अत: उदाहरण के लिए, यदि आप प्रयास कर रहे हैं करने का किसी तरह का टेक्स्ट क्लैसिफ़िकेशन प्रॉब्लम, जहाँ इनपुट x है एक स्ट्रिंग तब शायद हम चाहते हैं जानना समानता दो स्ट्रिंग्स में इस्तेमाल करके स्ट्रिंग कर्नल, लेकिन मैं व्यक्तिगत रूप से आप जानते हैं, कभी-कभार ही, यदि करना ही पड़े, इस्तेमाल करता हूँ ये अधिक गूढ़ कर्नल्स. मैं सोचता हूँ शायद मैंने इस्तेमाल किया है काई-स्क्वेर कर्नल, शायद एक बार मेरी ज़िंदगी में और हिस्टोग्राम कर्नल, शायद एक या दो बार मेरी ज़िन्दगी में, मैंने वास्तव में कभी इस्तेमाल नहीं किया स्ट्रिंग कर्नल ख़ुद. लेकिन यदि आपको मिलता है यह अन्य ऐप्लिकेशन्स में, आप जानते हैं, यदि आप करते हैं एक तुरत वेब सर्च हम करते हैं एक तुरत गूगल सर्च या तुरत बिंग सर्च आपको मिल सकती हैं परिभाषाएँ कि ये भी कर्नल्स हैं. तो केवल आख़िरी दो जानकारी मैं देना चाहता हूँ इस वीडियो में. एक है मल्टीक्लास क्लैसिफ़िकेशन. तो आपके पास हैं चार क्लैसेज़ या आम तौर पर 3 क्लैसेज़, आउटपुट करें कुछ उचित निर्णायक सीमा रेखा आपकी कई क्लैसेज़ में. अधिकांश SVM, बहुत सी SVM पैकिज में पहले से ही बिल्ट-इन है मल्टीक्लास क्लैसिफ़िकेशन कार्यक्षमता. तो यदि आप इस्तेमाल कर रहे हैं एक पैटर्न वैसा, आप सिर्फ़ इस्तेमाल क वह बिल्ट-इन कार्यक्षमता और वह काम करेगा सही. अन्यथा, एक ढंग उसे करने का है कि इस्तेमाल करें वन वर्सेस ऑल विधि जिसकी हमने बात की थी जब हम कर रहे थे लॉजिस्टिक रेग्रेशन. तो आप क्या करते हैं कि आप ट्रेन करते हैं k SVM यदि आपके पास हैं k क्लैसेज़, प्रत्येक अंतर करने के लिए हर एक क्लास को बाक़ी से. और यह देगा आपको k पेरामिटर वेक्टर्स, तो यह देगा आपको, थीटा 1, जो प्रयास करता हैं भेद करने का क्लास y बराबर एक को सभी अन्य क्लैसेज़ से, फिर आपको मिलता है दूसरा पेरामिटर, वेक्टर थीटा 2, वह है जो आपको मिलता है जब आपके, आप जानते हैं, पास है y बराबर 2 पॉज़िटिव क्लास के लिए और बाक़ी की सभी नेगेटिव क्लास हैं और इसी प्रकार आगे पेरामिटर वेक्टर थीटा k तक, जो है पेरामिटर वेक्टर अलग करने के लिए अंतिम क्लास k अन्य सभी क्लैसेज़ से, और फिर अंत में, यह है बिल्कुल वैसा है जैसे वन वर्सेस ऑल विधि हमारे पास थी लॉजिस्टिक रेग्रेशन के लिए. जहाँ हम सिर्फ़ प्रिडिक्ट करते हैं क्लास i जिसका है सबसे बड़ा थीटा ट्रान्स्पोज़ x. तो वह है मल्टीक्लास क्लैसिफ़िकेशन. अधिक समान्य केस के लिए एक अच्छी सम्भावना है कि जो सॉफ़्टवेयर पैकिज आप इस्तेमाल करते हैं, आप जानते हैं, होगी एक उचित सम्भावना कि उनमें पहले से ही बिल्ट-इन होगी मल्टीक्लास क्लैसिफ़िकेशन कार्यक्षमता, और इसलिए आपको इस परिणाम के बारे में चिंता करने की जरूरत नहीं है. अंत में, हमने बनाई सपोर्ट वेक्टर मशीन शुरू करके लॉजिसिटिक रेग्रेशन से और फिर परिवर्तित करके कॉस्ट फ़ंक्शन को थोड़ा. अंतिम चीज़ जो हम करना चाहते हैं इस वीडियो में है, सिर्फ़ कहूँगा थोड़ा सा इस बारे में. जब आप इस्तेमाल करेंगे एक इन दो अल्गोरिद्म्स से, तो मान लो कि n है संख्या फ़ीचर्ज़ की और m है संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की. तो, कब हमें इस्तेमाल करना चाहिए पहला और कब दूसरा? ठीक है, यदि n है बड़ा तुलना में आपके ट्रेनिंग सेट के साइज़ से, तो उदाहरण के लिए, यदि आप लेते हैं बहुत बड़ी संख्या फ़ीचर्ज़ की यह है काफ़ी बड़ा m से और यह हो सकता, उदाहरण के लिए, यदि आपके पास है एक टेक्स्ट क्लैसिफ़िकेशन प्रॉब्लम, जहाँ आप जानते हैं, डिमेन्शन फ़ीचर वेक्टर की है शायद, 10 हज़ार. और यदि आपका ट्रेनिंग सेट साइज़ है शायद 10 आप जानते हैं, शायद, 1000 तक. तो कल्पना करें एक स्पैम क्लैसिफ़िकेशन प्रॉब्लम, जैसे ईमेल स्पैम, जहाँ आपके पास हैं 10,000 फ़ीचर्ज़ जो कॉरेस्पॉंड करते हैं 10,000 शब्दों को लेकिन आपके पास है, आप जानते हैं, शायद 10 ट्रेनिंग इग्ज़ाम्पल्ज़ या शायद 1,000 तक ट्रेनिंग इग्ज़ाम्पल्ज़. तो यदि n है बड़ा तुलना में m के, तब मैं क्या अक्सर करूँगा कि इस्तेमाल करूँगा लॉजिस्टिक रेग्रेशन या इस्तेमाल करूँगा SVM बिना कर्नल के या इस्तेमाल करूँगा इसे एक लिनीअर कर्नल के साथ. क्योंकि यदि आपके पास है इतने सारे फ़ीचर्ज़ और छोटा ट्रेनिंग सेट, आप जानते हैं, एक लिनीअर फ़ंक्शन शायद सही काम करेगा, और आपके पास नहीं है वास्तव में पर्याप्त डेटा फ़िट करने के लिए एक जटिल नॉन-लिनीअर फ़ंक्शन. अब यदि n है छोटा और m है मध्यवर्ती, मेरा क्या मतलब है उससे कि n है शायद कुछ 1 - 1000, 1 होगा बहुत छोटा लेकिन शायद 1000 तक फ़ीचर्ज़ और यदि संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की है शायद कहीं 10, आप जानते हैं, 10 से शायद 10,000 इग्ज़ाम्पल्ज़ तक. शायद 50,000 इग्ज़ाम्पल्ज़ तक. यदि m है बड़ा शायद 10,000 तक लेकिन एक दस लाख तक नहीं. ठीक है? तो यदि m है एक मध्यवर्ती साइज़ का तब अक्सर एक SVM लिनीअर कर्नल के साथ अच्छा काम करेगा. हमने बात की थी इसकी पहले भी, एक ठोस उदाहरण के साथ, यह होगा यदि आपके पास है एक दो डिमेन्शन का ट्रेनिंग सेट. तो, यदि n है बराबर 2 जहाँ आपके पास है, आप जानते हैं, एक काफ़ी बड़ी संख्या ट्रेनिंग इग्ज़ाम्पल्ज़ की. तो गॉशियन कर्नल करेगा एक काफ़ी अच्छा काम अलग करने के लिए पॉज़िटिव या नेगेटिव क्लैसेज़ को. एक तीसरी सेटिंग जो है सम्बंधित है यदि n है छोटा लेकिन m है बड़ा. तो यदि n है, आप जानते है, फिर से शायद 1 से 1000, हो सकता है बड़ा भी. लेकिन यदि m था, शायद 50,000 और बड़ा शायद लाखों में. तो यदि, 50,000, एक 100,000, मिल्यन, ट्रिल्यन. आपके पास है एक बहुत बहुत बड़ा ट्रेनिंग सेट साइज़, ठीक है. तो यदि यह है केस, तब एक SVM गॉशियन कर्नल के साथ होगी कुछ हद तक धीमी. आजकल के SVM पैकिजेज़, यदि आप इस्तेमाल कर रहे हैं एक गॉशियन कर्नल, थोड़ा धीरे चलते हैं. यदि आपके पास है, आप जानते हैं, शायद 50 हजार ठीक है, लेकिन अगर आपके पास हैं एक मिल्यन ट्रेनिंग इग्ज़ाम्पल्ज़, शायद यहाँ तक कि एक 100,000 जिसमें है एक बहुत बड़ी वैल्यू m की. आजकल के SVM पैकिज बहुत अच्छे हैं, लेकिन फिर भी उन्हें थोड़ी कठिनाई आ सकती है जब आपके पास है एक बड़ा, बहुत बड़ा ट्रेनिंग सेट साइज़ जब इस्तेमाल कर रहे हैं एक गॉशियन कर्नल. तो उस केस में, मैं क्या अक्सर करता हूँ कि प्रयास करता हूँ बस ख़ुद से बनाने के और फ़ीचर्ज़ और फिर इस्तेमाल करता हूँ लॉजिस्टिक रिग्रेशन या एक SVM बिना कर्नल के. और यदि आप देखें इस स्लाइड को और आप देखते हैं लॉजिसिटक रेग्रेशन या SVM बिना एक कर्नल के. इन दोनो स्थानों में, मैंने एक तरह से जोड़ दिया है उन्हें एक साथ. उसका एक कारण है, कि लॉजिस्टिक रिग्रेशन और SVM बिना कर्नल का, वे हैं काफ़ी समान अल्गोरिद्म्स और, आप जानते हैं, या लॉजिस्टिक रिग्रेशन या SVM बिना कर्नल का अक्सर करेंगे काफ़ी समान चीज़ें और देंगे काफ़ी समान पर्फ़ॉर्मन्स, लेकिन निर्भर करते हुए आपकी इम्प्लमेंटेशन की विस्तृत जानकारी पर, एक हो सकता है अधिक कुशल तुलना में दूसरे की. लेकिन, जहाँ एक इन अल्गोरिद्म्स में से अप्लाई करता है, लॉजिस्टिक रेग्रेशन या SVM बिना एक कर्नल के, दूसरा भी होगा सम्भावित बेहतर काम करने के लिए. लेकिन क्षमता SVM की है जब आप इस्तेमाल करते हैं भिन्न कर्नल्स लर्न करने के लिए जटिल नॉन-लिनीअर फ़ंक्शन्स. और यह काम करता है, आप जानते है, जब आपके पास हैं शायद 10,000 तक इग्ज़ाम्पल्ज़, शायद 50,000 तक. और आपकी संख्या फ़ीचर्ज़ की, यह यथोचित बड़ी है. यह है बहुत आम बात और शायद वह है एक क्षेत्र जहाँ एक सपोर्ट वेक्टर मशीन एक कर्नल के साथ बहुत अच्छा काम करती है. आप कर सकते हैं काम जो हैं बहुत कठिन करने के लिए जिन्हें चाहिए लॉजिसिटिक रेग्रेशन. और अंत में न्यूरल नेटवर्क कहाँ फ़िट होते हैं? ठीक है सारी इन प्राब्लम्ज़ के लिए, सभी इन भिन्न क्षेत्रों में, एक बेहतर डिज़ाइन किया गया न्यूरल नेटवर्क भी अच्छा काम कर सकता है. एक नुकसान, यह एक कारण कि वह कभी कभी नहीं इस्तेमाल करते न्यूरल नेटवर्क है कि, इनमें से कुछ प्राब्लम्ज़ के लिए, न्यूरल नेटवर्क शायद ट्रेन हो धीरे-धीरे. लेकिन यदि आपके पास है एक बहुत बढ़िया SVM इम्प्लमेंटेशन की पैकिज, जो तेज़ी से काम कर सकती है, काफ़ी तेज़ी से तुलना में आपके न्यूरल नेटवर्क के. और, हालांकि हमने नहीं दिखाया यह पहले, ऐसा होता है कि ऑप्टिमायज़ेशन प्रॉब्लम जो SVM की है, है एक कान्वेक्स ऑप्टिमायज़ेशन प्रॉब्लम और इसलिए बढ़िया SVM ऑप्टिमायज़ेशन सॉफ़्टवेयर पैकिजेज़ हमेशा ढूँढ पाती हैं ग्लोबल मिनिमम या कुछ उसके आस पास. और इसलिए SVM में आपको चिंता करने की जरूरत नहीं है लोकल ऑप्टिमा की. आमतौर पर लोकल ऑप्टिमा नहीं हैं एक बड़ी समस्या न्यूरल नेटवर्क्स में लेकिन वे सब हल कर लेते हैं, अत: यह है एक चीज़ कम चिंता करने की यदि आप इस्तेमाल कर रहे हैं एक SVM. और निर्भर करते हुए आपकी प्रॉब्लम पर, न्यूरल नेटवर्क धीरे काम कर सकते हैं, ख़ासकर इस तरह के क्षेत्र में SVM की तुलना में. यदि दिशा निर्देश जो दिए हैं यहाँ, लगते हैं थोड़े अस्पष्ट और आप ग़ौर कर रहे हैं कुछ प्राब्लम्ज़ पर, आप जानते हैं, दिशा निर्देश हैं थोड़े अस्पष्ट, मैं अभी भी पूरी तरह से नहीं हूँ निश्चित, कि इस्तेमाल करूँ यह अल्गोरिद्म या वह अल्गोरिद्म, वह वास्तव में ठीक है. जब हमारे सामने है एक मशीन लर्निंग प्रॉब्लम, आप जानते हैं, कभी कभी यह वास्तव में नहीं होता स्पष्ट कि वह है सबसे बढ़िया अल्गोरिद्म इस्तेमाल करने के लिए, लेकिन जैसे आपने देखा पहले के वीडियो में, वास्तव में, आप जानते हैं, अल्गोरिद्म अवश्य मायने रखता हैं, लेकिन अक्सर क्या मायने रखता हैं और भी अधिक कि कितना डेटा है आपके पास. और आप कितने कुशल है, कितने अच्छे हैं आप करने में एरर अनालिसिस और डीबग करने में लर्निंग अल्गोरिद्म्स को, समझने में कैसे डिज़ाइन करने हैं नए फ़ीचर्ज़ और समझने में कि कौन से अन्य फ़ीचर्ज़ देते हैं आपको लर्निंग अल्गोरिद्म्स इत्यादि. और अक्सर वे चीज़ें रखेंगी मायने अधिक तुलना में कि क्या आप कर रहे हैं लॉजिस्टिक रिग्रेशन या एक SVM. लेकिन ऐसा कहने के बाद, SVM अभी भी व्यापक रूप से मानी जाती है एक सबसे अधिक प्रभावशाली लर्निंग अल्गोरिद्म्स में से, और यह क्षेत्र है जब वहाँ है एक बहुत प्रभावशाली ढंग लर्न करने के लिए जटिल नॉन-लिनीअर फ़ंक्शन्स. और इसलिए मैं वास्तव में, साथ में लॉजिस्टिक रिग्रेशन, न्यूरल नेटवर्क्स, SVM के उन्हें इस्तेमाल करके बढ़ाने के गति लर्निंग अल्गोरिद्म की आप हैं, मैं सोचता हूँ, एक अच्छी स्थिति में बनाने के लिए अत्याधुनिक आप जानते हैं मशीन लर्निंग सिस्टम्स एक बड़े क्षेत्र में ऐप्लिकेशन्स के और यह है एक और शक्तिशाली टूल आपके पास. एक जो इस्तेमाल किया जाता है सभी स्थानों पर सिलिकॉन वैली में. या इंडस्ट्री में और शिक्षा के क्षेत्र में बनाने के लिए उच्च पर्फ़ॉर्मन्स के मशीन लर्निंग सिस्टम.