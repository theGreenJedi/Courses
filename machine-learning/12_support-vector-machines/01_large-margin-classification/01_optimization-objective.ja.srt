1
00:00:00,570 --> 00:00:01,860
ここまでで、様々な

2
00:00:02,090 --> 00:00:04,860
学習アルゴリズムを見てきた。
教師有り学習の中では、

3
00:00:05,280 --> 00:00:06,810
それぞれの学習アルゴリズム同士のパフォーマンスは

4
00:00:07,300 --> 00:00:08,830
とても似通っていて、

5
00:00:09,650 --> 00:00:10,740
学習アルゴリズムAを使うか

6
00:00:11,040 --> 00:00:12,140
学習アルゴリズムBを使うかの違いは

7
00:00:12,440 --> 00:00:13,450
重要で無い事が多い。

8
00:00:13,660 --> 00:00:15,020
それよりも重要になる事が多いのは

9
00:00:15,190 --> 00:00:16,190
これらのアルゴリズムを

10
00:00:16,360 --> 00:00:17,100
適用する対象のデータの量とか、

11
00:00:17,330 --> 00:00:18,530
または学習アルゴリズムを適用するスキル、

12
00:00:19,280 --> 00:00:20,480
例えば学習アルゴリズムに

13
00:00:20,600 --> 00:00:21,990
与えるフィーチャーの選択とか

14
00:00:23,150 --> 00:00:24,480
正規化パラメータをどう選ぶかとか

15
00:00:24,660 --> 00:00:25,790
そういった物の方が

16
00:00:26,010 --> 00:00:27,030
重要な事が

17
00:00:27,200 --> 00:00:28,530
多い。

18
00:00:29,190 --> 00:00:31,690
だが、それでももう一つ、

19
00:00:31,930 --> 00:00:34,110
とても強力で、

20
00:00:34,380 --> 00:00:35,460
業界でもアカデミアでも良く使われている

21
00:00:35,580 --> 00:00:37,400
アルゴリズムがある。

22
00:00:38,050 --> 00:00:39,590
それはサポートベクターマシーンと呼ばれていて、

23
00:00:39,850 --> 00:00:41,080
ロジスティック回帰やニューラルネットワークと比べて、

24
00:00:41,200 --> 00:00:42,600
サポートベクターマシーン、

25
00:00:46,770 --> 00:00:48,190
またの名をSVMは、

26
00:00:48,440 --> 00:00:50,120
複雑な非線形の関数を学習する方法として、

27
00:00:50,890 --> 00:00:52,040
場合によってはより明解で、

28
00:00:52,480 --> 00:00:53,250
よりパワフルな事がある。

29
00:00:54,970 --> 00:00:56,300
だから次のビデオで、

30
00:00:56,480 --> 00:00:57,850
それについて

31
00:00:57,890 --> 00:01:00,100
話したい。

32
00:01:00,400 --> 00:01:01,400
このコースの後半で、

33
00:01:01,540 --> 00:01:02,710
様々な教師有り学習アルゴリズムの

34
00:01:03,100 --> 00:01:04,340
簡単なサーベイを行い、

35
00:01:05,200 --> 00:01:06,790
とても簡潔にそれらを紹介するつもりだ。

36
00:01:07,430 --> 00:01:08,870
だがサポートベクターマシーンは

37
00:01:09,370 --> 00:01:10,840
その人気があまりにも大きいので、

38
00:01:10,980 --> 00:01:11,920
教師有り学習アルゴリズムの

39
00:01:12,060 --> 00:01:13,800
最後として、

40
00:01:14,440 --> 00:01:16,710
このコースの中のそれなりの時間を費やしたいと思う。

41
00:01:19,260 --> 00:01:20,440
ここまでの学習アルゴリズムの開発と同様、

42
00:01:20,670 --> 00:01:22,280
最適化の目的関数から

43
00:01:22,650 --> 00:01:23,940
始めたいと思う。

44
00:01:24,750 --> 00:01:26,420
ではこのアルゴリズムを

45
00:01:26,620 --> 00:01:27,920
始めよう。

46
00:01:29,420 --> 00:01:30,960
サポートベクターマシーンを記述する為に、

47
00:01:31,270 --> 00:01:32,570
まずはロジスティック回帰から

48
00:01:32,610 --> 00:01:34,020
始めて、

49
00:01:34,990 --> 00:01:35,990
それをちょこっと変更して

50
00:01:36,820 --> 00:01:37,630
本質的にはサポートベクターマシーンが得られる

51
00:01:38,240 --> 00:01:39,260
やり方をお見せしたい。

52
00:01:40,290 --> 00:01:41,740
ではロジスティック回帰において、

53
00:01:41,950 --> 00:01:43,680
今や見慣れた仮説の形が

54
00:01:43,740 --> 00:01:46,000
これで、そしてsigmoidアクティベーション関数が

55
00:01:46,450 --> 00:01:48,590
右に示してある。

56
00:01:50,390 --> 00:01:51,330
そして数学をいくつか

57
00:01:51,800 --> 00:01:52,650
説明する為に、

58
00:01:52,850 --> 00:01:55,960
zをシータ転置のxを表すのに使う。

59
00:01:57,620 --> 00:01:58,650
では、ロジスティック回帰において

60
00:01:58,900 --> 00:02:01,150
我らが何をするかを見てみよう。

61
00:02:01,270 --> 00:02:02,800
手本があって、

62
00:02:03,070 --> 00:02:04,360
y=1とする、

63
00:02:04,540 --> 00:02:05,480
これの意味は、

64
00:02:06,100 --> 00:02:07,100
トレーニングセットなりテストセットなり

65
00:02:07,440 --> 00:02:11,780
クロスバリデーションセットにおいて、y=1という事で、

66
00:02:12,030 --> 00:02:14,300
それはようするに、h(x)が1に近い事を期待する、という事を意味する。

67
00:02:14,380 --> 00:02:15,760
つまり、手本を

68
00:02:16,140 --> 00:02:17,330
正しく分類する事を望んでいて、

69
00:02:18,520 --> 00:02:19,390
h(x)が1に近いことは、

70
00:02:19,510 --> 00:02:20,710
シータ転置のxが

71
00:02:20,850 --> 00:02:22,080
0よりも

72
00:02:22,360 --> 00:02:23,380
ずっと大きくなければならない事を意味する。

73
00:02:23,770 --> 00:02:24,990
これは大なり大なりの

74
00:02:25,330 --> 00:02:26,680
記号で、

75
00:02:26,900 --> 00:02:28,220
0よりも、とってもとっても

76
00:02:28,530 --> 00:02:30,880
大きい事を意味する。

77
00:02:31,120 --> 00:02:32,840
そしてそれはとりもなさず、z、つまり

78
00:02:32,960 --> 00:02:34,750
シータ転置のxが

79
00:02:34,940 --> 00:02:35,910
0よりもずっと大きい時

80
00:02:36,010 --> 00:02:37,240
この図で

81
00:02:37,310 --> 00:02:39,060
遥か右に位置するという事で、

82
00:02:39,360 --> 00:02:42,430
ロジスティック回帰の出力は1に近くなるという事を意味する。

83
00:02:44,510 --> 00:02:45,580
逆に、

84
00:02:45,630 --> 00:02:46,870
y=0の手本の時は

85
00:02:47,000 --> 00:02:48,470
期待する事は

86
00:02:48,750 --> 00:02:49,620
仮説が0に近い値を

87
00:02:50,420 --> 00:02:51,890
出力する事で

88
00:02:52,010 --> 00:02:53,850
それはシータ転置のxが

89
00:02:54,650 --> 00:02:55,990
つまりzが、

90
00:02:56,250 --> 00:02:57,080
0よりもずっと小さいという事だ。

91
00:02:57,440 --> 00:02:58,720
何故ならそれに対応する

92
00:02:59,160 --> 00:03:01,250
仮説の出力の値は0に近いから。

93
00:03:02,180 --> 00:03:03,590
ここでロジスティック回帰の

94
00:03:03,760 --> 00:03:06,300
コスト関数を見てみると、

95
00:03:06,440 --> 00:03:07,470
見られる結果は

96
00:03:07,710 --> 00:03:09,400
各手本、x、yが

97
00:03:10,190 --> 00:03:11,520
このような項として

98
00:03:11,700 --> 00:03:14,320
全体のコストに貢献している。

99
00:03:15,450 --> 00:03:16,900
つまりコスト関数の全体としては、普通は

100
00:03:17,390 --> 00:03:18,600
トレーニング手本全体に渡る

101
00:03:18,890 --> 00:03:21,430
和があり、さらに1/mの項もある。

102
00:03:22,450 --> 00:03:22,740
だがここのこの式は、

103
00:03:23,240 --> 00:03:24,150
これこそが、

104
00:03:24,470 --> 00:03:25,450
一つのトレーニング手本の寄与の

105
00:03:26,220 --> 00:03:28,490
項だ、

106
00:03:28,780 --> 00:03:31,550
ロジスティック回帰の目的関数全体への。

107
00:03:33,250 --> 00:03:34,350
今、この仮説の定義の式を取り、

108
00:03:35,190 --> 00:03:36,120
ここに

109
00:03:37,030 --> 00:03:38,700
代入する。

110
00:03:39,790 --> 00:03:40,710
得られた物は、

111
00:03:40,920 --> 00:03:43,130
各トレーニング手本の寄与はこの項だ。

112
00:03:44,270 --> 00:03:45,480
1/mは無視してるが、

113
00:03:45,720 --> 00:03:47,130
この項がロジスティック回帰の

114
00:03:47,470 --> 00:03:49,470
全体のコスト関数への

115
00:03:49,680 --> 00:03:52,260
寄与だ。

116
00:03:52,820 --> 00:03:54,310
今、2つの場合を考えてみよう:

117
00:03:54,700 --> 00:03:55,970
y=1の時と

118
00:03:56,040 --> 00:03:57,250
y=0の時。

119
00:03:57,820 --> 00:03:59,040
最初のケースとして、

120
00:03:59,170 --> 00:04:00,260
y=1の時を考えよう。

121
00:04:00,520 --> 00:04:01,960
この場合は、

122
00:04:02,440 --> 00:04:04,850
この目的関数の

123
00:04:04,980 --> 00:04:06,910
最初の項だけが重要だ、何故なら

124
00:04:07,130 --> 00:04:08,830
この1-yの項は0になるから、

125
00:04:09,210 --> 00:04:10,510
y=1の時は。

126
00:04:13,640 --> 00:04:15,340
つまりy=1の時は

127
00:04:15,400 --> 00:04:17,130
手本x, yの、

128
00:04:17,310 --> 00:04:18,240
yが1の時には、

129
00:04:18,420 --> 00:04:19,840
我らが得るのは

130
00:04:20,010 --> 00:04:21,340
この項、

131
00:04:21,560 --> 00:04:22,370
- logの 1+eの-z乗 分の一。

132
00:04:22,860 --> 00:04:25,050
ここで一つ前のスライドと同様、

133
00:04:25,330 --> 00:04:26,480
zをシータ転置xを表すのに

134
00:04:27,490 --> 00:04:29,430
使っている。

135
00:04:29,640 --> 00:04:30,930
もちろん、コストでは

136
00:04:31,040 --> 00:04:32,130
実際はこの -y があるはずだが、

137
00:04:32,380 --> 00:04:33,490
今言ったように、y=1の場合だ。

138
00:04:33,540 --> 00:04:34,790
だからそれは1だ。

139
00:04:35,020 --> 00:04:36,500
それを単に

140
00:04:36,580 --> 00:04:38,010
ここに書いたように

141
00:04:38,300 --> 00:04:39,820
整理しただけ。

142
00:04:41,950 --> 00:04:43,030
そしてこの関数をzの関数として、

143
00:04:43,580 --> 00:04:45,080
プロットすると、

144
00:04:45,230 --> 00:04:46,320
こんな曲線が

145
00:04:47,160 --> 00:04:48,630
この左下に描いた

146
00:04:49,220 --> 00:04:50,290
この線が見られる。

147
00:04:51,120 --> 00:04:52,290
こうして、

148
00:04:52,640 --> 00:04:53,590
zがとても大きい時は

149
00:04:53,860 --> 00:04:54,930
つまりシータ転置xが

150
00:04:55,440 --> 00:04:56,930
大きい場合は、

151
00:04:57,800 --> 00:04:58,790
とても小さい値、

152
00:04:58,890 --> 00:04:59,900
コスト関数に

153
00:05:00,100 --> 00:05:02,050
ちょっとしか寄与しない

154
00:05:03,000 --> 00:05:04,650
zに対応する。

155
00:05:04,740 --> 00:05:06,120
これは、何故

156
00:05:06,270 --> 00:05:07,790
ロジスティック回帰において、

157
00:05:08,260 --> 00:05:10,020
陽性の手本で

158
00:05:10,640 --> 00:05:12,200
y =1を見たら

159
00:05:12,860 --> 00:05:14,220
シータ転置xに

160
00:05:14,650 --> 00:05:15,810
とても大きな値を入れたがる、ある種の説明になっている。

161
00:05:15,980 --> 00:05:17,440
何故ならそれは対応するコスト関数の中の

162
00:05:18,300 --> 00:05:21,490
この項が、とても小さくなる事を意味するから。

163
00:05:21,760 --> 00:05:23,640
ここで、サポートベクターマシンを構築する為に、これがやるべき事だ。

164
00:05:23,740 --> 00:05:24,780
このコスト関数取って、

165
00:05:25,740 --> 00:05:29,420
この-log の 1足すe の -z乗 分の一 を、ちょびっと変更する。

166
00:05:31,270 --> 00:05:32,450
この点、

167
00:05:33,590 --> 00:05:35,120
ここにある1を取り、

168
00:05:36,150 --> 00:05:37,200
今後使うコスト関数を書いてみよう、

169
00:05:37,280 --> 00:05:38,510
新しいコスト関数は

170
00:05:38,870 --> 00:05:40,320
ここからフラットになり、

171
00:05:42,000 --> 00:05:42,980
そして成長の仕方は

172
00:05:43,170 --> 00:05:45,720
直線で描く、

173
00:05:46,280 --> 00:05:49,230
ロジスティック回帰に

174
00:05:49,530 --> 00:05:50,710
似ているが、しかしこれは

175
00:05:50,950 --> 00:05:52,740
直線。

176
00:05:52,870 --> 00:05:55,040
つまり、マゼンタで今描いた

177
00:05:55,190 --> 00:05:57,580
曲線。
紫というかマゼンダで描いた曲線。

178
00:05:58,090 --> 00:05:59,580
つまりこれは、

179
00:05:59,730 --> 00:06:01,840
ロジスティック回帰で使っていたコスト関数に

180
00:06:02,310 --> 00:06:03,480
極めて近い近似となっている。

181
00:06:03,900 --> 00:06:05,060
2つの線分から

182
00:06:05,130 --> 00:06:06,590
構成されている所が違うが。

183
00:06:07,490 --> 00:06:09,110
右側にはこのフラットな部分があり、

184
00:06:09,430 --> 00:06:11,590
そしてこの左側には

185
00:06:11,860 --> 00:06:14,340
直線の部分がある。

186
00:06:14,630 --> 00:06:16,460
そして直線部分の傾きについてはあんま気にしないでくれ。

187
00:06:16,930 --> 00:06:18,930
それはそんなには重要じゃない。

188
00:06:19,180 --> 00:06:21,630
以上がy=1のときに使う事になる

189
00:06:21,730 --> 00:06:23,910
新しいコスト関数だ。

190
00:06:24,100 --> 00:06:25,240
そして想像できると思うが

191
00:06:25,340 --> 00:06:28,310
ロジスティック回帰と極めて似た事をやっていく事になる。

192
00:06:29,190 --> 00:06:30,470
だがやがて明らかになるが、これは

193
00:06:30,750 --> 00:06:32,630
サポートベクターマシンの計算的な優位である、

194
00:06:33,690 --> 00:06:34,470
より簡単な最適化問題を

195
00:06:34,890 --> 00:06:37,190
あとで与えてくれる事となる。

196
00:06:37,570 --> 00:06:39,670
それは株の取引などにより容易に応用出来る。

197
00:06:41,050 --> 00:06:41,990
ここまではy=1の場合だけを

198
00:06:42,120 --> 00:06:43,300
話してきた。

199
00:06:43,370 --> 00:06:44,420
もう一方のケース、y=0、

200
00:06:44,660 --> 00:06:46,120
この場合は、

201
00:06:47,090 --> 00:06:47,870
コスト関数を見てみると、

202
00:06:48,510 --> 00:06:49,880
この二番目の項だけが

203
00:06:50,220 --> 00:06:51,470
適用される、何故なら

204
00:06:51,610 --> 00:06:52,800
最初の項は、y=0の時は

205
00:06:53,330 --> 00:06:54,490
消え去るから。

206
00:06:54,640 --> 00:06:55,670
つまりここは0となる。

207
00:06:55,800 --> 00:06:56,640
だから上の式で

208
00:06:57,040 --> 00:06:58,100
二番目の項だけが残る。

209
00:06:59,150 --> 00:07:00,600
だから手本のコスト、

210
00:07:00,710 --> 00:07:01,960
つまりコスト関数へと寄与は

211
00:07:01,980 --> 00:07:03,620
ここの、この項で

212
00:07:03,840 --> 00:07:04,850
与えられる。

213
00:07:05,180 --> 00:07:06,620
そしてそれをzの関数として

214
00:07:06,710 --> 00:07:07,860
プロットすると、、、

215
00:07:08,560 --> 00:07:09,750
だからここで横軸に

216
00:07:09,990 --> 00:07:11,290
zを取って、最終的には

217
00:07:11,400 --> 00:07:13,370
このカーブとなる。

218
00:07:13,470 --> 00:07:14,570
そしてサポートベクターマシンの為、

219
00:07:14,790 --> 00:07:15,540
ふたたびこの青い線を

220
00:07:16,250 --> 00:07:17,860
似たような物で置き換える。

221
00:07:18,380 --> 00:07:20,060
そして新しいコストで

222
00:07:20,670 --> 00:07:22,220
それを置き換えると、

223
00:07:23,480 --> 00:07:24,910
ここは平坦となる。ここは0で、

224
00:07:25,020 --> 00:07:26,230
その後は直線で増加していく。

225
00:07:27,900 --> 00:07:27,900
こんな感じ。

226
00:07:29,070 --> 00:07:29,710
では、これら2つの関数に

227
00:07:29,860 --> 00:07:31,950
名前をつけよう。

228
00:07:32,830 --> 00:07:33,910
この左の関数を

229
00:07:34,080 --> 00:07:35,850
cost下付き添字1のzと

230
00:07:37,140 --> 00:07:38,360
呼ぶ。

231
00:07:38,800 --> 00:07:39,650
そしてこの右側の関数を、

232
00:07:39,870 --> 00:07:41,700
cost下付き添字0のzと呼ぶ。

233
00:07:42,980 --> 00:07:44,260
ここで下付き添字は単に

234
00:07:44,860 --> 00:07:46,740
y=1に対応しているコストか、

235
00:07:47,070 --> 00:07:48,570
またはy=0に対応しているコストかを示しているに過ぎない。

236
00:07:49,930 --> 00:07:51,470
これらの定義で武装したので、

237
00:07:51,580 --> 00:07:54,730
サポートベクターマシンを構築する準備は整った！

238
00:07:55,000 --> 00:07:56,030
これはロジスティック回帰の

239
00:07:56,300 --> 00:07:57,230
コスト関数、Jのシータだ。

240
00:07:57,340 --> 00:07:58,440
この方程式が

241
00:07:58,770 --> 00:07:59,760
ちょっと見慣れない、と感じたとしたら、

242
00:07:59,860 --> 00:08:02,220
それは前回はマイナスの符号を

243
00:08:02,360 --> 00:08:04,270
外に置いていた。

244
00:08:04,800 --> 00:08:05,820
だがここでは、マイナスの符号を

245
00:08:05,930 --> 00:08:07,010
この式の中に

246
00:08:07,610 --> 00:08:08,800
移動した。

247
00:08:08,950 --> 00:08:09,920
だからちょっと違って見えるかもしれない。

248
00:08:10,080 --> 00:08:12,970
サポートベクターマシンの為に

249
00:08:13,340 --> 00:08:14,670
我らがやる事は

250
00:08:14,730 --> 00:08:16,550
本質的にはここを、

251
00:08:16,820 --> 00:08:18,460
cost1のzで

252
00:08:19,080 --> 00:08:21,260
置き換える。

253
00:08:21,740 --> 00:08:23,060
これはcost1のシータ転置x。

254
00:08:23,320 --> 00:08:25,240
そしてこれを

255
00:08:25,300 --> 00:08:27,250
cost0のzで置き換える。

256
00:08:28,640 --> 00:08:31,420
これはcost0のシータ転置xで、

257
00:08:32,060 --> 00:08:34,090
ここで

258
00:08:35,030 --> 00:08:36,680
cost1関数は

259
00:08:37,000 --> 00:08:37,740
前のスライドで見た奴で、

260
00:08:38,170 --> 00:08:39,930
こんな感じで、

261
00:08:40,890 --> 00:08:42,540
cost0関数もまた、

262
00:08:42,680 --> 00:08:44,420
前のスライドで見た奴で、

263
00:08:44,910 --> 00:08:46,730
こんな感じの奴。

264
00:08:46,860 --> 00:08:48,080
サポートベクターマシンにおいて、

265
00:08:48,420 --> 00:08:49,360
我らがやるのは、

266
00:08:49,910 --> 00:08:52,220
1/mの和を

267
00:08:52,340 --> 00:08:55,210
トレーニング手本に渡って取ることの、

268
00:08:55,400 --> 00:08:58,650
y(i)掛けるcost1の

269
00:08:59,090 --> 00:09:01,050
シータ転置x(i)

270
00:09:01,300 --> 00:09:03,910
足すことの 1-y(i)

271
00:09:04,650 --> 00:09:06,640
掛けるcost0のシータ転置x(i)。

272
00:09:07,220 --> 00:09:10,490
そしてさらに、

273
00:09:10,990 --> 00:09:13,470
いつもの正規化パラメータ、

274
00:09:17,120 --> 00:09:23,280
こんな感じ。

275
00:09:24,130 --> 00:09:25,280
ここでサポートベクターマシーンの

276
00:09:25,570 --> 00:09:27,610
慣例により、実際にはちょっと違った

277
00:09:27,790 --> 00:09:29,510
書き方をする。

278
00:09:30,570 --> 00:09:31,690
これをちょっと違う風にパラメトライズする。

279
00:09:31,850 --> 00:09:33,720
まず、1/mの項を

280
00:09:34,130 --> 00:09:35,360
取り除く。

281
00:09:35,670 --> 00:09:36,860
これは単に

282
00:09:37,130 --> 00:09:38,480
これは単に

283
00:09:38,770 --> 00:09:40,380
ロジスティック回帰とはちょっとだけ異なる

284
00:09:40,640 --> 00:09:41,930
コンベンションをサポートベクターマシンでは

285
00:09:42,140 --> 00:09:43,400
人々が偶然使っていた、というだけ。

286
00:09:44,160 --> 00:09:46,180
それはこういう事だ。

287
00:09:46,670 --> 00:09:47,960
つまり単純に

288
00:09:48,210 --> 00:09:49,450
1/mの項を取り除く。

289
00:09:50,070 --> 00:09:50,860
これは最適なシータの値には

290
00:09:51,070 --> 00:09:53,030
違いをうまないはず。

291
00:09:53,620 --> 00:09:55,020
何故なら1/mは単に定数だから。

292
00:09:56,420 --> 00:09:57,550
だからこの最小化問題を

293
00:09:57,930 --> 00:09:59,410
前に1/mを置いて解こうが置かないで解こうが

294
00:09:59,580 --> 00:10:00,430
得られる結果は

295
00:10:01,100 --> 00:10:02,010
同じ最適なシータの

296
00:10:02,490 --> 00:10:03,510
値となる。

297
00:10:04,590 --> 00:10:05,450
それはこういう事だ。

298
00:10:05,590 --> 00:10:07,000
具体例を見よう。

299
00:10:08,010 --> 00:10:09,170
以下のような最適化問題があるとする。

300
00:10:09,370 --> 00:10:11,040
実数のuを、(u-5)の二乗 +1を

301
00:10:11,460 --> 00:10:14,700
最小化するように選ぶ。

302
00:10:17,080 --> 00:10:18,540
この場合、最小になるのは

303
00:10:18,620 --> 00:10:20,040
これが最小になるのは

304
00:10:20,440 --> 00:10:21,900
u=5の時だ。

305
00:10:23,090 --> 00:10:23,980
今、この目的関数に対し、

306
00:10:24,120 --> 00:10:25,800
これを10掛けると

307
00:10:26,430 --> 00:10:28,240
するとこの場合、

308
00:10:28,770 --> 00:10:29,850
最小化問題は

309
00:10:30,570 --> 00:10:33,510
10掛ける (u-5)の二乗

310
00:10:33,960 --> 00:10:35,270
足すことの10 を最小にするuだ。

311
00:10:35,920 --> 00:10:37,650
これを最小にするuは

312
00:10:37,670 --> 00:10:40,350
u=5のままだ。

313
00:10:40,940 --> 00:10:42,540
つまり、最小化したい物に、

314
00:10:42,640 --> 00:10:44,160
何か定数を掛けても、

315
00:10:44,360 --> 00:10:45,540
この場合は10を掛けた訳だが、

316
00:10:46,010 --> 00:10:47,710
その事はこの関数を最小にする

317
00:10:48,290 --> 00:10:51,450
uの値を、変える事は無い。

318
00:10:52,650 --> 00:10:53,680
つまり同様に、

319
00:10:53,830 --> 00:10:55,120
このmを取り除く為にやったのは、

320
00:10:55,430 --> 00:10:56,940
私がやったのは、

321
00:10:56,990 --> 00:10:58,770
目的関数にある定数、mを

322
00:10:59,240 --> 00:11:00,650
掛けただけだ。

323
00:11:00,940 --> 00:11:01,920
だからそれは、最小になる

324
00:11:02,360 --> 00:11:04,310
シータを変化させる事は無い。

325
00:11:05,480 --> 00:11:07,190
2つ目のちょっとしたノーテーションの変更は

326
00:11:07,470 --> 00:11:08,560
ロジスティック回帰の代わりに

327
00:11:08,740 --> 00:11:10,630
SVMを使う時に、

328
00:11:11,170 --> 00:11:13,250
もっとも一般的なコンベンションだが、それは以下のような物だ。

329
00:11:14,210 --> 00:11:15,880
ロジスティック回帰の時は、

330
00:11:16,520 --> 00:11:18,270
目的関数に2つの項があった。

331
00:11:19,340 --> 00:11:20,500
一つ目の項は

332
00:11:20,920 --> 00:11:22,020
トレーニングセットから来る

333
00:11:22,450 --> 00:11:23,910
コストだった。

334
00:11:23,990 --> 00:11:25,730
二番目のこの項は、

335
00:11:26,140 --> 00:11:28,330
正規化の項。

336
00:11:28,380 --> 00:11:29,460
そして我らがやらなくてはいけなかったのは、

337
00:11:29,870 --> 00:11:30,900
これらの間のトレードオフを

338
00:11:31,270 --> 00:11:32,600
制御する事だった。つまり、

339
00:11:32,810 --> 00:11:34,760
最小化したいのはA足すことの、

340
00:11:35,760 --> 00:11:38,240
正規化のパラメータ、ラムダに

341
00:11:39,370 --> 00:11:42,280
掛けるなんかの項、Bだ。

342
00:11:42,430 --> 00:11:43,430
ここでAを

343
00:11:43,510 --> 00:11:44,970
この最初の項を指すのに使い、

344
00:11:45,080 --> 00:11:46,160
そしてBをこの

345
00:11:46,390 --> 00:11:48,280
二番目の項を指すのに

346
00:11:48,490 --> 00:11:49,560
使う。ラムダは抜きで。

347
00:11:49,650 --> 00:11:52,440
そしてこのAとBの

348
00:11:53,140 --> 00:11:56,090
優先度を考える代わりに、

349
00:11:56,270 --> 00:11:57,950
我らがやったのは、

350
00:11:58,200 --> 00:11:59,670
この正規化のパラメータ、ラムダに

351
00:12:00,010 --> 00:12:02,210
異なる値をセットしていったのだった。

352
00:12:03,060 --> 00:12:04,180
我らは相対的に

353
00:12:04,670 --> 00:12:05,720
どれだけトレーニングセットに

354
00:12:05,900 --> 00:12:06,780
良くフィットさせるか、

355
00:12:07,560 --> 00:12:09,390
つまりどれだけAを最小化するかと、

356
00:12:09,510 --> 00:12:12,930
とれだけパラメータの値を小さく保つ事を気にするか、

357
00:12:13,470 --> 00:12:14,530
それがパラメータBだが、

358
00:12:14,640 --> 00:12:16,170
それらの間のトレードオフを取る。

359
00:12:16,380 --> 00:12:17,620
サポートベクターマシンでは、

360
00:12:18,250 --> 00:12:19,150
慣例により、違うパラメータを使う。

361
00:12:19,570 --> 00:12:21,960
一番目の項と二番目の項の間の

362
00:12:22,180 --> 00:12:23,220
重みをコントロールする為に

363
00:12:23,640 --> 00:12:24,730
ラムダを使う代わりに、

364
00:12:24,810 --> 00:12:26,260
そこでもまだパラメータを

365
00:12:26,300 --> 00:12:27,370
使う事になるのだが、

366
00:12:27,710 --> 00:12:29,070
それはコンベンションで

367
00:12:29,290 --> 00:12:31,530
Cと呼ばれる。

368
00:12:31,730 --> 00:12:33,550
そして、代わりに C掛けるA 足す B

369
00:12:34,430 --> 00:12:39,160
を最小化する。

370
00:12:39,380 --> 00:12:41,210
ロジスティック回帰の時は

371
00:12:41,340 --> 00:12:42,730
とても大きなラムダの値を用いると、

372
00:12:42,990 --> 00:12:43,980
それの意味する所はBに

373
00:12:44,260 --> 00:12:45,970
とても大きな重みを付与する、という事だ。

374
00:12:46,590 --> 00:12:47,640
今回は、もしCにとても小さな

375
00:12:47,960 --> 00:12:49,750
値をセットすると、

376
00:12:50,070 --> 00:12:51,510
それがB に、Aとくらべて

377
00:12:51,800 --> 00:12:53,530
とても大きな重みを付与する事になる。

378
00:12:54,610 --> 00:12:55,730
つまり、これはトレードオフをコントロールする

379
00:12:55,890 --> 00:12:57,330
単なる別のやり方、または

380
00:12:57,630 --> 00:12:58,970
どれだけ最初の項を最適化するか、 vs

381
00:12:59,060 --> 00:13:01,530
どれだけ二番目の項の最適化を重視するか、 をパラメトライズする異なるやり方に過ぎない。

382
00:13:05,290 --> 00:13:06,250
必要に応じて

383
00:13:06,380 --> 00:13:07,620
これをパラメータCが、

384
00:13:08,180 --> 00:13:09,580
1/ラムダ と

385
00:13:09,800 --> 00:13:11,570
似たよう役割の物と

386
00:13:11,890 --> 00:13:13,900
みなすことができる。

387
00:13:14,080 --> 00:13:16,100
それはこれら2つの

388
00:13:16,720 --> 00:13:17,900
方程式、2つの式が同じになるという訳では無く、

389
00:13:18,000 --> 00:13:19,500
C=1/ラムダ というのはそういう場合という訳では無く、

390
00:13:19,650 --> 00:13:21,350
もしCが1/ラムダ と等しいと

391
00:13:22,260 --> 00:13:24,510
これら2つの最適化の目的関数は

392
00:13:24,710 --> 00:13:26,670
同じ結果の値を

393
00:13:26,940 --> 00:13:28,260
与える、という事。

394
00:13:28,500 --> 00:13:29,460
同じ最適値シータを。

395
00:13:30,350 --> 00:13:31,180
それを踏まえると、

396
00:13:31,400 --> 00:13:33,030
ラムダを消して、

397
00:13:33,730 --> 00:13:34,940
定数C をここに書く。

398
00:13:35,030 --> 00:13:37,930
以上の操作で、

399
00:13:38,170 --> 00:13:40,830
サポートベクターマシンの

400
00:13:41,280 --> 00:13:42,650
全体の最適化の目的関数が得られる。

401
00:13:42,900 --> 00:13:43,970
そしてこの関数を

402
00:13:44,080 --> 00:13:46,200
最適化すれば、

403
00:13:46,340 --> 00:13:47,410
SVMにより学習したパラメータを

404
00:13:48,230 --> 00:13:52,800
得られる。

405
00:13:52,940 --> 00:13:54,690
最後に、ロジスティック回帰と異なり、

406
00:13:54,840 --> 00:13:56,110
サポートベクターマシンは確率を出力する訳では無い。

407
00:13:56,220 --> 00:13:57,850
その代わりに、

408
00:13:57,970 --> 00:13:58,910
我らが得るのは

409
00:13:59,190 --> 00:14:00,600
このコスト関数を最小化する

410
00:14:00,730 --> 00:14:02,770
パラメータ、シータで、

411
00:14:02,910 --> 00:14:03,900
サポートベクターマシンがやるのは、

412
00:14:05,130 --> 00:14:05,970
yが1か0かの予言を

413
00:14:07,050 --> 00:14:08,650
直接行う。

414
00:14:08,690 --> 00:14:10,390
つまり、仮説は、

415
00:14:11,310 --> 00:14:12,920
シータ転置のxが

416
00:14:14,150 --> 00:14:15,630
0より大きければ

417
00:14:15,890 --> 00:14:17,680
1を予言し、

418
00:14:18,230 --> 00:14:20,060
それ以外なら0を予言する。

419
00:14:20,320 --> 00:14:21,560
つまり、学習したパラメータのシータを

420
00:14:21,610 --> 00:14:23,010
得た後は、

421
00:14:23,360 --> 00:14:25,980
これがサポートベクターマシンの仮説の形だ。

422
00:14:26,850 --> 00:14:27,870
以上が、サポートベクターマシンが

423
00:14:27,980 --> 00:14:29,670
何をするかの

424
00:14:29,840 --> 00:14:31,520
数学的な定義だ。

425
00:14:31,750 --> 00:14:32,870
次に続く幾つかのビデオて、

426
00:14:33,100 --> 00:14:33,900
この最適化の目的関数が

427
00:14:34,260 --> 00:14:36,030
何を意味するかを直感的に

428
00:14:36,480 --> 00:14:37,660
把握する事を目指します。

429
00:14:37,820 --> 00:14:38,840
そしてSVMが

430
00:14:39,720 --> 00:14:41,300
学習する仮説の元と

431
00:14:41,700 --> 00:14:43,060
どう修正したら、

432
00:14:43,600 --> 00:14:44,640
より複雑な、非線形の関数が

433
00:14:44,920 --> 00:14:46,280
学習出来るかも話します。