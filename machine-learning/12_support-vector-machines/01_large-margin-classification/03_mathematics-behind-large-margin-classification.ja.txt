このビデオでは 大きなマージンによる分類の 背後にある数学について、ちょっと話しておきたい。 このビデオはオプショナルです。だからどうぞご自由にスキップしちゃって下さい。 このビデオでは、また、 サポートベクターマシンの 最適化問題が、どのように 大きなマージン分類器を導くのかについての より良い直感も与えたいと思う。 始めるにあたって まずベクトルの内積について 幾つかの性質を思い出しておこう。 2つのベクトル、uとvが あったとする。こんな感じの。 つまりどちらも二次元ベクトルだ。 そしてu転置のvが どんな風になるか見てみよう。 u転置 v はまた、 ベクトルuとvとの 内積、とも言われる。 二次元のベクトルを使う事で この図にプロットする事が出来る。 さて、これが ベクトルuとしよう。 これの意味する所は、 水平軸上で、 何かしらの値u1を取り、 そして垂直軸上では その高さは 何かしらの値u2を取る、 これがベクトルuの 第二成分である、という事。 ここで、得ておくと良い 一つの量として、 ベクトルuのノルムがある。 これらの、左と右の両方にある 二重線が、 uのノルム、言い換えると長さを表す。 つまりこれは単に、 ベクトルuのユークリッド距離を表すに過ぎない。 そして、 ピタゴラスの定理により、 イコール u1の二乗に 足すことの u2の二乗、 これをルートを取る。 そしてこれはベクトルuの長さで、それは実数だ。 この長さ、 ここのこのベクトルの 長さ。 ここに今書いた矢印の長さ、 これがuのノルムだ。 さてここで、戻って、ベクトルvを見てみよう、 何故なら内積を計算したいのだから。 さて、vもまた何らかの 別のベクトルで、 何らかの値、v1とv2がある。 だからベクトルvも こんな感じに、vベクトル。 ここで、戻って、 uとvの内積を計算する方法を 見てみよう。 それはこんなやり方で出来る。 ベクトルvに対して それをベクトルu上に射影しよう。 つまり、直角に 射影する、 あるいは90度に射影する、そしてそれを u上に下ろす。 そしてやるべき事は、 この赤い線、たった今引いたこれの 長さを測る。 この赤い線の長さを pと呼ぶ事にしよう。 するとpはベクトルvを ベクトルuに射影した時の 長さ、大きさである。 ここに書き記しておこう。 つまりpは ベクトルvを ベクトルuに射影した時の 長さである。 そして内積である u転置 vは p掛ける uのノルム、あるいは長さに 等しくなる、 という事を 示す事が 出来る。 つまり、これは内積を計算する一つの方法である。 そして実際に幾何学を用いると pが何なのか、uのノルムが何なのかを 知る事が出来る。 この結果は 内積の別の計算方法と 同じ答えとなるべきだ。 でしょ？ それは uの転置 vで、 u転置 は u1, u2。 これは1x2 行列。それに かけることのv。 つまり、これは実際に u1 v1 足す事の u2 v2 を与える。 つまり、線形代数の定理として これら二つの式は 同じ答えとなる。 ところで、uの転置 vは、 v転置 uとも 等しい。 だから同様のプロセスを反対に行えば、 vをuに射影する代わりに uをvに射影出来て、 同様のプロセスだが uとvの役割を反転させると、 実際にも同じ数字を得る、 その数字がなんであれ。 この等式で何が起こっているのかを もう少し明らかにしておく。 uのノルムは実数で pもまた実数だ。 だから u転置 v は、 単なる二つの実数の、普通の掛け算で、 pの長さ 掛ける uのノルム。 最後に一つ細かい話を。 pのノルムを見る時には、 pは実際は符合つきだ。 それはプラスにもマイナスにもなりうる。 ようするに、 ベクトルuが このようなベクトルだとして、 vがこんなベクトルだとすると、 つまりuとvのなす角が 90度より大きければ、 vをu上に射影すると、 得られる射影は こんな感じとなり、 これがpの長さとなる。 そしてこの場合、 u転置 vは 基本的には、依然として p掛ける uのノルム、となるが、 しかしこの場合は、 pが負になる所だけが違う。 つまり、内積においては、 uとvのなす角が 90度未満の時は、 pは赤い線の正の長さとなり、 一方でここの角度が 90度以上の時は、 ここのpは マイナスの長さ、 マイナスの、ここの線分の長さとなる。 つまり、二つのベクトルの内積は マイナスになる事がある、 もしなす角が90度より大きければ。 以上がベクトルの内積が どう機能するかだ。 これらのベクトルの内積の 性質を用いて、 ここのサポートベクターマシンの 最適化の目的関数を理解しよう。 これが以前に見た、サポートベクターマシンの 最適化の目的関数だ。 このスライドの目的の為に 一つ単純化しておこう、 つまり、目的関数を分析しやすくする為に 切片項を 無視する事にする。
つまりシータ0を無視する、つまりイコール0とする。 またプロットしやすいように、n、つまりフィーチャーの数を2とする。 つまり、x1とx2だけとする。 ここで、目的関数を見てみよう。 SVMの目的関数を。 フィーチャーは二つだけなので、 何故ならn=2だから、 これは以下のように書ける： 1/2の シータ1の二乗 足すことの シータ2の二乗、と。 何故なら我らは、二つのパラメータだけ、シータ1とシータ2だけしか持たないから。 そしてこれをちょっと書き換える。 これを、1/2の シータ1の二乗に 足す事の シータ2の二乗、 そしてこれらのルートを取る。 こんな事が出来る理由というのは、 任意の数wに対して、 wを二乗して、 それ全体のルートを取ると、それはちょうどwと等しくなるから。 つまり、ルートして二乗は 同じ物を返す。 ここで気づく事として、 この中の項は、 シータのノルムと 言い換えるとベクトルシータの長さと 等しい。 そしてそれによって意味する事は、 ベクトルシータをこんな風に 書き下すと、 つまり、シータ1, シータ2,と書くと、 するとこの今赤で下線を引いた この項は、これは正確に ベクトルシータの長さ、ノルムである。 前のスライドにあった、 ベクトルのノルムの定義に等しい。 そして実際に、これは ベクトルシータの長さに 等しい。たとえあなたが シータ0, シータ1, シータ2で書いても、 ここで仮定したようにシータ0が0だから、 または単にこれはシータ1, シータ2の長さでもあるが、 このスライドではシータ0を 無視するのだったから、 シータをこんな風に シータの、このシータ1, シータ2のノルムを こんな風に 書いてみよう。 だが、この数学は どっちでも成立する。 シータ0を含めようとも、無視しようとも。 だからこれは以下の導出には、影響しない。 そして最終的に、これは 私の最適化の目的関数が 1/2のシータのノルムの二乗に 等しい事を意味する。 つまりサポートベクターマシンがやる事の全ては、 最適化の目的関数として、 パラメータベクトルのシータの ノルムの二乗、つまり長さの二乗を 最小化しようと試みる。 ここで私はこれらの項を見て、 シータ転置 xを見て、 それらが何をやっているのかをもっと良く理解していこう。 さて、パラメータベクトルのシータが与えられたとして、 手本のxが与えられたとすると、これは何に等しいだろうか？ 前のスライドでは、 u転置 v とはどんな物なのかを見ていった、 uとvは別のベクトル。 そこで我らはそれらの定義を 持ってきて、シータとx(i)に uとvの役割を させてみよう。 するとどんな絵となるかを見てみよう。 さて、プロットし、、、さて、たった一つの トレーニング手本を見てみるとする。 陽性の手本が一つあるとして、 その場所に十字を描いておくとする。 これを手本x(i)としよう。 それが実際に意味する事は、 横軸にある値、x(i) 1、 そして縦軸に ある値x(i) 2を プロットした、という事。 これがトレーニング手本のプロットの仕方だった。 そして、ここまでの所、 これが実際にはベクトルであるとは考えてこなかったが、 これは本当は 原点、0, 0から このトレーニング手本の位置までの ベクトルだ。 そして今、パラメータベクトルが あるとして、 それも同様にベクトルとして プロットする。 どういう事かというと、シータ1をここに、 シータ2をここにプロットすると、 内積である シータ転置 x(i) は どうなるだろうか？ 以前の手法を用いると、 それを計算する方法は、 手本に対して、 それをパラメータベクトルのシータの上に射影する。 そして次にこの線分の 長さを見る、 今赤で描いているこの長さだ。 そしてこれを、 p上付き添字iと呼ぼう、 これはi番目のトレーニング手本の パラメータベクトル、シータに対する 射影を表す。 すると我らが得るのは、 シータ転置 x(i) は 前のスライドにあった、 以下に等しい。 これは p掛ける ベクトルシータのノルム、長さに 等しくなる。 そしてこれはもちろん、 シータ1 x1 足すことの シータ2 x2 に等しくなる。 つまりこれらはそれぞれどれも、 シータとx(i)の内積を計算する 同じように正統な方法である。 オーケー。 すると何だろう？ これの意味する所は、 この制約条件、シータ転置 x(i) が 1以上か-1以下という条件、 この意味する所は、 制約に使われている式を p(i) 掛ける x が1以上、 に置き換える事が出来る。 何故なら シータ転置 x(i) は p(i)掛けることの シータのノルムに等しいから。 つまり、以上を最適化の目的関数に書きこむと、 これが得られる、 ここでは シータ転置 x(i)の代わりに、 今度は p(i)掛けるシータのノルム となっている。 そして、思い出そう、 前に見てみたように、 この最適化の目的関数は、 1/2掛けるシータのノルムの二乗、 とも書けるのだった。 では下にあるような トレーニング手本を 考えてみよう、 そしてここでも、シータ0が0と等しいという 単純化を継続する。 サポートベクターマシンがどんな決定境界を選ぶかを見てみよう。 ここにそんな選択肢の一つがある。 サポートベクターマシンが仮に この決定境界を選んだ、と仮定してみよう。 これはとても良い選択という訳では無さそうだ。何故ならマージンがとても小さいから。 この決定境界はトレーニング手本のとても近くを通ってる。 何故サポートベクターマシンがこれを行わないかを見ていこう。 このパラメータの選択において、 パラメータベクトルは実際に 決定境界と90度の角度をなす事が 証明出来る。 つまり、この緑の決定境界は この方向を向いたパラメートルベクトルのシータに 対応している。 ところで、シータ0がイコール0だという 単純化は、単に 決定境界が原点、ここの(0, 0)を 通らないといけない、という事を意味しているに過ぎない。 ではここで、 これが最適化の目的関数に対して 何を意味しているかを見ていこう。 この手本がここにあったとする。 これが私の最初の手本、 x(1)だとしよう。 この手本のパラメータシータに対する 射影を見てみると、 これが射影となる。 つまりこの赤い線分。 これはイコールp1だ。 そしてこれは極めて小さい。でしょ？ そして同様に、このここの手本を見ると、 これをx2とすると、 これが二番目の手本という事だが、 この手本のシータに対する射影を見てみよう。 お分かりの通り、 これをマゼンタで描く事にすると、 この小さなマゼンタの線分、 これがp(2)となる。 これが二番目の手本を パラメータベクトルシータに 射影した物で、それはこんな感じになる。 つまり、この小さな射影の 線分は、極めて小さくなってしまう。 p(2)は実際には負の数だから、p(2)は 反対の向きになる。 このベクトルは パラメータベクトルから90度より 大きな角度となるので、0以下となる。 すると分かる事は、 これらの項、p(i)は 極めて小さな数となるという事だ。 つまり最適化の目的関数を見ると、 陽性の手本に対しては p(i)掛ける シータのノルムが 1以上である必要があるが、 ここのp(i)、 ここのp(1)が とても小さければ、 シータのノルムは とても大きくならないといけない。でしょ？ p(1) が小さくて、 p(1)掛けるシータのノルムを 1以上に したいのだから、 この条件を真にする 唯一の方法は、 この二つの数が大きくなるには、 p(1)が小さいとするなら、 シータのノルムが大きくなる必要がある。 同様に陰性の手本に対しては、 p(2) 掛けることの シータのノルムが、 -1未満で なくてはならない。 そしてこの手本に対しては p(2)は極めて小さい 負の数である事を既に見た。 だからその条件が満たされる 唯一の方法も、同様に、 シータのノルムが大きくなる、という事だ。 だが我らが行っている 最適化の目的関数は、 以下のような条件を満たした シータの組を探すという事だった： その条件とはシータのノルムが 小さくなる、という物、つまり、 これはパラメータベクトルのシータにとって 良い方向では 無さそうだ。 これと比較して、別の決定境界を見てみよう。 今度は、このSVMはこんな決定境界を 選んだとしよう。 こんどは随分と違う絵となる。 これが決定境界だとすると、 それに対応したシータの方向は こうなる。 さて、この決定境界、 垂直な直線に、 対応した決定境界は、 線形代数を用いて 証明する事が出来るのだが、 この緑の決定境界を得る方法は、 それと直角の シータベクトルを持てば良い。 そしてあなたのデータを ベクトルシータに 射影した物を見ると、 前と同様にこの手本を 手本x(1)とすると、 これをシータに射影すると、 これがp(1)となる。 この長さがp(1)。 別の手本、この手本にも 同様の射影を 行って、 この長さ、 ここが、p(2)となり、 これは0未満となる。 そして見て分かるように、 ここでのp(1)とp(2)、 これら射影の長さは、 もっと大きくなっている。 だから、この制約、 p(1) シータのノルム が 1以上、という制約が ここでも満たされている必要があるとすると、p(1)はいまやもっと大きくなったので ノルムは小さくなれる。 すると、この意味する所は、 決定境界を、 左に示したような物では無く右側に示したような物を 選ぶ事によって、 SVMはパラメータシータのノルムを もっと小さくする事が出来る。 すると、シータのノルムを 小さくする事が出来ると、 それはシータのノルムの二乗も 小さくなるので、 それこそが、SVMが 右側の仮説の方を選ぶであろう理由となる。 そしてこのようにして、 SVMは大きなマージンの分類の効果を 生み出す。 例えば、この緑の直線を見ると、 この緑の仮説を見ると、 我らは、陽性と陰性の手本の シータに対する射影を 大きくしたい。 これを真に保つ、唯一の方法は、 緑の線を囲むとすると、 この大きなマージンが存在する事、 この陽性と陰性の手本を分離する時に 大きなギャップが存在する事、 実際にこのギャップの大きさ、 このマージンの大きさは、 実際にp(1)、p(2)、p(3)などの 値である。 つまりこのマージンを大きくする事で、 これらp(1)、p(2)、p(3)などを 大きくしようとする事で、 SVMは結果として シータのノルムを小さくする事が出来る、 そしてそれこそが目的関数でやろうとしていた事だった。 こんな訳で、サポートベクターマシンは 分類器のマージンを 広げる事になる、何故なら、 それはp(1)のノルム、 それは決定境界から手本までの距離だが、 それを最大化しようとするからだ。 最後に、我らはこれらの導出を 全てパラメータのシータ0が、イコール0という 単純化の元で行なってきた。 その効果を簡単に 伝えておく。 シータ0が0と等しい時というのは、 それの意味する所は、 決定境界をいつも、 原点を通る物だけで 決めるという事に対応する。 こんな風に原点を通る。 もしシータ0に、0以外の値を 許すとすると、 その意味する所は、 原点を通らない決定境界も 試していくという事を意味する。今ここに描いたような物も、だ。 これの完全な証明を する気は無いが、 まさにそっくりの 大きなマージンの証明が ほとんど同様に成立する。 そして、ここまで長々と やってきた議論を 一般化出来て、 シータ0が非ゼロでも、 SVMが試みるのはーー この最適化の目的関数を持つ時に、 これもふたたび、Cがとても大きい場合に 対応するが、 ここでも、シータ0が0で無くても このサポートベクターマシンは 同様に陽性と陰性の 手本を分離するような、 大きなマージンの分離を 探そうとする、という事を 示す事が出来る。 以上が、サポートベクターマシンが どのように大きなマージンの分類器であるのか、の説明だ。 次のビデオでは、 これらのSVMの考え方の 幾つかを用いて、 それを複雑な 非線型の分類器を構築する為に 適用していく方法を見ていこう。