इस विडीओ में, मैं चाहूँगा बताना आपको थोड़ा बहुत गणित लार्ज मार्जिन क्लैसिफ़िकेशन के पीछे. यह वीडियो वैकल्पिक है, तो यदि आप चाहें तो छोड़ भी सकते हैं. यह आपको शायद दे पाए एक बेहतर समझ कि कैसे ऑप्टिमायज़ेशन प्रॉब्लम सपोर्ट वेक्टर मशीन की, कैसे वह ले जाती है लार्ज मार्जिन क्लैसिफ़ायअर्स पर. शुरू करने के लिए, चलो पहले आपको याद दिलाता हूँ कुछ गुणों का कि वेक्टर इन इनर प्रोडक्टस कैसे दिखता है. मान लो मेरे पास है दो वेक्टर्स U और V, जो ऐसे दिखते हैं. तो दोनो दो-डिमेन्शनल वेक्टर्स हैं. तब चलो देखते हैं कैसे U ट्रान्स्पोज़ V दिखता है. और U ट्रान्स्पोज़ V को इनर प्रोडक्ट भी कहते हैं वेक्टर्स U और V में. लें एक दो-डिमेन्शनल वेक्टर, तो मैं प्लॉट कर सकता हूँ उसे इस चित्र में. तो मान लो वह है वेक्टर U. और उससे मेरा क्या मतलब है कि यदि हॉरिज़ॉंटल ऐक्सिस पर वह वैल्यू लेती है कुछ भी वैल्यू U1 और वर्टिकल ऐक्सिस पर ऊँचाई उसकी है जो भी U2 है दूसरा कम्पोनेंट वेक्टर U का. अब, एक संख्या जो अच्छी होगी रखने के लिए है नॉर्म वेक्टर U का. तो ये हैं, आप जानते हैं, डबल बारज़ बाईं और दाईं तरफ़ जो डिनोट करती हैं नॉर्म या लम्बाई U की. तो इसका सिर्फ़ मतलब है; वास्तव में यूक्लिडीयन लम्बाई वेक्टर U का. तो यह है पयथागोरस थ्योरम है सिर्फ़ बराबर U1 स्क्वेर्ड प्लस U2 स्क्वेर्ड उसका स्क्वेर रूट, ठीक? और यह है लम्बाई वेक्टर U की. वह है एक रियल नम्बर. सिर्फ़ कहता हूँ, आप जानते हैं, क्या है लम्बाई इसकी, क्या है लम्बाई इस वेक्टर की यहाँ नीचे. क्या है लम्बाई इस ऐरो की जो मैंने अभी बनाया है, वह है नोर्मल व्यू. चलो अभी वापिस चलते हैं और देखते हैं वेक्टर V को क्योंकि हम कम्प्यूट करना चाहते हैं इनर प्रोडक्ट. तो V होगा कोई अन्य वेक्टर जिसमें हैं, आप जानते हैं, कुछ वैल्यूज़ V1, V2. और इसलिए, वेक्टर V दिखेगा वैसा, V की तरफ़ ऐसे. चलो अब वापिस चलते हैं और देखते हैं कैसे कम्प्यूट करना है इनर प्रोडक्ट U और V में. यहाँ है कि आप कैसे कर सकते हैं इसे. मैं लेता हूँ वेक्टर V और प्रोजेक्ट करता हूँ इसे नीचे वेक्टर U पर. तो, मैं लूँगा एक ओर्थोग्नल प्रजेक्शन या एक 90 डिग्री का प्रजेक्शन, और प्रोजेक्ट करूँगा इसे नीचे U पर इस तरह. और मैं क्या करूँगा कि मापेंगे लम्बाई इस लाल लाइन की जो मैंने अभी बनाया है यहाँ. तो, मैं कहूँगा लम्बाई को उस लाल लाइन की P. तो P, है लम्बाई या है परिमाण प्रोजेक्शन का वेक्टर V का वेक्टर U पर. मैं सिर्फ़ लिखता हूँ उसे यहाँ. तो, P है लम्बाई प्रोजेक्शन की वेक्टर V के वेक्टर U पर. और यह है सम्भव दिखा पाना कि इनर प्रोडक्ट U ट्रान्स्पोज़ V, कि वह होगा बराबर P के गुणा नॉर्म या लम्बाई वेक्टर U की. तो यह एक ढंग कम्प्यूट करने का इनर प्रोडक्ट को. और यदि आप वास्तव में करते हैं ज्यामिति / ज्योमेटरी समझने के लिए कि क्या है P और समझने के लिए कि क्या है नॉर्म U का. इसे देना चाहिए समान उत्तर, समान उत्तर जैसे दूसरे ढंग से कम्प्यूट करने का इनर प्रोडक्ट से. सही जो है यदि आप लेते हैं U ट्रान्स्पोज़ V तब U ट्रान्स्पोज़ करता हैं इस U1 U2 को, यह है एक एक बाई दो मेट्रिक्स, 1 गुणा V. और इसलिए इसे वास्तव में आपको देना चाहिए U1, V1 प्लस U2, V2. और इसलिए थ्योरम लिनीअर ऐल्जेब्रा की कि ये दोनो फ़ॉर्म्युला देते हैं आपको एक समान उत्तर. और वैसे भी, U ट्रान्स्पोज़ V है बराबर V ट्रान्स्पोज़ U के भी. तो यदि आपको करनी होती समान प्रक्रिया रिवर्स में, बजाय प्रोजेक्ट करने के V को U पर, आप कर सकते थे प्रोजेक्ट U को V पर. तब, आप जानते हैं, करें वही प्रकिया, लेकिन U और V की रोज़ को उलट कर. आपको वास्तव में, आपको वास्तव में मिलना चाहिए वही नम्बर, जो भी वह नम्बर है. और सिर्फ़ स्पष्ट करने के लिए क्या चल रहा है इस इक्वेज़न में U का नॉर्म है एक रियल नम्बर और P भी है एक रियल नम्बर. और इसलिए U ट्रान्स्पोज़ V है आमतौर का गुणन दो रियल नम्बर्ज़ का लम्बाई P गुणा U का नॉर्म. केवल एक आख़िरी जानकारी, जो है यदि आप देखते हैं नॉर्म P पर, P है वास्तव में साइन के साथ. और यह हो सकता है पॉज़िटिव या नेगेटिव. तो चलो मैं बताता हूँ मेरा क्या मतलब है उस से, यदि U है एक वेक्टर जो दिखता है इस तरह और V है एक वेक्टर जो दिखता है ऐसे. तो यदि कोण U और V के बीच बड़ा है नब्बे डिग्री से. तब यदि मैं प्रोजेक्ट करता हूँ V को U पर, मुझे क्या मिलता है एक प्रजेक्शन जो दिखता है ऐसे और इसलिए वह है लम्बाई P. और इस केस में, मेरे पास अभी भी होगा कि U ट्रान्स्पोज़ V है बराबर P गुणा U का नॉर्म. सिवाय कि इस उदाहरण में P होगा नेगेटिव. तो, आप जानते हैं, इनर प्रोडक्ट में यदि कोण U और V के बीच है कम नब्बे डिग्री से, तब P है पॉज़िटिव लम्बाई उस लाल लाइन की जबकि यदि कोण इसका कोण यहाँ का है बड़ा नब्बे डिग्री से, तब P यहाँ होगा नेगेटिव लम्बाई उस सुपर लाइन की उस छोटी लाइन सेगमेंट की यहाँ पर. तो इनर प्रोडक्ट दो वेक्टर्ज़ में नेगेटिव भी हो सकता है यदि कोण उनके बीच में बड़ा है 90 डिग्री से. तो वह है कि कैसे वेक्टर इनर प्रोडक्ट काम करता हैं. हम करेंगे इस्तेमाल इन गुणों का वेक्टर इनर प्रोडक्ट के समझने के लिए सपोर्ट वेक्टर मशीन के ऑप्टिमायज़ेशन अब्जेक्टिव का वहाँ पर. यह है ऑप्टिमायज़ेशन अब्जेक्टिव सपोर्ट वेक्टर मशीन का जो हमने बनाई थी पहले. केवल उद्देश्य से इस स्लाइड के मैं करूँगा एक सरल काम या चीज़ सिर्फ़ करने के लिए अब्जेक्टिव का आसान अनालिसिस और मैं क्या करूँगा कि अनदेखा करूँगा बाइयस टर्म को. अत:, हम सिर्फ़ अनदेखा करेंगे थीटा 0 और सेट करेंगे उसे 0. आसानी से प्लॉट करने के लिए, मैं सेट करूँगा n, संख्या फ़ीचर्ज़ की 2. तो, हमारे पास हैं केवल 2 फ़ीचर्ज़, x1 और x2. अब, चलो देखते हैं अब्जेक्टिव फ़ंक्शन को. ऑप्टिमायज़ेशन अब्जेक्टिव SVM का. हमारे पास केवल दो फ़ीचर्ज़ हैं. जब n है बराबर 2. यह लिखा जा सकता है, वन हाफ़ ऑफ़ थीटा1 स्क्वेर्ड +थीटा 2 स्क्वेर्ड. क्योंकि हमारे पास हैं केवल दो पेरमिटर्स, थीटा 1 और थीटा 2. मैं क्या करुंगा कि मैं इसे दोबारा लिखूँगा थोड़ा. मैं लिखूँगा इसे इस तरह वन हाफ़ ऑफ़ थीटा 1 स्क्वेर्ड प्लस थीटा 2 स्क्वेर्ड और पूरे का स्क्वेर रूट और फिर से स्क्वेर्ड. और कारण है कि मैं ऐसा कर सकता हूँ, है क्योंकि किसी भी नम्बर, आप जानते है, W का, ठीक है, W का स्क्वेर रूट और फिर से स्क्वेर करना, वह है सिर्फ़ बराबर W के ही. तो स्क्वेर रूट और फिर स्क्वेर करना देता है आपको वही चीज़. जो आप शायद नोटिस कर सकते हैं कि यह अंदर की टर्म वह है बराबर नॉर्म के या लम्बाई के वेक्टर थीटा की और क्या मेरा मतलब है उससे कि यदि हम लिखते हैं वेक्टर थीटा इस तरह, जैसे आप जानते हैं थीटा 1, थीटा 2. तब यह टर्म जो मैंने अभी रेखांकित की है लाल रंग से, वह है वास्तव में लम्बाई, या नॉर्म वेक्टर थीटा का. हम ले रहे हैं परिभाषा वेक्टर के नॉर्म की जो हमारे पास थी पिछली स्लाइड में. और वैसे भी यह वास्तव में है बराबर लम्बाई के वेक्टर थीटा की, चाहे आप लिखें इसे थीटा 0, थीटा 1, थीटा 2 जैसे. मतलब, यदि थीटा 0 है ज़ीरो, जैसे मैंने माना है यहाँ. या सिर्फ़ लम्बाई थीटा 1, थीटा 2 की; लेकिन इस लाइन के लिए मैं करूँगा अनदेखा थीटा ज़ीरो को. तो मैं सिर्फ़, आप जानते हैं, लेता हूँ थीटा को इस तरह, मैं सिर्फ़ लिखता हूँ थीटा, सामान्य थीटा को ऐसे थीटा1, थीटा 2 ही. लेकिन गणित काम करता है दोनो तरह, चाहे हम लें थीटा0 यहाँ या नहीं. तो उससे अंतर नहीं पड़ता हमारी बाक़ी की डेरिवेशन पर. और इसलिए अंत में इसका मतलब है कि मेरा ऑप्टिमायज़ेशन अब्जेक्टिव है बराबर वन हाफ़ ऑफ़ नॉर्म ऑफ़ थीटा स्क्वेर्ड. तो जो सपोर्ट वेक्टर मशीन कर रही है ऑप्टिमायज़ेशन अब्जेक्टिव में कि यह मिनमायज़ करती है स्क्वेर्ड नॉर्म को, स्क्वेर्ड लम्बाई को पेरामिटर वेक्टर थीटा के. अब, मैं क्या करना चाहता हूँ देखूँगा इन टर्म्ज़ को, थीटा ट्रान्स्पोज़ x और समझूँगा बेहतर कि क्या वे कर रही हैं. तो दिया होने पर पेरामिटर वेक्टर थीटा और दिए होने पर हमारे इग्ज़ाम्पल्ज़ x, यह किसके बराबर है? और पिछली स्लाइड पर, हमने देखा था कि कैसे U ट्रैन्स्पोज़ V दिखता है, भिन्न भिन्न वेक्टर्स U और V के साथ. और इसलिए हम लेंगे वे परिभाषाएँ, आप जानते हैं, जिसमें थीटा और x(i) निभा रहे हैं भूमिका U और V की. और चलो देखते हैं कैसी दिखती है वह तस्वीर. तो, चलो मान लो मैं प्लॉट करता हूँ. मान लो मैं लेता हूँ केवल एक ट्रेनिंग इग्ज़ाम्पल. मान लो मेरे पास है एक पॉज़िटिव इग्ज़ाम्पल और बनाता हूँ इसे वहाँ और मान लो वह है मेरा इग्ज़ाम्पल x(i), क्या उसका वास्तव में मतलब है कि प्लॉट करें हॉरिज़ॉंटल ऐक्सिस पर कुछ वैल्यू x(i) 1 और वर्टिकल ऐक्सिस पर x(i) 2. ऐसे मैं प्लॉट करता हूँ मेरे ट्रेनिंग इग्ज़ाम्पल्ज़. और हालांकि हम वास्तव में नहीं सोच रहे थे इसे एक वेक्टर के जैसे, क्या यह वास्तव में है, यह है एक वेक्टर ऑरिजिन से 0,0 से बाहर एस ट्रेनिंग इग्ज़ाम्पल तक. अब, मान लो हमारे पास है एक पेरामिटर वेक्टर और मैं करूँगा प्लॉट उसे भी एक वेक्टर के रूप में. उससे मेरा क्या मतलब है कि यदि मैं प्लॉट करता हूँ थीटा1 यहाँ और थीटा 2 वहाँ तो क्या है इनर प्रोडक्ट थीटा ट्रान्स्पोज़ x(i) का. जब हम इस्तेमाल कर रहे थे हमारी पहली विधि, जैसे हम कम्प्यूट करते हैं उसे है हम लेते हैं मेरा इग्ज़ाम्पल और प्रोजेक्ट करते हैं उसे मेरे पेरामिटर वेक्टर थीटा पर. और फिर मैं लूँगा लंबाई इस सेगेमेंट की जो मैं रंग कर रहा हूँ, लाल से. और मैं कहूँगा उसे P सूपरस्क्रिप्ट i डिनोट करने के लिए कि यह है एक प्रोजेक्शन i-थ ट्रेनिंग इग्ज़ाम्पल का पेरामिटर वेक्टर थीटा पर. और इसलिए हमारे पास क्या है की थीटा ट्रान्स्पोज़ x(i) है बराबर निम्नलिखित को जो हमारे पास है पिछली स्लाइड पर, यह होगा बराबर P गुणा लम्बाई, या नॉर्म वेक्टर थीटा का. और यह निस्संदेह ही बराबर भी है थीटा 1 x1 प्लस थीटा 2 x2. अत: प्रत्येक इनमें से है, आप जानते हैं, एक बराबर का वैध ढंग कम्प्यूट करने के लिए इनर प्रोडक्ट थीटा और x(i) के बीच. ठीक है. तो यह हमें कहां छोड़ता है? इसका क्या मतलब है कि, यह प्रतिबंधित करता है कि थीटा ट्रान्स्पोज़ x(i) होना चाहिए बड़ा या बराबर एक के या माइनस एक से कम. इसका क्या मतलब है कि यह इस्तेमाल किया जा सकता है प्रतिबंधों के स्थान पर कि P(i) गुणा x होना चाहिए बड़ा या बराबर एक के. क्योंकि थीटा ट्रान्स्पोज़ x(i) है बराबर P(i) गुणा थीटा का नॉर्म. तो लिखते हुए उसे हमारे ऑप्टिमायज़ेशन अब्जेक्टिव में, यह है जो हमें मिलता है जहाँ मेरे पास है, बजाय थीटा ट्रान्स्पोज़ x(i) के, मेरे पास अब है P(i) गुणा थीटा का नॉर्म. और बस आपको याद दिला दूँ कि हमने पहले भी किया है कि यह ऑप्टिमायज़ेशन अब्जेक्टिव जा सकता है लिखा ऐसे वन हाफ़ टाइम्ज़ नॉर्म ऑफ़ थीटा स्क्वेर्ड. तो, चलो अब लेते हैं ट्रेनिंग इग्ज़ाम्पल जो हमारे पास है नीचे और अभी के लिए, इस्तेमाल करते रहेंगे सरलीकरण कि थीटा 0 है 0 के बराबर. चलो देखते हैं क्या निर्णय सीमा रेखा सपोर्ट वेक्टर मशीन चुनेगा. यहाँ है एक विकल्प, मान लो सपोर्ट वेक्टर मशीन को करना होता चुनाव इस निर्णायक सीमा रेखा का. यह नहीं है एक बहुत अच्छा चुनाव क्योंकि इसमें हैं बहुत छोटे मार्जिन. यह निर्णायक सीमा रेखा है बहुत नज़दीक ट्रेनिंग इग्ज़ाम्पल्ज़ के. चलो देखते हैं कि क्यों सपोर्ट वेक्टर मशीन इसे नहीं करेगी. पेरमिटर्स की इन वैल्यूज़ के लिए यह सम्भव है दिखा पाना कि पेरामिटर वेक्टर थीटा वास्तव में है 90 डिग्री पर निर्णायक सीमा रेखा के. और इसलिए वह हरी निर्णायक सीमा रेखा कॉरेस्पॉंड करती है एक पेरामिटर वेक्टर थीटा को जो इशारा करता है उस दिशा में. और वैसे भी, सरलीकरण कि थीटा 0 है 0 के बराबर उसका सिर्फ़ मतलब है कि निर्णायक सीमा रेखा जानी ही चाहिए ऑरिजिन, (0,0) से वहाँ पर. तो अब, चलो देखते हैं इसका क्या तात्पर्य है ऑप्टिमायज़ेशन अब्जेक्टिव के लिए. मान लो कि यह इग्ज़ाम्पल यहाँ. मान लो कि वह मेरा पहला इग्ज़ाम्पल है, आप जानते है, x1. यदि हम देखते हैं प्रोजेक्शन को इस इग्ज़ाम्पल के मेरे पेरमिटर्स थीटा पर. वह है प्रोजेक्शन. और इसलिए वह छोटा लाल लाइन सेगमेंट. वह है बराबर P1. और वह होगा काफ़ी कम, ठीक है. और इसी प्रकार, यदि यह इग्ज़ाम्पल यह, यदि यह होता x2, वह है मेरा दूसरा इग्ज़ाम्पल्ज़. तब, यदि मैं देखता प्रोजेक्शन पर इस इग्ज़ाम्पल के थीटा पर. आप जानते हैं. तब, चलो मैं बनाता हूँ इसे मजेंटा में. यह छोटी मजेंटा लाइन, वह होगी P2. वह है प्रोजेक्शन दूसरे इग्ज़ाम्पल का ऊपर मेरे, दिशा में मेरे पेरामिटर वेक्टर थीटा के जो ऐसे जाता है. और इसलिए, यह छोटा प्रोजेक्शन लाइन सेगमेंट होगा काफ़ी छोटा. P2 होगा वास्तव में एक नेगेटिव नम्बर, ठीक है तो P2 है विपरीत दिशा में. इस वेक्टर का है बड़ा कोण 90 डिग्री से मेरे पेरामिटर वेक्टर थीटा से, यह होगा 0 से छोटा. और इसलिए हमें क्या मिलता है कि ये टर्म्ज़ P(i) होंगी बहुत छोटे नम्बर्ज़. तो यदि हम देखते हैं ऑप्टिमायज़ेशन अब्जेक्टिव को और पाते हैं, ठीक, अच्छा, पॉज़िटिव इग्ज़ाम्पल्ज़ के लिए हमें चाहिए P(i) गुणा थीटा का नॉर्म बड़ा या बराबर एक के. लेकिन यदि P(i) यहाँ पर, यदि P1 यहाँ पर है बहुत छोटा, उसका मतलब है कि हमें चाहिए नॉर्म थीटा का बहुत बड़ा, ठीक है? यदि P1 थीटा का है छोटा और हम चाहते हैं P1, आप जानते है, गुणा नॉर्म थीटा का बड़ा या बराबर एक के, ठीक है एक ही रास्ता उसके लिए है कि ये दो नम्बर्ज़ बड़े हों यदि P1 है छोटा, जैसे कि हमने कहा हम चाहते है नॉर्म थीटा का बड़ा. और इसी प्रकार, हमारे नेगेटिव इग्ज़ाम्पल के लिए, हमें चाहिए P2 ग़ुणा नॉर्म थीटा का होना चाहिए कम या बराबर माइनस एक के. और जैसे हमने देखा इस इग्ज़ाम्पल में पहले ही P2 होगा बहुत छोटा नेगेटिव नम्बर, और इसलिए एक ही रास्ता उसके होने के लिए है कि नॉर्म थीटा का हो बड़ा, लेकिन क्या हम करेंगे ऑप्टिमायज़ेशन अब्जेक्टिव में कि हम कोशिश करेंगे ढूँढने की एक सेटिंग पेरमिटर्स की जहाँ नॉर्म थीटा का है छोटा, और इसलिए आप जानते हैं, तो यह नहीं लगता एक उतना अच्छा रास्ता पेरामिटर वेक्टर थीटा के लिए. इसके विपरीत, सिर्फ़ देखें निर्णायक सीमा रेखा को. यहाँ, मान लो, यह SVM चुनती है वह निर्णायक सीमा रेखा. अब यह होगा बहुत भिन्न. यदि वह निर्णायक सीमा रेखा है, यहाँ है कॉरेस्पॉंडिंग दिशा थीटा के लिए. तो, इस निर्णायक सीमा रेखा में, आप जानते हैं, वह वर्टिकल लाइन जो कॉरेस्पॉंड करती है यह सम्भव है दिखा पाना लिनीअर ऐल्जेब्रा से कि पाने का ढंग वह हरी निर्णायक सीमा रखा है कि वेक्टर थीटा हो 90 डिग्री उस पर, और अब यदि आप देखें प्रोजेक्शन आपके थीटा का वेक्टर x पर, मान लो पहले इग्ज़ाम्पल का है मेरा इग्ज़ाम्पल x1. तो जब मैं प्रोजेक्ट करता हूँ इस x पर, या थीटा पर, मुझे मिलता है कि यह है P1. वह लम्बाई वहाँ है P1. दूसरा इग्ज़ाम्पल, वह है यह इग्ज़ाम्पल और मैं करता हूँ वही प्रोजेक्शन और मुझे क्या मिलता है कि यह लम्बाई यहाँ है एक P2 वास्तव में वह होगी 0 से कम. और आपने ध्यान किया कि P1 और P2, ये लंबाइयाँ प्रोजेक्शन्स की होंगी काफ़ी बड़ी, और इसलिए यदि हमें अभी भी लगाने हैं ये प्रतिबंध कि P1 गुणा नॉर्म थीटा का है बड़ा या बराबर 1, क्योंकि P1 है काफ़ी बड़ा अब. नॉर्म हो सकता है छोटा. और इसलिए, इसका क्या मतलब है कि लेने से निर्णायक सीमा रेखा जो दाईं तरफ़ है बजाय जो बाईं तरफ़ है, SVM कर सकता है नॉर्म पेरमिटर्स थीटा का बहुत कम. तो, यदि हम कर सकते हैं नॉर्म थीटा का काफ़ी कम और इसलिए कर सकते हैं स्क्वेर्ड नॉर्म थीटा का कम, जिस वजह से SVM चुनेगी यह हायपॉथिसस जो दाईं तरफ़ है इसके बजाय. और ऐसे SVM देती है यह लार्ज मार्जिन का आभास. मुख्यत:, यदि आप देखें इस हरी लाइन को, यदि आप देखते हैं इस हरी हायपॉथिसस को, हम चाहते हैं प्रोजेक्शन मेरे पॉज़िटिव और नेगेटिव इग्ज़ाम्पल्ज़ का थीटा पर बड़ा, और एक ही रास्ता करने के लिए उसे है यदि हरी लाइन के आस पास यह लार्ज मार्जिन है, यह बड़ा अंतर है जो अलग करता है पॉज़िटिव और नेगेटिव इग्ज़ाम्पल वह है वास्तव में परिमाण इस अंतर का. परिमाण इस मार्जिन का है बिल्कुल वही जो वैल्यूज़ हैं P1, P2, P3 इत्यादि की. और इसलिए करने से मार्जिन लार्ज, और उससे ये P1, P2, P3 इत्यादि की कि SVM को मिल सकती है एक छोटी वैल्यू थीटा के नॉर्म की, वह है जो यह अब्जेक्टिव में करने का प्रयास कर रही है. और इसी वजह से इस मशीन को मिलता है एक लार्ज मार्जिन क्लैसिफ़ायअर क्योंकि यह अधिकतम करने की कोशिश कर रहा है नॉर्म को इन Pi के जो है दूरी ट्रेनिंग इग्ज़ाम्पल्ज़ से निर्णायक सीमा रेखा तक. अंत में, हमने किया यह पूरा डेरिवेशन इस सरलीकरण का उपयोग करते हुए कि पैरामीटर थीटा0, 0 के बराबर होना चाहिए. उसका प्रभाव है कि जैसे मैं कहता हूँ संक्षेप में, है कि यदि थीटा 0 है बराबर 0 के उसका क्या मतलब है कि हम ले रहे हैं निर्णायक सीमा रेखा जो गुज़रती है ऑरिजिन से, निर्णायक सीमा रेखाएँ गुज़रती हैं ऑरिजिन से उस तरह, यदि आप करते हैं थीटा0 को नॉन 0 तब क्या उसका मतलब है कि आप ले रहे हैं निर्णय सीमारेखा जो नहीं निकलती ऑरिजिन से, जैसे कि वह जो मैंने अभी बनाई है. और मैं नहीं करूँगा पूरा डेरिवेशन उसका. यह होता है कि यही लार्ज मार्जिन का प्रूफ़ काम करता है काफ़ी कुछ उसी तरह. और एक सामान्य रूप इस तर्क का जो हमने अभी देखा सीमा रेखा के ऑरिजिन से जाने का कि जब थीटा 0 नॉन-ज़ीरो भी है, क्या SVM करने की कोशिश करती है जब आपके पास है यह ऑप्टिमायज़ेशन अब्जेक्टिव. जो कॉरेस्पॉंड करता है उस केस को जब C है बहुत बड़ा. लेकिन यह संभव है दिखा पाना कि, आप जानते हैं, जब थीटा0 नहीं है 0 यह सपोर्ट वेक्टर मशीन अभी भी ढूँढ रही है, वास्तव में प्रयास कर रही है ढूँढने के लार्ज मार्जिन जो अलग करता है पॉज़िटिव तथा नेगेटिव इग्ज़ाम्पल्ज़. तो वह स्पष्ट करता है कि कैसे सपोर्ट वेक्टर मशीन एक लार्ज मार्जिन क्लैसिफ़ायअर है. अगले वीडियो में हम शुरू करेंगे बात करना कि कैसे लेने है इनमें से कुछ SVM विचार और शुरू करना है अप्लाई करना उन्हें बनाने के लिए एक जटिल नॉन-लिनीअर क्लैसिफ़ायअर.