पिछले वीडियो में, हमने शुरू किया बात करना कर्नल के बारे में और कैसे यह इस्तेमाल किया जा सकता है परिभाषित करने के लिए नए फ़ीचर्ज़ सपोर्ट वेक्टर मशीन के लिए. इस विडीओ में, मैं चाहूँगा डालना कुछ विवरण जो मिसिंग था और, बताऊँगा भी थोड़ा कि कैसे इस्तेमाल करना है इन सुझावों को व्यवहार में. जैसे कि, कैसे वे सम्बंधित हैं उदाहरण के लिए, बाइयस वेरीयन्स ट्रेड-ऑफ़ से सपोर्ट वेक्टर मशीन्स में. पिछले विडीओ में, मैंने बात की थी कुछ लैंडमार्क्स को चुनने की प्रक्रिया की. आप जानते हैं, l1, l2, l3 और उससे हम कर पाए परिभाषित समानता फ़ंक्शन जिन्हें कहते हैं कर्नल्स भी या इस उदाहरण में यदि आपके पास है यह समानता फ़ंक्शन यह है एक गॉशियन कर्नल. और उससे हम बना पाए यह फ़ॉर्म हायपॉथिसस फ़ंक्शन की. लेकिन कहाँ से मिलते हैं हमें ये लैंडमार्क्स ? लेकिन कहाँ से मिलते हैं हमें l1, l2, l3? और ऐसा लगता है, इसके अलावा, कि जटिल लर्निंग प्राब्लम्ज़ के लिए, शायद हम चाहते हैं बहुत अधिक लैंडमार्क्स बजाय केवल तीन के जो हम हाथ से चुन सकते हैं. तो व्यावहारिक दृष्टि से यह है कि कैसे चुने जाते हैं लैंडमार्क्स जो है कि दी होने पर मशीन लर्निंग प्रॉब्लम, हमारे पास है कुछ डेटा सेट जिसमें कुछ पॉज़िटिव और नेगेटिव इग्ज़ाम्पल्ज़ हैं. तो, यह है सुझाव यहाँ जो है कि हम लेंगे इग्ज़ाम्पल्ज़ और प्रत्येक ट्रेनिंग इग्ज़ाम्पल के लिए जो हमारे पास है, हम कहेंगे इसे ही. हम बस रखेंगे लैंडमार्क्स बिल्कुल उन्हीं स्थानों पर जहाँ हमारे ट्रेनिंग इग्ज़ाम्पल हैं. तो यदि मेरे पास एक ट्रेनिंग इग्ज़ाम्पल है यदि वह है x1, ठीक है, तो मैं लूँगा इसे मेरा पहला लैंडमार्क ठीक उसी स्थान पर जहाँ मेरा पहला ट्रेनिंग इग्ज़ाम्पल है. और यदि मेरे पास एक भिन्न ट्रेनिंग इग्ज़ाम्पल x2 है. ठीक है, हम करेंगे सेट दूसरा लैंडमार्क मेरे दूसरे ट्रेनिंग इग्ज़ाम्पल के स्थान पर. दाईं तरफ़ के चित्र में, मैंने ली हैं लाल और नीली डॉट्स सिर्फ़ स्पष्टिकरण के लिए, रंग इस चित्र का, रंग डॉट्स का दाईं तरफ़ के चित्र में महत्वपूर्ण नहीं है. लेकिन मुझे क्या मिलेगा इस विधि के इस्तेमाल से कि मुझे मिलेंगे m लैंडमार्क्स l1, l2 l(m) तक यदि मेरे पास हैं m ट्रेनिंग इग्ज़ाम्पल्ज़ जिनमें है एक लैंडमार्क्स प्रत्येक स्थान पर स्थान पर मेरे प्रत्येक ट्रेनिंग इग्ज़ाम्पल के. और यह है अच्छा क्योंकि यह कह रहा है कि मेरे फ़ीचर्ज़ मूलत: मापेंगे कितना नज़दीक एक इग्ज़ाम्पल है किसी एक चीज़ के जो मैंने देखी मेरे ट्रेनिंग सेट में. तो, सिर्फ़ लिखने के लिए यह रूपरेखा थोड़ी और स्पष्ट, दिए होने पर m ट्रेनिंग इग्ज़ाम्पल, मैं लूँगा / चुनुंगा स्थान मेरे लैंडमार्क्स का बिल्कुल नज़दीक उन्हीं स्थानों के जहाँ मेरे m ट्रेनिंग इग्ज़ाम्पल हैं. जब आपको दिया है इग्ज़ाम्पल x, और इस उदाहरण में x हो सकता है कुछ भी ट्रेनिंग सेट में, यह हो सकता है कुछ क्रॉस वैलिडेशन सेट में, या हो सकता है कुछ टेस्ट सेट में. दिया होने पर एक इग्ज़ाम्पल x, हम करेंगे कम्प्यूट, आप जानते हैं, ये फ़ीचर्ज़ जैसे f1, f2 और इसी प्रकार आगे. जहाँ l1 वास्तव में बराबर है x1 के और इसी प्रकार आगे. और ये तब मुझे देते हैं एक फ़ीचर वेक्टर. तो मैं लिखता हूँ f को फ़ीचर वेक्टर के जैसे. मैं लूँगा ये f1, f2 और आगे, और सिर्फ़ ग्रुप करूँगा उन्हें एक फ़ीचर वेक्टर में. लूँगा वे fm तक. और, आप जानते हैं, सिर्फ़ कन्वेन्शन के हिसाब से, यदि हम चाहते हैं, हम जोड़ सकते हैं एक अतिरिक्त फ़ीचर f0, जो है हमेशा बराबर 1. तो यह अदा करता है एक भूमिका समान उसके जो हमारे पास पहले था. x0 के लिए, जो हमारा इंटर्सेप्टर था. तो, उदाहरण के लिए, यदि हमारे पास है एक ट्रेनिंग इग्ज़ाम्पल x(i), y(i), फ़ीचर्ज़ जो हम कम्प्यूट करेंगे इस ट्रेनिंग इग्ज़ाम्पल के लिए होंगे निम्नलिखित: दिया होने पर x(i), हम करेंगे तब मैप इसे, आप जानते हैं f1(i) को. जो है समानता. मैं लिखूँगा संक्षेप में उसे SIM, बजाय लिखने के पूरा शब्द समानता, ठीक है. और f2(i) बराबर है समानता x(i) और l2 में, और इसी तरह आगे, नीचे fm(i) तक बराबर है समानता x(i) और l(m) में. और कहीं मध्य में, कहीं इस लिस्ट में, आप जानते है, i-थ कम्पोनेंट पर, मेरे वास्तव में होगा एक फ़ीचर कम्पोनेंट जो है f सबस्क्रिप्ट i(i), जो होगा समानता x(i) और l(i) में. जहाँ l(i) है बराबर x(i) के, और इसलिए आप जानते हैं fi(i) सिर्फ़ होगा समानता x और उसके ख़ुद के बीच में. और यदि आप इस्तेमाल कर रहे हैं गॉशियन कर्नल यह है वास्तव में e की पॉवर माइनस 0 ओवर 2 सिग्मा स्क्वेर्ड और इसलिए, यह होगा बराबर 1 और वह सही है. तो मेरे फ़ीचर्ज़ में से एक इस ट्रेनिंग इग्ज़ाम्पल के होगा बराबर 1. और इसी प्रकार जैसे मैंने किया है मैं ले सकता हूँ सारे ये m फ़ीचर्ज़ और ग्रूप कर सकता हूँ उन्हें एक फ़ीचर वेक्टर में. तो बजाय दर्शाने के मेरा इग्ज़ाम्पल, इस्तेमाल करके, आप जानते हैं, x(i) से जो है यह R(n) प्लस वन डिमेन्शनल वेक्टर. निर्भर करते हुए कि आप कर सकते हैं या नहीं सेट इंटर्सेप्टर को, यह है या R(n) R(n) प्लस 1. हम दर्शा सकते हैं इसके स्थान पर मेरा ट्रेनिंग इग्ज़ाम्पल इस फ़ीचर वेक्टर f से. मैं लिखूँगा इसे f सूपरस्क्रिप्ट i से. जो लेगा ये सभी चीज़ें और स्टैक करेगा उन्हें एक वेक्टर में. तो, f1(i) से fm(i) तक और यदि आप चाहते हैं और आमतौर पर हम जोड़ते हैं यह f0(i) भी, जहाँ f0 (i) बराबर है 1 के. और इसलिए यह वेक्टर यहाँ देता है मुझे मेरा नया फ़ीचर वेक्टर जिससे दर्शा सकते हैं मेरा ट्रेनिंग इग्ज़ाम्पल. तो दिए होने पर ये कर्नल्स और समानता फ़ंक्शन्स, यहाँ है कैसे हम इस्तेमाल करते हैं एक सपोर्ट वेक्टर मशीन. यदि आपने लर्न कर लिए हैं एक एक सेट पेरमिटर्स थीटा का, तब यदि आपको दी जाए एक वैल्यू x की और आप चाहते हैं करना एक प्रिडिक्शन. हम क्या करते हैं कि हम कम्प्यूट करते हैं फ़ीचर्ज़ f, जो है अब एक R(m) प्लस 1 डिमेन्शनल फ़ीचर वेकटर. और हमारे पास है m यहाँ क्योंकि हमारे पास हैं m ट्रेनिंग इग्ज़ाम्पल्ज़ और इसलिए m लैंडमार्क्स और क्या हम करते हैं कि हम प्रिडिक्ट करते हैं 1 यदि थीटा ट्रान्स्पोज़ f है बड़ा या बराबर 0 के. सही तो, यदि थीटा ट्रान्स्पोज़ f, निश्चय ही, वह है सिर्फ़ थीटा0 , f0 और प्लस थीटा1 f1 प्लस डॉट डॉट डॉट, प्लस थीटा m f(m). और इसलिए मेरा पेरामिटर वेक्टर थीटा भी अब होगा एक m प्लस 1 डिमेन्शनल वेक्टर. और हमारे पास है m यहाँ क्योंकि यहाँ संख्या लैंडमार्क्स की है बराबर ट्रेनिंग सेट साइज़ के. तो m था ट्रेनिंग सेट का साइज़ और अब, पेरामिटर वेक्टर थीटा होगा n प्लस एक डिमेन्शनल. तो ऐसे आप करते हैं एक प्रिडिक्शन यदि आपके पास पहले है एक सेट पेरमिटर्स थीटा का. कैसे मिलते हैं आपको पेरमिटर्स थीटा? ठीक है आप करते हैं वह इस्तेमाल करके SVM लर्निंग अल्गोरिद्म, और ख़ासतौर पर आप क्या करते है कि आप हल करेंगे यह मिनमायज़ेशन प्रॉब्लम. आप मिनमायज़ करते हैं पेरमिटर्स थीटा ऑफ़ C टाइम्ज़ यह कॉस्ट फ़ंक्शन जो हमारे पास था पहले. केवल अब, देखने के वहाँ बजाय करने के प्रिडिक्शन इस्तेमाल करके थीटा ट्रान्स्पोज़ x(i) इस्तेमाल करके हमारे प्रारम्भिक फ़ीचर्ज़ x(i). इसके स्थान पर हमने लिए हैं फ़ीचर्ज़ x(i) और बदल दिया है उन्हें एक नए फ़ीचर्ज़ से तो हम ले रहे हैं थीटा ट्रान्स्पोज़ f(i) करने के लिए एक प्रिडिक्शन ट्रेनिंग इग्ज़ाम्पल्ज़ पर और हम देखते हैं कि, आप जानते हैं, कि दोनो जगह यहाँ और हल करने से यह मिनीमाइज़ेशन प्रॉब्लम कि आपको मिलते हैं पेरमिटर्स आपके सपोर्ट वेक्टर मशीन के लिये. और एक आख़िरी जानकारी है क्योंकि इस ऑप्टिमायज़ेशन प्रॉब्लम में हमारे पास वास्तव में हैं n बराबर m फ़ीचर्ज़. मतलब यहाँ. संख्या फ़ीचर्ज़ की जो हमारे पास है. वास्तव में, वास्तविक संख्या फ़ीचर्ज़ की जो हमारे पास हैं, डिमेन्शन f की है. तो वह n वास्तव में होगा बराबर m के. तो, यदि आप चाहते हैं, आप सोच सकते हैं इसे एक जोड़ की तरह, यह वास्तव में है एक जोड़ j बराबर 1 से m तक. और सोचने का एक ढंग उसे हैं, कि आप सोच सकते हैं इसे कि n है बराबर m के, क्योंकि यदि f नहीं है एक नया फ़ीचर, तब हमारे पास हैं m प्लस 1 फ़ीचर्ज़, जहाँ प्लस 1 आता है इंटर्सेप्टर से. और यहाँ, हम अभी भी करते हैं जोड़ j बराबर 1 से n तक, क्योंकि जिस प्रकार से हमारे पिछले वीडियो में रेगुलराइज़ेशन पर, हम अभी भी रेगुलराइज़ नहीं करते हैं पेरमिटर्स थीटा ज़ीरो को, जो है कारण कि यह है एक जोड़ j बराबर 1 से m तक बजाय j बराबर 0 से m तक. तो वह है सपोर्ट वेक्टर मशीन लर्निंग अल्गोरिद्म. वह है एक तरह से, गणितीय विस्तृत जानकारी को एक तरह करते हुए मुझे बताना चाहिए, जो है कि जिस तरह से सपोर्ट वेक्टर मशीन इम्प्लमेंट की जाती है, यह आख़िरी टर्म वास्तव में की जाती है थोड़े अलग ढंग से. तो आपको वास्तव में जरूरत नहीं है जानने की यह आख़िरी जानकारी इस्तेमाल कर सकने के लिए सपोर्ट वेक्टर मशीन्स, और वास्तव में इक्वेज़न्स जो लिखी हैं यह उन्हें दे पाना चाहिए आपको सभी जानकारी जो आपको चाहिए. लेकिन जिस तरह से सपोर्ट वेक्टर मशीन इम्प्लमेंट की जाती है, आप जानते हैं, वह टर्म, सम ऑफ़ j ऑफ़ थीटा j स्क्वेर्ड ठीक है? और एक अन्य ढंग लिखने का इसे हो सकता हैं कि इसे लिख सकते हैं थीटा ट्रान्स्पोज़ थीटा, यदि हम अनदेखा करते हैं पेरमिटर्स थीटा 0 को. तो थीटा 1 से थीटा m तक, छोड़ते हुए थीटा 0. तब यह सम ऑफ़ j ऑफ़ थीटा j स्क्वेर्ड उसे लिख सकते हैं थीटा ट्रान्स्पोज़ थीटा. और क्या अधिकतर सपोर्ट वेक्टर मशीन की इम्प्लमेंटेशन करती हैं कि वास्तव में बदल देती हैं यह थीटा ट्रैन्स्पोज़ थीटा को, इसके स्थान पर, थीटा ट्रान्स्पोज़ टाइम्ज़ कोई मेट्रिक्स अंदर, जो निर्भर करता है कर्नल पर जो आप इस्तेमाल करते हैं, टाइम्ज़ थीटा. और इसलिए वह देता है हमें एक थोड़ी भिन्न दूरी की मेट्रिक. हम इस्तेमाल करेंगे एक थोड़ा अलग माप बजाय मिनमायज़ करने के यथार्थत: नॉर्म थीटा का स्क्वेर्ड मतलब कि मिनमायज़ करेंगे कुछ जो लगभग समान है इसके. वह है जैसे एक दोबारा स्केल किया वर्ज़न पेरामिटर वेक्टर थीटा का जो निर्भर करता है कर्नल पर. लेकिन यह है एक प्रकार से गणितीय विस्तार. वह करने देता हैं सपोर्ट वेक्टर मशीन के सॉफ़्टवेयर को रन अधिक कुशलता से. और कारण कि सपोर्ट वेक्टर मशीन करता है इसे इस बदलाव से. यह करने देता है इसे स्केल बहुत बड़े ट्रेनिंग सेट्स के लिए. क्योंकि, उदाहरण के लिए, यदि आपके पास है एक ट्रेनिंग सेट जिसमें 10000 ट्रेनिंग इग्ज़ाम्पल्ज़ हैं. तब, आप जानते हैं, जिस तरह से हम परिभाषित करते हैं लैंडमार्क्स, हमें मिलते हैं 10,000 लैंडमार्क्स. और इसलिए थीटा बन जाता हैं 10,000 डिमेन्शनल. और शायद वह काम करे, लेकिन जब m हो जाता हैं बहुत ही अधिक बड़ा तब हल करना सब इन पेरमिटर्स के लिए, आप जानते हैं, यदि m होता 50,000 या एक 100,000 तब हल करना इन सब पेरमिटर्स के लिए हो सकता है महँगा सपोर्ट वेक्टर मशीन के ऑप्टिमायज़ेशन सॉफ़्टवेयर के लिए, इसलिए हल करना मिनमायज़ेशन प्रॉब्लम जो मैंने यहाँ बनाई है. तो एक प्रकार से गणितीय विस्तार, जिसे आपको जानने की वास्तव में ज़रूरत नहीं है. यह बदल देता है वास्तव में वह आख़िरी टर्म थोड़ा बहुत ऑप्टिमायज़ करने के लिए कुछ भिन्न चीज़ बजाय सिर्फ़ ऑप्टिमायज़ करने के नॉर्म ऑफ़ थीटा स्क्वेर्ड. लेकिन यदि आप चाहें, आप सोच सकते हैं इसे एक प्रकार से इम्प्लमेंटेशन का विस्तार जो निश्चय ही बदल देता है अब्जेक्टिव थोड़ा सा, लेकिन यह करते हैं मुख्यत: कम्प्यूटेशनल दक्षता के कारणों से, तो अक्सर आपको वास्तव में इसकी चिंता करने की आवश्यकता नहीं हैं. और वैसे भी, यदि आप सोच रहे हैं कि क्यों हम नहीं करते अप्लाई कर्नल्स का विचार अन्य अल्गोरिद्म्स को भी जैसे लॉजिस्टिक रेग्रेशन, ऐसा होता है कि यदि आप चाहें, आप वास्तव में अप्लाई कर सकते हैं कर्नल का सिद्धांत और परिभाषित कर सकते हैं उद्ग़म फ़ीचर्ज़ का लेकर लैंडमार्क्स और ऐसा ही कुछ लॉजिस्टिक रेग्रेशन में. लेकिन कॉम्प्यूटेशन की तरकीब जो अप्लाई होती हैं सपोर्ट वेक्टर मशीन के लिए नही होती जनरलाइज सही ढंग से अन्य अल्गोरिद्म्स के लिए जैसे लॉजिस्टिक रेग्रेशन. और इसलिए, कर्नल्स के इस्तेमाल से लॉजिस्टिक रिग्रेशन होगा बहुत धीमा, जबकि, वजह से कम्प्यूटेशनल तरकीब से, जैसे सन्निहित है और यह कैसे बदलता है और इसे और विस्तृत जानकारी कि कैसे सपोर्ट वेक्टर मशीन सॉफ़्टवेयर करते हैं इम्प्लमेंट, सपोर्ट वेक्टर मशीन्स और कर्नल्स काम करते हैं सही एक साथ. जबकि लॉजिस्टिक रिग्रेशन और कर्नल्स, आप जानते हैं, आप कर सकते हैं इसे, लेकिन यह बहुत धीरे चलेगा. और यह नहीं ले पाएगा लाभ एडवांसड ऑप्टिमायज़ेशन तकनीक का जो लोगों ने निकाला है ख़ास केस के लिए चलाने के लिए एक सपोर्ट वेक्टर मशीन एक कर्नल के साथ. लेकिन यह सब केवल संबंधित है कि कैसे आप वास्तव में इम्प्लमेंट करते हैं सॉफ़्टवेयर न्यूनतम / मिनमायज़ करने के लिए इस कॉस्ट फ़ंक्शन को. इस बारे में मैं और बात करूँगा बाद में, अगले वीडियो में, लेकिन आपको वास्तव में नहीं है ज़रूरत जानने की कि कैसे लिखना है सॉफ़्टवेयर न्यूनतम / मिनमायज़ करने के लिए इस कॉस्ट फ़ंक्शन को क्योंकि आपको मिल सकते हैं बहुत अच्छे ऑफ़ द शेल्फ़ सॉफ़्टवेयर वह करने के लिए. और बस जैसे, आप जानते हैं, मैं नहीं सलाह दूँगा लिखने की कोड इन्वर्ट करने के लिए एक मैट्रिक्स या कम्प्यूट करने के लिए एक स्क्वेर रूट, मैं वास्तव में नहीं सलाह देता लिखने की सॉफ़्टवेयर न्यूनतम / मिनमायज़ करने के लिए इस कॉस्ट फ़ंक्शन को ख़ुद से, लेकिन बजाय इस्तेमाल करने के ऑफ़ द शेल्फ़ सॉफ़्टवेयर पैकिज जो लोगों ने विकसित की हैं और इसलिए उन सॉफ़्टवेयर पैकिज में पहले से ही सन्निहित है ये नूमेरिकल ऑप्टिमायज़ेशन तरकीबें, तो आपको वास्तव में इसकी चिंता करने की आवश्यकता नहीं हैं. लेकिन एक चीज़ जो है जानने योग्य कि जब आप अप्लाई कर रहे हैं एक सपोर्ट वेक्टर मशीन, कैसे आप चुनते हैं पेरमिटर्स सपोर्ट वेक्टर मशीन के? और अंतिम बात जो मैं चाहता हूँ बताना इस वीडियो में कि बताऊँ थोड़ा से बाइयस और वेरीयन्स ट्रेड ऑफ़ का जब इस्तेमाल कर रहे हैं सपोर्ट वेक्टर मशीन. जब इस्तेमाल कर रहे हैं एक SVM, एक चीज़ जो आपको चुनने की ज़रूरत है वह है पेरामिटर C जो था ऑप्टिमायज़ेशन अब्जेक्टिव में, और आप याद करें कि C अदा करता है एक भूमिका समान 1 ओवर लैम्डा के, जहाँ लैम्डा था रेगुलराइज़ेशन पेरामिटर हमारे पास लॉजिस्टिक रेग्रेशन के लिए. अत:, यदि आपके पास है एक बड़ी वैल्यू C की, यह कॉरेस्पॉंड करता हैं जो हमारे पास था लॉजिस्टिक रेग्रेशन में, एक छोटी वैल्यू से लैम्डा की मतलब नहीं कर रहे ज़्यादा रेगुलराइज़ेशन. और यदि आप करते हैं वह, आप को मिलती है एक हायपॉथिसस जिसमें बाइयस कम है और वेरीयन्स ज़्यादा है. जबकि यदि आप लेते हैं एक छोटी वैल्यू C की तब यह कॉरेस्पॉंड करता हैं जब कर रहे थे लॉजिस्टिक रिग्रेशन एक बड़ी वैल्यू से लैम्डा की और वह कॉरेस्पॉंड करता है एक हायपॉथिसस से जिसमें अधिक बाइयस है और कम वेरीयन्स है. और इसलिए, हायपॉथिसस जिसमें बड़ा C है उसमें एक अधिक वेरीयन्स हैं और इसकी अधिक सम्भावना है ओवरफ़िट करने की, जबकि हायपॉथिसस जिसमें छोटा C है उसमें अधिक बाइयस है और उसकी अधिक सम्भावना है अंडरफ़िट होने की. तो यह C है पेरामिटर जो हमें चुनना है. दूसरी चीज़ है पेरामिटर सिग्मा स्क्वेर्ड की, जो आता हैं गॉशियन कर्नल में. तो यदि गॉशियन कर्नल का सिग्मा स्क्वेर्ड है बड़ा, तब समानता फ़ंक्शन में, जो था यह आप जानते हैं e की पॉवर माइनस x माइनस लैंडमार्क वेरी करता है स्क्वेर्ड ओवर 2 सिग्मा स्क्वेर्ड. इस एक उदाहरण में; यदि मेरे पास है केवल एक फ़ीचर, x1, यदि मेरे पास है एक लैंडमार्क वहाँ उस स्थान पर, यदि सिग्मा स्क्वेर्ड है बड़ा, तब, आप जानते हैं, गॉशियन कर्नल की प्रवृति होगी नीचे आने की अपेक्षाकृत धीरे से और इसलिए यह होगा मेरा फ़ीचर f(i), और इसलिए यह होगा एक निर्बाध फ़ंक्शन जो बदलता है अधिक निर्बाध रूप से, और इसलिए यह देगा आपको एक हायपॉथिसस जिसमें हैं अधिक बाइयस और कम वेरीयन्स, क्योंकि गॉशियन कर्नल जो नीचे आता है निर्बाध रूप से आपको मिलती है एक हायपॉथिसस जो कम ज़्यादा होती है धीरे धीरे या कम ज़्यादा होती है निर्बाध, जैसे आप बदलते हैं इनपुट x को. जबकि इसके विपरीत, यदि सिग्मा स्क्वेर्ड होता कम और यदि वह है मेरा लैंडमार्क दिया होने पर मेरा 1 फ़ीचर x1, आप जानते हैं, मेरा गॉशियन कर्नल, मेरा समानता फ़ंक्शन, कम ज़्यादा होगा एकाएक. और दोनो केस में में लूँगा 1, और इसलिए यदि सिग्मा स्क्वेर्ड छोटा है, तब मेरे फ़ीचरज़ कम ज़्यादा होगें कम समता से. तो यदि यह है सिर्फ़ अधिक स्लोप या बड़े डेरिवेटिव यहाँ. और इसे इस्तेमाल करके, आप कर पाते हैं फ़िट हायपॉथिसस जिसमें कम बाइयस है और आपको मिल सकता है अधिक वेरीयन्स. और यदि आप देखें इस सप्ताह का अभ्यास, आप वास्तव में कर पायेंगे अभ्यास कुछ इन सिद्धांतो का स्वयं और देख पायेंगे ये असर स्वयं. तो, वह था सपोर्ट वेक्टर मशीन कर्नल अल्गोरिद्म के साथ. और उम्मीद है इस चर्चा से बाइयस और वेरीयन्स की आपको मिली होगी समझ कि कैसे आप उम्मीद कर सकते हैं कि यह अल्गोरिद्म सही काम करेगा.