1
00:00:00,080 --> 00:00:01,140
このビデオでは、

2
00:00:01,370 --> 00:00:03,120
複雑な非線形の分類器を構築する為に

3
00:00:03,390 --> 00:00:06,280
サポートベクタマシンを用いる事を開始しよう。

4
00:00:07,630 --> 00:00:10,410
これを行う主要なテクニックは、カーネルと呼ばれる物だ。

5
00:00:11,730 --> 00:00:13,690
カーネルとは何で、それをどう使うのかを見ていこう。

6
00:00:15,860 --> 00:00:16,930
こんなトレーニングセットが

7
00:00:17,030 --> 00:00:18,270
あったとして、

8
00:00:18,400 --> 00:00:20,000
陽性と陰性の手本を区別する

9
00:00:20,150 --> 00:00:21,670
非線型な決定境界を

10
00:00:22,270 --> 00:00:23,950
見つけたいとする。

11
00:00:24,350 --> 00:00:25,900
たとえばこんな感じの決定境界だ。

12
00:00:27,040 --> 00:00:27,950
これを行う方法として

13
00:00:28,230 --> 00:00:29,760
一つ考えられるのは、

14
00:00:29,970 --> 00:00:32,180
複雑な多項式のフィーチャーを用いる事だ。

15
00:00:32,340 --> 00:00:33,420
つまり、例えばこんな感じのフィーチャー群を用いて、

16
00:00:34,140 --> 00:00:34,990
結果として、

17
00:00:35,140 --> 00:00:37,120
仮説のxを、

18
00:00:38,050 --> 00:00:40,380
シータ0 + シータ1 x1 + ...と

19
00:00:40,570 --> 00:00:41,790
これらの多項式フィーチャーに渡って計算して

20
00:00:41,860 --> 00:00:45,000
それが0より大きければ

21
00:00:45,180 --> 00:00:47,410
1を予測し、

22
00:00:47,540 --> 00:00:49,170
そしてそれ以外では0を予測する。

23
00:00:51,070 --> 00:00:52,760
これを書くもう一つの

24
00:00:52,980 --> 00:00:54,330
方法として、後で使う事になる

25
00:00:54,840 --> 00:00:56,240
ちょっとしたノーテーションを

26
00:00:56,500 --> 00:00:57,860
導入しておくと、

27
00:00:58,200 --> 00:00:59,370
仮説を、これを用いて

28
00:00:59,730 --> 00:01:01,610
決定境界を計算する物と

29
00:01:02,120 --> 00:01:03,380
考える事が出来る、

30
00:01:03,820 --> 00:01:04,870
つまり、シータ0 + シータ1 f1 +

31
00:01:05,070 --> 00:01:06,130
シータ2 f2 + シータ3 f3、

32
00:01:06,610 --> 00:01:08,730
などなど。

33
00:01:09,590 --> 00:01:12,790
ここで私は

34
00:01:13,050 --> 00:01:14,070
この新しいノーテーション

35
00:01:14,730 --> 00:01:15,930
f1, f2, f3などを、

36
00:01:16,270 --> 00:01:17,610
今計算している、

37
00:01:19,350 --> 00:01:20,630
ある種の新しいフィーチャーを示すのに用いていて、

38
00:01:21,370 --> 00:01:24,250
つまりf1は単にx1で、f2はイコールx2で、

39
00:01:24,600 --> 00:01:27,060
f3は

40
00:01:27,140 --> 00:01:28,560
これに等しい。

41
00:01:28,770 --> 00:01:29,790
つまり x1x2。

42
00:01:29,900 --> 00:01:32,200
f4はイコール x1の二乗で、

43
00:01:33,840 --> 00:01:35,590
f5はx2の二乗、

44
00:01:35,680 --> 00:01:37,740
などとなり、

45
00:01:38,520 --> 00:01:39,780
そして以前に見たように、

46
00:01:40,350 --> 00:01:41,190
これらの高次の多項式を

47
00:01:41,370 --> 00:01:42,870
含めていくのは、

48
00:01:43,110 --> 00:01:44,390
もっと多くのフィーチャーにする為の一つの方法だ。

49
00:01:45,470 --> 00:01:47,070
ここで疑問に思うのは、

50
00:01:47,250 --> 00:01:48,600
この高次の多項式以外の

51
00:01:48,670 --> 00:01:51,350
フィーチャーの選択が無いものか？という事。

52
00:01:51,690 --> 00:01:53,510
何故なら、

53
00:01:53,830 --> 00:01:54,820
これらの高次の多項式は、

54
00:01:55,120 --> 00:01:56,350
我らの欲しい物かいまいち分からないし、

55
00:01:56,860 --> 00:01:57,920
コンピュータビジョンの、

56
00:01:58,170 --> 00:01:59,560
入力が画像のピクセルの場合などを

57
00:01:59,780 --> 00:02:01,940
議論したが、

58
00:02:02,540 --> 00:02:04,670
そこでは高次の多項式を用いるのは

59
00:02:05,140 --> 00:02:06,360
計算量的にとても高くつく事を見た、

60
00:02:07,320 --> 00:02:08,270
何故ならその場合は、

61
00:02:08,280 --> 00:02:09,830
大量の高次の多項式が存在する事になるから。

62
00:02:11,240 --> 00:02:12,280
だから、もっと別の、

63
00:02:12,430 --> 00:02:13,160
もっと良いフィーチャーの選択肢で、

64
00:02:14,110 --> 00:02:15,100
この種の仮説の形に

65
00:02:15,410 --> 00:02:16,770
代入出来るような物は

66
00:02:17,500 --> 00:02:19,200
無いものか？

67
00:02:19,420 --> 00:02:20,470
そこでこれが、新しいフィーチャーf1, f2, f3を定義する

68
00:02:20,580 --> 00:02:23,580
一つのやり方だ。

69
00:02:24,970 --> 00:02:25,930
このスライドでは、

70
00:02:26,100 --> 00:02:27,600
三つのフィーチャーだけを定義するが、

71
00:02:27,890 --> 00:02:28,770
現実の問題では、もっと多くの数の

72
00:02:29,500 --> 00:02:30,650
フィーチャーを定義する事になる。

73
00:02:31,060 --> 00:02:32,060
だがここでは、

74
00:02:32,260 --> 00:02:33,400
フィーチャーx1とx2の

75
00:02:33,640 --> 00:02:34,980
張る空間に対し、

76
00:02:35,400 --> 00:02:36,520
ここでx0、

77
00:02:36,720 --> 00:02:37,800
切片項のx0は

78
00:02:38,060 --> 00:02:39,230
省略する事にするが、

79
00:02:39,330 --> 00:02:40,320
このx1 x2の空間の中で、

80
00:02:42,550 --> 00:02:43,560
幾つかの点を手動で選ぶ、

81
00:02:43,750 --> 00:02:45,210
そしてこれらの点を、これをl(1)と呼び、

82
00:02:45,450 --> 00:02:46,720
さらに別の点を

83
00:02:46,820 --> 00:02:49,560
選んで、これをl(2)と呼ぶ、

84
00:02:50,080 --> 00:02:51,390
そして三番目を

85
00:02:51,710 --> 00:02:52,880
選んで、

86
00:02:53,170 --> 00:02:55,800
これをl(3)と呼ぶ事にする。

87
00:02:55,900 --> 00:02:56,830
ここでは、これら三つの点は

88
00:02:56,930 --> 00:02:59,220
手動で選ぶ事にする。

89
00:02:59,870 --> 00:03:02,860
そしてこれらの点をランドマークと呼ぶ事にする。つまりランドマークの1, 2, 3。

90
00:03:03,720 --> 00:03:04,630
そして新たなフィーチャーを

91
00:03:04,790 --> 00:03:07,190
以下のように定義する。

92
00:03:07,510 --> 00:03:10,070
ある手本xが与えられた時に、

93
00:03:10,170 --> 00:03:13,130
最初のフィーチャーf1を

94
00:03:13,330 --> 00:03:16,010
なんらかの

95
00:03:16,260 --> 00:03:18,960
類似度の指標、

96
00:03:19,330 --> 00:03:21,460
トレーニング手本xと

97
00:03:21,680 --> 00:03:26,270
最初のランドマークとの類似度を定義する、

98
00:03:26,520 --> 00:03:27,840
そしてここでは具体的に以下のような

99
00:03:27,950 --> 00:03:29,600
類似度の指標を用いる、

100
00:03:30,160 --> 00:03:31,830
eの指数乗の

101
00:03:31,940 --> 00:03:34,220
マイナスの

102
00:03:34,470 --> 00:03:37,880
x-l1の距離を二乗して、

103
00:03:38,320 --> 00:03:39,610
2 シグマ二乗 で割る。

104
00:03:40,730 --> 00:03:41,640
前回のオプショナルのビデオを

105
00:03:41,780 --> 00:03:43,420
あなたが見ているかどうかは分からないが、

106
00:03:44,390 --> 00:03:48,140
このノーテーション、これは

107
00:03:48,460 --> 00:03:49,340
ベクトルwの長さを表す。

108
00:03:49,680 --> 00:03:51,260
だからこの、ここのこれは、

109
00:03:51,460 --> 00:03:53,760
このx-l(1)は、

110
00:03:54,020 --> 00:03:55,990
これは実体は単なる

111
00:03:56,100 --> 00:03:57,440
ユークリッド距離の二乗で、

112
00:03:58,610 --> 00:03:59,950
点xとランドマークl1との

113
00:04:00,410 --> 00:04:03,240
ユークリッド距離だ。

114
00:04:03,530 --> 00:04:04,610
この事は後でもうちょっと詳しく見る事にする。

115
00:04:06,440 --> 00:04:07,990
だがとにかく、これが最初のフィーチャーだ。

116
00:04:08,120 --> 00:04:09,610
二番目のフィーチャーf2は

117
00:04:09,750 --> 00:04:11,750
l(2)とxが

118
00:04:12,370 --> 00:04:14,040
どれだけ類似しているかを測る

119
00:04:14,400 --> 00:04:17,310
similarity関数で、これは以下のような関数で

120
00:04:17,370 --> 00:04:19,360
定義される。

121
00:04:25,970 --> 00:04:27,320
それはeの、以下による指数乗で、その指数は

122
00:04:28,150 --> 00:04:29,050
マイナスの

123
00:04:29,820 --> 00:04:31,310
xと二番目のランドマークとの間の距離の二乗を分子として、

124
00:04:31,510 --> 00:04:32,660
割ることの2 シグマ二乗 が指数となる。

125
00:04:33,520 --> 00:04:35,280
同様にf3は

126
00:04:35,850 --> 00:04:39,480
xとl3の間の類似度で、

127
00:04:39,840 --> 00:04:41,860
それはイコール

128
00:04:41,980 --> 00:04:44,510
また同様の式となる。

129
00:04:46,550 --> 00:04:48,070
そしてこのsimilarity関数とは

130
00:04:48,830 --> 00:04:50,440
数学的な用語では、

131
00:04:50,730 --> 00:04:52,030
カーネル関数と

132
00:04:52,160 --> 00:04:54,390
呼ばれる物だ。

133
00:04:55,340 --> 00:04:56,810
そしてここで具体的にカーネルとして使っている関数は

134
00:04:57,140 --> 00:04:59,570
実際にはガウスカーネルと呼ばれる。

135
00:05:00,630 --> 00:05:01,920
つまり、この式、この具体的な

136
00:05:02,500 --> 00:05:04,990
similarity関数の選択を、ガウスカーネルと呼ぶ。

137
00:05:05,770 --> 00:05:07,220
だが用語的には、

138
00:05:07,360 --> 00:05:09,110
これらの様々なsimilarity関数を抽象的に

139
00:05:09,600 --> 00:05:11,270
カーネルと呼び、

140
00:05:11,600 --> 00:05:12,670
similarity関数には様々な物がありうる。

141
00:05:13,750 --> 00:05:16,410
そしてこの例で私が与えた物は、ガウスカーネルと呼ばれる。

142
00:05:17,110 --> 00:05:18,400
我らは後に、別のカーネルの例を見る事になるだろう。

143
00:05:18,840 --> 00:05:21,100
だが現時点では、これらは単なる類似度の関数と思っておけば良い。

144
00:05:22,470 --> 00:05:24,100
こんな事情により、xとlの間のsimilarity(類似度)と

145
00:05:24,500 --> 00:05:26,270
書く代わりに、

146
00:05:26,480 --> 00:05:28,380
時々これを、カーネルを表す

147
00:05:29,070 --> 00:05:32,360
小文字のkを用いて、xとランドマークの間のカーネル、と記述する事もある。

148
00:05:34,120 --> 00:05:36,120
ではカーネルが実際に

149
00:05:36,650 --> 00:05:38,480
何をやるかを見てみよう、

150
00:05:38,810 --> 00:05:40,640
そして何故この種の類似度関数が、

151
00:05:41,280 --> 00:05:44,540
これらの式が筋が通っているのかを見てみよう。

152
00:05:46,690 --> 00:05:48,020
そこでまず最初のランドマーク、

153
00:05:48,330 --> 00:05:49,230
ランドマークl(1)に対して、

154
00:05:49,350 --> 00:05:51,370
これはさっきの図で私が選んだ点の一つだが、

155
00:05:53,000 --> 00:05:54,160
xとl(1)の間のカーネルの類似度は、この式で与えられる。

156
00:05:57,530 --> 00:05:58,600
この分子が

157
00:05:58,690 --> 00:05:59,600
実際にどうなるのかを

158
00:05:59,780 --> 00:06:01,860
一応書いておくと、

159
00:06:01,960 --> 00:06:03,140
分子はこのように、

160
00:06:03,330 --> 00:06:04,620
j=1からnまでの、ある種の距離の

161
00:06:04,880 --> 00:06:06,470
和となる。

162
00:06:07,000 --> 00:06:08,700
つまりこれは、xとベクトルlの

163
00:06:09,270 --> 00:06:10,900
各要素に渡って取った距離だ。

164
00:06:11,070 --> 00:06:12,050
そしてここでも、

165
00:06:12,380 --> 00:06:14,460
これらのスライド上では、

166
00:06:14,720 --> 00:06:16,180
x0を無視する。

167
00:06:16,680 --> 00:06:17,910
つまり切片項のx0を、これはいつも=1だが、

168
00:06:18,220 --> 00:06:19,960
単に無視する事にする。

169
00:06:21,430 --> 00:06:22,470
すると、これがxとランドマークの類似度を用いて

170
00:06:22,630 --> 00:06:25,780
カーネルを計算する方法だ。

171
00:06:27,270 --> 00:06:28,200
ではこの関数が何をするかを見ていこう。

172
00:06:29,110 --> 00:06:31,870
xがランドマークの一つと近いとしてみよう。

173
00:06:33,320 --> 00:06:34,910
すると、この分子にある

174
00:06:35,360 --> 00:06:36,690
ユークリッド距離の式は

175
00:06:36,990 --> 00:06:38,770
0に近い値となる。

176
00:06:38,890 --> 00:06:40,070
つまり、この項、

177
00:06:40,580 --> 00:06:41,880
このxとl(1)の距離、

178
00:06:42,170 --> 00:06:43,130
この距離は

179
00:06:43,240 --> 00:06:45,130
0に近い値となる。

180
00:06:46,390 --> 00:06:47,440
するとf1、フィーチャーは、

181
00:06:47,710 --> 00:06:50,100
だいたい近似的に

182
00:06:50,290 --> 00:06:52,760
eの指数乗である所の

183
00:06:52,800 --> 00:06:54,650
-0の二乗が分子で、2 シグマ二乗が分母。

184
00:06:55,650 --> 00:06:56,670
つまり eの0乗で、

185
00:06:56,770 --> 00:06:58,070
eの-0乗で、

186
00:06:58,370 --> 00:06:59,810
eの0乗はだいたい1。

187
00:07:01,640 --> 00:07:03,480
そしてここに近似の記号を用いたのは

188
00:07:03,700 --> 00:07:05,430
距離は厳密に0では

189
00:07:05,530 --> 00:07:06,930
無いかもしれないからだが、

190
00:07:07,120 --> 00:07:08,040
しかしxがランドマークに近ければ、

191
00:07:08,340 --> 00:07:09,190
この項は0に近くなり、

192
00:07:09,440 --> 00:07:12,070
f1は1に近くなる。

193
00:07:13,400 --> 00:07:15,220
逆に、xがl(1)から

194
00:07:15,520 --> 00:07:17,350
遠く離れている時には、

195
00:07:17,550 --> 00:07:18,940
この最初のフィーチャーf1は

196
00:07:19,820 --> 00:07:21,190
eの指数乗である所の

197
00:07:21,540 --> 00:07:24,040
何らかの大きな数字の二乗に、

198
00:07:24,960 --> 00:07:25,980
割ることの2 シグマ二乗で、

199
00:07:26,260 --> 00:07:27,690
つまりeの

200
00:07:27,810 --> 00:07:28,800
マイナスの、大きな数による累乗は

201
00:07:29,630 --> 00:07:31,450
0に近い値となる。

202
00:07:33,320 --> 00:07:34,610
つまりこれらのフィーチャーが

203
00:07:34,750 --> 00:07:36,080
行う事は、xとランドマークの一つとが

204
00:07:36,290 --> 00:07:37,500
どれだけ似ているかを

205
00:07:37,670 --> 00:07:39,160
測っているのだ。

206
00:07:39,530 --> 00:07:40,290
そしてフィーチャーfは

207
00:07:40,540 --> 00:07:42,360
xがランドマークに近い時に

208
00:07:42,540 --> 00:07:43,810
1に近い値となり、

209
00:07:44,020 --> 00:07:45,310
xがランドマークから遥か離れていると、

210
00:07:45,380 --> 00:07:46,520
0に近い

211
00:07:46,790 --> 00:07:48,850
値となる。

212
00:07:49,320 --> 00:07:49,980
前のスライドにあった

213
00:07:50,590 --> 00:07:51,620
これらのランドマークそれぞれに対し、

214
00:07:52,250 --> 00:07:54,260
私は三つのランドマーク、l(1)、l(2)、l(3)を描いたのだが、

215
00:07:56,190 --> 00:08:00,030
これらのランドマークそれぞれに対し、新しいフィーチャー

216
00:08:00,660 --> 00:08:02,270
f1, f2, f3を定義する。

217
00:08:02,680 --> 00:08:03,660
つまり、ある所与の

218
00:08:03,710 --> 00:08:05,160
トレーニング手本xに対し

219
00:08:05,380 --> 00:08:06,750
三つのフィーチャー

220
00:08:06,930 --> 00:08:08,720
f1, f2, f3を計算出来る、

221
00:08:09,520 --> 00:08:11,010
さっき書いた三つのランドマークが

222
00:08:11,340 --> 00:08:13,530
所与の時には。

223
00:08:13,760 --> 00:08:15,030
だがまず、

224
00:08:15,240 --> 00:08:16,450
この指数関数を最初に見よう。

225
00:08:16,710 --> 00:08:18,190
まずこの類似度(similarity)関数から見ていこう。

226
00:08:18,570 --> 00:08:20,790
そしてそれをプロットしてみて、

227
00:08:21,230 --> 00:08:22,460
それが実際にどんな形かをもっと良く理解していこう。

228
00:08:23,510 --> 00:08:26,320
この例では、二つのフィーチャーx1とx2があるとする。

229
00:08:26,570 --> 00:08:27,430
そして最初のランドマークのl(1)は、

230
00:08:27,820 --> 00:08:29,290
地点3, 5に

231
00:08:29,520 --> 00:08:32,550
あるとする。

232
00:08:33,650 --> 00:08:35,750
そしてシグマ二乗はここでは1としよう。

233
00:08:36,500 --> 00:08:37,550
もしこのフィーチャーをプロットすると、

234
00:08:37,890 --> 00:08:40,420
この図が得られる。

235
00:08:41,210 --> 00:08:42,510
この垂直の軸、

236
00:08:42,760 --> 00:08:44,030
表面の高さは、

237
00:08:45,240 --> 00:08:46,280
f1の値だ。

238
00:08:46,630 --> 00:08:48,490
この下の、水平軸達は、

239
00:08:48,710 --> 00:08:50,580
あるトレーニング手本があった時に、

240
00:08:51,660 --> 00:08:53,050
それはx1とx2を持っている訳だが、

241
00:08:53,320 --> 00:08:54,940
あるトレーニング手本が与えられた時に、

242
00:08:55,120 --> 00:08:56,890
このx1とx2の値の

243
00:08:56,980 --> 00:08:58,140
トレーニング手本、

244
00:08:58,140 --> 00:08:59,390
この点の上の曲面までの高さが、

245
00:08:59,950 --> 00:09:02,220
対応するf1の値を示している、

246
00:09:02,410 --> 00:09:03,830
そしてこの下に、

247
00:09:03,960 --> 00:09:04,890
同じ図を等高線プロットを用いて

248
00:09:05,040 --> 00:09:06,600
描いた物を示しておいた。

249
00:09:06,810 --> 00:09:08,320
x1が横軸で

250
00:09:09,090 --> 00:09:10,340
x2が縦軸。

251
00:09:10,820 --> 00:09:12,500
つまりこの下の図は

252
00:09:12,820 --> 00:09:13,700
この三次元曲面の

253
00:09:13,940 --> 00:09:15,440
等高線プロットだ。

254
00:09:16,540 --> 00:09:17,800
見て分かるように、

255
00:09:18,030 --> 00:09:19,540
xがぴったり3, 5の時には、

256
00:09:19,820 --> 00:09:24,140
f1の値は

257
00:09:24,380 --> 00:09:25,680
1を取る、

258
00:09:25,760 --> 00:09:26,990
何故ならそこが

259
00:09:27,170 --> 00:09:29,400
最大となる点だからだ。

260
00:09:29,860 --> 00:09:31,150
そしてxが離れていくと、

261
00:09:31,680 --> 00:09:33,650
xが離れていくにつれて、

262
00:09:33,860 --> 00:09:35,270
このフィーチャーは

263
00:09:36,460 --> 00:09:37,160
0に近い値を取る。

264
00:09:38,750 --> 00:09:40,120
だからこれは実際に、

265
00:09:40,400 --> 00:09:42,100
f1はxが最初のランドマークと

266
00:09:42,400 --> 00:09:43,680
どれだけ近いかを測る指標、フィーチャーで、

267
00:09:44,040 --> 00:09:46,050
それは0と1の間の値を

268
00:09:46,520 --> 00:09:47,610
xが最初のランドマークl(1)が

269
00:09:47,790 --> 00:09:48,940
どれだけ近いかに応じて

270
00:09:49,160 --> 00:09:50,650
取る。

271
00:09:52,360 --> 00:09:53,710
さて、もう一つこのスライドで

272
00:09:53,920 --> 00:09:55,530
見せたい事は、

273
00:09:56,090 --> 00:09:59,740
このパラメータ、シグマ二乗を変えた時の効果だ。

274
00:10:00,040 --> 00:10:01,770
シグマ二乗はガウスカーネルのパラメータで、

275
00:10:02,530 --> 00:10:04,120
それを変えていく事で、ちょっと違った効果が得られる。

276
00:10:05,150 --> 00:10:06,380
シグマ二乗を

277
00:10:06,650 --> 00:10:07,570
イコール0.5にセットしよう。

278
00:10:07,710 --> 00:10:09,850
そしてどうなるか見てみよう。シグマ二乗に0.5をセットすると、

279
00:10:10,090 --> 00:10:11,170
カーネルは基本的には

280
00:10:11,430 --> 00:10:12,670
似たような形だが、こぶの幅が

281
00:10:12,730 --> 00:10:14,200
狭くなる。

282
00:10:14,790 --> 00:10:16,400
等高線もちょっと縮む。

283
00:10:17,120 --> 00:10:18,360
つまりシグマ二乗がイコール0.5なら、

284
00:10:18,740 --> 00:10:19,820
xイコール3 5から

285
00:10:20,250 --> 00:10:21,650
始まって、

286
00:10:21,910 --> 00:10:23,140
そこから離れていくにつれて、

287
00:10:24,750 --> 00:10:26,370
フィーチャーf1は0に、

288
00:10:27,050 --> 00:10:28,520
より急速に落ちていく。

289
00:10:28,730 --> 00:10:30,830
逆に、

290
00:10:32,090 --> 00:10:33,930
シグマ2乗を3に

291
00:10:34,670 --> 00:10:36,280
増加させると、

292
00:10:36,510 --> 00:10:37,700
その場合は、

293
00:10:37,800 --> 00:10:39,090
点lから離れていくと、

294
00:10:39,630 --> 00:10:40,770
この点がlだが、

295
00:10:41,110 --> 00:10:42,410
これはl(1)で、これは

296
00:10:42,610 --> 00:10:45,210
座標3 5だ。それはここ。

297
00:10:48,190 --> 00:10:49,480
そしてシグマ二乗が大きくなると、

298
00:10:49,660 --> 00:10:50,460
するとl(1)から

299
00:10:50,690 --> 00:10:54,040
離れていくに連れて

300
00:10:54,320 --> 00:10:56,170
フィーチャーの値は

301
00:10:56,740 --> 00:10:57,670
よりゆっくりと、低下していく。

302
00:11:03,590 --> 00:11:05,200
このフィーチャーの定義が

303
00:11:05,290 --> 00:11:06,730
与えられたとして、

304
00:11:06,960 --> 00:11:08,420
どんな仮説が学習出来るか見てみよう。

305
00:11:09,550 --> 00:11:11,360
ある手本xが与えられたとして、

306
00:11:11,480 --> 00:11:12,930
これらのフィーチャーf1, f2, f3を

307
00:11:14,670 --> 00:11:16,360
計算する、

308
00:11:17,550 --> 00:11:18,980
そして仮説は

309
00:11:19,040 --> 00:11:20,510
シータ0 + シータ1 f1 + シータ2 f2...が

310
00:11:20,760 --> 00:11:22,050
0以上の時に

311
00:11:22,330 --> 00:11:26,210
1を予測する。

312
00:11:26,250 --> 00:11:27,100
この具体例だと、

313
00:11:27,290 --> 00:11:28,460
既に学習アルゴリズムを見つけていて、

314
00:11:28,620 --> 00:11:29,520
どうにかして既に

315
00:11:30,190 --> 00:11:31,220
これらのパラメータの値を

316
00:11:31,900 --> 00:11:32,880
得ていたとする。

317
00:11:33,510 --> 00:11:34,600
そして シータ0 = -0.5、

318
00:11:34,830 --> 00:11:36,010
シータ1 = 1,

319
00:11:36,390 --> 00:11:37,780
シータ2 = 1,

320
00:11:38,180 --> 00:11:39,570
シータ3 = 0だったとする。

321
00:11:40,370 --> 00:11:42,480
そして私がやりたい事は、

322
00:11:42,720 --> 00:11:44,530
以下のようなマゼンダの点の位置の

323
00:11:44,670 --> 00:11:46,100
手本の時には、

324
00:11:46,200 --> 00:11:48,060
何が起こるか？を

325
00:11:49,260 --> 00:11:51,710
見てみる事だ。

326
00:11:52,510 --> 00:11:55,050
たった今描いたここの点。

327
00:11:55,380 --> 00:11:56,180
トレーニング手本xがあったら、

328
00:11:56,290 --> 00:11:58,690
仮説は何を予測するだろうか？

329
00:11:59,000 --> 00:12:01,430
この式を見てみると、

330
00:12:04,580 --> 00:12:05,890
トレーニング手本xは

331
00:12:06,050 --> 00:12:07,820
l(1)の近くなので、

332
00:12:08,230 --> 00:12:10,190
f1は

333
00:12:10,250 --> 00:12:11,830
1に近い値となる、

334
00:12:12,250 --> 00:12:13,200
トレーニング手本xは

335
00:12:13,360 --> 00:12:15,050
l(2)とl(3)からは遠く離れているから、

336
00:12:15,360 --> 00:12:16,880
f2は0に近い値で、

337
00:12:17,590 --> 00:12:20,500
f3も0に近い値だから、

338
00:12:21,550 --> 00:12:22,700
この式を見ると、

339
00:12:22,880 --> 00:12:23,970
シータ0 +

340
00:12:24,230 --> 00:12:25,670
シータ1 掛ける1 +

341
00:12:26,600 --> 00:12:29,970
シータ2掛ける何かしらの値で、その値は

342
00:12:30,510 --> 00:12:32,390
完全に0では無いが、0に近いとしよう。

343
00:12:33,140 --> 00:12:36,400
そして足すことのシータ3掛ける何かしら0に近い値。

344
00:12:37,480 --> 00:12:39,810
これはイコール、これらの値を代入すると、

345
00:12:41,050 --> 00:12:43,470
すると-0.5+

346
00:12:44,160 --> 00:12:46,820
1*1でこれは1、などと以下同様に、

347
00:12:46,960 --> 00:12:47,740
これはイコール0.5となり、これは0以上だ。

348
00:12:48,000 --> 00:12:50,820
つまり、この点は

349
00:12:51,160 --> 00:12:54,280
y=1と予測する事になる、

350
00:12:54,740 --> 00:12:57,320
何故ならこれが0以上となったから。

351
00:12:58,910 --> 00:12:59,950
ここで、別の点をとってみよう。

352
00:13:00,800 --> 00:13:02,100
今度は別の点、

353
00:13:02,140 --> 00:13:03,060
これを別の色で

354
00:13:03,260 --> 00:13:04,370
シアン色で

355
00:13:04,770 --> 00:13:07,080
描く事にしよう、それを

356
00:13:07,250 --> 00:13:08,470
ここの点とする。

357
00:13:08,710 --> 00:13:10,580
これがトレーニング手本xだとすると、

358
00:13:11,270 --> 00:13:12,190
同様の計算を行っていくと、

359
00:13:12,950 --> 00:13:14,390
f1, f2, f3は

360
00:13:15,420 --> 00:13:16,850
全て0に近い値となる、

361
00:13:18,160 --> 00:13:19,910
すると、シータ0+

362
00:13:20,240 --> 00:13:23,940
シータ1 f1 +

363
00:13:24,230 --> 00:13:26,010
...と続いていき、

364
00:13:26,200 --> 00:13:27,830
これはイコール

365
00:13:28,020 --> 00:13:30,810
-0.5となる。

366
00:13:31,170 --> 00:13:32,110
何故ならシータ0は-0.5で、

367
00:13:32,190 --> 00:13:33,920
f1, f2, f3は全てゼロだから。

368
00:13:34,910 --> 00:13:37,510
だからこれは0.5となり、これは0未満だ。

369
00:13:37,860 --> 00:13:38,910
つまり、ここの点は、

370
00:13:39,090 --> 00:13:40,220
y=0と

371
00:13:40,470 --> 00:13:42,010
予測する事になる。

372
00:13:44,190 --> 00:13:45,100
そしてもしあなたが自分で、

373
00:13:45,270 --> 00:13:46,230
さまざまな点で

374
00:13:46,380 --> 00:13:47,460
計算してみると、

375
00:13:47,670 --> 00:13:48,660
l(2)に近い点の

376
00:13:48,730 --> 00:13:50,340
トレーニング手本は、

377
00:13:50,890 --> 00:13:52,390
これもまたy=1を予測する事になる、と

378
00:13:52,970 --> 00:13:55,730
納得出来ると思う。

379
00:13:56,800 --> 00:13:58,110
そして結局、

380
00:13:58,240 --> 00:13:59,300
最終的にあなたがやってるのは、

381
00:13:59,350 --> 00:14:00,920
この空間を見回して、

382
00:14:01,140 --> 00:14:02,300
l(1)とl(2)に

383
00:14:02,820 --> 00:14:03,900
近い点なら、

384
00:14:04,090 --> 00:14:05,560
陽性と予測する事になる。

385
00:14:06,550 --> 00:14:07,780
そしてl(1)とl(2)から

386
00:14:08,050 --> 00:14:09,260
遠い点は、

387
00:14:09,470 --> 00:14:12,220
これら二つのランドマークの両方から遠い点は、

388
00:14:12,480 --> 00:14:13,780
そのクラスはイコール0だと

389
00:14:14,390 --> 00:14:15,560
予測する事になる。

390
00:14:16,510 --> 00:14:17,380
だから最終的にやってる事は、

391
00:14:17,890 --> 00:14:20,270
この仮説の決定境界は

392
00:14:20,400 --> 00:14:22,110
こんな感じの

393
00:14:22,280 --> 00:14:24,210
物となり、

394
00:14:24,370 --> 00:14:25,630
この赤い決定境界の内側を

395
00:14:26,580 --> 00:14:28,240
y=1と予測し、

396
00:14:28,630 --> 00:14:30,250
外側を

397
00:14:32,570 --> 00:14:32,570
y=0と予測する。

398
00:14:33,020 --> 00:14:34,770
つまり以上が、

399
00:14:34,850 --> 00:14:36,010
ランドマークとカーネル関数を

400
00:14:36,870 --> 00:14:38,560
定義する事で、

401
00:14:39,370 --> 00:14:40,940
我らは極めて複雑な、非線型の決定境界を

402
00:14:41,420 --> 00:14:42,800
学習させる事が出来る、

403
00:14:42,930 --> 00:14:44,150
例えば私がさっき描いたような、

404
00:14:44,560 --> 00:14:46,990
二つのランドマークに近い時に陽性と予想し、

405
00:14:47,570 --> 00:14:48,880
どのランドマークからも遠く離れている時には

406
00:14:49,260 --> 00:14:50,680
陰性と

407
00:14:50,950 --> 00:14:52,990
予想するような。

408
00:14:53,440 --> 00:14:55,000
以上がカーネルという

409
00:14:55,050 --> 00:14:57,300
考え方と、

410
00:14:57,600 --> 00:14:58,620
それをサポートベクターマシンで

411
00:14:58,770 --> 00:14:59,810
使う方法だ、

412
00:14:59,990 --> 00:15:01,720
それはランドマークを用いて、

413
00:15:02,040 --> 00:15:03,900
これらの新しいフィーチャーを定義し、

414
00:15:04,770 --> 00:15:06,730
類似度関数を用いてより複雑な非線型の分類器を学習する。

415
00:15:08,210 --> 00:15:09,290
以上でカーネルと

416
00:15:09,390 --> 00:15:10,410
それを用いて

417
00:15:10,590 --> 00:15:11,680
サポートベクターマシンで新しいフィーチャーを定義する方法が

418
00:15:11,890 --> 00:15:14,110
分かっただろうか。

419
00:15:15,510 --> 00:15:17,670
だが、まだ幾つか答えてない疑問がある。

420
00:15:18,010 --> 00:15:19,550
一つ目は、どうやってこれらのランドマークを得たらいいだろうか？

421
00:15:20,120 --> 00:15:20,930
これらのランドマークを、どうやって選んだらいいだろう？

422
00:15:21,050 --> 00:15:22,910
そしてもう一つは、

423
00:15:23,090 --> 00:15:24,500
別の類似度関数として、

424
00:15:24,750 --> 00:15:25,680
我らが話してきた物、ガウスカーネル以外には

425
00:15:25,780 --> 00:15:29,000
どんな物が使えるだろうか？

426
00:15:29,190 --> 00:15:29,970
次のビデオではこれらの問いに対する

427
00:15:29,990 --> 00:15:31,290
解答を与えていく。

428
00:15:31,490 --> 00:15:33,150
そして全てを組み合わせて

429
00:15:33,740 --> 00:15:35,060
サポートベクターマシンがカーネルとあわせて

430
00:15:35,720 --> 00:15:36,960
どのように複雑な非線形の関数を

431
00:15:37,200 --> 00:15:38,610
学習する事が出来るかを見ていく。