假如你想要确定对于某组数据 最合适的多项式次数是几次 怎样选用正确的特征来构造学习算法 或者假如你需要正确选择 学习算法中的正则化参数λ 你应该怎样做呢？ 这些问题我们称之为模型选择问题 在我们对于这一问题的讨论中 我们还将提到 如何将数据分为三组 也就是训练集、验证集和测试集 而不仅仅是前面提到的两组数据 在这节视频中 我们将会介绍这些内容的含义 以及如何使用它们进行模型选择 我们已经多次接触到过拟合现象 在过拟合的情况中 学习算法在适用于训练集时表现非常完美 但这并不代表此时的假设也很完美 更一般地说 这也是为什么训练集误差 通常不能正确预测出该假设是否能很好地拟合新样本的原因 具体来讲 如果你把这些参数集 比如θ0 θ1 θ2等等 调整到非常拟合你的训练集 那么结果就是 你的假设会在训练集上表现地很好 但这并不能确定 当你的假设推广到训练集之外的新的样本上时 预测的结果是怎样的 而更为普遍的规律是 只要你的参数非常拟合某个数据组 比如说 非常拟合训练集 当然也可以是其他数据集 那么你的假设对于相同数据组的预测误差 比如说训练误差 是不能够用来推广到一般情况的 或者说 是不能作为实际的泛化误差的 也就是说 不能说明你的假设对于新样本的效果 下面我们来考虑模型选择问题 假如说你现在要选择能最好地拟合你数据的多项式次数 换句话说 你应该选择一次函数 二次函数 还是三次函数呢 等等一直到十次函数 所以似乎应该有这样一个参数 这里我用 d 来表示 d表示的就是你应该选择的多项式次数 所以 似乎除了你要确定的参数θ之外 你还要考虑确定一个参数 你同样需要用你的数据组来确定这个多项式的次数d 第一个选择是 d=1 也就表示线性(一次)方程 我们也可以选择d=2或者3 等等一直到d=10 因此 我们想确定这个多出来的参数d最适当的取值 具体地说 比如你想要选择一个模型 那就从这10个模型中 选择一个最适当的多项式次数 并且用这个模型进行估计 预测你的假设能否很好地推广到新的样本上 那么你可以这样做 你可以先选择第一个模型 然后求训练误差的最小值 这样你就会得到 一个参数向量θ 然后你再选择第二个模型 二次函数模型 进行同样的过程 这样你会得到另一个参数向量 θ 为了区别这些不同的 参数向量θ 我想用上标(1) 上标(2)来表示 这里的上标(1)表示的是 在调整第一个模型 使其拟合训练数据时得到的参数θ 同样地 θ上标(2)表示的是 二次函数在和训练数据拟合的过程中得到的参数 以此类推 在拟合三次函数模型时我又得到一个参数θ(3) 等等 直到θ(10) 接下来我们要做的是 对所有这些模型 求出测试集误差 因此 我可以算出 Jtest(θ(1)) Jtest(θ(2)) Jtest(θ(3)) 以此类推 也就是对于每一个模型对应的假设 都计算出其作用于测试集的表现如何 接下来为了确定选择哪一个模型最好 我要做的是 看看这些模型中 哪一个对应的测试集误差最小 那么对于这一个例子 我们假设最终选择了五次多项式模型 目前看来还比较合理 那么现在 我确定了我的模型 我得到了我的假设 也就是这个五次函数模型 现在我想知道 这个模型能不能很好地推广到新样本 我们可以观察这个五次多项式假设模型 对测试集的拟合情况 但这里有一个问题是 这样做仍然不能公平地说明 我的假设推广到一般时的效果 其原因在于 我们刚才是使用的测试集 跟假设拟合 来得到的 多项式次数d 这个参数 这也就是说 我们选择了一个 能够最好地拟合测试集的 参数d的值 因此 我们的参数向量θ(5) 在拟合测试集时的结果 很可能导致一个比实际泛化误差更完美的预测结果 对吧？ 因为我是找了一个最能拟合测试集的参数d 因此我再用测试集 来评价我的假设就显得不公平了 因为我已经选了一个能够最拟合测试集的参数 我选择的多项式次数d 本身就是按照最拟合测试集来选择的 因此我的假设 很可能很好地拟合测试集 而且这种拟合的效果很可能会比对那些没见过的新样本拟合得更好 而我们其实是更关心对新样本的拟合效果的 所以 再回过头来说 在前面的幻灯片中 我们看到 如果我们 用训练集来拟合参数 θ0 θ1 等等参数时 那么 拟合后的模型 在作用于训练集上的效果 是不能预测出 我们将这个假设推广到新样本上时效果如何的 这是因为这些参数能够很好地拟合训练集 因此它们很有可能 在对训练集的预测中表现地很好 但对其他的新样本来说 就不一定那么好了 而在刚才这一页幻灯片上 我讲到的步骤 也是在做同样的事 具体来讲 我们做的实际上是用测试集来拟合参数d 通过用测试集来拟合这个参数 同样也意味着 这并不能较为公平地预测出 假设函数的在遇到新样本时的表现 为了解决这一问题 在模型选择中 如果我们想要评价某个假设 我们通常采用以下的方法 给定某个数据集 和刚才将数据分为 训练和测试集不同的是 我们要将其分为三段 第一部分还是叫训练集 所以 我们还是称这部分为训练集 第二部分我把它叫做交叉验证集（cross validation set） Cross validation 我用CV来简写“交叉验证” 有时候也直接叫验证集 不叫交叉验证集 最后一部分依然和以前一样是测试集 同时 一种典型的分割比例是 将60%的数据 分给训练集 大约20%的数据给交叉验证集 最后20%给测试集 这个比例可以稍微调整 但这种分法是最典型的 所以现在我们的训练集就只占总数据的60%了 然后交叉验证集 或者说验证集 将拥有一部分样本 我把它的数量用m下标CV来表示 这是交叉验证集样本的数量 按照之前我们的符号表示习惯 我将用(x(i)CV, y(i)CV) 来表示第i个交叉验证样本 最后 我们还是有这样一些测试集样本 用m下标test来表示测试样本的总数 好的 现在我们就定义了训练集、交叉验证集 以及测试集 我们随之也可以定义训练误差 交叉验证误差 和测试误差 因此这便是我定义的训练误差 我用J下标train来表示 这跟我们之前定义的 J(θ)没有任何区别 也就是对训练集数据进行预测得到的误差 然后J下标CV定义为交叉验证集误差 这也不难想象 跟训练误差类似的定义 只不过是在交叉验证集上预测得到的误差 然后这是测试集 跟前面一样 好的 那么我们的模型选择问题是这样的 和之前使用测试集来选择模型不同 我们现在要使用验证集 或者说交叉验证集来选择模型 具体来讲 首先我们用第一个假设函数 也就是第一个模型 然后求代价函数的最小值 然后我们会得到这个线性模型对应的参数向量θ 和之前一样 我们还是用上表(1)来表示 这个参数是对应于线性模型的 对二次函数 我们也做同样的事情 这样可以得到θ(2) 然后是θ(3) 等等以此类推 一直到10次多项式 然后我要做的是 跟之前用测试集来预测这些假设不同 我要在交叉验证集中测试这些假设的表现 我要测出Jcv来看看 这些假设在交叉验证集中表现如何 然后我要选择的是交叉验证集误差最小的那个假设 因此 对于这个例子 假如是 四次函数的模型有最小的交叉验证误差 因此 我们就选择这个四次多项式模型 最后 这样做的意义是 参数d 别忘了参数d 是多项式的次数 d=2 d=3 一直到d=10 我们刚才做的是拟合出最好的系数d等于4 并且我们是通过交叉验证集来完成的 因此 这样一来这个参数d 这个多项式的次数 就没有跟测试集进行拟合 这样我们就回避了测试集的嫌疑 我们可以光明正大地使用测试集 来估计所选模型的泛化误差了 好的 这就是模型选择了 以及你应该怎样 将数据分成训练集、验证集和测试集 以及使用你的交叉验证集数据来选择模型 最后用测试集来评价模型的表现 最后我还想提醒的一点是 在如今的机器学习应用中 确实也有很多人是像我之前介绍的那样做的 我说过这并不是一个好的方法 也就是用测试集来选择模型 然后用同样的测试集来 评价模型的表现 报告测试误差 看起来好像还能得到比较不错的泛化误差 这的确是一种做法 但不幸的是 现在还有很多人这样做 如果你有很多很多测试集的话 这也许还能行得通 但大多数的机器学习开发人员 还是不会选择这样做 因为最佳做法还是把数据分成训练集、验证集、测试集 但我还是告诉你 在现实中确实有很大一部分人 有时会使用同样一组数据 既作为验证集 也作为测试集 也就是只有训练集和测试集 你的确可能会看到很多人选择这种方法 但如果可能的话