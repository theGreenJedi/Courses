现在你应该已经知道 算法正则化可以有效地防止过拟合 但正则化跟算法的偏差和方差 又有什么关系呢？ 在这段视频中 我想更深入地 探讨一下偏差和方差的问题 讨论一下两者之间 是如何相互影响的 以及和算法的正则化之间的相互关系 假如我们要对这样一个高阶多项式进行拟合 为了防止过拟合现象 我们要使用一个正则化项 因此我们试图通过这样一个正则化项 来让参数的值尽可能小 正则化项的求和范围照例取为 j 等于1到 m 而非 j 等于0到 m 然后我们来分析以下三种情形 第一种情形是正则化参数 λ 取一个比较大的值 比如 λ 的值取为10000甚至更大 在这种情况下 所有这些参数 θ1 θ2 θ3 等等 将被大大惩罚 其结果是 这些参数的值将近似等于0 并且假设模型 h(x) 的值将等于或者近似等于 θ0 因此我们最终得到的假设函数 应该是这个样子 近似是一条平滑的直线 因此这个假设处于高偏差 对数据集欠拟合(underfit) 因此一条水平直线 对这个数据集来讲不是一个好的假设 与之对应的另一种情况是 λ值很小 比如说 λ 的值等于0 在这种情况下 如果我们要拟合一个高阶多项式的话 那么我们通常会处于过拟合(overfitting)的情况 在拟合一个高阶多项式时 如果没有进行正则化 或者正则化程度很微小的话 我们通常会得到高方差和过拟合的结果 因为 λ 的值等于0相当于没有正则化项 因此会对假设过拟合 只有当我们取一个中间大小的 既不大也不小的 λ 值时 我们才会得到一组合理的 对数据刚好拟合的 θ 参数值 那么我们应该怎样自动地选择出一个最合适的正则化参数 λ 呢？ 重申一下 我们的模型和学习参数 以及最优化目标是这样的 让我们假设在使用正则化的情形中 定义 Jtrain(θ) 为另一种不同的形式 同样定义为最优化目标 但不使用正则化项 在先前的授课视频中 当我们没有使用正则化时 我们定义的Jtrain(θ) 就是代价函数J(θ) 但当我们使用正则化多出这个 λ 项时 我们就将训练集误差 也就是Jtrain 定义为 训练集数据预测误差的平方求和 或者说是训练集的平均误差平方和 但不考虑正则化项 与此类似 我们来定义交叉验证集误差和测试集误差 和之前一样定义为 对交叉验证集和测试集进行预测的平均误差平方和 总结一下 我们对于训练误差Jtrain Jcv Jtest的定义 都是平均误差平方和 或者准确地说 是训练集 验证集和测试集进行预测 在不使用正则化项时 平均误差平方和的一半 下面就是我们自动选取正则化参数 λ 的方法 通常我的做法是 选取一系列我想要尝试的 λ 值 因此首先我可能考虑不使用正则化的情形 以及一系列我可能会试的值 比如说我可能从0.01 0.02 0.04开始 一直试下去 通常我会将步长设为2倍速度增长 直到一个比较大的值 在本例中以两倍步长递增的话 我们最终取值10.24 实际上我们取的是10 但已经非常接近了 因为小数点后的24对最终的结果不会有太大影响 因此 这样我就得到了12个不同的正则化参数 λ 对应的12个不同的模型 当然了 你也可以试小于0.01的值或者大于10的值 但在这里我就不讨论这些情况了 得到这12组模型后 接下来我们要做的事情是 选用第一个模型 也就是 λ 等于0 然后最小化我们的代价函数 J(θ) 这样我们就得到了某个参数向量 θ 与之前视频的做法类似 我使用θ上标(1) 来表示第一个参数向量θ 然后我再取第二个模型 λ 等于0.01的模型 最小化代价方差 当然现在 λ 等于0.01 那么会得到一个完全不同的参数向量 θ 用 θ(2)来表示 同理 接下来我会得到 θ(3) 对应于我的第三个模型 以此类推 一直到最后一个 λ 等于10或10.24的模型 对应 θ(12) 接下来我就可以用交叉验证集来评价这些假设和参数了 因此我可以从第一个模型开始 然后是第二个模型 对每一个不同的正则化参数 λ 进行拟合 然后用交叉验证集来评价每一个模型 也即测出每一个参数 θ 在交叉验证集上的平均误差平方和 然后我就选取这12个模型中交叉验证集误差最小的 那个模型作为最终选择 对于本例而言 假如说 最终我选择了 θ(5) 也就是五次多项式 因为此时的交叉验证集误差最小 做完这些 最后 如果我想看看该模型在测试集上的表现 我可以用经过学习得到的模型 θ(5) 来测出它对测试集的预测效果如何 再次重申 这里我们依然是用交叉验证集来拟合模型 这也是为什么我之前预留了一部分数据作为测试集的原因 这样我就可以用这部分测试集比较准确地估计出 我的参数向量 θ 对于新样本的泛化能力 这就是模型选择在选取正则化参数 λ 时的应用 在这段视频中我想讲的最后一个问题是 当我们改变正则化参数 λ 的值时 交叉验证集误差和训练集误差 会随之发生怎样的变化 我想提醒一下 我们最初的代价函数 J(θ) 但在这里我们把训练误差 定义为不包括正则化项 交叉验证集误差也定义为不包括正则化项 我要做的是绘制出 Jtrain和 Jcv 的曲线 表达的是随着我增大正则化项参数 λ 的值 看看我的假设 在训练集上的表现如何变化 以及在交叉验证集上表现如何变化 就像我们之前看到的 如果 λ 的值很小 那也就是说我们几乎没有使用正则化 因此我们有很大可能处于过拟合 而如果 λ 的值取的很大的时候 也就是说取值在横坐标的右端 那么由于 λ 的值很大 我们很有可能处于高偏差的问题 所以 如果你画出 Jtrain 和 Jcv 的曲线 你就会发现 当 λ 的值取得很小时 对训练集的拟合相对较好 因为没有使用正则化 因此 对于 λ 值很小的情况正则化项可以忽略 你只需要对平方误差求最小值即可 所以当 λ 值很小时 你最终能得到一个值很小的Jtrain 而如果 λ 的值很大时你将处于高偏差问题 不能对训练集很好地拟合 因此你的误差值可能位于这个位置 因此 当 λ 增大时 训练集误差Jtrain的值 会趋于上升 因为 λ 的值比较大时对应着高偏差的问题 此时你连训练集都不能很好地拟合 反过来 当 λ 的值取得很小的时候 你的数据能随意地与高次多项式很好地拟合 而交叉验证集误差的曲线是这样的 在曲线的右端 当 λ 的值取得很大时 我们会处于欠拟合问题 因此这对应着偏差问题 那么此时交叉验证集误差将会很大 我写在这里 这是交叉验证集误差Jcv(θ) 由于高偏差的原因我们不能很好地拟合 我们的假设不能在交叉验证集上表现地比较好 而曲线的左端对应的是高方差问题 此时我们的 λ 值取得很小很小 因此我们会对数据过度拟合 所以由于过拟合的原因 交叉验证集误差也会很大 好的 这就是当我们改变正则化参数 λ 的值时 交叉验证集误差和训练集误差随之发生的变化 当然 在中间取的某个 λ 的值 表现得刚好合适 这种情况下表现最好 交叉验证集误差或者测试集误差都很小 当然由于我在这里画的图显得太卡通 也太理想化了 对于真实的数据 你得到的曲线可能比这看起来更凌乱 会有很多的噪声 对某个实际的数据集 你或多或少能看出像这样的一个趋势 通过绘出这条曲线 通过交叉验证集误差的变化趋势 你可以用自己选择出 或者编写程序自动得出 能使交叉验证集误差最小的那个点 然后选出那个与之对应的参数 λ 的值 当我在尝试为学习算法选择正则化参数 λ 的时候 我通常都会画出像这样一个图 帮助我更好地理解各种情况 同时也帮助我确认 我选择的正则化参数值到底好不好 希望这节课的内容让你更深入地理解了正则化 以及它对学习算法的偏差和方差的影响 到目前为止你已经从不同角度认识了方差和偏差问题 在下一节视频中我要做的是 基于我们已经介绍过的所有这些概念 将它们结合起来 建立我们的诊断法 也称为学习曲线 这种方法通常被用来诊断一个学习算法 到底是处于偏差问题还是方差问题 还是两者都有 【果壳教育无边界字幕组】翻译/时间轴：所罗门捷列夫 假如说 最终我选择了theta(5) 也就是五次多项式 因为此时的交叉验证集误差最小 做完这些 最后 如果我想看看该模型 在测试集上的表现 我可以用经过学习 得到的模型theta(5) 来测出它对测试集的 预测效果如何 再次重申一下 这里我们依然是用 交叉验证集来拟合模型 这也是为什么我之前 预留了一部分数据 作为测试集的原因 这样我就可以用这部分测试集 比较准确地估计出 我的参数向量theta 对于新样本的泛化能力 这就是模型选择在选取 正则化参数lambda时的应用 在这段视频中 我想讲的最后一个问题是 当我们改变 正则化参数lambda的值时 交叉验证集误差 和训练集误差会随之 发生怎样的变化 我想提醒一下 我们最初的代价函数J(θ) 原来是这样的形式 但在这里我们把训练误差 定义为不包括正则化项 交叉验证集误差 也定义为不包括 正则化项 我要做的是 绘制出Jtrain和Jcv的曲线 随着我增大正则化项参数 lambda的值 看看我的假设 在训练集上的表现如何变化 以及在交叉验证集上 表现如何变化 就像我们之前看到的 如果正则化项参数 lambda的值很小 那也就是说我们几乎没有使用正则化 因此我们有很大可能处于过拟合 而如果lambda的值 取的很大的时候 也就是说取值在 横坐标的右端 那么由于lambda的值很大 我们很有可能处于高偏差的问题 所以 如果你画出 Jtrain和Jcv的曲线 你就会发现 当lambda的值取得很小时 对训练集的拟合相对较好 因为没有使用正则化 因此 对于lambda值很小的情况 正则化项基本可以忽略 你只需要对平方误差 做最小化处理即可 所以当lambda值很小时 你最终能得到一个 值很小的Jtrain 而如果lambda的值很大时 你将处于高偏差问题 不能对训练集很好地拟合 因此你的误差值可能位于这个位置 因此 当lambda增大时 训练集误差Jtrain的值 会趋于上升 因为lambda的值比较大时 对应着高偏差的问题 此时你连训练集都不能很好地拟合 反过来 当lambda的值 取得很小的时候 你的数据能随意地与高次多项式 很好地拟合 交叉验证集误差的曲线是这样的 在曲线的右端 当lambda的值 取得很大时 我们会处于欠拟合问题 也对应着偏差问题 那么此时交叉验证集误差 将会很大 我写在这里 这是交叉验证集误差Jcv 由于高偏差的原因我们不能很好地拟合 我们的假设不能在交叉验证集上表现地比较好 而曲线的左端对应的是高方差问题 此时我们的lambda值 取得很小很小 因此我们会对数据过度拟合 所以由于过拟合的原因 交叉验证集误差Jcv 结果也会很大 好的 这就是 当我们改变正则化参数 lambda的值时 交叉验证集误差 和训练集误差 随之发生的变化 当然 在中间取的某个 lambda的值 表现得刚好合适 这种情况下表现最好 交叉验证集误差 或者测试集误差都很小 当然由于我在这里画的图 显得太卡通 也太理想化了 对于真实的数据 你得到的曲线可能 比这看起来更凌乱 会有很多的噪声 对某个实际的数据集 你或多或少能看出 像这样的一个趋势 通过绘出这条曲线 通过交叉验证集误差的变化趋势 你可以用自己选择出 或者编写程序自动得出 能使交叉验证集误差 最小的那个点 然后选出那个与之对应的 参数lambda的值 当我在尝试为学习算法 选择正则化参数 lambda的时候 我通常都会得出 类似这个图的结果 帮助我更好地理解各种情况 同时也帮助我确认 我选择的正则化参数值 到底好不好 希望这节课的内容 让你更深入地理解了正则化 以及它对学习算法的 偏差和方差的影响 到目前为止你已经从不同角度 见识了方差和偏差问题 在下一节视频中 我要做的是 基于我们已经浏览过的 所有这些概念 将它们结合起来 建立我们的诊断法 也称为学习曲线 这种方法通常被用来 诊断一个学习算法 到底是处于偏差问题 还是方差问题 还是两者都有【教育无边界字幕组】翻译、校对、审核：所罗门捷列夫