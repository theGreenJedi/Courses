1
00:00:00,090 --> 00:00:01,140
以前のビデオで、

2
00:00:01,260 --> 00:00:02,510
私は以下の事を繰り返し言ってきた:

3
00:00:02,650 --> 00:00:03,980
機械学習システムを開発する時に

4
00:00:04,770 --> 00:00:06,630
もっとも貴重なリソースの一つは

5
00:00:06,810 --> 00:00:08,050
デベロッパとしてのあなたの時間だ、とーー

6
00:00:08,490 --> 00:00:09,820
次に作業すべき事を

7
00:00:09,950 --> 00:00:11,520
選ぶ時には。

8
00:00:11,950 --> 00:00:12,710
あるいは、あなたはデベロッパのチームなり

9
00:00:13,300 --> 00:00:14,610
エンジニアのチーム一丸となって

10
00:00:15,090 --> 00:00:16,620
機械学習のシステムを開発する時もまた、

11
00:00:16,930 --> 00:00:18,420
もっとも貴重なリソースの一つはそのシステムを開発している

12
00:00:18,990 --> 00:00:20,790
エンジニアとかデベロッパの時間だ。

13
00:00:22,420 --> 00:00:23,340
そして本当に避けたい事として、

14
00:00:23,430 --> 00:00:25,340
あなたなり、あなたの同僚なり

15
00:00:25,360 --> 00:00:26,410
あなたの友人なりが、

16
00:00:26,680 --> 00:00:27,560
あるコンポーネントに対して

17
00:00:27,970 --> 00:00:29,510
たくさんの作業をした後で

18
00:00:30,470 --> 00:00:31,540
何週間とか何ヶ月とか時間を費やした後ではじめて

19
00:00:31,620 --> 00:00:33,070
それらの作業全てが

20
00:00:33,310 --> 00:00:35,090
最終的なシステムのパフォーマンスには

21
00:00:35,380 --> 00:00:38,120
大した違いを生まない、と気づく、という事だ。

22
00:00:39,350 --> 00:00:40,430
このビデオでは、

23
00:00:40,550 --> 00:00:42,960
シーリング(天井)分析と呼ばれる物について議論したい。

24
00:00:44,510 --> 00:00:45,760
あなた、あるいはあなたのチームが

25
00:00:46,280 --> 00:00:47,270
機械学習パイプラインのシステムの

26
00:00:47,520 --> 00:00:48,860
仕事をしている時には、

27
00:00:49,020 --> 00:00:50,380
この手法はパイプラインの

28
00:00:50,630 --> 00:00:51,650
どの部分を改善するのが

29
00:00:52,340 --> 00:00:53,730
もっとも良いのかについての

30
00:00:54,150 --> 00:00:56,550
強力なシグナル、あるいはガイダンスを提供してくれる事がある。

31
00:00:59,740 --> 00:01:01,700
シーリング分析の議論を行う為に

32
00:01:01,860 --> 00:01:03,140
ここでもPhoto OCRの例を

33
00:01:03,690 --> 00:01:04,910
引き続き採用

34
00:01:05,640 --> 00:01:06,870
していく。前にも言った通り

35
00:01:07,170 --> 00:01:08,270
これらの箱、

36
00:01:08,480 --> 00:01:09,900
テキスト検出、

37
00:01:10,200 --> 00:01:12,140
文字分割、そして文字認識、、、

38
00:01:12,310 --> 00:01:13,730
これらの各箱は

39
00:01:14,100 --> 00:01:15,550
それぞれ小規模かチームが担当する場合もあるし、

40
00:01:15,920 --> 00:01:17,370
システム全体を

41
00:01:17,690 --> 00:01:18,640
あなた一人だけで構築することもあるだろう。

42
00:01:18,800 --> 00:01:19,700
どちらにせよ、

43
00:01:19,960 --> 00:01:22,340
問題は、どこにリソースを割くべきか、という事だ。

44
00:01:22,730 --> 00:01:24,250
これらの箱のうちどれが

45
00:01:24,430 --> 00:01:26,630
パフォーマンスを改善しよう、と労力を払うのに

46
00:01:26,920 --> 00:01:28,260
もっとも価値がある物だろうか？

47
00:01:29,070 --> 00:01:30,350
シーリング分析のアイデアを

48
00:01:30,840 --> 00:01:32,560
説明する為に、

49
00:01:32,730 --> 00:01:35,690
このPhoto OCRパイプラインの例を使い続けていく。

50
00:01:37,000 --> 00:01:38,320
以前述べたように、

51
00:01:38,430 --> 00:01:39,630
これらの各箱は、

52
00:01:39,850 --> 00:01:41,860
これらの各機械学習のコンポーネントは

53
00:01:42,170 --> 00:01:43,270
エンジニアの小さなチームでそれぞれ

54
00:01:43,470 --> 00:01:44,720
従事しても良いし、またはシステム全体を

55
00:01:45,280 --> 00:01:48,110
一人の人間が見ても良い。

56
00:01:48,780 --> 00:01:49,920
だが何にせよ問題は、いったいどこに

57
00:01:50,100 --> 00:01:51,990
貴重なリソースを割り振るべきだろうか？という事だ。

58
00:01:52,130 --> 00:01:53,200
この場合だと、これらのコンポーネントの

59
00:01:53,690 --> 00:01:54,860
一つ目か、二つ目か、または三つ目に

60
00:01:54,950 --> 00:01:56,250
時間を使うのが

61
00:01:57,080 --> 00:01:58,540
パフォーマンスを改善するのに

62
00:01:59,200 --> 00:02:01,060
もっとも有益か？

63
00:02:01,660 --> 00:02:02,810
シーリング分析とはこんな物だ。

64
00:02:04,140 --> 00:02:05,520
これ以外の機械学習の問題と同様、

65
00:02:05,890 --> 00:02:07,170
機械学習の開発の過程において、

66
00:02:07,340 --> 00:02:08,490
システムを開発する時の

67
00:02:08,670 --> 00:02:09,740
様々な決断を

68
00:02:09,970 --> 00:02:11,150
行う為には、

69
00:02:11,710 --> 00:02:12,770
学習システムに関する

70
00:02:12,900 --> 00:02:14,070
単一で実数の評価指標があると

71
00:02:14,580 --> 00:02:17,650
とても役に立つ。

72
00:02:18,450 --> 00:02:19,390
例えば文字レベルでの正確さを選んだとしよう。

73
00:02:19,530 --> 00:02:21,140
つまり、、、

74
00:02:21,570 --> 00:02:22,840
あるテストセットの画像が与えられた時に、

75
00:02:22,860 --> 00:02:24,710
テストセットの画像内にある文字を

76
00:02:25,060 --> 00:02:26,570
どれだけの割合で

77
00:02:28,980 --> 00:02:29,390
正しく認識出来たのか、の割合。

78
00:02:29,550 --> 00:02:30,830
別にこれ以外の単一の実数の

79
00:02:31,030 --> 00:02:32,270
評価指標を選んでも良い。お望みならね。

80
00:02:32,370 --> 00:02:33,740
だがどんな評価指標を

81
00:02:34,040 --> 00:02:35,820
使うにせよ、

82
00:02:35,920 --> 00:02:37,680
とにかくシステム全体として、

83
00:02:37,880 --> 00:02:40,090
現在の所72%の正確さ(accuracy)だった、と分かったとしよう。

84
00:02:40,350 --> 00:02:42,210
言い換えると、

85
00:02:42,350 --> 00:02:43,380
我らはあるテストセットの画像を

86
00:02:43,520 --> 00:02:44,960
持っていて、それらテストセットの各画像に

87
00:02:45,180 --> 00:02:46,460
テキスト検出、

88
00:02:46,640 --> 00:02:47,850
文字分割、

89
00:02:47,980 --> 00:02:49,280
文字認識を、順番に走らせて

90
00:02:49,560 --> 00:02:50,680
そして我らのテストセットに対しては

91
00:02:51,010 --> 00:02:52,240
システム全体に対して、

92
00:02:52,370 --> 00:02:53,570
あなたの選んだ指標に関して

93
00:02:53,800 --> 00:02:56,220
72%の正確さだと分かった、とする。

94
00:02:58,120 --> 00:02:59,700
さて、以下にシーリング分析のアイデアの

95
00:03:00,070 --> 00:03:01,610
背景を述べる。それは、

96
00:03:01,910 --> 00:03:03,530
我らは最初のモジュールを見て

97
00:03:03,670 --> 00:03:05,100
この機械学習パイプラインの最初のモジュールは

98
00:03:05,400 --> 00:03:06,810
テキスト検出だ。

99
00:03:07,270 --> 00:03:08,400
そして我らがやる事は、

100
00:03:08,420 --> 00:03:09,170
テストセットに

101
00:03:09,270 --> 00:03:11,310
細工をする事だ。

102
00:03:11,980 --> 00:03:12,920
テストセットに直接おもむき、

103
00:03:12,990 --> 00:03:14,270
各テスト手本に対し

104
00:03:14,830 --> 00:03:16,170
正解のテキスト検出の出力を

105
00:03:16,380 --> 00:03:18,230
直接提供する。

106
00:03:19,210 --> 00:03:20,300
言い換えると、テストセットにおもむき、

107
00:03:20,560 --> 00:03:21,760
単に手動でアルゴリズムに

108
00:03:21,960 --> 00:03:23,340
各テスト手本のどこに

109
00:03:24,350 --> 00:03:26,210
テキストがあるかを

110
00:03:26,780 --> 00:03:27,940
伝える。

111
00:03:28,950 --> 00:03:29,960
さらに言い換えると、

112
00:03:30,030 --> 00:03:31,510
我らがもし100%正確な

113
00:03:32,030 --> 00:03:33,640
テキスト検出のシステムがあったら

114
00:03:33,890 --> 00:03:35,350
何が起こるのかをシミュレートする訳だ。

115
00:03:35,610 --> 00:03:37,180
画像のテキスト検出の

116
00:03:38,300 --> 00:03:40,410
目的の為に。

117
00:03:42,050 --> 00:03:43,070
そしてそれを実際に行う方法は

118
00:03:43,110 --> 00:03:44,210
とてもシンプルだ。

119
00:03:44,620 --> 00:03:45,840
学習アルゴリズムに画像のテキストを

120
00:03:46,340 --> 00:03:47,630
検出さえる代わりに、

121
00:03:48,180 --> 00:03:49,110
あなたが直接画像に赴き

122
00:03:49,340 --> 00:03:51,230
人力でテストセットの画像のどこに

123
00:03:51,540 --> 00:03:53,620
テキストがあるかをラベル付けする。

124
00:03:54,200 --> 00:03:55,040
そしてこれらを正解にした上で、

125
00:03:55,530 --> 00:03:56,620
つまりテストセットの

126
00:03:56,990 --> 00:03:58,370
画像の中の

127
00:03:58,560 --> 00:04:00,010
どこにテキストがあるかの

128
00:04:00,090 --> 00:04:01,330
完璧に正しいラベルを付けた上で、

129
00:04:01,580 --> 00:04:02,990
これらの完璧に正しいラベルを用いて

130
00:04:03,110 --> 00:04:04,200
次のステージのパイプラインに

131
00:04:04,470 --> 00:04:07,550
食わせる、つまり文字分割のパイプラインに。

132
00:04:07,710 --> 00:04:09,250
もう一度言おう。

133
00:04:09,680 --> 00:04:10,790
このチェックマークは

134
00:04:11,500 --> 00:04:12,590
私がテストセットに実際におもむき、

135
00:04:12,750 --> 00:04:13,750
単純に正解の答えを

136
00:04:13,860 --> 00:04:14,970
与える、正しいラベルを与える、

137
00:04:15,480 --> 00:04:16,520
という事を意味している。

138
00:04:16,650 --> 00:04:18,250
パイプラインのテキスト検出の部分を。

139
00:04:19,240 --> 00:04:20,280
そうする事で、まるで

140
00:04:20,410 --> 00:04:21,700
テストセットに対して完璧なテキスト検出を

141
00:04:22,370 --> 00:04:24,270
持っているフリをする為に。

142
00:04:24,460 --> 00:04:26,570
そして次にやることは

143
00:04:27,190 --> 00:04:28,150
このデータを残りのパイプライン、つまり

144
00:04:28,530 --> 00:04:29,860
文字分割と文字認識に流す。

145
00:04:30,680 --> 00:04:31,930
そして次に、以前と同様の

146
00:04:32,300 --> 00:04:33,310
評価指標を用いて、

147
00:04:34,000 --> 00:04:35,240
システム全体の正確さを

148
00:04:35,450 --> 00:04:36,900
計測する。

149
00:04:37,790 --> 00:04:39,890
そして完璧なテキスト検出を用いるのだから、たぶんパフォーマンスは向上する事が期待される。

150
00:04:40,330 --> 00:04:41,870
ここでは89%に

151
00:04:41,930 --> 00:04:44,550
向上したとしよう。

152
00:04:44,680 --> 00:04:45,830
そして次に、そのまま続けて、

153
00:04:46,090 --> 00:04:47,120
次のパイプラインのセクションに進み、

154
00:04:47,330 --> 00:04:50,230
文字分割に対して、またテストセットの画像におもむき、

155
00:04:50,540 --> 00:04:52,300
いまや正確なテキスト検出の出力が

156
00:04:52,390 --> 00:04:54,140
与えられている所に

157
00:04:54,900 --> 00:04:55,970
今度は正確な文字分割の出力を

158
00:04:56,490 --> 00:04:58,220
与える。つまり

159
00:04:59,400 --> 00:05:00,780
手動で正確な文字の分割のラベル付けを行い

160
00:05:01,330 --> 00:05:03,710
個々の文字に分割する。

161
00:05:04,730 --> 00:05:05,560
そしてそれがどれだけ改善するかを見てみるのだ。

162
00:05:05,810 --> 00:05:06,670
そして例えば、全体のシステムが90%の正確さに

163
00:05:06,800 --> 00:05:09,140
改善したとしよう。

164
00:05:10,070 --> 00:05:11,060
つまり正確さといったらいつでも

165
00:05:11,340 --> 00:05:13,420
システム全体の正確さだ。

166
00:05:14,120 --> 00:05:15,460
つまり文字認識システムの

167
00:05:15,830 --> 00:05:17,450
最終的なアウトプットが何かだ。

168
00:05:17,560 --> 00:05:18,870
つまりパイプライン全体の

169
00:05:19,040 --> 00:05:19,660
アウトプットが何かだ。

170
00:05:19,930 --> 00:05:22,400
それが正確さの指標となる。

171
00:05:22,520 --> 00:05:23,720
そして最後に、文字認識システムにも

172
00:05:24,170 --> 00:05:26,170
正しいラベルを与える。

173
00:05:26,780 --> 00:05:29,270
もしそれをやったら、当たり前だが、100%の正確さを得られる。

174
00:05:31,270 --> 00:05:32,530
今、この分析を行う

175
00:05:32,850 --> 00:05:34,340
良い点としては、

176
00:05:34,450 --> 00:05:36,080
我らはこれらの各コンポーネントを改善する時の

177
00:05:36,700 --> 00:05:40,250
ポテンシャルの上限が理解出来る、という事だ。

178
00:05:41,390 --> 00:05:44,180
つまりもし、我らが完璧なテキスト検出を得たら、

179
00:05:44,950 --> 00:05:46,360
我らのパフォーマンスは72%から89%へと

180
00:05:46,710 --> 00:05:48,080
上昇する事が分かる。

181
00:05:48,420 --> 00:05:50,670
つまり17%のパフォーマンス向上が得られる。

182
00:05:51,640 --> 00:05:52,680
つまり、あなたが現在のシステムに対して

183
00:05:52,890 --> 00:05:54,030
テキスト検出の改善に

184
00:05:54,160 --> 00:05:56,130
たくさんの時間を費やしたら、

185
00:05:57,330 --> 00:05:58,750
その場合は我らのシステムのパフォーマンスを

186
00:05:59,200 --> 00:06:00,640
17%向上出来る可能性がある、という事を意味している。

187
00:06:01,020 --> 00:06:02,850
これはやる価値がありそうに見える。

188
00:06:03,770 --> 00:06:05,840
一方、対照的に、

189
00:06:06,200 --> 00:06:08,360
テキスト検出から離れて、

190
00:06:08,640 --> 00:06:12,450
完璧な文字分割を与えても、パフォーマンスはたったの1%しか向上しない。

191
00:06:13,020 --> 00:06:14,820
これはより信頼出来るメッセージだ。

192
00:06:15,250 --> 00:06:16,880
これの意味する所は、

193
00:06:17,090 --> 00:06:18,510
どれだけ文字分割に時間を費やそうとも、

194
00:06:19,800 --> 00:06:20,990
潜在的な上限は、

195
00:06:21,080 --> 00:06:22,280
とても小さい、という事だ。

196
00:06:22,460 --> 00:06:23,420
だからきっと、あなたは

197
00:06:23,580 --> 00:06:24,340
大きなエンジニアのチームを

198
00:06:24,860 --> 00:06:26,860
この文字分割の仕事に従事させたい、とは思わないだろう。

199
00:06:26,990 --> 00:06:28,860
この種の分析は、

200
00:06:29,150 --> 00:06:30,180
仮に完璧な文字分割を

201
00:06:30,260 --> 00:06:32,480
与えられたとしても、

202
00:06:32,620 --> 00:06:34,180
パフォーマンスは1%しか向上しない、という事を示してくれる。

203
00:06:34,620 --> 00:06:36,090
つまり、これは本当に推計だ。

204
00:06:36,890 --> 00:06:38,080
何が天井（シーリング）なのか、

205
00:06:38,300 --> 00:06:39,360
何が上限なのか。これらのうちの一つのコンポーネントに対し

206
00:06:39,550 --> 00:06:40,690
作業を行った時に、

207
00:06:40,740 --> 00:06:42,710
どれだけシステムのパフォーマンスを改善出来るか？

208
00:06:44,330 --> 00:06:45,600
そして最後に、文字まで行って、

209
00:06:46,320 --> 00:06:47,700
より良い文字認識を得たら、

210
00:06:47,900 --> 00:06:50,080
パフォーマンスはさらに10%上がる。

211
00:06:50,530 --> 00:06:51,640
つまり、ここでも

212
00:06:51,750 --> 00:06:52,570
10%の改善に、

213
00:06:52,860 --> 00:06:55,630
どれだけ時間を使うか、を決める事が出来る。

214
00:06:55,830 --> 00:06:57,200
これはパイプラインの

215
00:06:57,400 --> 00:06:58,670
終着駅に、

216
00:06:58,730 --> 00:06:59,690
もっと労力を集中すべき、と言っているかもしれない。

217
00:07:00,360 --> 00:07:02,840
システム全体のパフォーマンスも

218
00:07:03,760 --> 00:07:04,500
改善出来る。

219
00:07:05,610 --> 00:07:06,580
これについての別の考え方としては、

220
00:07:06,870 --> 00:07:08,090
この種の分析を

221
00:07:08,290 --> 00:07:09,470
行っていく事で、

222
00:07:09,570 --> 00:07:10,640
これらの各コンポーネントを

223
00:07:10,740 --> 00:07:12,700
改善した時の

224
00:07:13,480 --> 00:07:14,980
上限のポテンシャルを調べている、と考えても良い。

225
00:07:15,080 --> 00:07:16,730
あるいは、これらのコンポーネントが一つ

226
00:07:17,260 --> 00:07:18,910
究極的に完璧になったら、どれだけの物が得られるか、を調べていると考えても良い。

227
00:07:19,380 --> 00:07:20,780
これでシステムのパフォーマンスの上限が

228
00:07:21,060 --> 00:07:23,230
設定出来る。

229
00:07:24,220 --> 00:07:26,290
シーリング分析のアイデアはとても重要だ。

230
00:07:26,900 --> 00:07:29,840
このアイデアを再び、もっと複雑な別の例で例示しよう。

231
00:07:31,860 --> 00:07:32,990
あなたは画像の顔認識を

232
00:07:33,260 --> 00:07:34,830
したいとしよう。

233
00:07:35,280 --> 00:07:35,960
つまり写真を見て、

234
00:07:35,990 --> 00:07:37,650
この写真の人が

235
00:07:37,820 --> 00:07:38,770
あなたの特定の友人かどうかを

236
00:07:39,470 --> 00:07:40,640
認識したい。

237
00:07:40,670 --> 00:07:43,880
この画像にいる人物を認識したいとする。

238
00:07:44,180 --> 00:07:46,260
これはちょっと人工的な例で、

239
00:07:47,130 --> 00:07:51,080
実際の現場で顔認識がどう行われているか、

240
00:07:51,320 --> 00:07:52,790
というのを正確に反映した物では無い。

241
00:07:52,800 --> 00:07:53,660
だがシーリング分析のプロセスがどんな感じになるか、という

242
00:07:53,870 --> 00:07:54,800
例をもう一つ挙げる為に

243
00:07:54,940 --> 00:07:56,220
このパイプラインがどうなっているのかを

244
00:07:56,450 --> 00:07:57,820
見ていきたい。

245
00:07:58,710 --> 00:07:59,980
さて、我らはカメラの

246
00:08:00,160 --> 00:08:03,830
画像を持っていて、以下のようなパイプラインをデザインするとしよう。

247
00:08:04,420 --> 00:08:05,120
最初にやるのは

248
00:08:05,380 --> 00:08:07,480
画像の前処理としよう。

249
00:08:07,560 --> 00:08:08,770
この右上に見せたような

250
00:08:08,910 --> 00:08:10,310
画像を取ってきて、

251
00:08:10,390 --> 00:08:11,040
そして背景を除去したい、と

252
00:08:11,140 --> 00:08:12,510
してみよう。

253
00:08:13,030 --> 00:08:14,790
つまり前処理を通す事で背景が消える。

254
00:08:16,070 --> 00:08:18,820
次に人の顔を認識したい、とする。

255
00:08:19,370 --> 00:08:20,550
これは通常学習アルゴリズムを用いて行われる。

256
00:08:20,930 --> 00:08:21,960
つまり我らはスライディングウィンドウの分類器を

257
00:08:22,180 --> 00:08:24,900
実行していって、人の顔の回りに箱を描く。

258
00:08:25,680 --> 00:08:26,720
一旦顔を認識出来たら

259
00:08:26,790 --> 00:08:27,650
人を識別する為には、

260
00:08:27,770 --> 00:08:29,320
目というのはとても有力な

261
00:08:29,530 --> 00:08:31,630
手がかりだと分かってる。

262
00:08:32,000 --> 00:08:33,860
我らは実際の所、

263
00:08:34,130 --> 00:08:35,420
友人を認識する時に、

264
00:08:35,700 --> 00:08:36,870
目がどんな見た目かというのは、

265
00:08:37,330 --> 00:08:38,680
実際にもっとも重視している手がかりだ。

266
00:08:39,470 --> 00:08:41,610
だから人間の目を検出する為の別の分類器を走らせよう。

267
00:08:42,500 --> 00:08:43,660
目の部分を切りだして、

268
00:08:44,410 --> 00:08:45,650
というのは人物を

269
00:08:45,900 --> 00:08:47,290
認識するのに

270
00:08:47,380 --> 00:08:48,840
これは有用なフィーチャー（特徴）だからだが、

271
00:08:49,100 --> 00:08:50,400
そして次に、顔の他の部分で使えそうな所、

272
00:08:50,990 --> 00:08:52,330
例えば鼻を切り出す。

273
00:08:52,830 --> 00:08:54,750
そして口を切り出す。

274
00:08:54,980 --> 00:08:56,230
そして次に、目、鼻、口を

275
00:08:56,370 --> 00:08:57,060
見つけた後に、

276
00:08:57,340 --> 00:08:58,420
これら全てが恐らく、

277
00:08:58,740 --> 00:08:59,920
ロジスティック回帰などの分類器に食わせるのに

278
00:09:00,580 --> 00:09:01,540
有用なフィーチャーとなる。

279
00:09:02,500 --> 00:09:03,200
そしてこの分類器の仕事は、

280
00:09:03,480 --> 00:09:04,420
我らに全体として、

281
00:09:04,710 --> 00:09:05,850
この人物が

282
00:09:05,970 --> 00:09:06,930
誰だと思っているかの

283
00:09:07,190 --> 00:09:08,450
ラベルを与える。

284
00:09:10,110 --> 00:09:11,730
これは複雑なパイプラインだ。

285
00:09:12,160 --> 00:09:13,300
これは実際に使うべきパイプラインよりも

286
00:09:13,950 --> 00:09:16,810
もっと複雑な物だろう。もし実際に人を認識したいなら。

287
00:09:17,620 --> 00:09:20,330
だがシーリング分析を考えてみる上では示唆に富む例だ。

288
00:09:22,150 --> 00:09:24,510
ではどうやってこのパイプラインのシーリング分析を行えば良いだろう？

289
00:09:25,000 --> 00:09:26,790
これらのピースを一度に一つづつ見ていこう。

290
00:09:27,470 --> 00:09:28,900
あなたのシステムが全体として

291
00:09:29,150 --> 00:09:30,560
85％の正確さを持つとしよう。

292
00:09:30,720 --> 00:09:31,670
最初にやる事は、

293
00:09:31,750 --> 00:09:32,890
テストセットにおもむき、そして手動で

294
00:09:33,860 --> 00:09:36,200
前景と背景の分割を行う、という事。

295
00:09:36,740 --> 00:09:38,090
つまりテストセットにおもむき

296
00:09:38,150 --> 00:09:39,670
Photoshopなりなんなりを用いて

297
00:09:40,290 --> 00:09:41,750
どれが背景かを

298
00:09:41,950 --> 00:09:43,130
伝えて、そして手動で

299
00:09:43,360 --> 00:09:45,230
背景を除去する。

300
00:09:45,470 --> 00:09:48,050
つまり完全に正しい背景で、どれだけ正確さが向上するかを見る。

301
00:09:48,990 --> 00:09:50,320
この例では、正確さは

302
00:09:50,800 --> 00:09:53,700
0.1%向上した。

303
00:09:53,860 --> 00:09:54,900
つまりこれは、強烈なサインとなる。

304
00:09:55,100 --> 00:09:56,240
たとえ完璧な背景分離が、

305
00:09:56,630 --> 00:09:59,680
本当に完璧な

306
00:09:59,840 --> 00:10:01,650
背景除去であったとしても、

307
00:10:01,730 --> 00:10:03,740
あなたのシステムのパフォーマンスは大して向上しない。

308
00:10:03,880 --> 00:10:05,000
これはつまり、前処理の背景除去には

309
00:10:05,190 --> 00:10:07,720
これ以上莫大な労力を投入する価値は無い、という事だろう。

310
00:10:09,270 --> 00:10:10,170
次に、またテストセットにおもむき、

311
00:10:10,230 --> 00:10:11,290
正確な顔検出の

312
00:10:11,780 --> 00:10:13,650
領域を与えて、また次に

313
00:10:14,140 --> 00:10:16,690
目、鼻、口の分割と順番に見ていく。

314
00:10:17,100 --> 00:10:17,470
順番を一つ選ぶ。

315
00:10:17,700 --> 00:10:18,890
目の正確な位置を与えて、

316
00:10:19,340 --> 00:10:20,520
鼻の正確な位置を与えて、

317
00:10:20,750 --> 00:10:22,510
口の正確な位置を与えて、

318
00:10:22,520 --> 00:10:23,740
そして最後に全体として

319
00:10:24,130 --> 00:10:26,200
正解のラベルを与えると、100%正確となる。

320
00:10:27,900 --> 00:10:29,390
つまり、

321
00:10:29,500 --> 00:10:30,430
システムを順番に見ていって

322
00:10:31,040 --> 00:10:32,080
どんどん各コンポーネントに

323
00:10:32,210 --> 00:10:33,900
テストセットの正解のラベルを

324
00:10:34,370 --> 00:10:35,350
与えていくと、パフォーマンス、、、

325
00:10:35,830 --> 00:10:37,550
つまりシステム全体のパフォーマンスは向上する。

326
00:10:37,730 --> 00:10:38,640
そして各別々のステップで

327
00:10:38,890 --> 00:10:39,860
どれだけパフォーマンスが向上するかを

328
00:10:40,240 --> 00:10:41,660
見ていく事が出来る。

329
00:10:42,550 --> 00:10:43,830
完璧な顔検出が提供されると、

330
00:10:44,440 --> 00:10:45,270
システム全体のパフォーマンスは

331
00:10:45,570 --> 00:10:48,290
5.9%向上する。

332
00:10:49,710 --> 00:10:50,670
これはかなり大きなジャンプだ。

333
00:10:50,980 --> 00:10:52,100
つまり、顔検出を改善するのに、

334
00:10:52,370 --> 00:10:53,660
かなりの労力を費やす価値がありそうだ。

335
00:10:54,670 --> 00:10:56,290
ここでは4%、

336
00:10:56,710 --> 00:10:58,680
ここでは1%、

337
00:10:59,160 --> 00:11:00,600
ここでは1%、ここでは3%。

338
00:11:01,520 --> 00:11:02,840
つまり、どうやら

339
00:11:02,980 --> 00:11:04,250
最も我らが頑張るに値する

340
00:11:04,730 --> 00:11:06,520
コンポーネントは、

341
00:11:06,680 --> 00:11:08,540
完璧な顔検出を提供出来たら

342
00:11:09,680 --> 00:11:10,190
システムは5.9%向上し、

343
00:11:10,490 --> 00:11:11,990
完璧な目の分割を行えたら

344
00:11:12,170 --> 00:11:14,170
4%向上する。

345
00:11:14,380 --> 00:11:15,540
そして最後のロジスティック分類器は、

346
00:11:16,000 --> 00:11:19,220
またさらに3%のギャップがある。

347
00:11:19,570 --> 00:11:20,580
つまりこうして、我らが取り組む価値が

348
00:11:20,810 --> 00:11:23,400
もっともありそうなコンポーネントを教えてくれる。

349
00:11:24,610 --> 00:11:25,690
ところで、

350
00:11:25,830 --> 00:11:28,110
これは本当にあった話なのだが、

351
00:11:28,680 --> 00:11:29,620
このプリプロセスの背景除去を

352
00:11:29,850 --> 00:11:32,350
ここに含めた理由は、

353
00:11:32,600 --> 00:11:34,050
現実にこんな話があったのを

354
00:11:34,340 --> 00:11:35,530
知っているからだ。それは、

355
00:11:35,770 --> 00:11:37,140
あるリサーチチームが実際に

356
00:11:37,480 --> 00:11:38,990
文字通り二人を1.5年間

357
00:11:39,580 --> 00:11:40,250
つまり18ヶ月

358
00:11:40,530 --> 00:11:42,410
費やして、背景除去を

359
00:11:42,770 --> 00:11:44,050
改善する仕事をさせた。

360
00:11:44,480 --> 00:11:45,680
実際の詳細は、、、

361
00:11:46,120 --> 00:11:47,490
詳細は曖昧にさせてくれ。分かるだろ？

362
00:11:47,970 --> 00:11:48,770
だがとにかく、コンピュータビジョンの

363
00:11:48,820 --> 00:11:50,610
アプリケーションがあってさ。

364
00:11:50,720 --> 00:11:51,660
二人のエンジニアのチームが

365
00:11:51,770 --> 00:11:52,850
文字通り1.5年間、

366
00:11:52,990 --> 00:11:54,210
背景除去の仕事に

367
00:11:54,550 --> 00:11:56,050
従事したのだ。

368
00:11:56,550 --> 00:11:57,720
実際に彼らはとても複雑なアルゴリズムを用いて

369
00:11:57,820 --> 00:12:00,270
最終的には1本の研究論文まで出した。

370
00:12:01,080 --> 00:12:02,000
だがそれらの仕事を終えた後になって

371
00:12:02,110 --> 00:12:03,020
彼らは気づいたのだ。

372
00:12:03,260 --> 00:12:04,910
彼らの実際のアプリケーションに関しては、

373
00:12:05,200 --> 00:12:06,490
その違いは全体のパフォーマンスについては

374
00:12:06,710 --> 00:12:09,120
大した違いを生まない、という事を。

375
00:12:09,450 --> 00:12:10,770
そしてお分かりの通り、

376
00:12:10,770 --> 00:12:13,170
もし誰かが、もし仮にシーリング分析を前もって行っていたら、

377
00:12:13,700 --> 00:12:15,790
この事が分かったと思われる。

378
00:12:17,240 --> 00:12:18,360
そして彼らの一人が後になって

379
00:12:18,480 --> 00:12:19,510
こう言った。

380
00:12:19,640 --> 00:12:20,580
もしこの種の分析をやっていたら、

381
00:12:20,850 --> 00:12:21,710
たぶん彼らは

382
00:12:21,990 --> 00:12:23,190
18ヶ月の仕事をする前に、

383
00:12:23,440 --> 00:12:25,180
彼らが文字通り18ヶ月の仕事を

384
00:12:25,240 --> 00:12:26,300
背景除去に従事する前に

385
00:12:26,680 --> 00:12:28,920
彼らの労力を別のコンポーネントに

386
00:12:29,380 --> 00:12:31,230
注ぐべきだと気づけたんじゃないかな。

387
00:12:33,910 --> 00:12:36,140
まとめよう。パイプラインは

388
00:12:36,390 --> 00:12:38,630
複雑な機械学習のアプリケーションにおいては広く使われている物だ。

389
00:12:39,890 --> 00:12:40,950
そして大きな機械学習のアプリケーションに

390
00:12:41,200 --> 00:12:42,780
従事している時は、

391
00:12:42,830 --> 00:12:45,450
あなたのデベロッパーとしての時間はあまりにも貴重だ。

392
00:12:46,090 --> 00:12:47,360
だからあなたは、あまり重要では無い事に

393
00:12:47,460 --> 00:12:50,120
多くの時間を費やしてはならない。

394
00:12:51,350 --> 00:12:52,370
そしてこのビデオで、我らは

395
00:12:52,490 --> 00:12:53,570
シーリング分析のアイデアを議論してきた。

396
00:12:54,340 --> 00:12:55,750
この手法は作業すべきコンポーネントを

397
00:12:55,850 --> 00:12:57,000
見つけ出すのに、

398
00:12:57,130 --> 00:12:58,660
とても便利なツールだと、しばしば思う物だ。

399
00:12:58,760 --> 00:12:59,830
そしてあなたがそのコンポーネントに

400
00:13:00,050 --> 00:13:01,010
労力を集中して、大きく改善出来たら、

401
00:13:01,250 --> 00:13:02,420
最終的なシステム全体にも

402
00:13:03,050 --> 00:13:04,360
巨大な影響を

403
00:13:04,620 --> 00:13:06,040
与えるだろう。

404
00:13:07,070 --> 00:13:08,010
何年も機械学習の

405
00:13:08,340 --> 00:13:09,520
仕事をしてきて、私は本当に

406
00:13:09,710 --> 00:13:10,900
どのコンポーネントに取り組むべきかの

407
00:13:11,100 --> 00:13:13,200
自分自身の直感を、あまり信じてはいけない、という事を学んできた。

408
00:13:13,280 --> 00:13:14,310
つまり、ほんとうに良く、長い期間

409
00:13:14,540 --> 00:13:15,440
機械学習の仕事をしていると、

410
00:13:15,570 --> 00:13:17,160
機械学習の問題を

411
00:13:17,360 --> 00:13:18,770
見た時に、

412
00:13:18,950 --> 00:13:20,130
直感がこう言う事がある：

413
00:13:20,450 --> 00:13:22,970
このコンポーネントにもっと時間を注ぎ込んだらいいんじゃないか、と。

414
00:13:24,120 --> 00:13:25,050
だが何年もかかって、

415
00:13:25,160 --> 00:13:26,600
自分自身の直感すら

416
00:13:26,740 --> 00:13:27,800
信じてはいけない、むしろ自分の直感を

417
00:13:28,130 --> 00:13:29,310
それほどは信じない、という事を学習した。

418
00:13:29,980 --> 00:13:31,450
そのかわりに、何らかの機械学習の問題に

419
00:13:31,520 --> 00:13:33,060
取り組む時には、

420
00:13:33,180 --> 00:13:34,750
なるべくもっと系統だった、

421
00:13:34,960 --> 00:13:36,340
事をする。シーリング分析などは

422
00:13:36,660 --> 00:13:37,720
しばしば、どこに労力を集中すべきかを決める

423
00:13:37,910 --> 00:13:39,110
もっと良い、そしてもっと信頼出来る

424
00:13:39,670 --> 00:13:40,900
方法だ。それによって

425
00:13:40,940 --> 00:13:42,270
どこのコンポーネントのパフォーマンスを

426
00:13:42,690 --> 00:13:44,570
実際に改善すべきかが分かる。

427
00:13:44,680 --> 00:13:45,900
そして実際にそれを行えば、

428
00:13:46,180 --> 00:13:46,960
全体的なシステムの最終的なパフォーマンスが

429
00:13:47,200 --> 00:13:49,460
実際に大きく改善する事を確認出来るだろう。