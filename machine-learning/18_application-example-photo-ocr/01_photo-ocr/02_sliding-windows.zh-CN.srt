1
00:00:00,370 --> 00:00:01,590
在上一段视频中

2
00:00:01,890 --> 00:00:04,570
我们谈到了照片 OCR 流水线 以及其工作原理

3
00:00:05,480 --> 00:00:06,370
我们讲到可以照一张照片

4
00:00:07,050 --> 00:00:08,070
然后将其通过

5
00:00:08,130 --> 00:00:10,010
一系列机器学习组件

6
00:00:10,280 --> 00:00:11,680
来尝试读出

7
00:00:11,890 --> 00:00:13,820
图片中的文字信息

8
00:00:14,590 --> 00:00:15,820
在这段视频中

9
00:00:16,210 --> 00:00:17,360
我想再多介绍一些

10
00:00:17,780 --> 00:00:20,310
照片OCR流水线中的组件是如何工作的

11
00:00:21,270 --> 00:00:24,070
具体来说 这段视频的大部分内容

12
00:00:24,680 --> 00:00:25,950
将关注一种叫

13
00:00:26,750 --> 00:00:31,570
滑动窗(sliding windows)的分类器

14
00:00:32,000 --> 00:00:33,390
滑动窗的第一个步骤

15
00:00:33,730 --> 00:00:35,090
是文字检测(text detection)

16
00:00:35,330 --> 00:00:36,640
我们有这样一幅照片

17
00:00:37,020 --> 00:00:39,320
并且想要找出图片中出现文字的区域

18
00:00:39,850 --> 00:00:42,490
文字识别是计算机视觉中的一个非同寻常的问题

19
00:00:43,220 --> 00:00:44,820
因为取决于你

20
00:00:45,140 --> 00:00:46,150
想要找到的文字的长度

21
00:00:46,290 --> 00:00:47,870
这些长方形区域

22
00:00:47,970 --> 00:00:49,600
会呈现不同的宽高比

23
00:00:51,100 --> 00:00:52,060
为了更好地介绍

24
00:00:52,220 --> 00:00:53,550
图像的检测

25
00:00:54,300 --> 00:00:55,860
我们从一个简单一点的例子开始

26
00:00:56,550 --> 00:01:00,080
我们先看这个探测行人的例子

27
00:01:00,460 --> 00:01:02,300
等下再把我们从行人检测中

28
00:01:02,570 --> 00:01:04,840
得出的想法 应用到文字检测中

29
00:01:06,280 --> 00:01:08,010
在行人检测中

30
00:01:08,360 --> 00:01:09,440
你希望照一张相片

31
00:01:09,600 --> 00:01:11,010
然后找出图像中

32
00:01:11,160 --> 00:01:12,920
出现的行人

33
00:01:13,260 --> 00:01:14,440
所以这就是一个行人

34
00:01:14,520 --> 00:01:15,550
这是第二个

35
00:01:15,780 --> 00:01:17,920
这是第三、第四、第五个

36
00:01:18,290 --> 00:01:19,390
以及第六个

37
00:01:19,560 --> 00:01:20,990
这个问题似乎

38
00:01:21,320 --> 00:01:22,770
比文字检测的问题更简单

39
00:01:23,100 --> 00:01:24,200
原因是 大部分的

40
00:01:24,560 --> 00:01:27,490
行人都比较相似

41
00:01:28,170 --> 00:01:29,280
因此可以使用一个固定宽高比的

42
00:01:29,630 --> 00:01:31,960
矩形来分离出你希望找到的行人

43
00:01:32,420 --> 00:01:33,610
我说的宽高比

44
00:01:33,920 --> 00:01:36,420
就是指的这些矩形的高度和宽度的比值

45
00:01:37,820 --> 00:01:38,190
在行人的问题中

46
00:01:38,650 --> 00:01:40,120
不同矩形的宽高比都是一样的

47
00:01:40,490 --> 00:01:42,650
但对文字检测的问题

48
00:01:43,030 --> 00:01:44,560
高度和宽度的比值

49
00:01:44,960 --> 00:01:45,830
对不同行的文字就是不同的了

50
00:01:46,460 --> 00:01:47,940
虽然在行人检测的问题中

51
00:01:48,020 --> 00:01:49,250
行人可能会与相机

52
00:01:49,810 --> 00:01:51,250
处于不同的距离位置

53
00:01:51,390 --> 00:01:52,730
因此这些矩形的高度

54
00:01:53,380 --> 00:01:55,600
也取决于他们离相机的距离远近

55
00:01:55,990 --> 00:01:57,090
但这个比值应该是一样的

56
00:01:57,720 --> 00:01:58,880
为了建立一个行人检测系统

57
00:01:59,440 --> 00:02:02,460
以下是具体步骤

58
00:02:02,520 --> 00:02:03,650
假如说我们把

59
00:02:03,970 --> 00:02:06,100
宽高比标准化到

60
00:02:06,690 --> 00:02:08,010
82比36这样一个比例

61
00:02:08,180 --> 00:02:10,040
我们可以把这个比值

62
00:02:10,330 --> 00:02:11,510
进行圆整 比如化为

63
00:02:12,020 --> 00:02:14,000
80比40之类的 但82比36也可以

64
00:02:16,110 --> 00:02:17,280
接下来我们要做的

65
00:02:17,650 --> 00:02:20,420
就是到街上去收集一大堆正负训练样本

66
00:02:21,240 --> 00:02:22,790
这些是82×36大小的

67
00:02:22,900 --> 00:02:24,230
有行人的

68
00:02:24,360 --> 00:02:26,230
图像样本

69
00:02:26,550 --> 00:02:28,360
而这些样本里没有行人

70
00:02:29,470 --> 00:02:30,710
在这里我展示

71
00:02:31,050 --> 00:02:33,170
12个正样本 也就是 y=1

72
00:02:33,730 --> 00:02:34,990
以及12个负样本 y=0

73
00:02:36,410 --> 00:02:37,790
在更典型的行人识别

74
00:02:38,180 --> 00:02:39,200
应用中 我们

75
00:02:39,500 --> 00:02:40,880
可以有1000个训练样本

76
00:02:41,230 --> 00:02:42,210
到10000个训练样本

77
00:02:42,300 --> 00:02:44,410
不等 甚至更多

78
00:02:44,460 --> 00:02:45,360
如果你能得到

79
00:02:45,510 --> 00:02:47,180
大规模训练样本的话

80
00:02:47,460 --> 00:02:48,590
然后你要做的事

81
00:02:48,910 --> 00:02:50,160
是训练一个神经网络

82
00:02:50,510 --> 00:02:52,420
或者别的什么学习算法

83
00:02:52,610 --> 00:02:54,570
输入这些图片

84
00:02:54,970 --> 00:02:56,710
82×36维的图像块

85
00:02:56,850 --> 00:02:59,180
然后对 y 进行分类

86
00:02:59,710 --> 00:03:01,070
把图像块分成"有行人"

87
00:03:01,510 --> 00:03:03,850
和"没有行人"两类

88
00:03:05,250 --> 00:03:06,250
因此这一步

89
00:03:06,470 --> 00:03:08,050
实际上是一个监督学习

90
00:03:08,210 --> 00:03:09,290
你通过一个图像块

91
00:03:09,530 --> 00:03:12,420
然后决定这个图像块里有没有行人

92
00:03:14,310 --> 00:03:15,190
现在假如我们获得

93
00:03:15,400 --> 00:03:16,520
一张新的图像

94
00:03:16,850 --> 00:03:17,920
一个测试集图片 像这张图

95
00:03:18,030 --> 00:03:20,240
我们想来试试看在这张图片中找行人

96
00:03:21,520 --> 00:03:22,340
我们要做的是

97
00:03:22,670 --> 00:03:25,140
首先对这个图像取一小块长方形

98
00:03:25,580 --> 00:03:26,800
就像这里所示的

99
00:03:26,900 --> 00:03:27,930
比如这是一个

100
00:03:28,010 --> 00:03:29,440
82×36的图像块

101
00:03:30,270 --> 00:03:31,530
我们将这个图像块

102
00:03:31,830 --> 00:03:33,660
通过我们训练得到的分类器

103
00:03:33,840 --> 00:03:34,900
来确定

104
00:03:34,980 --> 00:03:36,310
这个图像块中是不是有行人

105
00:03:36,620 --> 00:03:38,100
如果没问题的话 我们的分类器

106
00:03:38,260 --> 00:03:40,600
应该报告这个图像块 y=0 因为没有行人

107
00:03:42,020 --> 00:03:42,900
接下来 我们把这个

108
00:03:43,140 --> 00:03:44,380
绿色的长方形图片

109
00:03:44,490 --> 00:03:45,680
滑动一点点

110
00:03:45,940 --> 00:03:47,180
然后得到一个新的图像块

111
00:03:47,560 --> 00:03:49,700
并同样把它传入我们的分类器 看看这里面有没有行人

112
00:03:50,760 --> 00:03:51,740
做完这以后

113
00:03:51,920 --> 00:03:53,070
 我们再向右滑动一点窗口

114
00:03:53,160 --> 00:03:54,160
然后同样地

115
00:03:54,420 --> 00:03:56,690
把图像块传入分类器

116
00:03:56,970 --> 00:03:57,850
你每次滑动窗口的

117
00:03:58,280 --> 00:03:59,770
大小是一个参数

118
00:04:00,260 --> 00:04:01,720
通常被称为

119
00:04:02,190 --> 00:04:04,000
步长(step size)

120
00:04:04,070 --> 00:04:06,020
有时也称为

121
00:04:06,380 --> 00:04:08,970
步幅参数(stride parameter)

122
00:04:09,120 --> 00:04:11,050
你每次移动一个像素

123
00:04:11,210 --> 00:04:12,020
就是说你是用的步长

124
00:04:12,360 --> 00:04:14,020
或者说步幅是1

125
00:04:14,340 --> 00:04:15,560
这样通常表现得最好

126
00:04:15,700 --> 00:04:16,960
但可能计算量比较大

127
00:04:17,430 --> 00:04:18,940
因此通常使用4个像素

128
00:04:19,090 --> 00:04:20,010
作为步长值

129
00:04:20,210 --> 00:04:20,970
或者每次8个像素

130
00:04:21,250 --> 00:04:22,350
或者每步选择更大的像素

131
00:04:22,550 --> 00:04:23,600
都是比较常见的

132
00:04:24,010 --> 00:04:25,320
因为这样你每次

133
00:04:25,430 --> 00:04:26,570
都把矩形窗

134
00:04:26,700 --> 00:04:28,570
多移动一点点

135
00:04:28,870 --> 00:04:30,090
所以通过这个过程

136
00:04:30,870 --> 00:04:32,310
你一点点连续向右移动

137
00:04:32,340 --> 00:04:33,160
这个小的矩形窗

138
00:04:33,370 --> 00:04:34,450
并且每次都将图像块

139
00:04:34,520 --> 00:04:35,780
通过你的分类器

140
00:04:36,620 --> 00:04:38,220
直到最后你滑动小窗

141
00:04:38,900 --> 00:04:42,080
遍历图片中的不同位置

142
00:04:42,150 --> 00:04:43,340
从一开始

143
00:04:43,550 --> 00:04:44,680
在第一行滑动

144
00:04:44,850 --> 00:04:46,080
然后到图片中的

145
00:04:46,160 --> 00:04:47,580
下面几行

146
00:04:47,710 --> 00:04:49,100
你会逐渐地

147
00:04:49,290 --> 00:04:50,490
以某个步长或步幅

148
00:04:50,550 --> 00:04:52,070
把这些图像块

149
00:04:52,240 --> 00:04:53,330
全部放入你的分类器

150
00:04:53,430 --> 00:04:54,990
并运行

151
00:04:56,990 --> 00:04:57,870
但这个矩形

152
00:04:57,970 --> 00:04:59,870
是非常小的

153
00:05:00,310 --> 00:05:02,310
只能探测到某种尺寸的行人

154
00:05:02,780 --> 00:05:04,210
接下来我们要做的

155
00:05:04,470 --> 00:05:05,990
是看看更大的图像块

156
00:05:06,730 --> 00:05:08,270
因此我们用更大一些的图像块

157
00:05:08,610 --> 00:05:09,700
像这里所示的

158
00:05:10,310 --> 00:05:11,960
同样地 传入分类器运行

159
00:05:13,540 --> 00:05:14,320
顺便说一下

160
00:05:14,600 --> 00:05:15,830
我说"用更大一些的图像块"

161
00:05:16,080 --> 00:05:17,780
我的意思是

162
00:05:17,860 --> 00:05:18,850
当你用这样的图像块时

163
00:05:19,490 --> 00:05:20,720
你先取出这个图像块

164
00:05:20,880 --> 00:05:22,110
然后把这张图像块

165
00:05:22,800 --> 00:05:24,750
重新压缩到82×36的尺寸

166
00:05:25,000 --> 00:05:26,260
就是取一个大一点的图

167
00:05:26,550 --> 00:05:28,180
然后重新把大小

168
00:05:28,300 --> 00:05:29,800
调整到小的尺寸

169
00:05:29,970 --> 00:05:31,260
或者说调整到

170
00:05:31,600 --> 00:05:32,620
可以传入确定图片中是否有行人的

171
00:05:32,990 --> 00:05:35,340
分类器应该使用的尺寸

172
00:05:37,230 --> 00:05:38,310
最后 你可以

173
00:05:38,470 --> 00:05:39,530
做一个更大的矩形

174
00:05:39,930 --> 00:05:41,870
同样滑动窗口

175
00:05:42,080 --> 00:05:43,830
到最后

176
00:05:43,980 --> 00:05:45,920
完成整个过程以后

177
00:05:45,980 --> 00:05:47,480
你的算法应该就能

178
00:05:48,040 --> 00:05:49,670
检测出图像中

179
00:05:50,140 --> 00:05:52,070
是否出现行人了

180
00:05:52,470 --> 00:05:53,850
因此整个步骤就是

181
00:05:54,290 --> 00:05:55,630
你先训练一个分类器

182
00:05:55,890 --> 00:05:57,360
然后用一个滑动窗分类器

183
00:05:57,920 --> 00:05:59,820
或者叫滑动窗检测器

184
00:05:59,970 --> 00:06:01,740
来找出图像中出现的行人

185
00:06:03,070 --> 00:06:04,050
接下来我们转向

186
00:06:04,150 --> 00:06:05,910
文字识别的例子

187
00:06:06,100 --> 00:06:07,490
让我们来看看

188
00:06:07,790 --> 00:06:09,330
对于照片 OCR 流水线中

189
00:06:09,570 --> 00:06:11,340
要检测出文字 需要怎样的步骤

190
00:06:13,250 --> 00:06:15,010
跟行人检测类似

191
00:06:15,250 --> 00:06:16,730
你也可以先收集一些

192
00:06:17,030 --> 00:06:18,410
带标签的训练集

193
00:06:19,060 --> 00:06:20,930
包括正样本和负样本

194
00:06:21,530 --> 00:06:23,810
分别对应文字出现的区域

195
00:06:24,300 --> 00:06:27,290
只是跟刚才不同的是 现在我们要检测文字 而不是行人

196
00:06:28,130 --> 00:06:29,670
因此正样本就表示

197
00:06:29,770 --> 00:06:31,640
图像中有文字的那些图片

198
00:06:31,970 --> 00:06:33,330
而负样本表示

199
00:06:33,380 --> 00:06:36,000
没有文字图像的图片

200
00:06:36,330 --> 00:06:37,530
训练完了以后

201
00:06:38,030 --> 00:06:39,450
我们就可以把它

202
00:06:39,870 --> 00:06:41,190
应用到新的图像中

203
00:06:42,460 --> 00:06:42,910
或者说 测试集图片中

204
00:06:43,310 --> 00:06:44,900
我们以这幅图片为例

205
00:06:46,040 --> 00:06:47,300
我们假设

206
00:06:47,440 --> 00:06:48,400
对于这个例子

207
00:06:48,560 --> 00:06:50,300
为了表达方便

208
00:06:50,640 --> 00:06:52,030
我们用一个固定的比例

209
00:06:52,370 --> 00:06:54,360
来运行滑动窗

210
00:06:54,450 --> 00:06:56,000
也就是说 我只用一种矩形尺寸

211
00:06:56,790 --> 00:06:58,110
假如说我用

212
00:06:58,350 --> 00:07:00,070
许多很小的矩形图片

213
00:07:00,170 --> 00:07:01,570
来运行矩形窗算法

214
00:07:01,630 --> 00:07:04,340
就像这样

215
00:07:04,430 --> 00:07:05,430
如果我这样做的话

216
00:07:05,530 --> 00:07:06,670
最终得到的结果

217
00:07:07,040 --> 00:07:08,530
是这样的

218
00:07:08,900 --> 00:07:10,700
白色的区域表示

219
00:07:10,940 --> 00:07:12,190
我的文字检测系统已经发现了文字

220
00:07:12,210 --> 00:07:15,960
所以这两幅图的坐标是对应的

221
00:07:16,390 --> 00:07:17,700
这张图的这个区域

222
00:07:18,110 --> 00:07:19,200
就对应这幅图的这个位置

223
00:07:19,230 --> 00:07:20,710
因此这一块是黑色的

224
00:07:20,840 --> 00:07:22,040
就表示在原图中

225
00:07:22,850 --> 00:07:24,390
分类器在这一个区域

226
00:07:24,840 --> 00:07:25,940
没有找到任何文字

227
00:07:26,170 --> 00:07:28,100
而相对地

228
00:07:28,170 --> 00:07:29,630
在这里出现了很多

229
00:07:29,810 --> 00:07:31,300
白色的区域

230
00:07:31,540 --> 00:07:33,260
这就表示分类器在原图中的

231
00:07:33,520 --> 00:07:34,310
这一块发现了文字

232
00:07:35,040 --> 00:07:35,700
这里我所做的

233
00:07:35,780 --> 00:07:36,870
左下角的这幅图

234
00:07:37,070 --> 00:07:38,820
实际上是用白色的区域

235
00:07:38,970 --> 00:07:41,050
来表示分类器在原图这一块区域发现了文字

236
00:07:41,810 --> 00:07:43,280
并且不同的灰度

237
00:07:43,880 --> 00:07:45,560
就表示分类器给出的

238
00:07:45,670 --> 00:07:46,750
输出结果的概率值

239
00:07:47,110 --> 00:07:48,000
所以比如有些灰色的阴影

240
00:07:48,520 --> 00:07:49,860
这就表示分类器

241
00:07:49,930 --> 00:07:50,750
似乎发现了文字

242
00:07:51,210 --> 00:07:53,900
但并不十分确信

243
00:07:54,260 --> 00:07:55,980
而比较白亮的区域

244
00:07:57,440 --> 00:07:58,400
则表示分类器

245
00:07:58,660 --> 00:08:00,470
预测这个区域有文字

246
00:08:00,630 --> 00:08:03,110
有比较大的概率

247
00:08:04,110 --> 00:08:05,270
现在我们还没完成文字检测呢

248
00:08:05,690 --> 00:08:06,580
因为我们实际上想做的

249
00:08:06,830 --> 00:08:08,620
是在图像中

250
00:08:08,850 --> 00:08:09,780
有文字的各区域

251
00:08:10,490 --> 00:08:12,540
都画上矩形窗

252
00:08:12,650 --> 00:08:13,540
所以我们还需要完成一步

253
00:08:13,840 --> 00:08:14,990
我们取出分类器的输出

254
00:08:15,230 --> 00:08:16,880
然后输入到一个

255
00:08:17,290 --> 00:08:19,280
被称为"展开器"(expansion operator)的东西

256
00:08:20,750 --> 00:08:22,250
展开器的作用就是

257
00:08:22,430 --> 00:08:24,270
它会取过这张图片

258
00:08:25,450 --> 00:08:26,700
对每一个白色的小点

259
00:08:26,800 --> 00:08:28,200
都扩展为一块

260
00:08:28,270 --> 00:08:30,590
白色的区域

261
00:08:31,460 --> 00:08:32,460
从数学上说

262
00:08:32,610 --> 00:08:34,110
这一步实现就是

263
00:08:34,270 --> 00:08:35,280
看右边这幅图

264
00:08:35,690 --> 00:08:36,780
我们得到右边这幅图的做法就是

265
00:08:36,930 --> 00:08:38,110
对于每一个像素

266
00:08:38,370 --> 00:08:39,510
我们都考察一下

267
00:08:39,610 --> 00:08:40,790
它是不是在左边

268
00:08:41,370 --> 00:08:42,960
这幅图中的某个

269
00:08:43,100 --> 00:08:44,650
白色像素的范围之内

270
00:08:45,430 --> 00:08:46,800
所以比如说

271
00:08:47,220 --> 00:08:48,420
如果某一个像素点

272
00:08:48,950 --> 00:08:50,280
在最左边那幅图中

273
00:08:50,610 --> 00:08:52,310
白色像素点的五或十个像素范围中

274
00:08:52,540 --> 00:08:55,020
那么我们将把右边那幅图的相同像素设为白色

275
00:08:56,190 --> 00:08:57,010
因此 这样做的效果就是

276
00:08:57,300 --> 00:08:58,350
我们把左边图中的

277
00:08:58,730 --> 00:08:59,630
所有的白色小点

278
00:09:00,030 --> 00:09:01,370
都扩展了一下

279
00:09:01,500 --> 00:09:02,200
让它们都变大了一些

280
00:09:02,670 --> 00:09:04,110
根据它们周围临近像素是不是白色的

281
00:09:04,170 --> 00:09:05,420
如果是的话

282
00:09:05,900 --> 00:09:07,980
我们把它们也变成了白色

283
00:09:08,430 --> 00:09:09,900
这样我们就快完成了

284
00:09:10,180 --> 00:09:11,210
我们现在可以根据

285
00:09:11,480 --> 00:09:12,900
右边的这张图

286
00:09:13,210 --> 00:09:14,650
锁定那些连接部分

287
00:09:15,320 --> 00:09:16,700
也就是这些连续的白色区域

288
00:09:16,990 --> 00:09:19,350
然后围绕着它们画个框就行了

289
00:09:20,260 --> 00:09:20,990
具体来讲

290
00:09:21,390 --> 00:09:22,850
如果我们分析这些白色区域

291
00:09:23,080 --> 00:09:24,750
比如说这个 这个

292
00:09:24,990 --> 00:09:26,670
这个 等等

293
00:09:27,030 --> 00:09:27,810
我们可以简单地

294
00:09:28,390 --> 00:09:30,240
凭直觉来判断

295
00:09:30,660 --> 00:09:32,760
哪些区域是比较奇怪的

296
00:09:32,870 --> 00:09:34,460
因为我们知道有文字的区域

297
00:09:34,730 --> 00:09:36,130
应该不是很高的 而是比较宽的

298
00:09:37,110 --> 00:09:38,310
所以我们忽略那些

299
00:09:38,410 --> 00:09:39,990
又高又瘦的白块

300
00:09:40,230 --> 00:09:42,120
比如这个和这个

301
00:09:42,190 --> 00:09:43,390
我们抛弃这些

302
00:09:43,880 --> 00:09:45,490
因为它们太瘦长了

303
00:09:45,660 --> 00:09:46,780
然后对剩下的那些

304
00:09:47,470 --> 00:09:48,440
从比例上来看

305
00:09:48,840 --> 00:09:50,420
比较像正常的文字区域的

306
00:09:50,610 --> 00:09:51,800
这些白块

307
00:09:51,950 --> 00:09:53,310
画上矩形窗

308
00:09:53,380 --> 00:09:55,070
也就是说

309
00:09:55,450 --> 00:09:56,660
我们围着这些

310
00:09:56,970 --> 00:09:58,500
白块画上矩形边界

311
00:09:58,610 --> 00:10:00,550
比如这里

312
00:10:01,060 --> 00:10:02,180
LULA B's ANTIQUE MALL 商标

313
00:10:02,650 --> 00:10:04,690
还有 LULA B's 和那边小的“正在营业”

314
00:10:05,840 --> 00:10:06,000
的牌子

315
00:10:07,100 --> 00:10:09,550
这个例子漏掉了一块文字

316
00:10:09,860 --> 00:10:12,550
虽然很难识别 但其实这里是有一行文字的

317
00:10:13,080 --> 00:10:14,710
还是写的 LULA B's

318
00:10:14,950 --> 00:10:16,180
但由于宽高比不正常

319
00:10:16,530 --> 00:10:17,960
因此被忽略掉了

320
00:10:19,100 --> 00:10:20,240
所以 对这幅图来讲

321
00:10:20,530 --> 00:10:21,460
检测效果还不错

322
00:10:21,660 --> 00:10:22,760
但对于这个具体的例子

323
00:10:23,290 --> 00:10:24,400
分类器还是漏掉了一些文字

324
00:10:24,760 --> 00:10:25,780
因为这段文字

325
00:10:25,960 --> 00:10:26,900
是写在透明窗户上的

326
00:10:27,240 --> 00:10:28,700
因此确实比较难读出来

327
00:10:29,750 --> 00:10:31,200
好的 这就是使用滑动窗

328
00:10:32,430 --> 00:10:33,120
来进行文字检测

329
00:10:33,800 --> 00:10:35,300
找到这些有文字的

330
00:10:36,100 --> 00:10:37,010
长方形以后

331
00:10:37,110 --> 00:10:38,240
我们现在就能够

332
00:10:38,450 --> 00:10:39,890
剪下这些图像区域

333
00:10:40,070 --> 00:10:42,100
然后应用流水线的后面步骤对文字进行识别

334
00:10:45,390 --> 00:10:46,820
如果你还记得的话

335
00:10:46,880 --> 00:10:48,360
你应该知道流水线的

336
00:10:48,570 --> 00:10:50,620
第二步是字符分割

337
00:10:50,890 --> 00:10:52,530
所以给出上面这样的图像

338
00:10:52,790 --> 00:10:55,660
我们应该怎样分割出图像中的单个字符呢？

339
00:10:56,580 --> 00:10:57,460
同样地 我们还是使用

340
00:10:57,910 --> 00:10:59,590
一种监督学习算法

341
00:11:00,010 --> 00:11:01,020
用一些正样本

342
00:11:01,100 --> 00:11:01,990
和一些负样本

343
00:11:02,100 --> 00:11:03,810
而我们要做的

344
00:11:03,880 --> 00:11:04,840
就是看看这些图片

345
00:11:04,900 --> 00:11:06,160
然后试着决定一下

346
00:11:06,390 --> 00:11:08,110
图像中是不是

347
00:11:08,370 --> 00:11:09,690
在两个字符之间

348
00:11:10,700 --> 00:11:12,070
有一条分界线

349
00:11:13,030 --> 00:11:14,100
所以对这些正样本

350
00:11:14,960 --> 00:11:17,040
比如第一个样本

351
00:11:17,290 --> 00:11:18,590
这个图片中间

352
00:11:18,650 --> 00:11:20,050
似乎就有一条分界线

353
00:11:21,320 --> 00:11:22,890
把两个字符分开了

354
00:11:23,110 --> 00:11:24,120
然后第二个样本

355
00:11:24,680 --> 00:11:25,770
同样地像是一个

356
00:11:25,950 --> 00:11:27,370
正样本 因为我

357
00:11:27,840 --> 00:11:29,020
可以画一条线

358
00:11:29,160 --> 00:11:31,190
来把两个字符分开

359
00:11:31,350 --> 00:11:33,310
所以这些都是正样本

360
00:11:33,510 --> 00:11:35,370
这些样本的图像中间

361
00:11:35,970 --> 00:11:36,930
有一条沟或者分隔线

362
00:11:37,960 --> 00:11:40,320
把两个不同的字符分开了

363
00:11:40,560 --> 00:11:41,870
而对于负样本

364
00:11:42,010 --> 00:11:43,160
你不能在中间

365
00:11:43,690 --> 00:11:44,810
画一条分隔线

366
00:11:44,900 --> 00:11:46,610
来把左右分开

367
00:11:46,820 --> 00:11:48,160
所以这些都是负样本

368
00:11:48,460 --> 00:11:50,660
因为它们不表示两个字符的中间部分

369
00:11:51,760 --> 00:11:52,490
因此我们要做的就是

370
00:11:52,650 --> 00:11:53,940
训练一个分类器

371
00:11:54,500 --> 00:11:55,910
可以用神经网络

372
00:11:56,180 --> 00:11:58,000
也可以用别的学习算法

373
00:11:58,120 --> 00:12:01,420
来试着对这些正负样本进行分类

374
00:12:02,770 --> 00:12:03,980
训练好这个分类器以后

375
00:12:04,320 --> 00:12:06,030
我们就要把这个分类器

376
00:12:06,690 --> 00:12:07,830
应用到我们文字中

377
00:12:07,940 --> 00:12:09,410
这是文字检测系统的输出

378
00:12:09,590 --> 00:12:10,970
比如从这个矩形开始

379
00:12:11,130 --> 00:12:12,080
我们要问

380
00:12:12,230 --> 00:12:13,280
这个矩形窗的

381
00:12:13,510 --> 00:12:15,000
中间部分是不是像

382
00:12:15,100 --> 00:12:16,600
两个字符的

383
00:12:16,680 --> 00:12:18,470
中间位置呢

384
00:12:18,980 --> 00:12:20,220
同样地 正常情况下

385
00:12:20,320 --> 00:12:21,760
分类器应该回答 不是

386
00:12:22,170 --> 00:12:23,280
然后我们滑动矩形窗

387
00:12:23,410 --> 00:12:24,850
这是一个一维的

388
00:12:25,200 --> 00:12:26,410
矩形窗分类器

389
00:12:26,500 --> 00:12:27,820
因为我们滑动矩形窗的

390
00:12:28,470 --> 00:12:29,560
方向就是沿着一条直线

391
00:12:29,780 --> 00:12:32,070
从左向右 不存在其他行

392
00:12:32,270 --> 00:12:34,420
这里只有一行

393
00:12:34,520 --> 00:12:36,160
对现在这个位置

394
00:12:36,240 --> 00:12:37,250
我们要问问

395
00:12:37,490 --> 00:12:38,700
我们应该把这两个字符分开吗 

396
00:12:39,570 --> 00:12:41,580
或者说 我们应该在矩形中间画条线吗

397
00:12:41,950 --> 00:12:43,040
同样地 正常情况下

398
00:12:43,190 --> 00:12:44,720
分类器会输出 y=1

399
00:12:44,780 --> 00:12:46,460
这就表示我们应该

400
00:12:46,630 --> 00:12:49,690
在中间画一条线 分开两个字符

401
00:12:50,710 --> 00:12:51,620
然后我们再继续移动窗口

402
00:12:51,870 --> 00:12:53,440
然后分类器再作出决定

403
00:12:53,650 --> 00:12:55,020
这时分类器会说 不要分开

404
00:12:55,300 --> 00:12:56,580
然后再移动 分类器再说

405
00:12:57,230 --> 00:12:58,830
 是的应该分开

406
00:12:59,200 --> 00:13:00,410
然后把两个字符分开

407
00:13:00,560 --> 00:13:01,770
然后再慢慢向右移动

408
00:13:01,920 --> 00:13:03,310
按道理在这里

409
00:13:03,380 --> 00:13:05,160
分类器会输出另一个正样本

410
00:13:05,770 --> 00:13:07,470
一直下去

411
00:13:08,010 --> 00:13:09,180
就这样 我们要依次向右

412
00:13:09,820 --> 00:13:10,990
滑动矩形窗

413
00:13:11,160 --> 00:13:12,670
每一步都运行分类器

414
00:13:12,800 --> 00:13:13,800
如果正常的话

415
00:13:14,210 --> 00:13:15,070
分类器会告诉我们

416
00:13:16,190 --> 00:13:17,820
应该在什么地方

417
00:13:18,290 --> 00:13:20,410
来将图像分割为独立的字符

418
00:13:21,090 --> 00:13:22,450
这就是用于

419
00:13:22,810 --> 00:13:24,190
字符分割的一维滑动窗

420
00:13:25,520 --> 00:13:28,430
这里我们又回到了整个照片OCR流水线

421
00:13:29,120 --> 00:13:30,280
在这段视频中

422
00:13:30,780 --> 00:13:32,170
我们谈到了文字检测

423
00:13:32,360 --> 00:13:34,570
在文字检测中 我们使用滑动窗来检测文字

424
00:13:35,200 --> 00:13:36,390
同时我们还用了一个

425
00:13:37,070 --> 00:13:38,420
一维滑动窗来进行

426
00:13:38,790 --> 00:13:40,160
字符的分割

427
00:13:40,730 --> 00:13:42,860
来将图像分割为独立的字符

428
00:13:43,900 --> 00:13:44,770
流水线的最后一步

429
00:13:44,810 --> 00:13:46,040
是字符分类

430
00:13:46,720 --> 00:13:48,150
这一步 根据之前你已经学到的

431
00:13:48,370 --> 00:13:49,750
监督学习算法

432
00:13:50,020 --> 00:13:51,490
你应该比较清楚

433
00:13:52,080 --> 00:13:54,470
应该怎么做了

434
00:13:55,170 --> 00:13:56,440
你可以使用一种

435
00:13:56,940 --> 00:13:58,150
标准的监督学习算法

436
00:13:58,360 --> 00:13:59,250
比如神经网络

437
00:13:59,570 --> 00:14:00,650
或者其他方法

438
00:14:00,860 --> 00:14:02,100
输入这样的图像

439
00:14:02,980 --> 00:14:05,030
然后将图像按字母分类

440
00:14:05,480 --> 00:14:07,120
化为26个字母

441
00:14:07,230 --> 00:14:08,320
A到Z中的一个

442
00:14:08,570 --> 00:14:09,670
或者我们也可以有36种字符

443
00:14:09,780 --> 00:14:11,140
如果你算上数字字符的话

444
00:14:11,270 --> 00:14:12,650
这就是一个多元分类问题

445
00:14:13,080 --> 00:14:14,410
你应该把这个

446
00:14:14,510 --> 00:14:15,690
带有字符的图像

447
00:14:16,050 --> 00:14:17,390
作为输入

448
00:14:18,140 --> 00:14:20,450
然后确定这个图像中出现了什么字符

449
00:14:21,080 --> 00:14:22,460
这就是照片OCR流水线技术

450
00:14:23,730 --> 00:14:24,750
以及使用滑动窗的方法

451
00:14:24,910 --> 00:14:26,140
作为分类器

452
00:14:26,520 --> 00:14:27,960
来把这些不同的组件

453
00:14:28,100 --> 00:14:29,790
放在一起

454
00:14:30,060 --> 00:14:31,570
共同开发成一个照片OCR系统

455
00:14:32,430 --> 00:14:33,570
在接下来的课程中

456
00:14:33,680 --> 00:14:34,930
我们将继续围绕照片OCR技术

457
00:14:35,150 --> 00:14:36,550
探究其他一些有趣的应用问题

458
00:14:36,960 --> 00:14:39,070
【教育无边界字幕组】翻译：所罗门捷列夫 校对：竹二个 审核：Naplessss