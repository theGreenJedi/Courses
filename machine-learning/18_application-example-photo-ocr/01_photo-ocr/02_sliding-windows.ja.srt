1
00:00:00,370 --> 00:00:01,590
前回のビデオでは

2
00:00:01,890 --> 00:00:04,570
Photo OCRのパイプラインについてと、それがどう機能するかについて議論してきた。

3
00:00:05,480 --> 00:00:06,370
それは画像をとり、

4
00:00:07,050 --> 00:00:08,070
それを一連の機械学習の

5
00:00:08,130 --> 00:00:10,010
コンポーネントを通過させて、

6
00:00:10,280 --> 00:00:11,680
画像の中にあるテキストを

7
00:00:11,890 --> 00:00:13,820
読み取ることを試みる、という物だった。

8
00:00:14,590 --> 00:00:15,820
このビデオでは、

9
00:00:16,210 --> 00:00:17,360
個々のパイプラインのコンポーネントが

10
00:00:17,780 --> 00:00:20,310
どう機能するかについてもう少し議論していきたい。

11
00:00:21,270 --> 00:00:24,070
具体的には、このビデオの大半を、スライディングウィンドウ分類器(classifier)と呼ばれる物に

12
00:00:24,680 --> 00:00:25,950
関する議論に費やしたいと思う。

13
00:00:26,750 --> 00:00:31,570
PhotoOCRのパイプラインの

14
00:00:32,000 --> 00:00:33,390
最初のステージは

15
00:00:33,730 --> 00:00:35,090
テキスト検出だった。そこでは

16
00:00:35,330 --> 00:00:36,640
こんな画像を見ていって

17
00:00:37,020 --> 00:00:39,320
この画像の中でテキストがある位置を見つける事を試みる。

18
00:00:39,850 --> 00:00:42,490
テキスト検出はコンピュータビジョンにとっては普通でない問題だ。

19
00:00:43,220 --> 00:00:44,820
何故なら見つけたいテキストの

20
00:00:45,140 --> 00:00:46,150
長さに応じて

21
00:00:46,290 --> 00:00:47,870
見つけようとするこれらの矩形も

22
00:00:47,970 --> 00:00:49,600
異なるアスペクト比となるからだ。

23
00:00:51,100 --> 00:00:52,060
だから画像の中の物事を

24
00:00:52,220 --> 00:00:53,550
検出する話をする為に、

25
00:00:54,300 --> 00:00:55,860
もっと簡単な例である、

26
00:00:56,550 --> 00:01:00,080
歩行者の検出から始めよう。その後に話を戻して

27
00:01:00,460 --> 00:01:02,300
歩行者の検出で構築したアイデアを

28
00:01:02,570 --> 00:01:04,840
テキスト検出に用いよう。

29
00:01:06,280 --> 00:01:08,010
さて、歩行者検出においては、

30
00:01:08,360 --> 00:01:09,440
こんな画像をとり、

31
00:01:09,600 --> 00:01:11,010
画像の中に居る個々の歩行者を

32
00:01:11,160 --> 00:01:12,920
見つける事を試みる物だ。

33
00:01:13,260 --> 00:01:14,440
つまり歩行者が一人見つかり、

34
00:01:14,520 --> 00:01:15,550
ここに二人目、

35
00:01:15,780 --> 00:01:17,920
三人目、四人目、五人目、

36
00:01:18,290 --> 00:01:19,390
そして六人目、と。

37
00:01:19,560 --> 00:01:20,990
この問題はテキスト検出の問題よりも

38
00:01:21,320 --> 00:01:22,770
ちょっとだけ簡単だろう。

39
00:01:23,100 --> 00:01:24,200
何故ならほとんどの歩行者のアスペクト比は

40
00:01:24,560 --> 00:01:27,490
きわめて似通っているからだ。

41
00:01:28,170 --> 00:01:29,280
我らが見つけようと試みている矩形に対し

42
00:01:29,630 --> 00:01:31,960
固定されたアスペクト比を用いる事で、

43
00:01:32,420 --> 00:01:33,610
ここでアスペクト比という言葉は

44
00:01:33,920 --> 00:01:36,420
これらの矩形の高さと幅の比の事を言う。

45
00:01:37,820 --> 00:01:38,190
それらは別々の歩行者に対しても

46
00:01:38,650 --> 00:01:40,120
同じだ。だが、

47
00:01:40,490 --> 00:01:42,650
テキスト検出の場合は、異なる行のテキストで

48
00:01:43,030 --> 00:01:44,560
縦と横の比は

49
00:01:44,960 --> 00:01:45,830
異なる。

50
00:01:46,460 --> 00:01:47,940
歩行者の検出の場合は

51
00:01:48,020 --> 00:01:49,250
歩行者の居る場所までの

52
00:01:49,810 --> 00:01:51,250
カメラからの距離が異なる事はあり得るので、

53
00:01:51,390 --> 00:01:52,730
これらの矩形の高さは、どれだけ離れているかに応じて

54
00:01:53,380 --> 00:01:55,600
違いうるけれど。

55
00:01:55,990 --> 00:01:57,090
でもアスペクト比は同一だ。

56
00:01:57,720 --> 00:01:58,880
歩行者検出システムを構築する為には

57
00:01:59,440 --> 00:02:02,460
こんな方法が考えられる。

58
00:02:02,520 --> 00:02:03,650
このアスペクト比を

59
00:02:03,970 --> 00:02:06,100
82 x 36に

60
00:02:06,690 --> 00:02:08,010
標準化する事にしよう。

61
00:02:08,180 --> 00:02:10,040
別に丸めた数字、

62
00:02:10,330 --> 00:02:11,510
例えば80x40とかにしても良いんだけど、

63
00:02:12,020 --> 00:02:14,000
82x36で特に問題無さそうなのでこれで行く。

64
00:02:16,110 --> 00:02:17,280
そして次にやるべき事は

65
00:02:17,650 --> 00:02:20,420
外に出て大量の陽性と陰性のトレーニングセットを集めてくる事だ。

66
00:02:21,240 --> 00:02:22,790
こちらが82x36の画像で

67
00:02:22,900 --> 00:02:24,230
歩行者を含んでいる

68
00:02:24,360 --> 00:02:26,230
手本だ。そしてこちらは

69
00:02:26,550 --> 00:02:28,360
含んでいない手本の画像。

70
00:02:29,470 --> 00:02:30,710
このスライドには、

71
00:02:31,050 --> 00:02:33,170
y =1となる12の陽性の手本と

72
00:02:33,730 --> 00:02:34,990
y=0となる12の手本をお見せしている。

73
00:02:36,410 --> 00:02:37,790
もっと典型的な歩行者検出のアプリケーションでは

74
00:02:38,180 --> 00:02:39,200
1000トレーニング手本から

75
00:02:39,500 --> 00:02:40,880
1万トレーニング手本くらいまで、

76
00:02:41,230 --> 00:02:42,210
またはもっとトレーニングセットが集められる時は

77
00:02:42,300 --> 00:02:44,410
それ以上の場合すら

78
00:02:44,460 --> 00:02:45,360
あるのが

79
00:02:45,510 --> 00:02:47,180
一般的だ。

80
00:02:47,460 --> 00:02:48,590
そしてその時にとれる手段としては、

81
00:02:48,910 --> 00:02:50,160
ニューラルネットワークか、それ以外の何らかの

82
00:02:50,510 --> 00:02:52,420
学習アルゴリズムを訓練して、

83
00:02:52,610 --> 00:02:54,570
この画像のパッチ、

84
00:02:54,970 --> 00:02:56,710
82 x 36の次元のパッチを入力として、

85
00:02:56,850 --> 00:02:59,180
それをyかどうか、を分類出来るようにする。

86
00:02:59,710 --> 00:03:01,070
つまりこれらの画像パッチに

87
00:03:01,510 --> 00:03:03,850
歩行者が含まれているかどうかを分類出来るようにする。

88
00:03:05,250 --> 00:03:06,250
以上のように、画像のパッチを受け取り

89
00:03:06,470 --> 00:03:08,050
そこに歩行者が居るかどうかを区別する為に

90
00:03:08,210 --> 00:03:09,290
教師あり学習を用いる

91
00:03:09,530 --> 00:03:12,420
事が出来る。

92
00:03:14,310 --> 00:03:15,190
今、新しい画像を与えられたとして、

93
00:03:15,400 --> 00:03:16,520
こんなテストセットの画像

94
00:03:16,850 --> 00:03:17,920
だとして、

95
00:03:18,030 --> 00:03:20,240
写真の画像から歩行者を見つけたいとする。

96
00:03:21,520 --> 00:03:22,340
そこで我らがやる事は

97
00:03:22,670 --> 00:03:25,140
この画像から矩形のパッチをとっていき、

98
00:03:25,580 --> 00:03:26,800
ここにあげたような感じで、

99
00:03:26,900 --> 00:03:27,930
これは82 x 36の

100
00:03:28,010 --> 00:03:29,440
画像のパッチとかで、

101
00:03:30,270 --> 00:03:31,530
そしてその画像のパッチを

102
00:03:31,830 --> 00:03:33,660
分類器に通して

103
00:03:33,840 --> 00:03:34,900
その画像パッチに

104
00:03:34,980 --> 00:03:36,310
歩行者が居るかどうかを決定する。

105
00:03:36,620 --> 00:03:38,100
そしてこのパッチについては

106
00:03:38,260 --> 00:03:40,600
分類器がy =0を返すのを期待する。何故なら歩行者は居ないから。

107
00:03:42,020 --> 00:03:42,900
次に、その緑の矩形を

108
00:03:43,140 --> 00:03:44,380
少しだけスライドさせて、

109
00:03:44,490 --> 00:03:45,680
その後にその

110
00:03:45,940 --> 00:03:47,180
新しい画像パッチに対して

111
00:03:47,560 --> 00:03:49,700
分類器を走らせて、歩行者がそこに居るかを判定する。

112
00:03:50,760 --> 00:03:51,740
それを終えたら、その後はさらに

113
00:03:51,920 --> 00:03:53,070
ウィンドウを右にスライドさせて

114
00:03:53,160 --> 00:03:54,160
そのパッチを分類器に

115
00:03:54,420 --> 00:03:56,690
ふたたび通す。

116
00:03:56,970 --> 00:03:57,850
矩形を一度にどれだけ

117
00:03:58,280 --> 00:03:59,770
シフトさせるかは

118
00:04:00,260 --> 00:04:01,720
パラメータだ。それはステップサイズのパラメータと

119
00:04:02,190 --> 00:04:04,000
呼ばれる事もあるし、

120
00:04:04,070 --> 00:04:06,020
また、ストライドパラメータと呼ばれる事も

121
00:04:06,380 --> 00:04:08,970
ある。そして

122
00:04:09,120 --> 00:04:11,050
もし一度に1ピクセルしか動かさなければ、

123
00:04:11,210 --> 00:04:12,020
つまりステップ幅、あるいは歩幅1を

124
00:04:12,360 --> 00:04:14,020
使う事が出来れば、それは普通

125
00:04:14,340 --> 00:04:15,560
一番良い実行結果が得られるが、

126
00:04:15,700 --> 00:04:16,960
計算量的にはより高価となる。

127
00:04:17,430 --> 00:04:18,940
だからステップサイズで4ピクセルとか

128
00:04:19,090 --> 00:04:20,010
8ピクセルとか、

129
00:04:20,210 --> 00:04:20,970
またはそれより大きな適当なピクセルを

130
00:04:21,250 --> 00:04:22,350
用いるのが

131
00:04:22,550 --> 00:04:23,600
より一般的だ。

132
00:04:24,010 --> 00:04:25,320
何故ならその方が毎回

133
00:04:25,430 --> 00:04:26,570
もうちょっとだけ

134
00:04:26,700 --> 00:04:28,570
矩形を動かせるから。

135
00:04:28,870 --> 00:04:30,090
このプロセスを用いる事で、

136
00:04:30,870 --> 00:04:32,310
毎回ちょっとずつ矩形を

137
00:04:32,340 --> 00:04:33,160
右に動かしていく事で、

138
00:04:33,370 --> 00:04:34,450
そしてこれらの各パッチを

139
00:04:34,520 --> 00:04:35,780
分類器にかけていく事で、

140
00:04:36,620 --> 00:04:38,220
最終的に、、、

141
00:04:38,900 --> 00:04:42,080
このウィンドウを画像の

142
00:04:42,150 --> 00:04:43,340
異なる場所へとスライドし続けて

143
00:04:43,550 --> 00:04:44,680
最初は最初の行から始めて

144
00:04:44,850 --> 00:04:46,080
その後に画像の

145
00:04:46,160 --> 00:04:47,580
さらなる先の行へと

146
00:04:47,710 --> 00:04:49,100
進めていき、

147
00:04:49,290 --> 00:04:50,490
なんらかのステップサイズで

148
00:04:50,550 --> 00:04:52,070
あるいはあるストライドのサイズで

149
00:04:52,240 --> 00:04:53,330
これら別々の画像のパッチに対し

150
00:04:53,430 --> 00:04:54,990
実行していく。

151
00:04:56,990 --> 00:04:57,870
ここまでは、とても小さな

152
00:04:57,970 --> 00:04:59,870
矩形だった。これは一つの特定のサイズの歩行者しか

153
00:05:00,310 --> 00:05:02,310
検出出来ない。

154
00:05:02,780 --> 00:05:04,210
次にやる事は、

155
00:05:04,470 --> 00:05:05,990
より大きな画像のパッチを見て、

156
00:05:06,730 --> 00:05:08,270
つまりより大きな画像のパッチを取って、

157
00:05:08,610 --> 00:05:09,700
ここに示したような、

158
00:05:10,310 --> 00:05:11,960
そしてふたたび同様に分類器を走らせる。

159
00:05:13,540 --> 00:05:14,320
ところで、より大きな

160
00:05:14,600 --> 00:05:15,830
画像のパッチを取る、と言った時に

161
00:05:16,080 --> 00:05:17,780
私が実際に意味している事は、

162
00:05:17,860 --> 00:05:18,850
こんな画像パッチをとった時、

163
00:05:19,490 --> 00:05:20,720
実際にやる事は、

164
00:05:20,880 --> 00:05:22,110
この画像のパッチを取り、これを

165
00:05:22,800 --> 00:05:24,750
82x36に縮小する、という事。

166
00:05:25,000 --> 00:05:26,260
つまりこのより大きなパッチを取り、

167
00:05:26,550 --> 00:05:28,180
それをより小さい画像に

168
00:05:28,300 --> 00:05:29,800
リサイズして、そして

169
00:05:29,970 --> 00:05:31,260
その小さくした画像こそが、

170
00:05:31,600 --> 00:05:32,620
分類器に渡す物で、

171
00:05:32,990 --> 00:05:35,340
そこで歩行者がパッチにいないか決定する事を試みる。

172
00:05:37,230 --> 00:05:38,310
そして最後に、さらに大きなスケールで

173
00:05:38,470 --> 00:05:39,530
これを行う事が出来て、

174
00:05:39,930 --> 00:05:41,870
そのスライディングウィンドウを最後まで

175
00:05:42,080 --> 00:05:43,830
実行する。

176
00:05:43,980 --> 00:05:45,920
そしてこれらのプロセスが全て終わったら、

177
00:05:45,980 --> 00:05:47,480
あなたのアルゴリズムはこの画像の中に

178
00:05:48,040 --> 00:05:49,670
これらの歩行者が居るかを

179
00:05:50,140 --> 00:05:52,070
検出する事が期待出来る訳だ。

180
00:05:52,470 --> 00:05:53,850
以上が分類器を訓練する方法と、

181
00:05:54,290 --> 00:05:55,630
そしてスライディングウィンドウの分類器、

182
00:05:55,890 --> 00:05:57,360
またはスライディングウィンドウの検出器を

183
00:05:57,920 --> 00:05:59,820
用いて、画像の中の歩行者を

184
00:05:59,970 --> 00:06:01,740
探す方法だ。

185
00:06:03,070 --> 00:06:04,050
テキスト検出の例に

186
00:06:04,150 --> 00:06:05,910
立ち戻って、

187
00:06:06,100 --> 00:06:07,490
PhotoOCRパイプラインでの

188
00:06:07,790 --> 00:06:09,330
テキスト検出のステージについて議論しよう、そこでは

189
00:06:09,570 --> 00:06:11,340
我らの目標は画像内のテキストの領域を見つける事だ。

190
00:06:13,250 --> 00:06:15,010
歩行者の検出と同様に、

191
00:06:15,250 --> 00:06:16,730
テキストが現れる場所に

192
00:06:17,030 --> 00:06:18,410
対応した陽性と陰性の

193
00:06:19,060 --> 00:06:20,930
手本を

194
00:06:21,530 --> 00:06:23,810
作り出す事ができる。

195
00:06:24,300 --> 00:06:27,290
つまり歩行者を検出する代わりに、今度はテキストを検出したい。

196
00:06:28,130 --> 00:06:29,670
つまり陽性の手本は

197
00:06:29,770 --> 00:06:31,640
テキストがあるイメージのパッチで

198
00:06:31,970 --> 00:06:33,330
陰性の手本はテキストが無い

199
00:06:33,380 --> 00:06:36,000
画像のパッチだ。

200
00:06:36,330 --> 00:06:37,530
これで分類器をトレーニングし終えたら、

201
00:06:38,030 --> 00:06:39,450
それを新規の画像、

202
00:06:39,870 --> 00:06:41,190
テストセットの画像に

203
00:06:42,460 --> 00:06:42,910
適用出来る。

204
00:06:43,310 --> 00:06:44,900
これは例として使ってきた画像だ。

205
00:06:46,040 --> 00:06:47,300
ここでは、この例においては、

206
00:06:47,440 --> 00:06:48,400
スライディングウィンドウを

207
00:06:48,560 --> 00:06:50,300
たった一つの固定されたスケールの物で

208
00:06:50,640 --> 00:06:52,030
実行する事にしよう。

209
00:06:52,370 --> 00:06:54,360
これは例示の為だ。つまり

210
00:06:54,450 --> 00:06:56,000
一つのサイズの矩形だけを用いる。

211
00:06:56,790 --> 00:06:58,110
だが、小さな、スライディングウィンドウの

212
00:06:58,350 --> 00:07:00,070
分類器を、たくさんのちいさな

213
00:07:00,170 --> 00:07:01,570
画像のパッチに対して実行するとしよう、

214
00:07:01,630 --> 00:07:04,340
こんな感じに。

215
00:07:04,430 --> 00:07:05,430
そうすると、

216
00:07:05,530 --> 00:07:06,670
結局はこんな結果が得らる。

217
00:07:07,040 --> 00:07:08,530
ここで白い領域は

218
00:07:08,900 --> 00:07:10,700
テキスト検出のシステムが

219
00:07:10,940 --> 00:07:12,190
テキストを見つけた場所を表す。

220
00:07:12,210 --> 00:07:15,960
つまりこれらの絵の軸は同一だ。

221
00:07:16,390 --> 00:07:17,700
つまりこの領域は

222
00:07:18,110 --> 00:07:19,200
この領域に

223
00:07:19,230 --> 00:07:20,710
対応している。

224
00:07:20,840 --> 00:07:22,040
そしてここが黒であるという事実は、

225
00:07:22,850 --> 00:07:24,390
分類器がここにテキストは

226
00:07:24,840 --> 00:07:25,940
見つからない、と

227
00:07:26,170 --> 00:07:28,100
思っている事を表している。

228
00:07:28,170 --> 00:07:29,630
一方でここにはたくさんの

229
00:07:29,810 --> 00:07:31,300
白い物があるという事実は、分類器が

230
00:07:31,540 --> 00:07:33,260
たくさんのテキストがここにある、と

231
00:07:33,520 --> 00:07:34,310
思っている事を反映している。

232
00:07:35,040 --> 00:07:35,700
この左下の絵で

233
00:07:35,780 --> 00:07:36,870
私がやった事は

234
00:07:37,070 --> 00:07:38,820
分類器がテキストを見つけた、と

235
00:07:38,970 --> 00:07:41,050
実際に思った場所を見せる為に、白を使ったという事だ。

236
00:07:41,810 --> 00:07:43,280
そしてグレイの影の違いは

237
00:07:43,880 --> 00:07:45,560
分類器の出力した

238
00:07:45,670 --> 00:07:46,750
確率に対応している。

239
00:07:47,110 --> 00:07:48,000
つまりグレイの影は

240
00:07:48,520 --> 00:07:49,860
分類器がテキストを発見したように思ってはいるが、

241
00:07:49,930 --> 00:07:50,750
だがそんなに

242
00:07:51,210 --> 00:07:53,900
自信は無い、と思っている所。

243
00:07:54,260 --> 00:07:55,980
明るい白は分類器が

244
00:07:57,440 --> 00:07:58,400
とても高い確率で

245
00:07:58,660 --> 00:08:00,470
テキストがある場所だ、と

246
00:08:00,630 --> 00:08:03,110
推計している場所に対応している。

247
00:08:04,110 --> 00:08:05,270
まだやるべき事が全て終わった訳では無い。

248
00:08:05,690 --> 00:08:06,580
何故なら我らが望んでいるのは、

249
00:08:06,830 --> 00:08:08,620
画像の中のこのテキストの

250
00:08:08,850 --> 00:08:09,780
全体の回りの領域に対して

251
00:08:10,490 --> 00:08:12,540
四角で囲む、という事だからだ。

252
00:08:12,650 --> 00:08:13,540
だからさらにもう一段階ステップを踏む、

253
00:08:13,840 --> 00:08:14,990
それは分類器の出力をとり、

254
00:08:15,230 --> 00:08:16,880
そこにexpansion operatorと呼ばれる物を

255
00:08:17,290 --> 00:08:19,280
適用する、という事をする。

256
00:08:20,750 --> 00:08:22,250
それがやる事は、

257
00:08:22,430 --> 00:08:24,270
この画像に対して、

258
00:08:25,450 --> 00:08:26,700
それぞれの白のシミに対して、

259
00:08:26,800 --> 00:08:28,200
それぞれの白い領域に対して、

260
00:08:28,270 --> 00:08:30,590
その白の領域を拡大する、という事をする。

261
00:08:31,460 --> 00:08:32,460
数学的には、

262
00:08:32,610 --> 00:08:34,110
それを実装する方法は、

263
00:08:34,270 --> 00:08:35,280
右の画像を見てみると、

264
00:08:35,690 --> 00:08:36,780
右の画像を作る為に

265
00:08:36,930 --> 00:08:38,110
やれる事としては、各ピクセルに対し、

266
00:08:38,370 --> 00:08:39,510
以下のように尋ねてみる事だ：

267
00:08:39,610 --> 00:08:40,790
このピクセルは、左の画像の白いピクセルから

268
00:08:41,370 --> 00:08:42,960
一定の距離以内に

269
00:08:43,100 --> 00:08:44,650
あるだろうか？と。

270
00:08:45,430 --> 00:08:46,800
つまり、もしあるピクセルが、

271
00:08:47,220 --> 00:08:48,420
一番左の画像で、例えば、そうだなぁ。

272
00:08:48,950 --> 00:08:50,280
白いピクセルの

273
00:08:50,610 --> 00:08:52,310
5ピクセルとか10ピクセル以内にあるのなら、

274
00:08:52,540 --> 00:08:55,020
その時は一番右のそのピクセルも白に塗る。

275
00:08:56,190 --> 00:08:57,010
このような操作が与える効果は、

276
00:08:57,300 --> 00:08:58,350
一番左の画像の白いしみを

277
00:08:58,730 --> 00:08:59,630
取り出して、ちょっとだけ

278
00:09:00,030 --> 00:09:01,370
拡張したような物となる。

279
00:09:01,500 --> 00:09:02,200
それらをちょっとだけ成長させるような。

280
00:09:02,670 --> 00:09:04,110
付近のピクセルが

281
00:09:04,170 --> 00:09:05,420
白いピクセルかどうか。

282
00:09:05,900 --> 00:09:07,980
そしてそばのピクセルも同様に白に塗る。

283
00:09:08,430 --> 00:09:09,900
最後に、これで終わりになるが、

284
00:09:10,180 --> 00:09:11,210
この一番右の画像を

285
00:09:11,480 --> 00:09:12,900
見ていき、

286
00:09:13,210 --> 00:09:14,650
くっついている構成要素を見ていき、

287
00:09:15,320 --> 00:09:16,700
つながった白い領域のバウンディングボックスを

288
00:09:16,990 --> 00:09:19,350
その回りに描く。

289
00:09:20,260 --> 00:09:20,990
具体的には、これらの白い領域を

290
00:09:21,390 --> 00:09:22,850
全部見ていくとすると、

291
00:09:23,080 --> 00:09:24,750
例えばこれとか、これとか、

292
00:09:24,990 --> 00:09:26,670
これとか。

293
00:09:27,030 --> 00:09:27,810
そして簡単な経験則で

294
00:09:28,390 --> 00:09:30,240
アスペクト比がおかしい、と思うような物を

295
00:09:30,660 --> 00:09:32,760
除外していくと、、、何故なら我らは

296
00:09:32,870 --> 00:09:34,460
テキストの回りの箱は

297
00:09:34,730 --> 00:09:36,130
高さよりも幅の方が大きいべきだという事を知っているから。

298
00:09:37,110 --> 00:09:38,310
だから痩せてて高い

299
00:09:38,410 --> 00:09:39,990
箱を無視していくと、例えばこれとか

300
00:09:40,230 --> 00:09:42,120
これとか。

301
00:09:42,190 --> 00:09:43,390
そしてこれらは捨てる、何故なら

302
00:09:43,880 --> 00:09:45,490
それらはあまりにも高くて薄いから。

303
00:09:45,660 --> 00:09:46,780
そしてアスペクト比が

304
00:09:47,470 --> 00:09:48,440
テキストの領域っぽい物の回りを

305
00:09:48,840 --> 00:09:50,420
囲んだ矩形を描く、ここで

306
00:09:50,610 --> 00:09:51,800
アスペクト比とは高さと幅の

307
00:09:51,950 --> 00:09:53,310
比の事。次に

308
00:09:53,380 --> 00:09:55,070
矩形を描く事が出来る。テキストの

309
00:09:55,450 --> 00:09:56,660
範囲の回りの

310
00:09:56,970 --> 00:09:58,500
バウンディングボックス。ここのテキストの範囲と

311
00:09:58,610 --> 00:10:00,550
ここのテキストの範囲と、ここのテキストの範囲。

312
00:10:01,060 --> 00:10:02,180
これらはそれぞれ、LULA B's ANTIQUE MALLのロゴと

313
00:10:02,650 --> 00:10:04,690
LULA B'sと、この小さなOPENのサインに対応している。

314
00:10:05,840 --> 00:10:06,000
こっち側の。

315
00:10:07,100 --> 00:10:09,550
所で、この例は実の所、一片のテキストを見逃している。

316
00:10:09,860 --> 00:10:12,550
これはとても読みにくいが、だがここには実際は一片のテキストがある。

317
00:10:13,080 --> 00:10:14,710
ここにもLULA B'sがあって、それはこれに対応しているのだが、

318
00:10:14,950 --> 00:10:16,180
だがこのアスペクト比は

319
00:10:16,530 --> 00:10:17,960
間違いっぽいので、それを捨てたのだった。

320
00:10:19,100 --> 00:10:20,240
つまり、この画像に関しては

321
00:10:20,530 --> 00:10:21,460
問題無さそうだが、

322
00:10:21,660 --> 00:10:22,760
この具体例においては分類器は

323
00:10:23,290 --> 00:10:24,400
実は一片のテキストを見逃している。

324
00:10:24,760 --> 00:10:25,780
それは凄い読みにくい、

325
00:10:25,960 --> 00:10:26,900
何故なら透明の窓に対して

326
00:10:27,240 --> 00:10:28,700
書かれたテキストだから。

327
00:10:29,750 --> 00:10:31,200
以上がスライディングウィンドウを用いた

328
00:10:32,430 --> 00:10:33,120
テキスト検出だ。

329
00:10:33,800 --> 00:10:35,300
テキストを囲むこれらの矩形を

330
00:10:36,100 --> 00:10:37,010
見つけたのちには、

331
00:10:37,110 --> 00:10:38,240
我らはこれらの画像の領域を

332
00:10:38,450 --> 00:10:39,890
切り抜いて、それをあとに続くパイプラインのステージで

333
00:10:40,070 --> 00:10:42,100
テキストを読む為に用いる事が出来る。

334
00:10:45,390 --> 00:10:46,820
さて、パイプラインの

335
00:10:46,880 --> 00:10:48,360
二番目のステージは

336
00:10:48,570 --> 00:10:50,620
文字分割だったのを覚えているだろうか？

337
00:10:50,890 --> 00:10:52,530
つまり上に見せたような画像を与えられた時に、

338
00:10:52,790 --> 00:10:55,660
この画像の各文字に、どうやって分割出来るだろうか？

339
00:10:56,580 --> 00:10:57,460
ここで取れる手段は、今回も

340
00:10:57,910 --> 00:10:59,590
教師あり学習のアルゴリズムだ。

341
00:11:00,010 --> 00:11:01,020
ある陽性の手本の集合と、

342
00:11:01,100 --> 00:11:01,990
ある陰性の手本の集合を

343
00:11:02,100 --> 00:11:03,810
共に用いた。

344
00:11:03,880 --> 00:11:04,840
それでやる事は

345
00:11:04,900 --> 00:11:06,160
画像のパッチを見て、

346
00:11:06,390 --> 00:11:08,110
画像のパッチのちょうど真ん中に

347
00:11:08,370 --> 00:11:09,690
二つの文字の区切りが

348
00:11:10,700 --> 00:11:12,070
あるかどうかを決めたい。

349
00:11:13,030 --> 00:11:14,100
例えばこの最初の陽性の手本では、

350
00:11:14,960 --> 00:11:17,040
この最初の手本は、

351
00:11:17,290 --> 00:11:18,590
この画像パッチは

352
00:11:18,650 --> 00:11:20,050
ちょうど真ん中に、、、つまり

353
00:11:21,320 --> 00:11:22,890
真ん中がちょうど二つの文字の分け目と

354
00:11:23,110 --> 00:11:24,120
なっている。そして二番目の手本も、

355
00:11:24,680 --> 00:11:25,770
これもまた、

356
00:11:25,950 --> 00:11:27,370
陽性の手本に見える。何故ならもし

357
00:11:27,840 --> 00:11:29,020
真ん中に線を引いて

358
00:11:29,160 --> 00:11:31,190
二つの文字を分けようとしたら、ちゃんと分けられるから。

359
00:11:31,350 --> 00:11:33,310
つまり、これらは陽性の手本だ。

360
00:11:33,510 --> 00:11:35,370
その画像の真ん中は、隙間、または

361
00:11:35,970 --> 00:11:36,930
二つの文字を分ける

362
00:11:37,960 --> 00:11:40,320
区切りで、

363
00:11:40,560 --> 00:11:41,870
他方、陰性の手本は、

364
00:11:42,010 --> 00:11:43,160
真ん中で二つの文字を

365
00:11:43,690 --> 00:11:44,810
分割したい、と思わないような物。

366
00:11:44,900 --> 00:11:46,610
つまりこれらは

367
00:11:46,820 --> 00:11:48,160
陰性の手本だ、何故なら

368
00:11:48,460 --> 00:11:50,660
これらは二つの文字の真ん中を表していないからだ。

369
00:11:51,760 --> 00:11:52,490
そこで我らが行う事は、

370
00:11:52,650 --> 00:11:53,940
分類器をトレーニングする事で、

371
00:11:54,500 --> 00:11:55,910
ニューラルネットワークを使ってもいいし、

372
00:11:56,180 --> 00:11:58,000
別のアルゴリズムでもいいが、

373
00:11:58,120 --> 00:12:01,420
とにかく陽性と陰性の手本を分類しようとするアルゴリズムをトレーニングする。

374
00:12:02,770 --> 00:12:03,980
そんな分類器をトレーニングし終えたら、

375
00:12:04,320 --> 00:12:06,030
その後我らはこれを

376
00:12:06,690 --> 00:12:07,830
テキスト検出器が取り出した

377
00:12:07,940 --> 00:12:09,410
こんな画像に対して走らせる。

378
00:12:09,590 --> 00:12:10,970
この矩形から始めて、

379
00:12:11,130 --> 00:12:12,080
こう問う：

380
00:12:12,230 --> 00:12:13,280
緑の矩形の

381
00:12:13,510 --> 00:12:15,000
真ん中は、、、

382
00:12:15,100 --> 00:12:16,600
2つの文字の間っぽく

383
00:12:16,680 --> 00:12:18,470
見えるか？と。

384
00:12:18,980 --> 00:12:20,220
そして期待するのは、分類器は

385
00:12:20,320 --> 00:12:21,760
NO、と言ってくれる事。そしてウィンドウを

386
00:12:22,170 --> 00:12:23,280
スライドさせて、、、所でこれは

387
00:12:23,410 --> 00:12:24,850
1次元のスライディングウィンドウの

388
00:12:25,200 --> 00:12:26,410
分類器だ。何故なら

389
00:12:26,500 --> 00:12:27,820
ウィンドウを一直線に

390
00:12:28,470 --> 00:12:29,560
左から右へとスライドさせるだけで

391
00:12:29,780 --> 00:12:32,070
ここでは別の行、というのが無いから。

392
00:12:32,270 --> 00:12:34,420
ここには一行しか無い。

393
00:12:34,520 --> 00:12:36,160
さて、ここで、分類器が

394
00:12:36,240 --> 00:12:37,250
この場所に来た時に、

395
00:12:37,490 --> 00:12:38,700
二つの文字をここで分割すべきか、

396
00:12:39,570 --> 00:12:41,580
または二つの文字の区切りをこの矩形の真ん中に置くべきか？と問う。

397
00:12:41,950 --> 00:12:43,040
そして期待される事としては、分類器は

398
00:12:43,190 --> 00:12:44,720
y=1と出力する事。つまり

399
00:12:44,780 --> 00:12:46,460
その場合はそこに

400
00:12:46,630 --> 00:12:49,690
線を引くと決定し、二つの文字を分割しようとする訳だ。

401
00:12:50,710 --> 00:12:51,620
そして次にウィンドウをまたスライドさせて、

402
00:12:51,870 --> 00:12:53,440
この場合は分類器はここでは分割しない、と

403
00:12:53,650 --> 00:12:55,020
出力する事が期待されて、さらにまたスライドさせて、

404
00:12:55,300 --> 00:12:56,580
yes、ここでスプリットせよ、と言う事が期待される。

405
00:12:57,230 --> 00:12:58,830
などなど。

406
00:12:59,200 --> 00:13:00,410
こうやってゆっくりと分類器をスライド

407
00:13:00,560 --> 00:13:01,770
させて右の方に行かせて、

408
00:13:01,920 --> 00:13:03,310
ここをさらなる陽性のサンプルと

409
00:13:03,380 --> 00:13:05,160
分類する事が期待される。

410
00:13:05,770 --> 00:13:07,470
などなど。

411
00:13:08,010 --> 00:13:09,180
そしてこのウィンドウを右側へと

412
00:13:09,820 --> 00:13:10,990
スライドさせていき、各ステップで

413
00:13:11,160 --> 00:13:12,670
分類器を実行し、

414
00:13:12,800 --> 00:13:13,800
そしてそれをもって我らに

415
00:13:14,210 --> 00:13:15,070
これらの文字列を分割する

416
00:13:16,190 --> 00:13:17,820
適切な場所を教えてくれる事を期待する訳だ、

417
00:13:18,290 --> 00:13:20,410
つまりこの画像を個々の文字へと分割する。

418
00:13:21,090 --> 00:13:22,450
以上が1Dスライディングウィンドウによる

419
00:13:22,810 --> 00:13:24,190
文字分割だ。

420
00:13:25,520 --> 00:13:28,430
ここにPhoto OCRパイプラインの全体像を再掲した。

421
00:13:29,120 --> 00:13:30,280
このビデオでは、テキスト検出のステップを

422
00:13:30,780 --> 00:13:32,170
議論して来た。そこでは、

423
00:13:32,360 --> 00:13:34,570
テキストを検出する為に、スライディングウィンドウを使った。

424
00:13:35,200 --> 00:13:36,390
そしてまた、文字分割でも

425
00:13:37,070 --> 00:13:38,420
1次元のスライディングウィンドウを

426
00:13:38,790 --> 00:13:40,160
分割する為に使った。

427
00:13:40,730 --> 00:13:42,860
このテキストの画像を、各文字に分割する。

428
00:13:43,900 --> 00:13:44,770
パイプラインの最後のステップは

429
00:13:44,810 --> 00:13:46,040
文字分類ステップだ。

430
00:13:46,720 --> 00:13:48,150
そしてそのステップに関しては、

431
00:13:48,370 --> 00:13:49,750
以前の教師あり学習のところの

432
00:13:50,020 --> 00:13:51,490
ビデオでやったので、

433
00:13:52,080 --> 00:13:54,470
既になじみの物だろう、

434
00:13:55,170 --> 00:13:56,440
そこでは、通常の教師あり学習の、

435
00:13:56,940 --> 00:13:58,150
例えばニューラルネットワークとか

436
00:13:58,360 --> 00:13:59,250
それ以外のなんでも良いが、その辺を使って

437
00:13:59,570 --> 00:14:00,650
画像を入力として、

438
00:14:00,860 --> 00:14:02,100
こんなような、

439
00:14:02,980 --> 00:14:05,030
そしてどのアルファベットか、言い換えると

440
00:14:05,480 --> 00:14:07,120
26文字のaからzまでのどの文字か、

441
00:14:07,230 --> 00:14:08,320
数字も入れるなら

442
00:14:08,570 --> 00:14:09,670
36文字にすべき

443
00:14:09,780 --> 00:14:11,140
かもしれない。

444
00:14:11,270 --> 00:14:12,650
何にせよ、複数クラスへの

445
00:14:13,080 --> 00:14:14,410
分類の問題で、

446
00:14:14,510 --> 00:14:15,690
文字を含んでいる

447
00:14:16,050 --> 00:14:17,390
画像を引数に取り、

448
00:14:18,140 --> 00:14:20,450
その画像にある文字は何なのかを決める、という問題だ。

449
00:14:21,080 --> 00:14:22,460
以上がPhoto OCRのパイプラインだ。

450
00:14:23,730 --> 00:14:24,750
そしてどうやって

451
00:14:24,910 --> 00:14:26,140
スライディングウィンドウの

452
00:14:26,520 --> 00:14:27,960
分類器などのアイデアを、、、

453
00:14:28,100 --> 00:14:29,790
これら別々のコンポーネントを組み合わせて

454
00:14:30,060 --> 00:14:31,570
Photo OCRシステムを開発するか、という話だ。

455
00:14:32,430 --> 00:14:33,570
次の一連のビデオでは、

456
00:14:33,680 --> 00:14:34,930
引き続きPhotoOCRの問題を用いて

457
00:14:35,150 --> 00:14:36,550
このようなアプリケーションを開発する時にまつわる

458
00:14:36,960 --> 00:14:39,070
いくらか興味深い問題を探求していく。