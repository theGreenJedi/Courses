No vídeo anterior, falamos sobre o encadeamento do reconhecimento de caracteres (OCR) em fotografias e como isso funciona. Nele, poderíamos pegar uma imagem, e passá-la por uma sequência de componentes de aprendizagem automática para tentar ler o texto que aparece na imagem. Neste vídeo eu gostaria de falar um pouco mais sobre como cada componente do encadeamento funciona. Em particular, este vídeo ficará mais centrado na discussão sobre o que é chamado de classificador "sliding windows" (janelas deslizantes). O primeiro estágio do filtro foi a detecção de texto, onde, olhando para uma imagem como esta, tenta-se encontrar as regiões de texto. Detecção de texto é um problema incomum em visão computacional, pois, dependendo do comprimento do texto que se está tentando encontrar, estes retângulos podem ter diferentes proporções. Para falar sobre detecção de coisas em imagens, vamos começar com um exemplo simples de detecção de pedestres. Depois voltaremos às ideias que foram desenvolvidas na detecção de pedestres e as aplicaremos na detecção de texto. Na detecção de pedestres, deseja-se pegar uma imagem como esta e encontrar pedestres individuais que aparecem na imagem. Este é um pedestre que encontramos, este é o segundo, o terceiro, o quarto, o quinto e o sexto. Este problema é talvez um pouco mais simples que detecção de texto apenas porque as proporções dos pedestres são bem similares. Então, podemos usar apenas uma proporção fixa para estes retângulos que estamos tentando encontrar. Por proporção quero dizer a relação entre a altura e a largura destes retângulos. As proporções são as mesmas para diferentes pedestres, porém, para detecção de texto, a relação entre altura e largura é diferente para diferentes linhas de texto. Na detecção de pedestres, apesar deles estarem a diferentes distâncias da câmera e a altura destes retângulos serem diferentes dependendo de quão distantes estão, a proporção é a mesma. Para construir um sistema de detecção de pedestres, podemos fazer o seguinte. Digamos que decidimos padronizar a proporção como 82 por 36. Poderíamos ter escolhido algum número arredondado, como 80 por 40 por exemplo, mas 82 por 36 parece bom. Depois, o que faríamos é sair e coletar grandes conjuntos de treinamento compostos de exemplos positivos e negativos. Aqui estão exemplos de pedaços de imagens de 82 por 36 que contém pedestres e aqui estão exemplos de imagens que não contém. Neste slide mostro 12 exemplos positivos de "y = 1" e 12 exemplos de "y = 0". Em típicas aplicações de detecção de pedestres, tem-se algo em torno de 1 mil a talvez 10 mil exemplos para treinamento, ou mais ainda se for possível coletar conjuntos maiores de treinamento. E o que se pode fazer então é treinar uma rede neural ou algum outro algoritmo de algoritmo de aprendizado para receber como entrada um pedaço de imagem, de dimensão 82 por 36, e classificá-la (variável "y") como contendo um pedestre ou não. Então, esta é uma forma de se aplicar aprendizado supervisionado para determinar se um pedaço de imagem contém ou não um pedestre. Agora, digamos que coletamos uma nova imagem como esta, uma do conjunto de testes, e queremos tentar encontrar os pedestres que aparecem na imagem. Poderíamos começar pegando um pedação retangular desta imagem, como este mostrado aqui em cima. Este poderia ser um pedaço de 82 por 36. Daí, passamos este pedaço de imagem pelo nosso classificador para determinar se existe ou não um pedestre no pedaço de imagem. E esperamos que o classificador retorne "y = 0" para este pedaço, já que não há pedestres. Depois, pegamos o retângulo verde e movemos um pouco, e rodamos o classificador para esse novo pedaço de imagem, para decidir se há um pedestre ali. E então, deslizamos a janela mais para a direita, e rodamos o classificador novamente. A distância, que você desliza o retângulo a cada iteração, é um parâmetro que, às vezes, é chamado de "step size" (tamanho do passo), e outras vezes é chamado de "stride" (passo). E se você deslizar a janela um pixel por iteração, ou seja, usar um passo de tamanho "1", normalmente, você terá o melhor desempenho, mas terá um custo maior. Portanto, é mais comum usar passos de tamanho 4 pixels, ou 8 pixels, ou um número maior de pixels. Já que você estará movendo o retângulo um pouco mais, a cada iteração. Assim, usando esse processo, você continua movendo o retângulo um pouco à direita, a cada iteração, e rodando cada um dos pedaços pelo classificador, até que, eventualmente, à medida que você desliza essa janela, por diferentes posições na imagem, começando pela primeira linha, e descendo pelas outras linhas dessa imagem, você terá passado todos esse pedaços da imagem, em algum passo, pelo seu classificador. Mas esse era um retângulo pequeno, ele iria detectar apenas pedestres de um tamanho específico. O que faremos em seguida é olhar pedaços maiores da imagem. Então, agora vamos pegar pedaços maiores da imagem, e passá-los pelo classificador também. E, aliás, quando digo "pegar um pedaço maior da imagem", o que eu realmente quero dizer é, quando você pega um pedaço grande, o que você faz é, pegar esse pedaço da imagem, e reduzi-lo para, por exemplo, 82x36. Então, você pega esse pedaço maior e redimensiona, para ser uma imagem menor, e então, é essa imagem menor que você passa pelo classificador, para decidir se há um pedestre naquele pedaço. E, finalmente, você pode fazer isso para janelas ainda maiores, e rodar esse tamanho de janela até o final. E depois de todo esse processo, esperamos que o seu algoritmo detecte os pedestres que aparecem nessa imagem. É assim que você treina um classificador de Aprendizado Supervisionado, e usa um classificador de janela deslizante, ou um detector de janela deslizante, para encontrar pedestres na imagem. Agora, vamos retornar ao problema de detecção de texto, e falar sobre esse estágio no nosso encadeamento do OCR, onde nosso objetivo é encontrar as regiões de texto. Similarmente à detecção de pedestres, você pode ter um conjunto de treino rotulado, com exemplos positivos e negativos, com os exemplos positivos correspondendo a regiões onde aparecem textos. Ao invés de tentar detectar pedestres, vamos tentar detectar textos. Então, exemplos positivos serão pedaços de imagens onde há texto, e exemplos negativos serão pedaços de imagens que não contém texto. Após treinar o classificador, nós podemos aplicá-lo a uma imagem do conjunto de teste. Aqui está a imagem que usamos como exemplo. Para esse exemplo, eu vou utilizar apenas uma janela deslizante com uma escala fixa, para efeito de ilustração, ou seja, vou usar apenas 1 tamanho de retângulo. Digamos que eu rode o meu classificador de janela deslizante em vários pequenos pedaços de imagem como esse. Se eu fizer isso, terminarei com um resultado como esse, onde as regiões em branco mostram onde meu sistema de detecção de texto encontrou texto. E os eixos dessas duas figuras são iguais. Então, a região aqui no topo, corresponde à região no topo da imagem, e o fato de estar preto, significa que o classificador não encontrou nenhum texto no topo da imagem. E o fato de ter um monte de janelas brancas aqui, reflete que o classificador encontrou um monte de texto nesse local, na imagem. O que eu fiz nessa imagem à esquerda foi usar branco para mostrar onde o classificador acredita que encontrou texto. E os diferentes tons de cinza correspondem à probabilidade gerada pelo classificador. Então, os tons de cinza correspondem a onde o classificador acha que encontrou texto, mas não tem muita confiança. Mas o branco brilhante corresponde a onde o classificador estimou uma probabilidade muito alta de haver texto naquele local. Mas nós ainda não terminamos, porque o que realmente queremos é desenhar retângulos em volta de todas as regiões onde há texto na imagem. Então, vamos tomar mais um passo: vamos pegar a saída do classificar, e aplicar a ela o que é chamado "operador de expansão". Então, o que ele faz é: ele pega a imagem à esquerda, e pega cada uma das regiões em branco, e expande essa região branca. Matematicamente, isso é implementado da seguinte forma: o que fazemos para criar a imagem à direita é para cada pixel, perguntamos se existe, dentro de uma certa distância, um pixel branco na imagem à esquerda. E então, se um pixel específico está até 5 ou 10 pixels de um pixel branco, na imagem à esquerda, colorimos esse pixel também, de branco, na imagem à direita. O efeito disso é: vamos pegar cada um dos borrões brancos na imagem à esquerda, e expandi-los um pouco, a partir da observação se os pixels próximos são brancos, e então colorindo esses pixels de branco, também. Finalmente, quase terminamos. Agora podemos olhar a imagem à direita, e ver os componentes conectados, essas regiões brancas, e desenhar caixas retangulares ao redor deles. E se você olhar todas as regiões brancas, como essa, essa, essa, ..., e usar uma heurística simples, para descartar os retângulos cuja razão entre os lados parece estranha, porque nós sabemos que caixas ao redor de textos devem ser mais largas do que altas. Então, se você ignorar os borrões altos e finos, como esse e esse, e se você descartar eles, porque são muito altos e finos, então desenhamos retângulos em volta daqueles cuja razão entre os lados parecem corretas para regiões de texto. Então, podemos desenhar caixas retangulares em volta dessa região de texto, dessa região, e dessa região, correspondendo ao logo da loja "Lula B's", o nome "Lula B's", e esse sinal "OPEN". Nesse exemplo, na verdade, um texto é perdido. É muito difícil ler, mas na verdade, existe um texto ali. Que diz "Lula B's", mas a razão entre os lados do retângulo parecia incorreta, pode isso descartamos. Então, o resultado está okay, mas na verdade, o classificador esqueceu de um texto. É muito difícil de ler, porque está escrito contra uma janela transparente. Então, isso é detecção de texto usando janela deslizante. E, tendo encontrado esses retângulos, com textos neles, podemos cortar essas regiões da imagem, e usar futuros estágios do encadeamento para ler o texto. Agora, lembre-se que o segundo estágio do encadeamento era segmentação dos caracteres. Dada uma imagem como essa no topo, como segmentamos os caracteres individuais nessa imagem? O que podemos fazer é usar um algoritmo de Aprendizado Supervisionado, com um conjunto de exemplos positivos, e exemplos negativos. E vamos olhar um pedaço da imagem, e tentar decidir se há uma quebra entre dois caracteres bem no meio daquela imagem. Então, para cada exemplo positivo, para esse primeiro exemplo, o meio desse pedaço de imagem parece, realmente, a quebra entre dois caracteres. O segundo exemplo, novamente, parece um exemplo positivo, porque colocando uma reta bem no meio, eu quebro ele em dois caracteres. Então, esses são exemplos positivos, onde o meio da imagem representa um espaço, ou uma quebra entre dois caracteres distintos, já para os exemplos negativos, você não quebra dois caracteres, bem no meio. Então eles são exemplos negativos porque não representam o ponto central entre dois caracteres. Então, nós vamos treinar um classificador, talvez usando Redes Neurais, talvez outro algoritmo de aprendizagem, para tentar classificar entre exemplos positivos e negativos. Tendo treinado tal classificador, podemos roda-lo nesse tipo de texto, que o nosso sistema de detecção de texto encontrou. À medida que olhamos esse retângulo verde, e nos perguntamos "O meio desse retângulo verde parece o ponto central entre dois caracteres?". E esperamos que a resposta diga "não", e então, deslizamos a janela. E esse é um classificador de deslizamento de janela de 1 dimensão, porque deslizamos a janela em uma linha reta, da esquerda para a direita, não há outras linhas aqui. Há apenas 1 linha aqui. Mas agora, com o classificador nessa posição, perguntamos se devemos colocar uma quebra no meio desse retângulo. E esperamos que a resposta do classificador seja "y=1", e nesse caso nós vamos desenhar uma linha ali no meio, para quebrar esses 2 caracteres. Então deslizamos a janela novamente, esperamos que o classificador diga "não", deslizamos novamente, esperamos que ele diga "sim, quebre aqui", e assim por diante. E deslizamos o classificador para a direita, e esperamos que ele classifique isso como outro exemplo positivo, e assim por diante. E nós vamos deslizar essa janela para a direita, rodando o classificador a cada passo, e esperamos que ele nos diga quais são as posições corretas para quebrar essa imagem em caracteres individuais. Então, isso é uma janela 1D para segmentação de caracteres. Aqui está, de forma geral, o encadeamento de OCR para fotografia: Nesse vídeo, nós falamos sobre o passo de detecção de texto, onde usamos janelas deslizantes para detectar textos. E nós também usamos uma janela deslizante de 1-dimensão, para fazer a segmentação de caracteres (dividir uma imagem em caracteres). E o último passo no encadeamento, é a classificação de caracteres, e você já deve estar muito mais familiarizado com esse passo, a partir de vídeos anteriores sobre Aprendizado Supervisionado. Onde você pode aplicar um método padrão de Aprendizado Supervisionado, como Redes Neurais, para tomar como entrada uma imagem como essa, e classificar que alfabeto, ou qual dos 26 caracteres de A à Z. Ou podemos ter 36 caracteres, se você tiver os dígitos numéricos. Mas seria um problema de classificação multi-classes, onde você toma como entrada uma imagem contendo um caractere, e decide qual é o caractere que aparece na imagem. Então, esse foi o encadeamento OCR de fotografia, e como você pode usar ideias como: classificadores de janelas deslizantes, para desenvolver uma sistema OCR de fotos. Nos próximos vídeos, continuaremos usando o problema de OCR, para explorar questões sobre como desenvolver um sistema como esse.
Tradução: Pablo de Morais Andrade.