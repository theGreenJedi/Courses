Di video ini, saya ingin menjelaskan mengenai bagaimana memulai K-means dan lebih penting lagi, hal ini akan mengarah kepada diskusi tentang bagaimana untuk membuat K-means menghindari local optima dengan baik berikut adalah algoritma pengelompokan K-means yang telah kita bahas sebelumnya Satu tahap yang kita belum pernah benar-benar membahasnya cukup banyak adalah tentang tahap ini tentang bagaimana secara random anda menginisialisasi pusat-pusat kluster Ada beberapa macam cara berbeda yang dapat dibayangkan untuk secara random menginisialisasi pusat-pusat kluster Tapi, jelas bahwa terdapat satu cara yang sangat direkomendasikan daripada sebagian besar pilihan lainnya yang mungkin terpikirkan oleh karena itu, biarkan saya jelaskan kepada anda tentang pilihan tersebut karena  dirasa yang terbaik Berikut adalah bagaimana saya biasanya memulai pusat-pusat kluster saya ketika menjalankan K-means, anda seharusnya mempunyai jumlah dari pusat-pusat kluster, K, Ditetapkan agar kurang dari jumlah contoh latihan M. Hal ini akan sangat aneh untuk menjalankan K-means dengan jumlah pusat-pusat kluster yang, anda tahu, sama atau lebih besar dari jumlah contoh yang anda miliki, kan? Oleh karena itu, cara yang biasa saya gunakan untuk menginisialisasi K-means, adalah Saya secara random akan mengambil K contoh latihan. Sehingga, apa yang Saya lakukan kemudian adalah mengatur Mu1 hingga MuK sama dengan K contoh ini Saya akan menunjukkan contoh konkritnya Andaikan k sama dengan 2 dan pada contoh berikut di sebelah kanan saya ingin menemuan 2 buah kluster Yang akan saya lakukan untuk menginisialisasi klaster centroid saya adalah, saya akan secara acak mengambil dua buah contoh. dan katakanlah, saya mengambil yang ini dan yang itu. dan cara saya untuk menginisialisasi klaster cendroid saya adalah, saya akan menginisialisasi klaster cendroid saya berada tepat diatas contoh-contoh tersebut. Jadi itulah klaster cendroid pertama saya dan ini adalah klaster cendroid ke-2 saya, dan itulah salah satu initialisasi random dari K-means. yang saya gambar terlihat seperti yang terbaik. dan terkadang saya mungkin saja kurang beruntung dan mungkin akan berakhir memilih itu sebagai contoh initialisasi random pertama saya, dan itu sebagai contoh ke-2. dan disini saya memilih dua contoh karena k = 2. kita telah memilih secara acak dua contoh latihan dan jika saya memilih dua contoh tersebut kemudian saya akan berakhir pada, kemungkinan ini sebagai klaster pertama cendroid saya dan itu sebagai lokasi inisialisasi ke-2 dari klaster cendroid. jadi, begitulah cara Anda dapat secara acak menginisialisasi pusat-pusat kluster jadi pada inisialisasi, Kluster cendroid pertama Anda Mu1 akan sama dengan x(i) untuk beberapa nilai acak dari I dan Mu2 akan sama dengan x(j) untuk perbedaan beberapa nilai yang dipilih secara acak dari j dan seterusnya, jika Anda memiliki lebih banyak lagi kluster cendroid. dan menyortir dari bagian yang umum. Saya harus mengatakan bahwa pada awal-awal video dimana saya pertama-tama mengilustrasikan K-means dengan animasi. Pada set slide tersebut. Hanya untuk tujuan ilustrasi. Saya sebenarnya menggunakan metode yang berbeda untuk menginisialisasikan kluster cendroid saya. Namun metode yang dijelaskan pada slide ini, adalah cara yang paling direkomendasikan. dan cara yang seharusnya digunakan, ketika Anda mengimplementasikan K-means. Jadi, sebagai saran mungkin dengan kedua ilustrasi di kanan ini. Anda mungkin benar-benar menebak bahwa K-means dapat berakhir memusat pada solusi yang berbeda tergantung pada ketepatan bagaimana solusi kluster di inisialisasikan, dan juga, tergantung pada inisialisasi secara acak. K-means dapat berakhir pada solusi yang berbeda. dan, tentunya, K-means sebenarnya dapat berakhir pada optima lokal. Jika kamu memberikan penjualan data seperti ini. sebenarnya, itu terlihat seperti, yah tahu lah, disana terdapat 3 kluster, jika Anda menjalankan K-means dan jika ia berakhir pada sebuah optima lokal yang baik ini kemungkinan optima global, Anda mungkin berakhir pada cincin kluster. Namun jika Anda memiliki sebuah ketidakberuntungan, inisialisasi random, K-means dapat juga dapat terpikat pada optima lokal yang berbeda. Jadi, pada contoh yang kiri ini terlihat seperti kluster biru ini telah menangkap banyak point dibagian kiri dan kemudian berada pada kluster hijau masing-masing diberi keterangan pada jumlah poin yang relatif kecil. dan seterusnya, ini bersesuaian dengan sebuah optima lokal yang buruk karena ia pada dasarnya telah mengambil kedua kluster dan menggunakan mereka dalam 1 dan selain itu, telah memisahkan kluster ke-2 menjadi dua sub-cluster yang terpisah seperti itu, dan ia juga telah mengambil kluster ke-2 dan memisahkannya menjadi dua sub-kluster yang terpisah seperti itu, dan kemudian, kedua contoh pada bagian bawah kanan bersesuaian dengan optima lokak yang berbeda dari K-means dan faktanya, pada contoh ini, kluster, kluster merah telah menangkan hanya 1 contoh optima tunggal. dan masa optima lokal, sebenatnya, mengarah pada optima lokal dari fungsi distorsi J ini, dan Apa solusi yang ada pada bagian kiri bawah, apa yang optima lokal sesuaikan adalah sesungguhnya solusi dimana K-means telah tinggal pada lokal opyima dan ia tidak melakukan sebuah pekerjaan yang sangat bagus dalam meminimalisasi fungsi distrorsi J. Jadi, Jika Anda khawatir mengenai K-means tertinggal di optima lokal, jika Anda ingin meningkatkan peluang K-means menemukan kemungkinan kluster terbaik, seperti yang terlihat di bagian atas sini, apa yang kita dapat lakukan, adalah mencoba beberapa, inisialisasi secara acak. jadi, tidak hanya menginisialisai K-means sekali dan berharap itu bekerja, apa yang dapat kita lakukan adalah, menginisialisasi K-means berkali- kali dan menjalankan K-means berkali- kali, dan gunakan ia untuk mencoba untuk memastikan kita mendapatkan solusi sebaik mungkin, sebaik optima lokal ataupun optima global yang memungkinkan Secara konkrit, disini bagaimana Anda dapat mengetahui cara melakukannya. Katakanlah, Saya memutuskan untuk menjalankan K-means 1000 kali Jadi saya akan menjalankan loop sebanyak 1000 kali dan ia adalah sejenis jumlah yang cukup khas dari waktu ketika sampai akan menjadi sesuatu dari 50 hingga mungkin mencapai 1000. Jadi, katakanlah Anda menutuskan bahwa K-means 100 kali. jadi apa yang terjadi adalah kita akan menginisialisasi K-means secara acak. dan untuk masing-masing dari 100 inisialisasi random kita akan menjalankan K-means dan itu akan memberikan kita satu set Ring kluster, dan satu set kluster cendroid, dan kemudian kita akan menghitung distorsi J, itu adalah perhitungan fungsi cost pada penugasan set kluster dan cendroid kluster yang kita dapatkan. Akhirnya, selesai lah seluruh prosedur 100 kali. Anda akan mendapatkan 100 cara berbeda untuk meng-kluster data dan kemudian akhirnya apa yang Anda lakukan adalah semua 100 cara Anda temukan untuk meng-klaster data, ambil satu saja, yang memberikan biaya terendah. yang memebrikan kita distorsi yang paling sedikit atau terendah. dan kenyataannya bahwa Jika Anda menjalankan K-means dengan sebuah jumlah kecil kluster, maka Anda akan mengetahui jika jumlah dari kluster dimana-mana dari 2 hingga mungkin 10 - lalu lakukan beberapa inisialisasi random bisa sering, bisa kadang-kadang pastikan bahwa anda menemukan optima lokal yang lebih baik. pastikan Anda menemukan data kluster yang lebih baik Namun jika K sangat besar, maka, jika K lebih besar dari 10 tentu saja jika K, Anda tahu, jika Anda mencoba untuk menemukan ratusan kluster, kemudian, mempunyai beberapa inisialisasi random adalah setidaknya membuat sebuah perbedaan besar dan terdapat banyak kesempatan lebih tinggi bahwa inisialisasi random pertama anda akan memberikan Anda sebuah solusi yang cukup baik dan lakukan lagi beberapa random inisialisasi kemungkinananya akan memberikan Anda solusi yang sedikit lebih baik, tapi mungkin tidak terlalu banyak. Namun itu benar-benar pada daerah dimana Anda memiliki jumlah yang relatif kecil dari kluster, khususnya jika Anda memiliki, mungkin 2 atau 3 atau 4 kluster yang mana random inisialiasasinya dapat membuat perbedaan besar dalam hal memastikan Anda melakukan pekerjaan yang baik meminimalisir distorsi fungsi dan memberikan Anda peng-kluster-an yang baik. Jadi, K-means itu tanpa random inisialisasi. jika Anda sedang mencoba untuk mempelajari peng-kluster-an dengan relatif jumlah kluster yang kecil, 2,3, 4,5,mungkin,6,7, menggunakan beberapa random inisialisasi dapat terkadang, membantu Anda menemukan kluster data yang lebih baik. namun, meskipun jika Anda sedang belajar jumlah kluster yang banyak atau besar, inisialisasi, random inisialisasi metode yang di jelaskan disini. Itu seharusnya memberikan K-means titik awal yang wajar untuk dimulai dari untuk mencari set kluster yang bagus.