1
00:00:00,230 --> 00:00:01,364
이 동영상 강의에서,

2
00:00:01,364 --> 00:00:02,699
행렬 간 곱에 대해

3
00:00:02,699 --> 00:00:05,020
이야기 하려고 합니다.

4
00:00:05,020 --> 00:00:06,618
우선 특별한 경우로

5
00:00:06,618 --> 00:00:08,347
시작하겠습니다.

6
00:00:08,350 --> 00:00:12,530
바로 벡터와 행렬의 곱에 대해서 말입니다.

7
00:00:12,530 --> 00:00:13,975
우선 예제를 봅시다.

8
00:00:13,975 --> 00:00:15,722
여기에 행렬과

9
00:00:15,722 --> 00:00:17,283
벡터가 있습니다.

10
00:00:17,283 --> 00:00:18,351
우리는 행렬과

11
00:00:18,351 --> 00:00:21,281
벡터를 곱하기를

12
00:00:21,281 --> 00:00:24,202
원합니다. 결과 값은 어떻게 나올까요?

13
00:00:24,202 --> 00:00:25,209
이번 예제를 통해

14
00:00:25,210 --> 00:00:27,058
확인해보겠습니다.

15
00:00:27,058 --> 00:00:29,886
우리는 어떤 과정으로 진행되는지 확인해 봅시다.

16
00:00:29,886 --> 00:00:31,104
우선 곱셈의 결과 값은,

17
00:00:31,104 --> 00:00:32,912
벡터로

18
00:00:32,912 --> 00:00:34,554
나올 것입니다.

19
00:00:34,560 --> 00:00:35,931
우선 이 괄호를

20
00:00:35,931 --> 00:00:37,108
그릴 것입니다.

21
00:00:37,108 --> 00:00:39,650
나중에 돌아와서 우리가 했던 작업을 다시 봅시다.

22
00:00:39,652 --> 00:00:41,228
벡터의 첫 번째 요소를

23
00:00:41,228 --> 00:00:42,445
얻기 위해 저는

24
00:00:42,445 --> 00:00:44,840
2개의 숫자를

25
00:00:44,849 --> 00:00:47,682
사용할 것입니다.

26
00:00:47,682 --> 00:00:49,463
A행렬의 첫 번째 행과

27
00:00:49,463 --> 00:00:51,884
행의 숫자와 이에 대응하는 수를 곱해서 더할 것입니다.

28
00:00:51,884 --> 00:00:54,223
1×1 +

29
00:00:54,223 --> 00:00:57,430
3×5을 계산하면

30
00:00:57,430 --> 00:00:58,616
1 + 15 로

31
00:00:58,616 --> 00:01:01,557
1 + 15 로

32
00:01:01,580 --> 00:01:04,542
16값이 나옵니다.

33
00:01:04,542 --> 00:01:06,879
여기에는 16이 들어갑니다.

34
00:01:06,880 --> 00:01:09,926
2번째 행을

35
00:01:09,926 --> 00:01:12,555
계산하기위에

36
00:01:12,555 --> 00:01:14,022
우리는 2번째 행과

37
00:01:14,022 --> 00:01:15,255
벡터를 곱할 것입니다.

38
00:01:15,255 --> 00:01:17,762
4×1

39
00:01:17,800 --> 00:01:20,554
+ 0×5

40
00:01:20,554 --> 00:01:21,894
= 결과값 4

41
00:01:21,894 --> 00:01:25,625
를 가질 것 이고 여기에 숫자 4가 들어갑니다.

42
00:01:25,625 --> 00:01:28,168
마지막 행을

43
00:01:28,168 --> 00:01:30,015
계산하기위해

44
00:01:30,015 --> 00:01:31,540
2×1

45
00:01:31,540 --> 00:01:33,791
+ 1×5

46
00:01:33,791 --> 00:01:36,361
1×5 =

47
00:01:36,361 --> 00:01:39,422
7이라는

48
00:01:39,422 --> 00:01:43,145
수식을 계산하고 여기서 7이 들어갑니다.

49
00:01:43,810 --> 00:01:45,464
3×2 행렬과

50
00:01:45,464 --> 00:01:48,102
2×1 행렬의

51
00:01:48,102 --> 00:01:50,750
곱셈 결과는

52
00:01:51,030 --> 00:01:53,498
3차원 벡터로

53
00:01:53,498 --> 00:01:55,504
볼 수 있고 결과값은 다음과 같습니다.

54
00:01:55,504 --> 00:01:57,034
그 결과는

55
00:01:57,040 --> 00:02:01,975
3×1 행렬

56
00:02:01,980 --> 00:02:03,945
입니다. 왜  3×1행렬

57
00:02:03,960 --> 00:02:05,737
일까요?

58
00:02:05,750 --> 00:02:07,534
다른 말로

59
00:02:07,550 --> 00:02:13,141
3×1 행렬은 3차원 벡터입니다.

60
00:02:13,170 --> 00:02:14,359
저는 제가 했던 과정을

61
00:02:14,359 --> 00:02:16,072
빠르게 깨달았습니다.

62
00:02:16,072 --> 00:02:17,078
여러분은 이런 과정을

63
00:02:17,078 --> 00:02:18,530
반복할 수 있다고 확실하지는 않습니다.

64
00:02:18,530 --> 00:02:20,196
그러나 벡터와

65
00:02:20,196 --> 00:02:22,019
행렬 곱셈 과정을

66
00:02:22,020 --> 00:02:26,618
자세히 봅시다.

67
00:02:26,618 --> 00:02:28,478
여기에는 행렬과 벡터가

68
00:02:28,478 --> 00:02:30,532
어떻게 곱해지는지 자세히 나와 있습니다.

69
00:02:30,540 --> 00:02:32,014
제가 행렬 A를 가지고 있고

70
00:02:32,014 --> 00:02:33,355
여기에 벡터× 를

71
00:02:33,355 --> 00:02:35,637
곱하려고 합니다.

72
00:02:35,637 --> 00:02:37,220
그 결과는 벡터 y로 나타납니다.

73
00:02:37,220 --> 00:02:39,569
그 결과는 벡터 y로 나타납니다.

74
00:02:39,569 --> 00:02:41,334
행렬 A는

75
00:02:41,334 --> 00:02:43,388
m×n 행렬입니다.

76
00:02:43,388 --> 00:02:45,062
m개의 row, n개의 column 가집니다.

77
00:02:45,062 --> 00:02:46,570
그리고 여기에 n차원 벡터라

78
00:02:46,570 --> 00:02:49,651
불리는 n×1 행렬을 곱하게 됩니다.

79
00:02:49,651 --> 00:02:51,203
여기서

80
00:02:51,203 --> 00:02:54,694
n과 저기 n이 매칭 되는 것입니다.

81
00:02:54,694 --> 00:02:55,933
다른 말로 행렬의

82
00:02:55,933 --> 00:02:58,560
column의 수라고

83
00:02:58,580 --> 00:03:01,821
할 수 있습니다.

84
00:03:01,821 --> 00:03:03,457
column의 수는

85
00:03:03,457 --> 00:03:06,442
여기서의 row의 수와 같습니다.

86
00:03:06,442 --> 00:03:09,274
이것을 벡터의 차원수와 일치한다고도 이야기 합니다.

87
00:03:09,280 --> 00:03:10,645
그래서 곱셈의 결과는 n차원의 벡터 y가 되는 것입니다.

88
00:03:10,645 --> 00:03:15,681
그래서 곱셈의 결과는 n차원의 벡터 y가 되는 것입니다.

89
00:03:15,761 --> 00:03:19,858
여기 Row들,

90
00:03:19,858 --> 00:03:23,009
M은 매트릭스 A의 row의 수와 같습니다.

91
00:03:23,010 --> 00:03:24,972
M은 매트릭스 A의 row의 수와 같습니다.

92
00:03:24,972 --> 00:03:28,237
M은 매트릭스 A의 row의 수와 같습니다.

93
00:03:28,250 --> 00:03:31,082
여러분은 벡터 Y에 대해서 어떻게 계산하나요?

94
00:03:31,082 --> 00:03:32,110
벡터 Y를 계산하면

95
00:03:32,110 --> 00:03:34,280
그 과정 중에 우리는 yi값을

96
00:03:34,280 --> 00:03:36,860
A의 i번째 행과

97
00:03:37,200 --> 00:03:38,799
곱하게 되고

98
00:03:38,799 --> 00:03:40,218
그것들을 더하게 됩니다.

99
00:03:40,218 --> 00:03:41,623
그것들을 더하게 됩니다.

100
00:03:41,625 --> 00:03:42,464
그래서 이것이 뜻하는 것은 다음과 같습니다.

101
00:03:42,470 --> 00:03:45,035
y 행렬의 첫 번째

102
00:03:45,060 --> 00:03:47,847
값을 얻기 위해,

103
00:03:47,847 --> 00:03:49,980
A행렬의 첫 번째 행과

104
00:03:49,980 --> 00:03:51,424
A행렬의 첫 번째 행과

105
00:03:51,424 --> 00:03:53,012
A행렬의 첫 번째 행과

106
00:03:53,020 --> 00:03:55,486
벡터x의 요소들을 곱합니다.

107
00:03:55,486 --> 00:03:57,680
벡터x의 요소들을 곱합니다.

108
00:03:57,680 --> 00:03:59,842
벡터x의 요소들을 곱합니다.

109
00:03:59,842 --> 00:04:01,755
그래서 각 각들의 첫 번째

110
00:04:01,760 --> 00:04:03,912
숫자끼리 곱셈을 합니다.

111
00:04:03,912 --> 00:04:07,331
그리고 각 숫자들의 2번째 값끼리 곱셈을 진행합니다.

112
00:04:07,331 --> 00:04:09,264
이후 3번째 숫자 끼리 곱셈을 진행하며,

113
00:04:09,264 --> 00:04:10,603
이 과정은 마지막 숫자를

114
00:04:10,603 --> 00:04:12,871
곱할 때 까지 진행합니다.

115
00:04:13,320 --> 00:04:14,578
각 곱셈의 결과들을 더합니다.

116
00:04:14,578 --> 00:04:16,289
각 곱셈의 결과들을 더합니다.

117
00:04:16,300 --> 00:04:19,918
그 값이 y 행렬의 첫 번째 요소입니다.

118
00:04:19,922 --> 00:04:21,690
이제 우리는 y 행렬의

119
00:04:21,690 --> 00:04:25,334
2번째 값을 구하려고 합니다. 바로 이 요소입니다.

120
00:04:25,340 --> 00:04:26,735
우리는 A행렬의 2번째

121
00:04:26,735 --> 00:04:28,688
행을 이용하여

122
00:04:28,688 --> 00:04:30,078
이전 과정을 반복하면 됩니다.

123
00:04:30,078 --> 00:04:31,265
그래서 우리는 A행렬의 2번째 행렬과

124
00:04:31,265 --> 00:04:32,994
그래서 우리는 A행렬의 2번째 행렬과

125
00:04:32,994 --> 00:04:34,407
x의 각 요소들을

126
00:04:34,407 --> 00:04:35,814
곱하고 그 결과 값을

127
00:04:35,830 --> 00:04:37,460
다 더한 후

128
00:04:37,460 --> 00:04:38,402
이것을 y행렬의 2번째 요소로

129
00:04:38,402 --> 00:04:40,107
사용합니다.

130
00:04:40,107 --> 00:04:41,598
우리는 이 방식은 계속 집행합니다.

131
00:04:41,600 --> 00:04:42,839
A행렬의 3번째 행의 값들과

132
00:04:42,850 --> 00:04:44,720
x벡터의 값들을 곱해서

133
00:04:44,720 --> 00:04:47,558
y값들을 구합니다.

134
00:04:47,560 --> 00:04:48,682
곱한 결과 값들을

135
00:04:48,682 --> 00:04:50,246
다 더한 값은 y벡터의 3번째 요소 값입니다.

136
00:04:50,260 --> 00:04:51,600
이 과정을 A행렬의

137
00:04:51,600 --> 00:04:55,139
마지막 행까지 반복합니다.

138
00:04:55,676 --> 00:04:57,930
이것이 절차입니다.

139
00:04:58,340 --> 00:05:00,685
한 가지 예제를 더 보겠습니다.

140
00:05:00,685 --> 00:05:05,240
한 가지 예가 있는데 한번 행렬들이 있습니다.

141
00:05:05,240 --> 00:05:08,428
하나는 3×4 행렬입니다.

142
00:05:08,428 --> 00:05:11,086
하나는 3×4 행렬입니다.

143
00:05:11,086 --> 00:05:13,280
다른 하나는 4차원 벡터입니다.

144
00:05:13,280 --> 00:05:15,292
다른 말로 4×1행렬입니다.

145
00:05:15,292 --> 00:05:16,825
이것이 그 결과이며,

146
00:05:16,825 --> 00:05:18,210
결과 값은 3차원 벡터입니다.

147
00:05:18,220 --> 00:05:20,881
결과 값은 3차원 벡터입니다.

148
00:05:20,890 --> 00:05:23,169
이 벡터는 3개의 공간을

149
00:05:23,180 --> 00:05:26,531
가지는 벡터를 그리겠습니다.

150
00:05:26,531 --> 00:05:30,256
그러면 계산을 해봅시다.

151
00:05:30,256 --> 00:05:32,915
우선 첫 번째 요소를

152
00:05:32,915 --> 00:05:35,068
계산하기 위해

153
00:05:35,068 --> 00:05:36,272
우리는 4개의 수와

154
00:05:36,272 --> 00:05:38,873
벡터x를 곱합니다.

155
00:05:38,873 --> 00:05:42,227
1×1 + 2×3 + 1×2 + 5×1 이 값은

156
00:05:42,568 --> 00:05:47,301
1×1 + 2×3 + 1×2 + 5×1 이 값은

157
00:05:47,301 --> 00:05:49,994
1+6, 2+5 결과 값은 14입니다.

158
00:05:50,050 --> 00:05:55,602
1+6, 2+5 결과 값은 14입니다.

159
00:05:55,630 --> 00:05:58,156
이제 2번째 값을 구해보자,

160
00:05:58,156 --> 00:05:59,754
이제 2번째 값을 구해보자,

161
00:05:59,754 --> 00:06:01,422
이 행과 벡터를 곱하면 됩니다. (0×1) + 3.

162
00:06:01,422 --> 00:06:04,604
이 행과 벡터를 곱하면 됩니다. (0×1) + 3.

163
00:06:04,604 --> 00:06:06,196
0×1+ 3×3 + 0×2 + 4×1

164
00:06:06,243 --> 00:06:12,764
0×1+ 3×3 + 0×2 + 4×1

165
00:06:12,764 --> 00:06:19,958
0×1+ 3×3 + 0×2 + 4×1

166
00:06:20,840 --> 00:06:22,974
이 계산 결과는 9+4로 13입니다.

167
00:06:22,974 --> 00:06:26,105
이 계산 결과는 9+4로 13입니다.

168
00:06:26,105 --> 00:06:28,093
마지막 값을 구하기 위해,

169
00:06:28,093 --> 00:06:29,455
우리는 마지막 행을 사용합니다.

170
00:06:29,455 --> 00:06:30,847
우리는 –1 한 개,

171
00:06:30,847 --> 00:06:33,978
-2 한 개, 나머지는 양수입니다.

172
00:06:34,110 --> 00:06:38,068
-2 한 개, 나머지는 양수입니다.

173
00:06:38,080 --> 00:06:40,656
-1×1 + (-2)×3 + 0×2 + 0×1을 계산하면

174
00:06:40,656 --> 00:06:42,441
-1×1 + (-2)×3 + 0×2 + 0×1을 계산하면

175
00:06:42,441 --> 00:06:44,047
-1×1 + (-2)×3 + 0×2 + 0×1을 계산하면

176
00:06:44,047 --> 00:06:45,496
–7 + 0 이므로 최종 값은 -7입니다.

177
00:06:45,496 --> 00:06:46,474
–7 + 0 이므로 최종 값은 -7입니다.

178
00:06:46,474 --> 00:06:49,636
–7 + 0 이므로 최종 값은 -7입니다.

179
00:06:49,636 --> 00:06:50,136
알겠죠?

180
00:06:50,136 --> 00:06:51,097
그래서 최종적으로

181
00:06:51,097 --> 00:06:54,033
구한 벡터 값은

182
00:06:54,033 --> 00:06:56,117
14, 13, -7이다.

183
00:06:56,117 --> 00:06:59,843
이건 검은색으로 쓰겠습니다.

184
00:07:01,190 --> 00:07:03,567
우리의 예상대로 결과 값은 3×1 행렬입니다.

185
00:07:03,567 --> 00:07:07,775
우리의 예상대로 결과 값은 3×1 행렬입니다.

186
00:07:07,775 --> 00:07:11,147
이것이 행렬과 벡터의 곱셈을 하는 방법입니다.

187
00:07:11,170 --> 00:07:12,309
이번 슬라이드에서 많은 것을 진행되었습니다.

188
00:07:12,309 --> 00:07:13,710
이번 슬라이드에서 많은 것을 진행되었습니다.

189
00:07:13,710 --> 00:07:14,662
만약 여러분이 이 과정들이

190
00:07:14,680 --> 00:07:16,228
정확하게 이해되지 않으면,

191
00:07:16,228 --> 00:07:17,260
잠시 영상을 멈추고

192
00:07:17,280 --> 00:07:18,345
천천히 주의 깊게

193
00:07:18,345 --> 00:07:19,980
천천히 주의 깊게 계산식을 다시 살펴보세요,

194
00:07:19,980 --> 00:07:21,195
천천히 주의 깊게 계산식을 다시 살펴보세요,

195
00:07:21,195 --> 00:07:22,318
이번 과정이 이해되도록 노력 하세요

196
00:07:22,318 --> 00:07:23,755
이번 과정이 이해되도록 노력 하세요

197
00:07:23,760 --> 00:07:25,144
이번 과정이 이해되도록 노력 하세요

198
00:07:25,144 --> 00:07:29,570
이번 과정이 이해되도록 노력 하세요

199
00:07:29,650 --> 00:07:31,959
마지막으로 간단한 트릭을 보여드리겠습니다.

200
00:07:31,959 --> 00:07:33,939
우리는 각기 다른 사이즈의 4개의 집을 가지고 있습니다.

201
00:07:33,940 --> 00:07:36,462
우리는 각기 다른 사이즈의 4개의 집을 가지고 있습니다.

202
00:07:36,462 --> 00:07:38,650
우리는 각기 다른 사이즈의 4개의 집을 가지고 있습니다.

203
00:07:38,650 --> 00:07:39,908
집 가격을 예측하는 함수를 가지고 있는데,

204
00:07:39,908 --> 00:07:41,418
집 가격을 예측하는 함수를 가지고 있는데,

205
00:07:41,420 --> 00:07:43,885
우리는 이것을 계산하여,

206
00:07:43,890 --> 00:07:45,861
h(×) 각 집의 가격을 예측하려고 합니다.

207
00:07:45,861 --> 00:07:49,347
h(×) 각 집의 가격을 예측하려고 합니다.

208
00:07:49,347 --> 00:07:51,039
동시에 우리 집들에 대한 가격을 예측하는 적절한 방법이 있습니다.

209
00:07:51,039 --> 00:07:52,979
동시에 우리 집들에 대한 가격을 예측하는 적절한 방법이 있습니다.

210
00:07:52,980 --> 00:07:56,780
가설함수에 집들의 가격을 모두 적용하는 것입니다.

211
00:07:56,780 --> 00:07:57,795
행렬 벡터 곱셈을 이용한 적절한 방법이 있습니다.

212
00:07:57,795 --> 00:07:59,509
행렬 벡터 곱셈을 이용한 적절한 방법이 있습니다.

213
00:07:59,509 --> 00:08:01,798
행렬 벡터 곱셈을 이용한 적절한 방법이 있습니다.

214
00:08:02,240 --> 00:08:03,672
우리가 해야 할 것이 여기 있습니다.

215
00:08:03,672 --> 00:08:06,717
다음과 같이 행렬을 만듭니다.

216
00:08:06,717 --> 00:08:08,122
행렬을 다음과 같이

217
00:08:08,122 --> 00:08:11,892
1, 1, 1, 1로 구성하고

218
00:08:11,892 --> 00:08:15,495
다음은 집들의 사이즈를 채웁니다.

219
00:08:15,510 --> 00:08:19,935
다음은 집들의 사이즈를 채웁니다.

220
00:08:19,935 --> 00:08:21,249
그리고 우리는 벡터를 만듭니다.

221
00:08:21,249 --> 00:08:23,354
사용하는 벡터는

222
00:08:23,354 --> 00:08:25,609
2개의 값을 가지는데

223
00:08:25,609 --> 00:08:30,072
2개의 값을 가지는데

224
00:08:30,072 --> 00:08:32,182
–40과 0.25입니다.

225
00:08:32,182 --> 00:08:34,607
이건 2개의 계수입니다. 바로 데이터 0, 1입니다.

226
00:08:34,607 --> 00:08:35,432
이건 2개의 계수입니다. 바로 데이터 0, 1입니다.

227
00:08:35,432 --> 00:08:36,835
이제 우리가 할 일은 행렬과 벡터를 곱하는 것입니다.

228
00:08:36,835 --> 00:08:38,048
이제 우리가 할 일은 행렬과 벡터를 곱하는 것입니다.

229
00:08:38,060 --> 00:08:39,708
이제 우리가 할 일은 행렬과 벡터를 곱하는 것입니다.

230
00:08:39,708 --> 00:08:42,465
여기서 곱은 곱셈 기호를 뜻합니다.

231
00:08:42,465 --> 00:08:43,288
우리는 무엇을 얻을 가요?

232
00:08:43,288 --> 00:08:46,412
이건 4×2 행렬입니다.

233
00:08:46,420 --> 00:08:48,228
이건 4×2 행렬입니다.

234
00:08:48,228 --> 00:08:52,005
이건 2×1행렬입니다.

235
00:08:52,005 --> 00:08:53,952
결과 값은 4×1벡터입니다.

236
00:08:53,952 --> 00:08:55,355
결과 값은 4×1벡터입니다.

237
00:08:55,355 --> 00:08:59,506
결과 값은 4×1벡터입니다.

238
00:08:59,520 --> 00:09:02,860
4×1행렬이 결과 값이며

239
00:09:02,870 --> 00:09:05,334
4×1행렬이 결과 값이며

240
00:09:05,334 --> 00:09:06,188
이건 4차원 벡터입니다.

241
00:09:06,188 --> 00:09:06,957
이건 4차원 벡터입니다.

242
00:09:06,957 --> 00:09:10,035
4개의 실수 값을 가지는 요소 값들 쓰겠습니다.

243
00:09:10,035 --> 00:09:11,562
4개의 실수 값을 가지는 요소 값들 쓰겠습니다.

244
00:09:11,562 --> 00:09:15,991
4개의 실수 값을 가지는 요소 값들 쓰겠습니다.

245
00:09:16,010 --> 00:09:17,202
이제 첫 번째 요소

246
00:09:17,202 --> 00:09:18,952
값을 계산 해보겠습니다.

247
00:09:18,952 --> 00:09:20,497
값을 계산 해보겠습니다.

248
00:09:20,497 --> 00:09:21,505
우리는 첫 번째 행과

249
00:09:21,505 --> 00:09:25,526
가져오고 이 값과 벡터 값을 곱하겠습니다.

250
00:09:25,526 --> 00:09:29,381
다음 식

251
00:09:29,381 --> 00:09:33,053
-40×1 + 4.25×2104을 계산하면

252
00:09:33,053 --> 00:09:37,645
-40×1 + 4.25×2104을 계산하면

253
00:09:37,645 --> 00:09:38,998
그런데 이전 슬라이드에서는

254
00:09:38,998 --> 00:09:40,915
그런데 이전 슬라이드에서는

255
00:09:40,915 --> 00:09:42,257
저는 1×–40 그리고 2104×0.25 적었는데,

256
00:09:42,260 --> 00:09:44,405
저는 1×–40 그리고 2104×0.25 적었는데,

257
00:09:44,405 --> 00:09:46,570
이건 전혀 문제가 되지 않습니다.

258
00:09:46,580 --> 00:09:49,637
-40×1 와 1×–40. 2개는 같은 것입니다.

259
00:09:49,637 --> 00:09:52,115
그래서 첫 번째 값은 h(2104)입니다.

260
00:09:52,115 --> 00:09:55,288
그래서 첫 번째 값은 h(2104)입니다.

261
00:09:55,288 --> 00:09:57,395
이것이 우리의 첫 번째 집의 예측 가격입니다.

262
00:09:57,395 --> 00:09:59,969
이것이 우리의 첫 번째 집의 예측 가격입니다.

263
00:09:59,969 --> 00:10:02,351
2번째 요소는 어떻게 될까요?,

264
00:10:02,390 --> 00:10:04,089
여러분이 제가 2번째 요소 값을

265
00:10:04,089 --> 00:10:07,912
계산할 때 확인하기를 바랍니다.

266
00:10:07,912 --> 00:10:08,750
그렇지 않습니까?

267
00:10:08,750 --> 00:10:11,052
이거와 벡터를 곱하면 됩니다.

268
00:10:11,052 --> 00:10:13,154
-40×1 + 0.25×1416 이걸 계산하면

269
00:10:13,180 --> 00:10:15,038
-40×1 + 0.25×1416 이걸 계산하면

270
00:10:15,038 --> 00:10:23,037
h(1416)을 계산하는 것입니다. 맞지요?

271
00:10:23,110 --> 00:10:23,110
그렇지 않습니까?

272
00:10:25,810 --> 00:10:27,024
세 번째와 4번째 요소들도 같은 방법으로 계산합니다.

273
00:10:27,024 --> 00:10:30,720
세 번째와 4번째 요소들도 같은 방법으로 계산합니다.

274
00:10:30,760 --> 00:10:33,797
세 번째와 4번째 요소들도 같은 방법으로 계산합니다.

275
00:10:33,800 --> 00:10:37,142
그리고 여기,

276
00:10:37,142 --> 00:10:39,239
제가 초록색 박스로

277
00:10:39,239 --> 00:10:41,131
그린 부분은 실수입니다.

278
00:10:41,131 --> 00:10:42,752
이건 하나의 실수이고

279
00:10:42,752 --> 00:10:44,169
보라색 박스로 가리키는 것

280
00:10:44,180 --> 00:10:45,673
, 퍼플, 마젠타 색으로

281
00:10:45,680 --> 00:10:47,812
, 퍼플, 마젠타 색으로

282
00:10:47,812 --> 00:10:49,826
칠한 각 박스들도 실수입니다.

283
00:10:49,850 --> 00:10:50,908
칠한 각 박스들도 실수입니다.

284
00:10:50,920 --> 00:10:52,683
오른쪽에 이것들은

285
00:10:52,683 --> 00:10:54,104
오른쪽에 이것들은

286
00:10:54,104 --> 00:10:55,200
4×1 행렬의 값이며

287
00:10:55,220 --> 00:10:59,288
이건 4차원 벡터입니다.

288
00:10:59,288 --> 00:11:00,728
여러분이 이것을

289
00:11:00,728 --> 00:11:02,128
SW방식으로 구현할 때

290
00:11:02,130 --> 00:11:04,613
SW방식으로 구현할 때

291
00:11:04,613 --> 00:11:06,344
, 4개의 집을 가지고 있고,

292
00:11:06,350 --> 00:11:08,525
여러분이 집값을 예측하는 hypothesis를 사용하고 싶을 때,

293
00:11:08,525 --> 00:11:12,308
집들의 예측가격을 나타내는 행렬 Y를 사용할 수 있습니다.

294
00:11:12,308 --> 00:11:13,553
이것이 의미하는 건 여러분은 이것을 코드로 쓸 수 있다는 것입니다.

295
00:11:13,553 --> 00:11:16,130
이것이 의미하는 건 여러분은 이것을 코드로 쓸 수 있다는 것입니다.

296
00:11:16,140 --> 00:11:17,878
나중에 프로그램 언어나 octave에 대해 이야기 할 때,

297
00:11:17,878 --> 00:11:19,782
나중에 프로그램 언어나 octave에 대해 이야기 할 때,

298
00:11:19,790 --> 00:11:22,120
여러분은 확실히 이것을 코드로 작성할 수 있을 것입니다.

299
00:11:22,120 --> 00:11:24,879
여러분은 예측 식을 데이터

300
00:11:24,879 --> 00:11:29,697
행렬×파라미터 값으로 쓸 수 있고,

301
00:11:30,582 --> 00:11:33,888
행렬×파라미터 값으로 쓸 수 있고,

302
00:11:33,890 --> 00:11:36,994
데이터와 파라미터 값들이

303
00:11:36,994 --> 00:11:38,661
있으면 행렬과 벡터의

304
00:11:38,661 --> 00:11:40,447
곱셈으로 표기됩니다.

305
00:11:40,447 --> 00:11:44,138
곱셈으로 표기됩니다.

306
00:11:44,138 --> 00:11:45,834
만약 여러분이 이 변수 예측을 할 경우,

307
00:11:45,834 --> 00:11:47,579
만약 여러분이 이 변수 예측을 할 경우,

308
00:11:47,579 --> 00:11:49,270
나쁜 글씨 때문에 죄송합니다.

309
00:11:49,270 --> 00:11:50,942
적절한 라이브러리를 이용하여

310
00:11:50,942 --> 00:11:52,357
행렬 벡터의 곱을

311
00:11:52,357 --> 00:11:55,328
구현할 수 있습니다.

312
00:11:55,328 --> 00:11:56,518
만역 여러분들이 구현을 한다면,

313
00:11:56,518 --> 00:11:58,965
결과 값은 4차원 벡터로 나올 것이고

314
00:11:58,965 --> 00:12:00,714
오른쪽과 같이 여러분께

315
00:12:00,714 --> 00:12:04,655
예측가격을 알려 줄 것입니다.

316
00:12:04,655 --> 00:12:07,163
그리고 여러분이 행렬 벡터 곱의

317
00:12:07,163 --> 00:12:09,286
그리고 여러분이 행렬 벡터 곱의

318
00:12:09,310 --> 00:12:11,241
대안으로 다음과 같은 방법이 있습니다.

319
00:12:11,241 --> 00:12:13,542
for I = 1~4입니다.

320
00:12:13,542 --> 00:12:15,150
그리고 수 천개의 집 가격을  계산한다면

321
00:12:15,160 --> 00:12:17,451
for I = 1~수천 이라고 표기하여

322
00:12:17,451 --> 00:12:18,772
사용할수 있습니다.

323
00:12:18,772 --> 00:12:21,898
그리고 prediction(i) 쓰면 됩니다.

324
00:12:21,910 --> 00:12:23,123
많은 수의 데이터에서

325
00:12:23,130 --> 00:12:25,645
더욱 효율적으로 사용 가능하며,

326
00:12:25,645 --> 00:12:27,188
여러분이 훨씬 많은 집을 가진 경우

327
00:12:27,188 --> 00:12:28,549
여러분이 훨씬 많은 집을 가진 경우

328
00:12:28,549 --> 00:12:29,928
여러분은 구현 시 4개의 집을 예측하려고

329
00:12:29,930 --> 00:12:31,033
여러분은 구현 시 4개의 집을 예측하려고

330
00:12:31,033 --> 00:12:33,230
하지 않고 수천 개의 집을 예측하려고 할 것입니다.

331
00:12:33,410 --> 00:12:35,175
컴퓨터 내부에서 위 과정을 구현하려고 한다면,

332
00:12:35,175 --> 00:12:36,118
컴퓨터 내부에서 위 과정을 구현하려고 한다면,

333
00:12:36,118 --> 00:12:40,087
여러 개의 언어를 이용할수 있습니다.

334
00:12:40,087 --> 00:12:41,535
이건 Octave뿐 만아니라

335
00:12:41,535 --> 00:12:43,022
다른 자바, 파이썬 같은

336
00:12:43,030 --> 00:12:46,252
하이레벨 언어에도 해당합니다.

337
00:12:46,252 --> 00:12:48,045
왼쪽 같은 스타일로 코드를 작성하면

338
00:12:48,045 --> 00:12:49,811
여러분은 코드를 간단히

339
00:12:49,811 --> 00:12:51,552
만들 수 없습니다.

340
00:12:51,552 --> 00:12:53,283
만들 수 없습니다.

341
00:12:53,283 --> 00:12:54,677
왜냐하면 데이터들의 형식보다

342
00:12:54,677 --> 00:12:55,857
왜냐하면 데이터들의 형식보다

343
00:12:55,870 --> 00:12:58,427
하나의 코드를 쓴 것이기 때문입니다.

344
00:12:58,450 --> 00:12:59,727
몇 가지 이유 때문에,

345
00:12:59,730 --> 00:13:01,398
우리는 나중에 보겠지만

346
00:13:01,400 --> 00:13:03,392
모든 집의 가격을 예측하는 것을

347
00:13:03,392 --> 00:13:05,617
모든 집의 가격을 예측하는 것을

348
00:13:05,617 --> 00:13:06,583
만들기 위해

349
00:13:06,583 --> 00:13:08,348
왼쪽 방법이 당신이

350
00:13:08,360 --> 00:13:09,693
수식을 적은 오른쪽 방법 보다

351
00:13:09,693 --> 00:13:13,334
더 효율적으로 계산합니다.

352
00:13:13,334 --> 00:13:14,596
나중에 vectorization에 대해 이야기 할 때

353
00:13:14,596 --> 00:13:15,978
나중에 vectorization에 대해 이야기 할 때

354
00:13:15,978 --> 00:13:17,684
나중에 vectorization에 대해 이야기 할 때

355
00:13:17,684 --> 00:13:19,145
이야기 하겠지만,

356
00:13:19,145 --> 00:13:20,511
vectorization는 좀 더 간단한 코드는

357
00:13:20,511 --> 00:13:23,200
아니지만 훨씬 효율적인 방법입니다.

358
00:13:23,200 --> 00:13:25,151
이것이 행렬과 벡터의 곱셈입니다.

359
00:13:25,151 --> 00:13:27,063
우리는 이러한 곱셈을

360
00:13:27,063 --> 00:13:28,432
다른 모델에서 regression를

361
00:13:28,432 --> 00:13:30,352
개발하기 위한 연산자로

362
00:13:30,370 --> 00:13:32,888
잘 활용할 수 있습니다.

363
00:13:32,910 --> 00:13:34,259
다음 영상에서는 우리는

364
00:13:34,259 --> 00:13:36,150
이것에 대해 이야기하고 이것을

365
00:13:36,150 --> 00:13:39,527
일반화하기 위해 행렬끼리의 곱셈에 대해 이야기 하겠습니다.