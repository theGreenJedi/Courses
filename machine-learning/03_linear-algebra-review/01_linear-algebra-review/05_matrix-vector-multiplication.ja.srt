1
00:00:00,230 --> 00:00:01,364
このビデオで私は

2
00:00:01,364 --> 00:00:02,699
2つの行列をどう掛けあわせるかを

3
00:00:02,699 --> 00:00:05,020
話して行きたいと思います。

4
00:00:05,020 --> 00:00:06,618
まずその特別なケースである

5
00:00:06,618 --> 00:00:08,347
行列とベクトルの積を話していきたい。

6
00:00:08,350 --> 00:00:12,530
行列をベクトルに掛けるという事。

7
00:00:12,530 --> 00:00:13,975
例を見る事から始めよう。

8
00:00:13,975 --> 00:00:15,722
ここに行列があって、

9
00:00:15,722 --> 00:00:17,283
ここにベクトルがあり、

10
00:00:17,283 --> 00:00:18,351
これらの

11
00:00:18,351 --> 00:00:21,281
行列とベクトルを

12
00:00:21,281 --> 00:00:24,202
掛け合わせたいとしよう。結果はどうなるか？

13
00:00:24,202 --> 00:00:25,209
まずこの例を見ていき

14
00:00:25,210 --> 00:00:27,058
そしてその後、

15
00:00:27,058 --> 00:00:29,886
一歩さがってどのような手順となるかを見てみよう。

16
00:00:29,886 --> 00:00:31,104
この掛け算のプロセスは

17
00:00:31,104 --> 00:00:32,912
結果がそれ自体

18
00:00:32,912 --> 00:00:34,554
ベクトルとなる。

19
00:00:34,560 --> 00:00:35,931
そしてまず、これをやってみて、

20
00:00:35,931 --> 00:00:37,108
そしてのちに、

21
00:00:37,108 --> 00:00:39,650
戻ってきて何をやったのか見直す。

22
00:00:39,652 --> 00:00:41,228
このベクトルの最初の要素を取り出す為、

23
00:00:41,228 --> 00:00:42,445
私は

24
00:00:42,445 --> 00:00:44,840
これら2つの数を取り出し

25
00:00:44,849 --> 00:00:47,682
これらを行列の

26
00:00:47,682 --> 00:00:49,463
最初の行を取って

27
00:00:49,463 --> 00:00:51,884
掛けて、対応する数を足し合わせる。

28
00:00:51,884 --> 00:00:54,223
1を取り出して

29
00:00:54,223 --> 00:00:57,430
1と掛け合わせる。

30
00:00:57,430 --> 00:00:58,616
そして3を取り出し

31
00:00:58,616 --> 00:01:01,557
5と掛け合わせる。

32
00:01:01,580 --> 00:01:04,542
すると1+15だから、16となる。

33
00:01:04,542 --> 00:01:06,879
ここに16と書く。

34
00:01:06,880 --> 00:01:09,926
次に、二行目は

35
00:01:09,926 --> 00:01:12,555
二番目の要素、

36
00:01:12,555 --> 00:01:14,022
二番目の行を取り出して

37
00:01:14,022 --> 00:01:15,255
このベクトルに掛ける。

38
00:01:15,255 --> 00:01:17,762
つまり、4掛ける1に

39
00:01:17,800 --> 00:01:20,554
足す事の0掛ける5に

40
00:01:20,554 --> 00:01:21,894
つまり4となる。

41
00:01:21,894 --> 00:01:25,625
それはイコール4だ。つまり4が答えだ。

42
00:01:25,625 --> 00:01:28,168
そして最後の奴は

43
00:01:28,168 --> 00:01:30,015
2、1掛ける1、5。

44
00:01:30,015 --> 00:01:31,540
だから2掛ける1

45
00:01:31,540 --> 00:01:33,791
足す事の1掛ける5。

46
00:01:33,791 --> 00:01:36,361
イコール、、、

47
00:01:36,361 --> 00:01:39,422
7。つまり、

48
00:01:39,422 --> 00:01:43,145
ここは7となる。

49
00:01:43,810 --> 00:01:45,464
3掛ける2行列と

50
00:01:45,464 --> 00:01:48,102
2掛ける1行列の積もまた、

51
00:01:48,102 --> 00:01:50,750
その結果は

52
00:01:51,030 --> 00:01:53,498
単なる二次元ベクトルと

53
00:01:53,498 --> 00:01:55,504
なる事が分かった。

54
00:01:55,504 --> 00:01:57,034
この結果は

55
00:01:57,040 --> 00:02:01,975
3x1行列となる。

56
00:02:01,980 --> 00:02:03,945
そんな訳で

57
00:02:03,960 --> 00:02:05,737
3掛ける1、つまり3x1行列に

58
00:02:05,750 --> 00:02:07,534
なる訳だが、言い換えると

59
00:02:07,550 --> 00:02:13,141
3x1行列はただの3次元ベクトル。

60
00:02:13,170 --> 00:02:14,359
分かってる、

61
00:02:14,359 --> 00:02:16,072
ちょっと早くやりすぎたね。

62
00:02:16,072 --> 00:02:17,078
だからたぶんあなたは自分一人でやりなおせるか、ちょっと不安だろう。

63
00:02:17,078 --> 00:02:18,530
だが

64
00:02:18,530 --> 00:02:20,196
何が起きたのか、

65
00:02:20,196 --> 00:02:22,019
より詳細に見てみよう。

66
00:02:22,020 --> 00:02:26,618
この行列のベクトルに対する掛け算がどんなかを。

67
00:02:26,618 --> 00:02:28,478
これが、行列をベクトルに

68
00:02:28,478 --> 00:02:30,532
どうやって掛けるかの詳細だ。

69
00:02:30,540 --> 00:02:32,014
行列Aがあって、

70
00:02:32,014 --> 00:02:33,355
それをベクトルxに

71
00:02:33,355 --> 00:02:35,637
掛けたいとしよう。

72
00:02:35,637 --> 00:02:37,220
結果はあるベクトルyに

73
00:02:37,220 --> 00:02:39,569
なるだろう。

74
00:02:39,569 --> 00:02:41,334
行列Aはm掛けるn次元の

75
00:02:41,334 --> 00:02:43,388
行列で、

76
00:02:43,388 --> 00:02:45,062
m行n列で、

77
00:02:45,062 --> 00:02:46,570
それをn掛ける1行列に

78
00:02:46,570 --> 00:02:49,651
言い換えるとn次元ベクトルに掛けようとしている。

79
00:02:49,651 --> 00:02:51,203
ここの、

80
00:02:51,203 --> 00:02:54,694
このnはこのnと一致してるのが分かる。

81
00:02:54,694 --> 00:02:55,933
言い換えると、この行列の

82
00:02:55,933 --> 00:02:58,560
列の総数、

83
00:02:58,580 --> 00:03:01,821
n列が、

84
00:03:01,821 --> 00:03:03,457
ここの列の総数が

85
00:03:03,457 --> 00:03:06,442
ここの行の総数に一致しなくてはならない。

86
00:03:06,442 --> 00:03:09,274
それはこのベクトルの次元にマッチしなくてはならない。

87
00:03:09,280 --> 00:03:10,645
そしてこの積の結果は

88
00:03:10,645 --> 00:03:15,681
n次元ベクトル

89
00:03:15,761 --> 00:03:19,858
yとなる。この行、

90
00:03:19,858 --> 00:03:23,009
mは、行列Aの

91
00:03:23,010 --> 00:03:24,972
行の総数と

92
00:03:24,972 --> 00:03:28,237
等しい。

93
00:03:28,250 --> 00:03:31,082
で、そのyは実際にはどう計算するか？

94
00:03:31,082 --> 00:03:32,110
このベクトル、

95
00:03:32,110 --> 00:03:34,280
yを求めるプロセスは

96
00:03:34,280 --> 00:03:36,860
つまりyのiを求めるには、

97
00:03:37,200 --> 00:03:38,799
Aのi番目の行に

98
00:03:38,799 --> 00:03:40,218
ベクトルxの要素を掛け合わせて、

99
00:03:40,218 --> 00:03:41,623
そして足し合わせる。

100
00:03:41,625 --> 00:03:42,464
つまり、こういう事だ。

101
00:03:42,470 --> 00:03:45,035
yの最初の要素を

102
00:03:45,060 --> 00:03:47,847
得るためには、

103
00:03:47,847 --> 00:03:49,980
その最初の数字は--それがどうなるにせよ--

104
00:03:49,980 --> 00:03:51,424
行列Aの

105
00:03:51,424 --> 00:03:53,012
最初の行を取って

106
00:03:53,020 --> 00:03:55,486
それを一度に一つずつ

107
00:03:55,486 --> 00:03:57,680
このベクトルの要素と

108
00:03:57,680 --> 00:03:59,842
掛けていく。

109
00:03:59,842 --> 00:04:01,755
つまり、この最初の数取って、

110
00:04:01,760 --> 00:04:03,912
この最初の数に掛ける。

111
00:04:03,912 --> 00:04:07,331
次に二番目の数を取って、二番目の数と掛ける。

112
00:04:07,331 --> 00:04:09,264
この三番目の数を取って、それがなんであれ、

113
00:04:09,264 --> 00:04:10,603
三番目の数と掛ける。

114
00:04:10,603 --> 00:04:12,871
それを終わりまで続ける。

115
00:04:13,320 --> 00:04:14,578
そして、これら3つの積の結果を

116
00:04:14,578 --> 00:04:16,289
足し合わせると、その結果は

117
00:04:16,300 --> 00:04:19,918
このyの最初の要素となる。

118
00:04:19,922 --> 00:04:21,690
次に、yの二番目の要素を

119
00:04:21,690 --> 00:04:25,334
得ようと思ったら、

120
00:04:25,340 --> 00:04:26,735
それを行う方法は

121
00:04:26,735 --> 00:04:28,688
Aの二番目の行を取って、

122
00:04:28,688 --> 00:04:30,078
それを得る方法は

123
00:04:30,078 --> 00:04:31,265
Aの二番目の行を取って

124
00:04:31,265 --> 00:04:32,994
それを要素ごとに

125
00:04:32,994 --> 00:04:34,407
掛ける。つまり、

126
00:04:34,407 --> 00:04:35,814
xの要素と、と言う事。そしてその掛けた結果を

127
00:04:35,830 --> 00:04:37,460
足し合わせる。

128
00:04:37,460 --> 00:04:38,402
その結果がyの

129
00:04:38,402 --> 00:04:40,107
二番目の要素になるという訳。

130
00:04:40,107 --> 00:04:41,598
そしてどんどん続けて、

131
00:04:41,600 --> 00:04:42,839
Aの三番目の行を取り

132
00:04:42,850 --> 00:04:44,720
要素ごとに掛ける、

133
00:04:44,720 --> 00:04:47,558
ベクトルxと。

134
00:04:47,560 --> 00:04:48,682
そして結果を足し合わせて、

135
00:04:48,682 --> 00:04:50,246
三番目の要素を得る。

136
00:04:50,260 --> 00:04:51,600
それを最後の行まで

137
00:04:51,600 --> 00:04:55,139
続ける。OK？

138
00:04:55,676 --> 00:04:57,930
以上が実際の手続きとなる。

139
00:04:58,340 --> 00:05:00,685
さらにもう一つ例を見てみよう。

140
00:05:00,685 --> 00:05:05,240
これがその例だ。まず次元に注目。

141
00:05:05,240 --> 00:05:08,428
ここで、これは3掛ける4の

142
00:05:08,428 --> 00:05:11,086
行列。

143
00:05:11,086 --> 00:05:13,280
これは4次元ベクトル、または

144
00:05:13,280 --> 00:05:15,292
4x1行列で、

145
00:05:15,292 --> 00:05:16,825
だからこの結果、

146
00:05:16,825 --> 00:05:18,210
この積の結果は、

147
00:05:18,220 --> 00:05:20,881
三次元ベクトルとなる。

148
00:05:20,890 --> 00:05:23,169
だから3つの要素の入るスペースの

149
00:05:23,180 --> 00:05:26,531
ベクトルを書く。

150
00:05:26,531 --> 00:05:30,256
では掛け算を実行しよう。

151
00:05:30,256 --> 00:05:32,915
最初の要素は

152
00:05:32,915 --> 00:05:35,068
これら4つの数字を取ってきて

153
00:05:35,068 --> 00:05:36,272
ベクトルxに掛ける。

154
00:05:36,272 --> 00:05:38,873
つまり結果は

155
00:05:38,873 --> 00:05:42,227
1x1足す2x3足す

156
00:05:42,568 --> 00:05:47,301
1x2足す5x1だから、

157
00:05:47,301 --> 00:05:49,994
それはイコール

158
00:05:50,050 --> 00:05:55,602
1+6+2+5。つまり14。

159
00:05:55,630 --> 00:05:58,156
そして次に

160
00:05:58,156 --> 00:05:59,754
二番目の要素は

161
00:05:59,754 --> 00:06:01,422
この列を今度は取って

162
00:06:01,422 --> 00:06:04,604
それをこのベクトルに掛ける！

163
00:06:04,604 --> 00:06:06,196
0x1足す、3、、、

164
00:06:06,243 --> 00:06:12,764
0x1足す3x3足す、

165
00:06:12,764 --> 00:06:19,958
0x2足す4x1で、

166
00:06:20,840 --> 00:06:22,974
つまりイコール、、、

167
00:06:22,974 --> 00:06:26,105
9+4だから、13。

168
00:06:26,105 --> 00:06:28,093
最後に、一番下の要素は、

169
00:06:28,093 --> 00:06:29,455
この最後の列を取って、

170
00:06:29,455 --> 00:06:30,847
つまり、

171
00:06:30,847 --> 00:06:33,978
マイナス1掛ける1。

172
00:06:34,110 --> 00:06:38,068
次に-2だけど、プラスを付けておく方が分かりやすいでしょう、

173
00:06:38,080 --> 00:06:40,656
掛ける3、足す事の

174
00:06:40,656 --> 00:06:42,441
0掛ける2、足す事の0掛ける1。

175
00:06:42,441 --> 00:06:44,047
つまり、以上から

176
00:06:44,047 --> 00:06:45,496
-1-6。

177
00:06:45,496 --> 00:06:46,474
だから結果は

178
00:06:46,474 --> 00:06:49,636
負の7。

179
00:06:49,636 --> 00:06:50,136
分かりましたか。

180
00:06:50,136 --> 00:06:51,097
だから最終的な答えとしては、

181
00:06:51,097 --> 00:06:54,033
このベクトル、14と、、、

182
00:06:54,033 --> 00:06:56,117
カラー無しで書くと、14と

183
00:06:56,117 --> 00:06:59,843
13、-7。

184
00:07:01,190 --> 00:07:03,567
そして決まり通り、

185
00:07:03,567 --> 00:07:07,775
この結果は3掛ける1行列となる。

186
00:07:07,775 --> 00:07:11,147
これが行列とベクトルの掛け方。

187
00:07:11,170 --> 00:07:12,309
このスライドでは

188
00:07:12,309 --> 00:07:13,710
たくさんの事を話しました。

189
00:07:13,710 --> 00:07:14,662
もしあなたがこれらの数字全てが

190
00:07:14,680 --> 00:07:16,228
どこに行くのか、しっかり分かっていなければ、

191
00:07:16,228 --> 00:07:17,260
ビデオを一旦一時停止して

192
00:07:17,280 --> 00:07:18,345
ゆっくりと時間をかけて

193
00:07:18,345 --> 00:07:19,980
私が今やった計算を

194
00:07:19,980 --> 00:07:21,195
追いかけて

195
00:07:21,195 --> 00:07:22,318
これらの数字、

196
00:07:22,318 --> 00:07:23,755
14、13、11をどうやって得たのかの

197
00:07:23,760 --> 00:07:25,144
ステップを

198
00:07:25,144 --> 00:07:29,570
しっかりと確認して下さい。

199
00:07:29,650 --> 00:07:31,959
最後に、ちょっと素敵なトリックをご紹介。

200
00:07:31,959 --> 00:07:33,939
例として、

201
00:07:33,940 --> 00:07:36,462
4つの家があるとしよう。

202
00:07:36,462 --> 00:07:38,650
このように、四つのサイズの家がある。

203
00:07:38,650 --> 00:07:39,908
そしてこんな仮定があるとする、

204
00:07:39,908 --> 00:07:41,418
家の価格を推測する、という。

205
00:07:41,420 --> 00:07:43,885
そして

206
00:07:43,890 --> 00:07:45,861
私は、この四つの家に対して、

207
00:07:45,861 --> 00:07:49,347
HのXを計算したいとする。

208
00:07:49,347 --> 00:07:51,039
これを行う、うまいやり方があるのが

209
00:07:51,039 --> 00:07:52,979
わかる。

210
00:07:52,980 --> 00:07:56,780
この仮説をこれらの家全てに同時に適用する方法が。

211
00:07:56,780 --> 00:07:57,795
これをやるうまいやり方、というのは

212
00:07:57,795 --> 00:07:59,509
行列の乗算を使った物だ、というのが

213
00:07:59,509 --> 00:08:01,798
分かる。

214
00:08:02,240 --> 00:08:03,672
これが、どうやるか、だ。

215
00:08:03,672 --> 00:08:06,717
私は行列を以下のように構築する。

216
00:08:06,717 --> 00:08:08,122
私の行列は

217
00:08:08,122 --> 00:08:11,892
1、1、1、1で掛ける事の

218
00:08:11,892 --> 00:08:15,495
4つの家のサイズを

219
00:08:15,510 --> 00:08:19,935
ここに書いて

220
00:08:19,935 --> 00:08:21,249
ベクトルを同様に構成する。

221
00:08:21,249 --> 00:08:23,354
私のベクトルは

222
00:08:23,354 --> 00:08:25,609
2つの要素のベクトルで

223
00:08:25,609 --> 00:08:30,072
それはこの

224
00:08:30,072 --> 00:08:32,182
-40と0.25。

225
00:08:32,182 --> 00:08:34,607
それはこれら2つの相関係数だ。

226
00:08:34,607 --> 00:08:35,432
data0とdata1。

227
00:08:35,432 --> 00:08:36,835
そしてやりたい事は、

228
00:08:36,835 --> 00:08:38,048
行列とベクトルをとってきて

229
00:08:38,060 --> 00:08:39,708
それらを掛け合わせたい。

230
00:08:39,708 --> 00:08:42,465
その掛け合わせる、というのにも、その掛け算の記号を使う。

231
00:08:42,465 --> 00:08:43,288
で、結果、何を得る？

232
00:08:43,288 --> 00:08:46,412
これは

233
00:08:46,420 --> 00:08:48,228
4掛ける2行列。

234
00:08:48,228 --> 00:08:52,005
これは2掛ける1行列。

235
00:08:52,005 --> 00:08:53,952
だから結果は

236
00:08:53,952 --> 00:08:55,355
4掛ける1の

237
00:08:55,355 --> 00:08:59,506
ベクトル。よろしい。

238
00:08:59,520 --> 00:09:02,860
えー

239
00:09:02,870 --> 00:09:05,334
つまりこれは

240
00:09:05,334 --> 00:09:06,188
4掛ける1行列が

241
00:09:06,188 --> 00:09:06,957
結果だ、言い換えると

242
00:09:06,957 --> 00:09:10,035
実際は4次元ベクトルだ。

243
00:09:10,035 --> 00:09:11,562
だからその

244
00:09:11,562 --> 00:09:15,991
4つの実数の一つをここに書いてみよう。

245
00:09:16,010 --> 00:09:17,202
つまりは、

246
00:09:17,202 --> 00:09:18,952
この結果の最初の要素は

247
00:09:18,952 --> 00:09:20,497
それを得る方法は

248
00:09:20,497 --> 00:09:21,505
それはズバリ、

249
00:09:21,505 --> 00:09:25,526
これを取って、ベクトルで掛ける。

250
00:09:25,526 --> 00:09:29,381
するとこれは、

251
00:09:29,381 --> 00:09:33,053
-40x1と

252
00:09:33,053 --> 00:09:37,645
足すことの4.25 x 2104。

253
00:09:37,645 --> 00:09:38,998
ところで、

254
00:09:38,998 --> 00:09:40,915
前のスライドでは

255
00:09:40,915 --> 00:09:42,257
1掛ける-40と

256
00:09:42,260 --> 00:09:44,405
2104掛ける0.25と書いた。

257
00:09:44,405 --> 00:09:46,570
でも順番なんて関係ないでしょ？

258
00:09:46,580 --> 00:09:49,637
-40x1は1x(-40)。

259
00:09:49,637 --> 00:09:52,115
そしてこの最初の要素はもちろん、ようするに、

260
00:09:52,115 --> 00:09:55,288
hを2104に適用した物だ。

261
00:09:55,288 --> 00:09:57,395
それは本当に

262
00:09:57,395 --> 00:09:59,969
最初の家の予想価格だ。

263
00:09:59,969 --> 00:10:02,351
では、二番目の要素はどうだろう？

264
00:10:02,390 --> 00:10:04,089
二番目の要素を

265
00:10:04,089 --> 00:10:07,912
どこから得るのか、もう分かりますよね。

266
00:10:07,912 --> 00:10:08,750
といいことでこのような行列が作成されます。

267
00:10:08,750 --> 00:10:11,052
これを取り出し、このベクトルと掛ける。

268
00:10:11,052 --> 00:10:13,154
その結果は、

269
00:10:13,180 --> 00:10:15,038
-40x1 + 0.25x1416。

270
00:10:15,038 --> 00:10:23,037
そしてこれは、h(1416)だ。

271
00:10:23,110 --> 00:10:23,110
といいことでこのような行列が作成されます。

272
00:10:25,810 --> 00:10:27,024
そしてそれ以降の

273
00:10:27,024 --> 00:10:30,720
三番目と四番目の要素も

274
00:10:30,760 --> 00:10:33,797
同様。

275
00:10:33,800 --> 00:10:37,142
そして念のために確認しておきます。

276
00:10:37,142 --> 00:10:39,239
ここにあるこれ、

277
00:10:39,239 --> 00:10:41,131
緑の箱でくくったこれ、

278
00:10:41,131 --> 00:10:42,752
これは実数です。OK？

279
00:10:42,752 --> 00:10:44,169
それは単独の実数。

280
00:10:44,180 --> 00:10:45,673
そしてこの、ここにある、

281
00:10:45,680 --> 00:10:47,812
マゼンダの色の箱を、

282
00:10:47,812 --> 00:10:49,826
紫の、マゼンダの色で囲った物、

283
00:10:49,850 --> 00:10:50,908
それは実数だ。

284
00:10:50,920 --> 00:10:52,683
だからこの

285
00:10:52,683 --> 00:10:54,104
右側にある物は

286
00:10:54,104 --> 00:10:55,200
この右側の物は全体で

287
00:10:55,220 --> 00:10:59,288
4掛ける1行列、つまり4次元ベクトルだ。

288
00:10:59,288 --> 00:11:00,728
この形式の良い所は

289
00:11:00,728 --> 00:11:02,128
これを実際にソフトウェアで実装する時には、

290
00:11:02,130 --> 00:11:04,613
つまり、

291
00:11:04,613 --> 00:11:06,344
4つの家があって、

292
00:11:06,350 --> 00:11:08,525
価格を予測する為に仮説を使いたいとする。

293
00:11:08,525 --> 00:11:12,308
これら4つの家の価格「y」を全て予測したいとする。

294
00:11:12,308 --> 00:11:13,553
これが意味する事は、

295
00:11:13,553 --> 00:11:16,130
これを一行のコードで書けるって事だ。

296
00:11:16,140 --> 00:11:17,878
のち程、Octaveとプログラム言語について

297
00:11:17,878 --> 00:11:19,782
話す時には、

298
00:11:19,790 --> 00:11:22,120
実際にこれを、一行のコードで書けるようになる。

299
00:11:22,120 --> 00:11:24,879
予想価格イコール

300
00:11:24,879 --> 00:11:29,697
データ行列掛けることの

301
00:11:30,582 --> 00:11:33,888
パラメータ。

302
00:11:33,890 --> 00:11:36,994
ここでデータ行列は

303
00:11:36,994 --> 00:11:38,661
これで、パラメータは

304
00:11:38,661 --> 00:11:40,447
これ。

305
00:11:40,447 --> 00:11:44,138
そしてこの掛け算が行列とベクトルの掛け算。

306
00:11:44,138 --> 00:11:45,834
そしてこれをただ実行するだけで

307
00:11:45,834 --> 00:11:47,579
この変数の予測となる。

308
00:11:47,579 --> 00:11:49,270
字汚くてごめんね。

309
00:11:49,270 --> 00:11:50,942
あとはこの一行のコードを

310
00:11:50,942 --> 00:11:52,357
行列とベクトルの掛け算のライブラリがあるという前提で

311
00:11:52,357 --> 00:11:55,328
実装するだけだ。

312
00:11:55,328 --> 00:11:56,518
もしこれを行えば、

313
00:11:56,518 --> 00:11:58,965
予測はこの4x1次元の

314
00:11:58,965 --> 00:12:00,714
ベクトルになる、

315
00:12:00,714 --> 00:12:04,655
この右側の。それが予測値の全てとなる。

316
00:12:04,655 --> 00:12:07,163
そしてこの行列とベクトルの掛け算をやる代わりの

317
00:12:07,163 --> 00:12:09,286
代替案は

318
00:12:09,310 --> 00:12:11,241
以下のような感じだろうか。

319
00:12:11,241 --> 00:12:13,542
for iが1から4まで、

320
00:12:13,542 --> 00:12:15,150
そしてもし家が千個なら、

321
00:12:15,160 --> 00:12:17,451
その場合は i=1から1000まで、となる。

322
00:12:17,451 --> 00:12:18,772
そして予測の式を書かなくてはならない。

323
00:12:18,772 --> 00:12:21,898
iの時の。

324
00:12:21,910 --> 00:12:23,123
そしてそれ以外にもたくさんの仕事を

325
00:12:23,130 --> 00:12:25,645
しなくてはいけない。

326
00:12:25,645 --> 00:12:27,188
しかも、たくさんの数の家がある時、

327
00:12:27,188 --> 00:12:28,549
その時に判明する事は、

328
00:12:28,549 --> 00:12:29,928
もし4つじゃなくて

329
00:12:29,930 --> 00:12:31,033
何千もの家の価格を

330
00:12:31,033 --> 00:12:33,230
予測する時には、

331
00:12:33,410 --> 00:12:35,175
その時にはコンピュータで、

332
00:12:35,175 --> 00:12:36,118
こんな風に実装するという事が分かるはず。

333
00:12:36,118 --> 00:12:40,087
どんな言語を使うにせよ。

334
00:12:40,087 --> 00:12:41,535
これはOctaveだけ、という訳じゃなくて、

335
00:12:41,535 --> 00:12:43,022
C++だろうとJavaだろうとPythonだろうと

336
00:12:43,030 --> 00:12:46,252
その他の高級言語だろうと同じだ。

337
00:12:46,252 --> 00:12:48,045
コードをこういうスタイルで書くのは、

338
00:12:48,045 --> 00:12:49,811
つまり左側のスタイルで書くのは

339
00:12:49,811 --> 00:12:51,552
コードを

340
00:12:51,552 --> 00:12:53,283
単純化するだけでは無く、

341
00:12:53,283 --> 00:12:54,677
だって今や単に

342
00:12:54,677 --> 00:12:55,857
一行のコードを書くだけで

343
00:12:55,870 --> 00:12:58,427
たくさんの事をやる代わりに出来るのだから。

344
00:12:58,450 --> 00:12:59,727
でもそれだけじゃなくて、微妙な理由により、

345
00:12:59,730 --> 00:13:01,398
それは

346
00:13:01,400 --> 00:13:03,392
計算的にはより

347
00:13:03,392 --> 00:13:05,617
効率的な事も判明する。

348
00:13:05,617 --> 00:13:06,583
家の価格を

349
00:13:06,583 --> 00:13:08,348
全て予測するのに。

350
00:13:08,360 --> 00:13:09,693
左の方法の方が

351
00:13:09,693 --> 00:13:13,334
右の方法、つまり自分で計算するより。

352
00:13:13,334 --> 00:13:14,596
この事については

353
00:13:14,596 --> 00:13:15,978
後でベクトル化について

354
00:13:15,978 --> 00:13:17,684
扱う時にもっと詳細に話す。

355
00:13:17,684 --> 00:13:19,145
ようするに、予測をこんな風に記述すると、

356
00:13:19,145 --> 00:13:20,511
コードがシンプルになるだけでなく、

357
00:13:20,511 --> 00:13:23,200
より効率的にもなっちゃうのだ。

358
00:13:23,200 --> 00:13:25,151
機械学習においては、実際には

359
00:13:25,151 --> 00:13:27,063
掛け算だ。

360
00:13:27,063 --> 00:13:28,432
そして今後、この種の演算をどんどん使っていく事になる、

361
00:13:28,432 --> 00:13:30,352
さらにその他のモデルに対して

362
00:13:30,370 --> 00:13:32,888
実際に回帰計算をするにつれて。

363
00:13:32,910 --> 00:13:34,259
だが次回のビデオでは

364
00:13:34,259 --> 00:13:36,150
これについて、一般化して

365
00:13:36,150 --> 00:13:39,527
行列と行列の乗算について扱います。