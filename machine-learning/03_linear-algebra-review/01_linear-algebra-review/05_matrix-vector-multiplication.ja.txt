このビデオで私は 2つの行列をどう掛けあわせるかを 話して行きたいと思います。 まずその特別なケースである 行列とベクトルの積を話していきたい。 行列をベクトルに掛けるという事。 例を見る事から始めよう。 ここに行列があって、 ここにベクトルがあり、 これらの 行列とベクトルを 掛け合わせたいとしよう。結果はどうなるか？ まずこの例を見ていき そしてその後、 一歩さがってどのような手順となるかを見てみよう。 この掛け算のプロセスは 結果がそれ自体 ベクトルとなる。 そしてまず、これをやってみて、 そしてのちに、 戻ってきて何をやったのか見直す。 このベクトルの最初の要素を取り出す為、 私は これら2つの数を取り出し これらを行列の 最初の行を取って 掛けて、対応する数を足し合わせる。 1を取り出して 1と掛け合わせる。 そして3を取り出し 5と掛け合わせる。 すると1+15だから、16となる。 ここに16と書く。 次に、二行目は 二番目の要素、 二番目の行を取り出して このベクトルに掛ける。 つまり、4掛ける1に 足す事の0掛ける5に つまり4となる。 それはイコール4だ。つまり4が答えだ。 そして最後の奴は 2、1掛ける1、5。 だから2掛ける1 足す事の1掛ける5。 イコール、、、 7。つまり、 ここは7となる。 3掛ける2行列と 2掛ける1行列の積もまた、 その結果は 単なる二次元ベクトルと なる事が分かった。 この結果は 3x1行列となる。 そんな訳で 3掛ける1、つまり3x1行列に なる訳だが、言い換えると 3x1行列はただの3次元ベクトル。 分かってる、 ちょっと早くやりすぎたね。 だからたぶんあなたは自分一人でやりなおせるか、ちょっと不安だろう。 だが 何が起きたのか、 より詳細に見てみよう。 この行列のベクトルに対する掛け算がどんなかを。 これが、行列をベクトルに どうやって掛けるかの詳細だ。 行列Aがあって、 それをベクトルxに 掛けたいとしよう。 結果はあるベクトルyに なるだろう。 行列Aはm掛けるn次元の 行列で、 m行n列で、 それをn掛ける1行列に 言い換えるとn次元ベクトルに掛けようとしている。 ここの、 このnはこのnと一致してるのが分かる。 言い換えると、この行列の 列の総数、 n列が、 ここの列の総数が ここの行の総数に一致しなくてはならない。 それはこのベクトルの次元にマッチしなくてはならない。 そしてこの積の結果は n次元ベクトル yとなる。この行、 mは、行列Aの 行の総数と 等しい。 で、そのyは実際にはどう計算するか？ このベクトル、 yを求めるプロセスは つまりyのiを求めるには、 Aのi番目の行に ベクトルxの要素を掛け合わせて、 そして足し合わせる。 つまり、こういう事だ。 yの最初の要素を 得るためには、 その最初の数字は--それがどうなるにせよ-- 行列Aの 最初の行を取って それを一度に一つずつ このベクトルの要素と 掛けていく。 つまり、この最初の数取って、 この最初の数に掛ける。 次に二番目の数を取って、二番目の数と掛ける。 この三番目の数を取って、それがなんであれ、 三番目の数と掛ける。 それを終わりまで続ける。 そして、これら3つの積の結果を 足し合わせると、その結果は このyの最初の要素となる。 次に、yの二番目の要素を 得ようと思ったら、 それを行う方法は Aの二番目の行を取って、 それを得る方法は Aの二番目の行を取って それを要素ごとに 掛ける。つまり、 xの要素と、と言う事。そしてその掛けた結果を 足し合わせる。 その結果がyの 二番目の要素になるという訳。 そしてどんどん続けて、 Aの三番目の行を取り 要素ごとに掛ける、 ベクトルxと。 そして結果を足し合わせて、 三番目の要素を得る。 それを最後の行まで 続ける。OK？ 以上が実際の手続きとなる。 さらにもう一つ例を見てみよう。 これがその例だ。まず次元に注目。 ここで、これは3掛ける4の 行列。 これは4次元ベクトル、または 4x1行列で、 だからこの結果、 この積の結果は、 三次元ベクトルとなる。 だから3つの要素の入るスペースの ベクトルを書く。 では掛け算を実行しよう。 最初の要素は これら4つの数字を取ってきて ベクトルxに掛ける。 つまり結果は 1x1足す2x3足す 1x2足す5x1だから、 それはイコール 1+6+2+5。つまり14。 そして次に 二番目の要素は この列を今度は取って それをこのベクトルに掛ける！ 0x1足す、3、、、 0x1足す3x3足す、 0x2足す4x1で、 つまりイコール、、、 9+4だから、13。 最後に、一番下の要素は、 この最後の列を取って、 つまり、 マイナス1掛ける1。 次に-2だけど、プラスを付けておく方が分かりやすいでしょう、 掛ける3、足す事の 0掛ける2、足す事の0掛ける1。 つまり、以上から -1-6。 だから結果は 負の7。 分かりましたか。 だから最終的な答えとしては、 このベクトル、14と、、、 カラー無しで書くと、14と 13、-7。 そして決まり通り、 この結果は3掛ける1行列となる。 これが行列とベクトルの掛け方。 このスライドでは たくさんの事を話しました。 もしあなたがこれらの数字全てが どこに行くのか、しっかり分かっていなければ、 ビデオを一旦一時停止して ゆっくりと時間をかけて 私が今やった計算を 追いかけて これらの数字、 14、13、11をどうやって得たのかの ステップを しっかりと確認して下さい。 最後に、ちょっと素敵なトリックをご紹介。 例として、 4つの家があるとしよう。 このように、四つのサイズの家がある。 そしてこんな仮定があるとする、 家の価格を推測する、という。 そして 私は、この四つの家に対して、 HのXを計算したいとする。 これを行う、うまいやり方があるのが わかる。 この仮説をこれらの家全てに同時に適用する方法が。 これをやるうまいやり方、というのは 行列の乗算を使った物だ、というのが 分かる。 これが、どうやるか、だ。 私は行列を以下のように構築する。 私の行列は 1、1、1、1で掛ける事の 4つの家のサイズを ここに書いて ベクトルを同様に構成する。 私のベクトルは 2つの要素のベクトルで それはこの -40と0.25。 それはこれら2つの相関係数だ。 data0とdata1。 そしてやりたい事は、 行列とベクトルをとってきて それらを掛け合わせたい。 その掛け合わせる、というのにも、その掛け算の記号を使う。 で、結果、何を得る？ これは 4掛ける2行列。 これは2掛ける1行列。 だから結果は 4掛ける1の ベクトル。よろしい。 えー つまりこれは 4掛ける1行列が 結果だ、言い換えると 実際は4次元ベクトルだ。 だからその 4つの実数の一つをここに書いてみよう。 つまりは、 この結果の最初の要素は それを得る方法は それはズバリ、 これを取って、ベクトルで掛ける。 するとこれは、 -40x1と 足すことの4.25 x 2104。 ところで、 前のスライドでは 1掛ける-40と 2104掛ける0.25と書いた。 でも順番なんて関係ないでしょ？ -40x1は1x(-40)。 そしてこの最初の要素はもちろん、ようするに、 hを2104に適用した物だ。 それは本当に 最初の家の予想価格だ。 では、二番目の要素はどうだろう？ 二番目の要素を どこから得るのか、もう分かりますよね。 といいことでこのような行列が作成されます。 これを取り出し、このベクトルと掛ける。 その結果は、 -40x1 + 0.25x1416。 そしてこれは、h(1416)だ。 といいことでこのような行列が作成されます。 そしてそれ以降の 三番目と四番目の要素も 同様。 そして念のために確認しておきます。 ここにあるこれ、 緑の箱でくくったこれ、 これは実数です。OK？ それは単独の実数。 そしてこの、ここにある、 マゼンダの色の箱を、 紫の、マゼンダの色で囲った物、 それは実数だ。 だからこの 右側にある物は この右側の物は全体で 4掛ける1行列、つまり4次元ベクトルだ。 この形式の良い所は これを実際にソフトウェアで実装する時には、 つまり、 4つの家があって、 価格を予測する為に仮説を使いたいとする。 これら4つの家の価格「y」を全て予測したいとする。 これが意味する事は、 これを一行のコードで書けるって事だ。 のち程、Octaveとプログラム言語について 話す時には、 実際にこれを、一行のコードで書けるようになる。 予想価格イコール データ行列掛けることの パラメータ。 ここでデータ行列は これで、パラメータは これ。 そしてこの掛け算が行列とベクトルの掛け算。 そしてこれをただ実行するだけで この変数の予測となる。 字汚くてごめんね。 あとはこの一行のコードを 行列とベクトルの掛け算のライブラリがあるという前提で 実装するだけだ。 もしこれを行えば、 予測はこの4x1次元の ベクトルになる、 この右側の。それが予測値の全てとなる。 そしてこの行列とベクトルの掛け算をやる代わりの 代替案は 以下のような感じだろうか。 for iが1から4まで、 そしてもし家が千個なら、 その場合は i=1から1000まで、となる。 そして予測の式を書かなくてはならない。 iの時の。 そしてそれ以外にもたくさんの仕事を しなくてはいけない。 しかも、たくさんの数の家がある時、 その時に判明する事は、 もし4つじゃなくて 何千もの家の価格を 予測する時には、 その時にはコンピュータで、 こんな風に実装するという事が分かるはず。 どんな言語を使うにせよ。 これはOctaveだけ、という訳じゃなくて、 C++だろうとJavaだろうとPythonだろうと その他の高級言語だろうと同じだ。 コードをこういうスタイルで書くのは、 つまり左側のスタイルで書くのは コードを 単純化するだけでは無く、 だって今や単に 一行のコードを書くだけで たくさんの事をやる代わりに出来るのだから。 でもそれだけじゃなくて、微妙な理由により、 それは 計算的にはより 効率的な事も判明する。 家の価格を 全て予測するのに。 左の方法の方が 右の方法、つまり自分で計算するより。 この事については 後でベクトル化について 扱う時にもっと詳細に話す。 ようするに、予測をこんな風に記述すると、 コードがシンプルになるだけでなく、 より効率的にもなっちゃうのだ。 機械学習においては、実際には 掛け算だ。 そして今後、この種の演算をどんどん使っていく事になる、 さらにその他のモデルに対して 実際に回帰計算をするにつれて。 だが次回のビデオでは これについて、一般化して 行列と行列の乗算について扱います。