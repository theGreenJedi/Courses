在上一节课中 我讲到了应当怎样面对 机器学习问题 有很多提高算法表现的方法 在本次课程中 我们将会讲到 误差分析（error analysis）的概念 这会帮助你 更系统地做出决定 如果你准备 研究机器学习的东西 或者构造机器学习应用程序 最好的实践方法 不是建立一个 非常复杂的系统 拥有多么复杂的变量 而是 构建一个简单的算法 这样你可以很快地实现它 每当我研究 机器学习的问题时 我最多只会花一天的时间 就是字面意义上的24小时 来试图很快的把结果搞出来 即便效果不好 坦白的说 就是根本没有用复杂的系统 但是只是很快的得到的结果 即便运行得不完美 但是也把它运行一遍 最后通过交叉验证来检验数据 一旦做完 你可以画出学习曲线 这个我们在前面的课程中已经讲过了 通过画出学习曲线 以及检验误差 来找出 你的算法是否有 高偏差和高方差的问题 或者别的问题 在这样分析之后 再来决定用更多的数据训练 或者加入更多的特征变量是否有用 这么做的原因是 这在你刚接触机器学习问题时 是一个很好的方法 你并不能 提前知道 你是否需要复杂的特征变量 或者你是否需要 更多的数据 还是别的什么 提前知道你应该做什么 是非常难的 因为你缺少证据 缺少学习曲线 因此 你很难知道 你应该把时间花在什么地方来提高算法的表现 但是当你实践一个 非常简单即便不完美的 方法时 你可以通过画出学习曲线来做出进一步的选择 你可以 用这种方式 来避免一种 电脑编程里的过早优化问题 这种理念是 我们必须 用证据来领导我们的决策 怎样分配自己的时间来优化算法 而不是仅仅凭直觉 凭直觉得出的东西一般总是错误的 除了画出学习曲线之外 一件非常有用的事是 误差分析 我的意思是说 当我们在构造 比如构造垃圾邮件分类器时 我会看一看 我的交叉验证数据集 然后亲自看一看 哪些邮件被算法错误地分类 因此 通过这些 被算法错误分类的垃圾邮件 与非垃圾邮件 你可以发现某些系统性的规律 什么类型的邮件总是被错误分类 经常地 这样做之后 这个过程能启发你 构造新的特征变量 或者告诉你 现在 这个系统的短处 然后启发你 如何去提高它 具体地说 这里有一个例子 假设你正在构造一个 垃圾邮件分类器 你拥有500个实例 在交叉验证集中 假设在这个例子中 该算法有非常高的误差率 它错误分类了 一百个交叉验证实例 所以我要做的是 人工检查这100个错误 然后手工为它们分类 基于例如 这些是什么类型的邮件 哪些变量 能帮助这个算法来正确分类它们 明确地说 通过鉴定这是哪种类型的邮件 通过检查 这一百封错误分类的邮件 我可能会发现 最容易被误分类的邮件 可能是 有关药物的邮件 基本上这些邮件都是卖药的 或者 卖仿品的 比如卖假表 或者一些骗子邮件 又叫做钓鱼邮件 等等 所以 在检查哪些邮件被错误分类的时候 我会看一看每封邮件 数一数 比如 在这100封错误归类的邮件中 我发现有12封 错误归类的邮件是和卖药有关的邮件 4封 是推销仿品的 推销假表或者别的东西 然后我发现 有53封邮件 是钓鱼邮件 诱骗你 告诉他们你的密码 剩下的31封别的类型的邮件 通过算出 每个类别中 不同的邮件数 你可能会发现 比如 该算法在 区分钓鱼邮件的时候 总是表现得很差 这说明 你应该花更多的时间 来研究这种类型的邮件 然后 看一看你是否能通过构造更好的特征变量 来正确区分这种类型的邮件 同时 我要做的是 看一看哪些特征变量 可能会帮助算法正确地分类邮件 我们假设 能帮助我们提高 邮件分类表现 的方法是 检查有意的拼写错误 不寻常的邮件路由来源 以及垃圾邮件特有的标点符号方式 比如很多感叹号 与之前一样 我会手动地浏览这些邮件 假设有5封这种类型的邮件 16封这种类型的 32封这种类型的 以及一些别的类型的 如果 这就是你从交叉验证中得到的结果 那么 这可能说明 有意地拼写错误出现频率较少 这可能并不值得 你花费时间 去编写算法来检测这种类型的邮件 但是如果你发现 很多的垃圾邮件 都有不一般的标点符号规律 那么这是一个很强的特征 说明你应该 花费你的时间 去构造基于标点符号的 更加复杂的特征变量 因此 这种类型的误差分析 是一种手动检测的过程 检测算法可能会犯的错误 这经常能够帮助你 找到更为有效的手段 这也解释了为什么 我总是推荐先实践一种 快速即便不完美的算法 我们真正想要的是 找出什么类型的邮件 是这种算法最难分类出来的 对于不同的算法 不同的机器学习算法 它们 所遇到的问题一般总是相同的 通过实践一些快速 即便不完美的算法 你能够更快地 找到错误的所在 并且快速找出算法难以处理的例子 这样你就能集中精力在这些真正的问题上 最后 在构造机器学习算法时 另一个有用的小窍门是 保证你自己 保证你能有一种 数值计算的方式来评估你的机器学习算法 我这么说的意思是 如果你在构造一个学习算法 如果你能有一种 评估你算法的方法 这是非常有用的 一种用数字说话的评估方法 你的算法可能精确 可能有错 但是它能准确的告诉你你的算法到底表现有多好 在接下来的课程中 我会更详细的讲述这个概念 但是先看看这个例子 假设我们试图 决定是否应该 把像"discount""discounts""discounter""discountring" 这样的单词都视为等同 一种方法 是检查这些单词的 开头几个字母 比如 当你在检查这些单词开头几个字母的时候 你发现 这几个单词 大概可能有着相同的意思 在自然语言处理中 这种方法 是通过一种叫做词干提取的软件实现的 如果你想自己来试试 你可以 在网上搜索一下 "Porter Stemmer(波特词干提取法)" 这是在词干提取方面 一个比较不错的软件 这个软件会 将单词"discount""discounts"以及等等 都视为同一个单词 但是这种词干提取软件 只会检查 单词的头几个字母 这有用 但是也可能会造成一些问题 因为 举个例子 因为这个软件会把单词"universe(宇宙)" 和"university(大学)" 也视为同一个单词 因为 这两个单词开头的字母是一样的 因此 当你在决定 是否应该使用词干提取软件用来分类 这总是很难说清楚 特别地 误差分析 也并不能帮助你决定 词干提取是不是一个好的方法 与之相对地 最好的方法 来发现词干提取软件 对你的分类器 到底有没有用 是迅速地着手试一试 来看看它表现到底怎么样 为了这么做 通过数值来评估你的算法 是非常有用的 具体地说 自然而然地 你应该通过交叉验证 来验证不用词干提取与用词干提取的算法的错误率 因此 如果你不在你的算法中使用词干提取 然后你得到 比如 5%的分类错误率 然后你再使用词干提取来运行你的算法 你得到 比如 3%的分类错误 那么这很大的减少了错误发生 于是你决定 词干提取是一个好的办法 就这个特定的问题而言 这里有一个数量的评估数字 即交差验证错误率 我们以后会发现 这个例子中的评估数字 还需要一些处理 但是 我们可以在今后的课程中看到 这么做还是会让你 能更快地做出决定 比如 是否使用词干提取 再说一个例子 假设 你在想是否应该 区分单词的大小写 比如 单词"mom" 大写的"M" 和小写的"m" 它们应该被视作 同一个单词还是不同的单词 它们应该被视作相同的特征变量还是不同的 再说一次 因为我们有一种 能够评估我们算法的方法 如果你在这里试一试 如果我不区分 大小写 最后得到3.2%的错误率 然后我发现 这个表现的较差些 如果 如果我只用了词干提取 这之后我再思考 是否要区分 大小写 因此当你在 构造学习算法的时候 你总是会去尝试 很多新的想法 实现出很多版本的学习算法 如果每一次 你实践新想法的时候 你都手动地检测 这些例子 去看看是表现差还是表现好 那么这很难让你 做出决定 到底是否使用词干提取 是否区分大小写 但是通过一个 量化的数值评估 你可以看看这个数字 误差是变大还是变小了 你可以通过它 更快地实践 你的新想法 它基本上非常直观地告诉你 你的想法是提高了算法表现 还是让它变得更坏 这会大大提高 你实践算法时的速度 所以我强烈推荐 在交叉验证集上来实施误差分析 而不是在测试集上 但是 还是有一些人 会在测试集上来做误差分析 即使这从数学上讲 是不合适的 所以我还是推荐你 在交叉验证向量上 来做误差分析 总结一下 当你在研究一个新的机器学习问题时 我总是推荐你 实现一个较为简单快速 即便不是那么完美的算法 我几乎从未见过 人们这样做 大家经常干的事情是 花费大量的时间 在构造算法上 构造他们以为的简单的方法 因此 不要担心你的算法太简单 或者太不完美 而是尽可能快地 实现你的算法 当你有了初始的实现之后 它会变成一个非常有力的工具 来帮助你决定 下一步的做法 因为我们可以先看看算法造成的错误 通过误差分析 来看看他犯了什么错 然后来决定优化的方式 另一件事是 假设你有了一个快速而不完美的算法实现 又有一个数值的评估数据 这会帮助你 尝试新的想法 快速地发现 你尝试的这些想法 是否能够提高算法的表现 从而 你会更快地 做出决定 在算法中放弃什么 吸收什么 【教育无边界字幕组】翻译: 御姐sama 校对/审核: 所罗门捷列夫