1
00:00:00,210 --> 00:00:01,300
在上一节课中

2
00:00:01,600 --> 00:00:03,390
我讲到了应当怎样面对

3
00:00:03,520 --> 00:00:04,780
机器学习问题

4
00:00:04,980 --> 00:00:07,260
有很多提高算法表现的方法

5
00:00:08,460 --> 00:00:09,510
在本次课程中

6
00:00:09,650 --> 00:00:11,060
我们将会讲到

7
00:00:11,330 --> 00:00:12,980
误差分析（error analysis）的概念

8
00:00:13,070 --> 00:00:13,980
这会帮助你

9
00:00:14,300 --> 00:00:15,830
更系统地做出决定

10
00:00:18,070 --> 00:00:19,420
如果你准备

11
00:00:19,540 --> 00:00:21,210
研究机器学习的东西

12
00:00:21,400 --> 00:00:23,340
或者构造机器学习应用程序

13
00:00:23,480 --> 00:00:24,880
最好的实践方法

14
00:00:25,840 --> 00:00:27,000
不是建立一个

15
00:00:27,520 --> 00:00:29,070
非常复杂的系统

16
00:00:29,220 --> 00:00:30,490
拥有多么复杂的变量

17
00:00:30,930 --> 00:00:32,450
而是

18
00:00:33,060 --> 00:00:34,120
构建一个简单的算法

19
00:00:34,510 --> 00:00:35,760
这样你可以很快地实现它

20
00:00:37,480 --> 00:00:38,610
每当我研究

21
00:00:38,740 --> 00:00:39,770
机器学习的问题时

22
00:00:40,150 --> 00:00:41,350
我最多只会花一天的时间

23
00:00:41,570 --> 00:00:43,160
就是字面意义上的24小时

24
00:00:43,460 --> 00:00:46,030
来试图很快的把结果搞出来 即便效果不好

25
00:00:47,040 --> 00:00:48,550
坦白的说 就是根本没有用复杂的系统

26
00:00:49,370 --> 00:00:50,310
但是只是很快的得到的结果

27
00:00:50,400 --> 00:00:52,080
即便运行得不完美

28
00:00:52,590 --> 00:00:53,710
但是也把它运行一遍

29
00:00:53,880 --> 00:00:55,870
最后通过交叉验证来检验数据

30
00:00:56,050 --> 00:00:57,140
一旦做完

31
00:00:57,480 --> 00:00:58,690
你可以画出学习曲线

32
00:00:59,960 --> 00:01:02,670
这个我们在前面的课程中已经讲过了

33
00:01:03,230 --> 00:01:05,160
通过画出学习曲线

34
00:01:05,370 --> 00:01:07,120
以及检验误差

35
00:01:07,310 --> 00:01:08,280
来找出

36
00:01:08,400 --> 00:01:09,630
你的算法是否有

37
00:01:10,120 --> 00:01:11,240
高偏差和高方差的问题

38
00:01:11,440 --> 00:01:13,180
或者别的问题

39
00:01:13,440 --> 00:01:14,380
在这样分析之后

40
00:01:14,490 --> 00:01:15,610
再来决定用更多的数据训练

41
00:01:16,080 --> 00:01:17,990
或者加入更多的特征变量是否有用

42
00:01:18,670 --> 00:01:19,830
这么做的原因是

43
00:01:20,000 --> 00:01:20,980
这在你刚接触机器学习问题时

44
00:01:21,940 --> 00:01:22,980
是一个很好的方法

45
00:01:23,100 --> 00:01:24,460
你并不能

46
00:01:24,680 --> 00:01:25,820
提前知道

47
00:01:26,480 --> 00:01:27,360
你是否需要复杂的特征变量

48
00:01:27,790 --> 00:01:29,200
或者你是否需要

49
00:01:29,250 --> 00:01:30,950
更多的数据 还是别的什么

50
00:01:31,280 --> 00:01:32,270
提前知道你应该做什么

51
00:01:32,510 --> 00:01:33,840
是非常难的

52
00:01:33,970 --> 00:01:36,040
因为你缺少证据

53
00:01:36,160 --> 00:01:37,840
缺少学习曲线

54
00:01:37,970 --> 00:01:39,130
因此 你很难知道

55
00:01:39,750 --> 00:01:42,860
你应该把时间花在什么地方来提高算法的表现

56
00:01:43,760 --> 00:01:45,360
但是当你实践一个

57
00:01:45,730 --> 00:01:46,670
非常简单即便不完美的

58
00:01:46,980 --> 00:01:48,100
方法时

59
00:01:48,540 --> 00:01:51,070
你可以通过画出学习曲线来做出进一步的选择

60
00:01:52,580 --> 00:01:53,340
你可以

61
00:01:53,560 --> 00:01:54,490
用这种方式

62
00:01:54,620 --> 00:01:56,270
来避免一种

63
00:01:56,570 --> 00:01:58,950
电脑编程里的过早优化问题

64
00:02:00,000 --> 00:02:01,070
这种理念是

65
00:02:01,200 --> 00:02:03,130
我们必须

66
00:02:03,460 --> 00:02:04,920
用证据来领导我们的决策

67
00:02:05,650 --> 00:02:06,540
怎样分配自己的时间来优化算法

68
00:02:07,160 --> 00:02:08,150
而不是仅仅凭直觉

69
00:02:09,070 --> 00:02:09,680
凭直觉得出的东西一般总是错误的

70
00:02:10,930 --> 00:02:12,120
除了画出学习曲线之外

71
00:02:12,390 --> 00:02:13,540
一件非常有用的事是

72
00:02:13,810 --> 00:02:16,440
误差分析

73
00:02:18,120 --> 00:02:19,080
我的意思是说

74
00:02:19,280 --> 00:02:20,520
当我们在构造

75
00:02:20,770 --> 00:02:22,190
比如构造垃圾邮件分类器时

76
00:02:22,470 --> 00:02:24,500
我会看一看

77
00:02:24,730 --> 00:02:26,690
我的交叉验证数据集

78
00:02:27,360 --> 00:02:29,110
然后亲自看一看

79
00:02:29,310 --> 00:02:30,910
哪些邮件被算法错误地分类

80
00:02:31,180 --> 00:02:32,250
因此 通过这些

81
00:02:32,630 --> 00:02:34,440
被算法错误分类的垃圾邮件

82
00:02:34,640 --> 00:02:36,920
与非垃圾邮件

83
00:02:37,430 --> 00:02:38,590
你可以发现某些系统性的规律

84
00:02:39,210 --> 00:02:41,300
什么类型的邮件总是被错误分类

85
00:02:42,980 --> 00:02:44,560
经常地 这样做之后

86
00:02:44,810 --> 00:02:45,960
这个过程能启发你

87
00:02:47,170 --> 00:02:48,800
构造新的特征变量

88
00:02:49,430 --> 00:02:50,420
或者告诉你

89
00:02:50,920 --> 00:02:52,150
现在

90
00:02:52,400 --> 00:02:53,290
这个系统的短处

91
00:02:54,270 --> 00:02:55,550
然后启发你

92
00:02:55,660 --> 00:02:57,680
如何去提高它

93
00:02:58,260 --> 00:03:00,070
具体地说 这里有一个例子

94
00:03:01,350 --> 00:03:02,360
假设你正在构造一个

95
00:03:02,780 --> 00:03:05,740
垃圾邮件分类器

96
00:03:05,840 --> 00:03:07,720
你拥有500个实例

97
00:03:07,940 --> 00:03:09,650
在交叉验证集中

98
00:03:10,410 --> 00:03:11,760
假设在这个例子中

99
00:03:12,010 --> 00:03:13,060
该算法有非常高的误差率

100
00:03:13,340 --> 00:03:14,640
它错误分类了

101
00:03:14,910 --> 00:03:16,500
一百个交叉验证实例

102
00:03:18,770 --> 00:03:19,850
所以我要做的是

103
00:03:20,450 --> 00:03:22,370
人工检查这100个错误

104
00:03:22,530 --> 00:03:24,450
然后手工为它们分类

105
00:03:24,700 --> 00:03:25,810
基于例如

106
00:03:25,980 --> 00:03:27,110
这些是什么类型的邮件

107
00:03:27,270 --> 00:03:28,630
哪些变量

108
00:03:28,710 --> 00:03:31,130
能帮助这个算法来正确分类它们

109
00:03:32,450 --> 00:03:33,880
明确地说

110
00:03:34,080 --> 00:03:35,050
通过鉴定这是哪种类型的邮件

111
00:03:35,560 --> 00:03:36,870
通过检查

112
00:03:37,140 --> 00:03:38,180
这一百封错误分类的邮件

113
00:03:38,520 --> 00:03:39,660
我可能会发现

114
00:03:39,970 --> 00:03:41,350
最容易被误分类的邮件

115
00:03:41,840 --> 00:03:43,450
可能是

116
00:03:44,010 --> 00:03:45,610
有关药物的邮件

117
00:03:45,610 --> 00:03:48,300
基本上这些邮件都是卖药的

118
00:03:48,610 --> 00:03:50,000
或者

119
00:03:50,180 --> 00:03:51,740
卖仿品的

120
00:03:51,760 --> 00:03:54,330
比如卖假表

121
00:03:56,160 --> 00:03:59,410
或者一些骗子邮件

122
00:04:00,240 --> 00:04:01,400
又叫做钓鱼邮件

123
00:04:02,180 --> 00:04:04,690
等等

124
00:04:06,160 --> 00:04:07,800
所以

125
00:04:08,120 --> 00:04:09,230
在检查哪些邮件被错误分类的时候

126
00:04:09,530 --> 00:04:10,420
我会看一看每封邮件

127
00:04:10,890 --> 00:04:11,990
数一数 比如

128
00:04:12,200 --> 00:04:14,220
在这100封错误归类的邮件中

129
00:04:14,400 --> 00:04:15,510
我发现有12封

130
00:04:15,620 --> 00:04:17,600
错误归类的邮件是和卖药有关的邮件

131
00:04:18,100 --> 00:04:19,460
4封

132
00:04:19,700 --> 00:04:20,840
是推销仿品的

133
00:04:20,980 --> 00:04:22,680
推销假表或者别的东西

134
00:04:23,720 --> 00:04:25,060
然后我发现

135
00:04:25,650 --> 00:04:26,970
有53封邮件

136
00:04:27,720 --> 00:04:29,480
是钓鱼邮件

137
00:04:29,730 --> 00:04:30,900
诱骗你

138
00:04:31,020 --> 00:04:32,760
告诉他们你的密码 剩下的31封别的类型的邮件

139
00:04:35,330 --> 00:04:37,210
通过算出

140
00:04:37,280 --> 00:04:38,280
每个类别中

141
00:04:38,430 --> 00:04:39,540
不同的邮件数

142
00:04:39,790 --> 00:04:41,570
你可能会发现 比如

143
00:04:41,870 --> 00:04:43,100
该算法在

144
00:04:44,170 --> 00:04:45,640
区分钓鱼邮件的时候

145
00:04:45,780 --> 00:04:47,240
总是表现得很差

146
00:04:47,400 --> 00:04:49,230
这说明

147
00:04:49,380 --> 00:04:50,490
你应该花更多的时间

148
00:04:50,690 --> 00:04:51,650
来研究这种类型的邮件

149
00:04:51,900 --> 00:04:53,350
然后

150
00:04:53,450 --> 00:04:54,450
看一看你是否能通过构造更好的特征变量

151
00:04:55,070 --> 00:04:56,280
来正确区分这种类型的邮件

152
00:04:57,550 --> 00:04:58,930
同时

153
00:04:59,000 --> 00:05:00,130
我要做的是

154
00:05:00,550 --> 00:05:02,120
看一看哪些特征变量

155
00:05:02,620 --> 00:05:04,920
可能会帮助算法正确地分类邮件

156
00:05:06,090 --> 00:05:06,970
我们假设

157
00:05:07,060 --> 00:05:09,700
能帮助我们提高

158
00:05:09,840 --> 00:05:10,780
邮件分类表现

159
00:05:10,920 --> 00:05:13,240
的方法是

160
00:05:13,490 --> 00:05:15,600
检查有意的拼写错误

161
00:05:16,220 --> 00:05:18,610
不寻常的邮件路由来源

162
00:05:19,950 --> 00:05:21,450
以及垃圾邮件特有的标点符号方式

163
00:05:21,790 --> 00:05:23,230
比如很多感叹号

164
00:05:23,700 --> 00:05:24,470
与之前一样

165
00:05:24,860 --> 00:05:25,670
我会手动地浏览这些邮件

166
00:05:25,760 --> 00:05:27,490
假设有5封这种类型的邮件

167
00:05:27,620 --> 00:05:29,400
16封这种类型的

168
00:05:29,500 --> 00:05:30,560
32封这种类型的

169
00:05:31,180 --> 00:05:33,620
以及一些别的类型的

170
00:05:34,770 --> 00:05:36,180
如果

171
00:05:36,350 --> 00:05:37,470
这就是你从交叉验证中得到的结果

172
00:05:38,070 --> 00:05:39,170
那么

173
00:05:39,300 --> 00:05:41,060
这可能说明

174
00:05:41,660 --> 00:05:42,730
有意地拼写错误出现频率较少

175
00:05:43,500 --> 00:05:44,480
这可能并不值得

176
00:05:44,840 --> 00:05:47,120
你花费时间

177
00:05:47,710 --> 00:05:48,780
去编写算法来检测这种类型的邮件

178
00:05:49,480 --> 00:05:50,480
但是如果你发现

179
00:05:50,780 --> 00:05:52,070
很多的垃圾邮件

180
00:05:52,140 --> 00:05:54,150
都有不一般的标点符号规律

181
00:05:54,290 --> 00:05:55,250
那么这是一个很强的特征

182
00:05:55,670 --> 00:05:56,730
说明你应该

183
00:05:57,000 --> 00:05:58,510
花费你的时间

184
00:05:58,780 --> 00:06:00,280
去构造基于标点符号的

185
00:06:00,910 --> 00:06:02,190
更加复杂的特征变量

186
00:06:03,330 --> 00:06:04,870
因此

187
00:06:05,040 --> 00:06:06,390
这种类型的误差分析

188
00:06:06,690 --> 00:06:08,430
是一种手动检测的过程

189
00:06:09,190 --> 00:06:10,540
检测算法可能会犯的错误

190
00:06:10,780 --> 00:06:12,220
这经常能够帮助你

191
00:06:12,560 --> 00:06:14,620
找到更为有效的手段

192
00:06:16,000 --> 00:06:17,410
这也解释了为什么

193
00:06:17,590 --> 00:06:19,260
我总是推荐先实践一种

194
00:06:19,550 --> 00:06:21,250
快速即便不完美的算法

195
00:06:22,040 --> 00:06:22,940
我们真正想要的是

196
00:06:23,260 --> 00:06:24,290
找出什么类型的邮件

197
00:06:24,310 --> 00:06:26,770
是这种算法最难分类出来的

198
00:06:27,860 --> 00:06:29,920
对于不同的算法

199
00:06:30,460 --> 00:06:31,730
不同的机器学习算法

200
00:06:32,010 --> 00:06:33,500
它们

201
00:06:33,560 --> 00:06:35,920
所遇到的问题一般总是相同的

202
00:06:37,010 --> 00:06:37,970
通过实践一些快速

203
00:06:38,060 --> 00:06:39,840
即便不完美的算法

204
00:06:39,910 --> 00:06:40,850
你能够更快地

205
00:06:41,430 --> 00:06:43,070
找到错误的所在

206
00:06:43,620 --> 00:06:44,690
并且快速找出算法难以处理的例子

207
00:06:44,790 --> 00:06:47,760
这样你就能集中精力在这些真正的问题上

208
00:06:49,230 --> 00:06:51,220
最后 在构造机器学习算法时

209
00:06:52,260 --> 00:06:53,880
另一个有用的小窍门是

210
00:06:54,190 --> 00:06:55,230
保证你自己

211
00:06:55,590 --> 00:06:56,450
保证你能有一种

212
00:06:56,810 --> 00:06:59,710
数值计算的方式来评估你的机器学习算法

213
00:07:02,130 --> 00:07:03,220
我这么说的意思是

214
00:07:03,460 --> 00:07:04,670
如果你在构造一个学习算法

215
00:07:05,230 --> 00:07:07,180
如果你能有一种

216
00:07:08,060 --> 00:07:09,170
评估你算法的方法

217
00:07:09,460 --> 00:07:10,830
这是非常有用的

218
00:07:11,290 --> 00:07:13,100
一种用数字说话的评估方法

219
00:07:13,650 --> 00:07:14,880
你的算法可能精确 可能有错

220
00:07:15,620 --> 00:07:18,390
但是它能准确的告诉你你的算法到底表现有多好

221
00:07:20,280 --> 00:07:21,330
在接下来的课程中

222
00:07:21,770 --> 00:07:24,650
我会更详细的讲述这个概念 但是先看看这个例子

223
00:07:25,790 --> 00:07:26,600
假设我们试图

224
00:07:26,690 --> 00:07:27,990
决定是否应该

225
00:07:28,060 --> 00:07:29,140
把像"discount""discounts""discounter""discountring"

226
00:07:29,590 --> 00:07:32,060
这样的单词都视为等同

227
00:07:32,370 --> 00:07:33,390
一种方法

228
00:07:33,520 --> 00:07:34,770
是检查这些单词的

229
00:07:35,400 --> 00:07:38,780
开头几个字母

230
00:07:38,960 --> 00:07:40,240
比如

231
00:07:40,300 --> 00:07:41,690
当你在检查这些单词开头几个字母的时候

232
00:07:41,780 --> 00:07:44,640
你发现

233
00:07:44,920 --> 00:07:45,970
这几个单词

234
00:07:46,130 --> 00:07:47,990
大概可能有着相同的意思

235
00:07:50,460 --> 00:07:52,090
在自然语言处理中

236
00:07:52,250 --> 00:07:53,270
这种方法

237
00:07:53,510 --> 00:07:55,960
是通过一种叫做词干提取的软件实现的

238
00:07:56,940 --> 00:07:58,080
如果你想自己来试试

239
00:07:58,160 --> 00:07:59,880
你可以

240
00:07:59,950 --> 00:08:01,240
在网上搜索一下

241
00:08:01,500 --> 00:08:02,660
"Porter Stemmer(波特词干提取法)"

242
00:08:02,960 --> 00:08:04,320
这是在词干提取方面

243
00:08:04,620 --> 00:08:05,830
一个比较不错的软件

244
00:08:06,110 --> 00:08:07,020
这个软件会

245
00:08:07,130 --> 00:08:08,140
将单词"discount""discounts"以及等等

246
00:08:08,800 --> 00:08:10,540
都视为同一个单词

247
00:08:13,950 --> 00:08:15,930
但是这种词干提取软件

248
00:08:16,630 --> 00:08:17,710
只会检查

249
00:08:17,830 --> 00:08:19,290
单词的头几个字母

250
00:08:19,450 --> 00:08:21,630
这有用 但是也可能会造成一些问题

251
00:08:22,240 --> 00:08:23,490
因为

252
00:08:23,900 --> 00:08:25,360
举个例子

253
00:08:25,930 --> 00:08:27,850
因为这个软件会把单词"universe(宇宙)"

254
00:08:27,990 --> 00:08:29,980
和"university(大学)"

255
00:08:30,070 --> 00:08:31,220
也视为同一个单词

256
00:08:31,450 --> 00:08:33,220
因为

257
00:08:33,480 --> 00:08:35,480
这两个单词开头的字母是一样的

258
00:08:37,300 --> 00:08:39,050
因此

259
00:08:39,280 --> 00:08:40,290
当你在决定

260
00:08:40,630 --> 00:08:42,490
是否应该使用词干提取软件用来分类

261
00:08:42,670 --> 00:08:45,960
这总是很难说清楚

262
00:08:46,350 --> 00:08:47,810
特别地

263
00:08:48,510 --> 00:08:49,590
误差分析

264
00:08:51,030 --> 00:08:52,860
也并不能帮助你决定

265
00:08:53,060 --> 00:08:54,410
词干提取是不是一个好的方法

266
00:08:55,570 --> 00:08:56,740
与之相对地 最好的方法

267
00:08:57,020 --> 00:08:58,320
来发现词干提取软件

268
00:08:58,690 --> 00:08:59,970
对你的分类器

269
00:09:00,190 --> 00:09:01,570
到底有没有用

270
00:09:01,740 --> 00:09:02,980
是迅速地着手试一试

271
00:09:03,370 --> 00:09:05,170
来看看它表现到底怎么样

272
00:09:08,560 --> 00:09:09,530
为了这么做

273
00:09:10,260 --> 00:09:11,350
通过数值来评估你的算法

274
00:09:12,250 --> 00:09:14,570
是非常有用的

275
00:09:15,940 --> 00:09:17,670
具体地说

276
00:09:18,110 --> 00:09:19,190
自然而然地

277
00:09:19,350 --> 00:09:20,250
你应该通过交叉验证

278
00:09:20,900 --> 00:09:23,510
来验证不用词干提取与用词干提取的算法的错误率

279
00:09:24,590 --> 00:09:25,560
因此

280
00:09:25,800 --> 00:09:27,190
如果你不在你的算法中使用词干提取

281
00:09:27,330 --> 00:09:28,430
然后你得到 比如

282
00:09:29,080 --> 00:09:31,260
5%的分类错误率

283
00:09:31,360 --> 00:09:32,410
然后你再使用词干提取来运行你的算法

284
00:09:32,540 --> 00:09:33,780
你得到 比如

285
00:09:34,110 --> 00:09:36,170
3%的分类错误

286
00:09:36,440 --> 00:09:37,920
那么这很大的减少了错误发生

287
00:09:38,640 --> 00:09:39,980
于是你决定

288
00:09:40,310 --> 00:09:42,250
词干提取是一个好的办法

289
00:09:43,080 --> 00:09:44,650
就这个特定的问题而言

290
00:09:44,940 --> 00:09:46,560
这里有一个数量的评估数字

291
00:09:46,830 --> 00:09:50,210
即交差验证错误率

292
00:09:50,930 --> 00:09:52,700
我们以后会发现

293
00:09:53,080 --> 00:09:54,360
这个例子中的评估数字

294
00:09:54,790 --> 00:09:58,220
还需要一些处理

295
00:09:58,790 --> 00:09:59,840
但是

296
00:09:59,930 --> 00:10:01,620
我们可以在今后的课程中看到

297
00:10:01,750 --> 00:10:02,860
这么做还是会让你

298
00:10:02,990 --> 00:10:04,290
能更快地做出决定

299
00:10:04,760 --> 00:10:06,380
比如 是否使用词干提取

300
00:10:08,700 --> 00:10:09,950
再说一个例子

301
00:10:10,680 --> 00:10:11,670
假设

302
00:10:12,040 --> 00:10:13,450
你在想是否应该

303
00:10:13,650 --> 00:10:15,710
区分单词的大小写

304
00:10:15,990 --> 00:10:16,910
比如

305
00:10:17,060 --> 00:10:18,850
单词"mom" 大写的"M"

306
00:10:19,060 --> 00:10:20,390
和小写的"m"

307
00:10:20,700 --> 00:10:21,720
它们应该被视作

308
00:10:21,780 --> 00:10:23,810
同一个单词还是不同的单词

309
00:10:23,970 --> 00:10:26,890
它们应该被视作相同的特征变量还是不同的

310
00:10:27,010 --> 00:10:28,060
再说一次

311
00:10:28,350 --> 00:10:29,150
因为我们有一种

312
00:10:29,300 --> 00:10:30,790
能够评估我们算法的方法

313
00:10:31,060 --> 00:10:32,350
如果你在这里试一试

314
00:10:32,650 --> 00:10:34,910
如果我不区分

315
00:10:35,140 --> 00:10:36,490
大小写

316
00:10:36,600 --> 00:10:38,580
最后得到3.2%的错误率

317
00:10:38,700 --> 00:10:39,820
然后我发现

318
00:10:40,020 --> 00:10:41,750
这个表现的较差些

319
00:10:42,260 --> 00:10:43,360
如果

320
00:10:43,640 --> 00:10:45,110
如果我只用了词干提取

321
00:10:45,370 --> 00:10:47,420
这之后我再思考

322
00:10:48,270 --> 00:10:49,720
是否要区分

323
00:10:49,820 --> 00:10:51,540
大小写

324
00:10:52,140 --> 00:10:53,390
因此当你在

325
00:10:53,690 --> 00:10:55,260
构造学习算法的时候

326
00:10:55,650 --> 00:10:56,840
你总是会去尝试

327
00:10:57,050 --> 00:10:59,930
很多新的想法 实现出很多版本的学习算法

328
00:11:00,960 --> 00:11:02,050
如果每一次

329
00:11:02,350 --> 00:11:03,740
你实践新想法的时候

330
00:11:03,840 --> 00:11:05,610
你都手动地检测

331
00:11:05,750 --> 00:11:06,730
这些例子

332
00:11:06,860 --> 00:11:08,530
去看看是表现差还是表现好

333
00:11:08,640 --> 00:11:09,410
那么这很难让你

334
00:11:09,580 --> 00:11:10,610
做出决定

335
00:11:10,980 --> 00:11:12,410
到底是否使用词干提取

336
00:11:12,580 --> 00:11:13,640
是否区分大小写

337
00:11:15,180 --> 00:11:16,590
但是通过一个

338
00:11:16,770 --> 00:11:18,520
量化的数值评估

339
00:11:18,680 --> 00:11:21,150
你可以看看这个数字 误差是变大还是变小了

340
00:11:22,420 --> 00:11:23,620
你可以通过它

341
00:11:23,940 --> 00:11:25,760
更快地实践

342
00:11:25,840 --> 00:11:27,820
你的新想法

343
00:11:27,990 --> 00:11:29,550
它基本上非常直观地告诉你

344
00:11:29,690 --> 00:11:31,480
你的想法是提高了算法表现

345
00:11:32,440 --> 00:11:33,230
还是让它变得更坏

346
00:11:33,930 --> 00:11:35,440
这会大大提高

347
00:11:35,560 --> 00:11:38,340
你实践算法时的速度

348
00:11:38,530 --> 00:11:39,720
所以我强烈推荐

349
00:11:40,220 --> 00:11:41,790
在交叉验证集上来实施误差分析

350
00:11:42,370 --> 00:11:44,760
而不是在测试集上

351
00:11:45,490 --> 00:11:46,970
但是

352
00:11:47,240 --> 00:11:48,260
还是有一些人

353
00:11:48,370 --> 00:11:49,480
会在测试集上来做误差分析

354
00:11:49,730 --> 00:11:51,530
即使这从数学上讲

355
00:11:52,190 --> 00:11:54,560
是不合适的

356
00:11:54,730 --> 00:11:55,660
所以我还是推荐你

357
00:11:55,780 --> 00:11:57,240
在交叉验证向量上

358
00:11:57,450 --> 00:11:58,760
来做误差分析

359
00:11:59,140 --> 00:12:01,160
总结一下

360
00:12:01,830 --> 00:12:03,340
当你在研究一个新的机器学习问题时

361
00:12:03,610 --> 00:12:05,370
我总是推荐你

362
00:12:05,610 --> 00:12:06,930
实现一个较为简单快速

363
00:12:07,030 --> 00:12:08,710
即便不是那么完美的算法

364
00:12:09,780 --> 00:12:11,760
我几乎从未见过

365
00:12:12,120 --> 00:12:15,370
人们这样做

366
00:12:18,640 --> 00:12:20,210
大家经常干的事情是

367
00:12:20,480 --> 00:12:22,050
花费大量的时间

368
00:12:22,370 --> 00:12:23,720
在构造算法上

369
00:12:24,580 --> 00:12:25,800
构造他们以为的简单的方法

370
00:12:26,590 --> 00:12:28,100
因此

371
00:12:29,070 --> 00:12:31,210
不要担心你的算法太简单 或者太不完美

372
00:12:32,120 --> 00:12:33,580
而是尽可能快地

373
00:12:33,690 --> 00:12:35,220
实现你的算法

374
00:12:35,450 --> 00:12:37,550
当你有了初始的实现之后

375
00:12:37,820 --> 00:12:38,860
它会变成一个非常有力的工具

376
00:12:39,230 --> 00:12:40,420
来帮助你决定

377
00:12:40,610 --> 00:12:42,170
下一步的做法

378
00:12:42,390 --> 00:12:43,390
因为我们可以先看看算法造成的错误

379
00:12:43,630 --> 00:12:44,720
通过误差分析

380
00:12:45,280 --> 00:12:46,360
来看看他犯了什么错

381
00:12:47,010 --> 00:12:48,420
然后来决定优化的方式

382
00:12:49,030 --> 00:12:50,880
另一件事是

383
00:12:51,000 --> 00:12:53,360
假设你有了一个快速而不完美的算法实现

384
00:12:53,620 --> 00:12:55,700
又有一个数值的评估数据

385
00:12:55,940 --> 00:12:57,660
这会帮助你

386
00:12:57,730 --> 00:12:58,980
尝试新的想法

387
00:12:59,810 --> 00:13:00,810
快速地发现

388
00:13:01,030 --> 00:13:02,170
你尝试的这些想法

389
00:13:02,440 --> 00:13:03,830
是否能够提高算法的表现

390
00:13:03,920 --> 00:13:05,420
从而

391
00:13:05,570 --> 00:13:06,470
你会更快地

392
00:13:06,860 --> 00:13:08,440
做出决定

393
00:13:08,760 --> 00:13:09,900
在算法中放弃什么 吸收什么

394
00:13:10,240 --> 00:13:11,520
【教育无边界字幕组】翻译: 御姐sama 校对/审核: 所罗门捷列夫