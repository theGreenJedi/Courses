1
00:00:00,210 --> 00:00:01,300
前回のビデオでは

2
00:00:01,600 --> 00:00:03,390
機械学習の問題に

3
00:00:03,520 --> 00:00:04,780
直面している時は

4
00:00:04,980 --> 00:00:07,260
アルゴリズムを改善するたくさんの方法がありうる、という話をした。

5
00:00:08,460 --> 00:00:09,510
このビデオでは

6
00:00:09,650 --> 00:00:11,060
エラー(誤差)分析の概念を話していく。

7
00:00:11,330 --> 00:00:12,980
それはこれらの決断を行うにあたって

8
00:00:13,070 --> 00:00:13,980
よりシステマティックなやり方を

9
00:00:14,300 --> 00:00:15,830
行う助けとなってくれる物だ。

10
00:00:18,070 --> 00:00:19,420
もしあなたが機械学習のプロダクトや

11
00:00:19,540 --> 00:00:21,210
機械学習のアプリケーションの

12
00:00:21,400 --> 00:00:23,340
仕事を始めたら、

13
00:00:23,480 --> 00:00:24,880
最初にとても複雑で

14
00:00:25,840 --> 00:00:27,000
たくさんの複雑なフィーチャーを持つような

15
00:00:27,520 --> 00:00:29,070
システムを構築する事から始めるのでは無く、

16
00:00:29,220 --> 00:00:30,490
その代わりに

17
00:00:30,930 --> 00:00:32,450
とてもシンプルなアルゴリズムで

18
00:00:33,060 --> 00:00:34,120
手早く実装出来る物から始める方が

19
00:00:34,510 --> 00:00:35,760
しばしば良い習慣だと考えられている。

20
00:00:37,480 --> 00:00:38,610
そして学習の問題に

21
00:00:38,740 --> 00:00:39,770
私がとりかかる時は

22
00:00:40,150 --> 00:00:41,350
いつもまる一日、

23
00:00:41,570 --> 00:00:43,160
文字通り長くとも24時間くらいで

24
00:00:43,460 --> 00:00:46,030
とても汚くて早く物を得ようとする。

25
00:00:47,040 --> 00:00:48,550
率直に言って、まったく洗練されてないシステムだ。

26
00:00:49,370 --> 00:00:50,310
そしてとても手早く汚い、

27
00:00:50,400 --> 00:00:52,080
動く物を実装し、

28
00:00:52,590 --> 00:00:53,710
それをクロスバリデーションのデータで

29
00:00:53,880 --> 00:00:55,870
テストする。

30
00:00:56,050 --> 00:00:57,140
ひとたびそれを終えれば

31
00:00:57,480 --> 00:00:58,690
学習曲線をプロット出来る。

32
00:00:59,960 --> 00:01:02,670
これは前回のビデオで我らが議論した物だ。

33
00:01:03,230 --> 00:01:05,160
そのトレーニングとテストの誤差による

34
00:01:05,370 --> 00:01:07,120
学習曲線をプロットし、

35
00:01:07,310 --> 00:01:08,280
それで、あなたの学習アルゴリズムが

36
00:01:08,400 --> 00:01:09,630
高バイアスに陥っているのか

37
00:01:10,120 --> 00:01:11,240
それとも高バリアンスか

38
00:01:11,440 --> 00:01:13,180
はたまたそれ以外の何かかを見分けようとする。

39
00:01:13,440 --> 00:01:14,380
そしてそれを用いて、

40
00:01:14,490 --> 00:01:15,610
もっと多くのデータやもっと多くのフィーチャーや

41
00:01:16,080 --> 00:01:17,990
そういった事が役に立ちそうかを決定しようと試みる。

42
00:01:18,670 --> 00:01:19,830
これが良いアプローチである理由は

43
00:01:20,000 --> 00:01:20,980
しばしば

44
00:01:21,940 --> 00:01:22,980
学習問題を始めた時には

45
00:01:23,100 --> 00:01:24,460
前もって、何が必要なのか、

46
00:01:24,680 --> 00:01:25,820
より複雑なフィーチャーが必要なのか

47
00:01:26,480 --> 00:01:27,360
はたまたより多くのデータが必要なのか、

48
00:01:27,790 --> 00:01:29,200
またはそれ以外の何かが必要なのか

49
00:01:29,250 --> 00:01:30,950
知る方法がまったく無いからだ。

50
00:01:31,280 --> 00:01:32,270
そして前もって

51
00:01:32,510 --> 00:01:33,840
エビデンス無しで

52
00:01:33,970 --> 00:01:36,040
学習曲線を見ること無く

53
00:01:36,160 --> 00:01:37,840
あなたはどこに時間を使うべきかを

54
00:01:37,970 --> 00:01:39,130
見出すのは、信じられないほど

55
00:01:39,750 --> 00:01:42,860
難しいってだけ。

56
00:01:43,760 --> 00:01:45,360
そしてしばしば、

57
00:01:45,730 --> 00:01:46,670
とてもとても早く汚い実装でさえ、それを行う事で

58
00:01:46,980 --> 00:01:48,100
学習曲線をプロット出来て

59
00:01:48,540 --> 00:01:51,070
これらの意思決定の助けと出来る。

60
00:01:52,580 --> 00:01:53,340
つまりもしお望みならこれを、

61
00:01:53,560 --> 00:01:54,490
コンピュータプログラミングにおいての

62
00:01:54,620 --> 00:01:56,270
いわゆる

63
00:01:56,570 --> 00:01:58,950
未熟な最適化を避ける方法みたいな物と考えても良い。

64
00:02:00,000 --> 00:02:01,070
そしてこれは、

65
00:02:01,200 --> 00:02:03,130
単純に、直感を用いるよりも

66
00:02:03,460 --> 00:02:04,920
エビデンスに我らが時間を費やすべき場所を

67
00:02:05,650 --> 00:02:06,540
ガイドさせるようにすべきだ、

68
00:02:07,160 --> 00:02:08,150
と言っているだけだ。

69
00:02:09,070 --> 00:02:09,680
直感は、しばしば間違ってるから。

70
00:02:10,930 --> 00:02:12,120
学習曲線をプロットする事に加えて、

71
00:02:12,390 --> 00:02:13,540
もう一つ、しばしば行うととても有効な事として、

72
00:02:13,810 --> 00:02:16,440
エラー分析、と呼ばれる物がある。

73
00:02:18,120 --> 00:02:19,080
エラー分析とは、

74
00:02:19,280 --> 00:02:20,520
例えばスパムフィルターなどを

75
00:02:20,770 --> 00:02:22,190
作っている時に、

76
00:02:22,470 --> 00:02:24,500
私はしばしば、

77
00:02:24,730 --> 00:02:26,690
クロスバリデーションセットを見てみて、

78
00:02:27,360 --> 00:02:29,110
そして私のアルゴリズムがエラーになったe-mailを

79
00:02:29,310 --> 00:02:30,910
人力で見ていく、という事をする。

80
00:02:31,180 --> 00:02:32,250
つまり、アルゴリズムが誤って分類した、

81
00:02:32,630 --> 00:02:34,440
スパムと非スパムのe-mailを

82
00:02:34,640 --> 00:02:36,920
調べていって、

83
00:02:37,430 --> 00:02:38,590
そして誤分類された手本に

84
00:02:39,210 --> 00:02:41,300
なんらかのシステマティックなパターンを特定出来ないか、見てみるのだ。

85
00:02:42,980 --> 00:02:44,560
そしてしばしば、これを行う事で、

86
00:02:44,810 --> 00:02:45,960
新しいフィーチャーをデザインする事を

87
00:02:47,170 --> 00:02:48,800
インスパイアしてくれたり、

88
00:02:49,430 --> 00:02:50,420
現在のシステムの

89
00:02:50,920 --> 00:02:52,150
短所などを教えてくれて

90
00:02:52,400 --> 00:02:53,290
そしてそれを改善する為に

91
00:02:54,270 --> 00:02:55,550
必要な事への

92
00:02:55,660 --> 00:02:57,680
インスピレーションを与えてくれる。

93
00:02:58,260 --> 00:03:00,070
具体的に見てみよう。ここに具体的な例がある。

94
00:03:01,350 --> 00:03:02,360
スパム分類器を作っているとしよう。

95
00:03:02,780 --> 00:03:05,740
そしてクロスバリデーションセットに

96
00:03:05,840 --> 00:03:07,720
500の手本が

97
00:03:07,940 --> 00:03:09,650
あるとする。

98
00:03:10,410 --> 00:03:11,760
そしてこの手本に対し、

99
00:03:12,010 --> 00:03:13,060
アルゴリズムはとても高いエラー率となっているとしよう。

100
00:03:13,340 --> 00:03:14,640
クロスバリデーションの手本を

101
00:03:14,910 --> 00:03:16,500
100通も誤分類しているとする。

102
00:03:18,770 --> 00:03:19,850
その時、そこで私が行うのは、

103
00:03:20,450 --> 00:03:22,370
手動でこれらの100個のエラーを精査していき、

104
00:03:22,530 --> 00:03:24,450
手動でそれらをカテゴライズする、という事だ。

105
00:03:24,700 --> 00:03:25,810
それは例えばe-mailの種類が何なのか、などに

106
00:03:25,980 --> 00:03:27,110
基づいて、あるいは

107
00:03:27,270 --> 00:03:28,630
アルゴリズムがそれらを正しく分類する為の

108
00:03:28,710 --> 00:03:31,130
助けとなりそうな手がかり、フィーチャーに基づいて。

109
00:03:32,450 --> 00:03:33,880
具体的には、

110
00:03:34,080 --> 00:03:35,050
e-mailの種類が何なのか、というのは、

111
00:03:35,560 --> 00:03:36,870
これらの100通の

112
00:03:37,140 --> 00:03:38,180
エラーのメールを見ていった時に、

113
00:03:38,520 --> 00:03:39,660
例えば誤って分類されているe-mailの中で

114
00:03:39,970 --> 00:03:41,350
もっとも一般的なのは

115
00:03:41,840 --> 00:03:43,450
薬事関係のe-mail、

116
00:03:44,010 --> 00:03:45,610
つまり基本的には

117
00:03:45,610 --> 00:03:48,300
薬とかを売ろうとするe-mailと、

118
00:03:48,610 --> 00:03:50,000
レプリカを売ろうとする

119
00:03:50,180 --> 00:03:51,740
e-mail、つまり

120
00:03:51,760 --> 00:03:54,330
偽物の時計とか、偽物の何かを売ろうとするメールとか、

121
00:03:56,160 --> 00:03:59,410
パスワードを盗もうとするe-mail、

122
00:04:00,240 --> 00:04:01,400
またそれは、フィッシングとも呼ばれるが、そういうのもあったとする。

123
00:04:02,180 --> 00:04:04,690
それはe-mailの、別の大きなカテゴリだ。
そして、それ以外のカテゴリ。

124
00:04:06,160 --> 00:04:07,800
つまり、e-mailが

125
00:04:08,120 --> 00:04:09,230
どのカテゴリに属しているか、という観点で

126
00:04:09,530 --> 00:04:10,420
実際にメールを見ていって

127
00:04:10,890 --> 00:04:11,990
数え上げていく、

128
00:04:12,200 --> 00:04:14,220
100通のe-mailを。すると例えば

129
00:04:14,400 --> 00:04:15,510
ミスラベルされているe-mailのうち、12通は

130
00:04:15,620 --> 00:04:17,600
薬事関係のe-mailだと分かったとする。

131
00:04:18,100 --> 00:04:19,460
そして4通は

132
00:04:19,700 --> 00:04:20,840
レプリカを売ろうとするe-mail、

133
00:04:20,980 --> 00:04:22,680
偽物の腕時計とか、そういう物を売ろうとする物。

134
00:04:23,720 --> 00:04:25,060
そしてミスラベルされたe-mailのうち

135
00:04:25,650 --> 00:04:26,970
53通が、いわゆる

136
00:04:27,720 --> 00:04:29,480
フィッシングe-mailだったとする、

137
00:04:29,730 --> 00:04:30,900
それは基本的にはあなたにパスワードを提供するように

138
00:04:31,020 --> 00:04:32,760
説得しようとする物だ。そして31通がそれ以外の種類のe-mailだったとする。

139
00:04:35,330 --> 00:04:37,210
そしてこれら別々のカテゴリに属する

140
00:04:37,280 --> 00:04:38,280
e-mailの数を数え上げる事により、

141
00:04:38,430 --> 00:04:39,540
例えば、あなたは

142
00:04:39,790 --> 00:04:41,570
アルゴリズムが特定のe-mailに関して

143
00:04:41,870 --> 00:04:43,100
とても貧弱に振舞っている、と

144
00:04:44,170 --> 00:04:45,640
例えばパスワードを盗もうとするe-mailに対して

145
00:04:45,780 --> 00:04:47,240
とても貧弱しか機能していないという事を発見したとする。

146
00:04:47,400 --> 00:04:49,230
するとそれは、

147
00:04:49,380 --> 00:04:50,490
あなたがその種のe-mailを

148
00:04:50,690 --> 00:04:51,650
もっと注意深く調べるべく労力を払う価値がある、という事を

149
00:04:51,900 --> 00:04:53,350
示唆している。

150
00:04:53,450 --> 00:04:54,450
そしてそれらを正しくカテゴライズ出来るような

151
00:04:55,070 --> 00:04:56,280
より良いフィーチャーを得られるか見てみる事にも。

152
00:04:57,550 --> 00:04:58,930
そしてまた、私は、

153
00:04:59,000 --> 00:05:00,130
どんな手がかりがあれば、

154
00:05:00,550 --> 00:05:02,120
どんな追加のフィーチャーがあれば

155
00:05:02,620 --> 00:05:04,920
アルゴリズムがe-mailを分類する助けとなるかを、見てみても良い。

156
00:05:06,090 --> 00:05:06,970
例えば、我らの仮説が

157
00:05:07,060 --> 00:05:09,700
よりe-mailをうまく分類するのを

158
00:05:09,840 --> 00:05:10,780
助けてくれそうな物、フィーチャーとして

159
00:05:10,920 --> 00:05:13,240
故意のミススペルを検出する、という事と、

160
00:05:13,490 --> 00:05:15,600
異常なe-mailのルーティング、

161
00:05:16,220 --> 00:05:18,610
そしてスパムっぽい句読点等の

162
00:05:19,950 --> 00:05:21,450
記号の使い方、たとえば

163
00:05:21,790 --> 00:05:23,230
エクスクラメーションマークを多様する、とか、があるとする。

164
00:05:23,700 --> 00:05:24,470
そしてもう一度、私は手動で

165
00:05:24,860 --> 00:05:25,670
見ていって、

166
00:05:25,760 --> 00:05:27,490
例えば5つのケースのこれを、

167
00:05:27,620 --> 00:05:29,400
そして16のケースのこれを、

168
00:05:29,500 --> 00:05:30,560
そして32のケースのこれを、

169
00:05:31,180 --> 00:05:33,620
そしてその他たくさんのそれ以外の種類のe-mailも、同様に見つけたとする。

170
00:05:34,770 --> 00:05:36,180
そしてもしこれが

171
00:05:36,350 --> 00:05:37,470
あなたが実際にクロスバリデーションセットで得られた物だとするなら、

172
00:05:38,070 --> 00:05:39,170
その場合はこれはつまり

173
00:05:39,300 --> 00:05:41,060
意図的なミススペルは

174
00:05:41,660 --> 00:05:42,730
現実には十分にレアな問題だと告げている訳だから、

175
00:05:43,500 --> 00:05:44,480
それはつまり、それを検出するアルゴリズムを

176
00:05:44,840 --> 00:05:47,120
書こうと時間を費やすだけの価値が

177
00:05:47,710 --> 00:05:48,780
実際には無い、という事を教えてくれる。

178
00:05:49,480 --> 00:05:50,480
だが、もしあなたが

179
00:05:50,780 --> 00:05:52,070
スパマーがたくさんの

180
00:05:52,140 --> 00:05:54,150
普通で無い句読点等の記号を用いている事を見つけたなら、

181
00:05:54,290 --> 00:05:55,250
それは句読点等の記号に基づいた

182
00:05:55,670 --> 00:05:56,730
より洗練したフィーチャーを

183
00:05:57,000 --> 00:05:58,510
開発するのに実際に時間を費やすのは

184
00:05:58,780 --> 00:06:00,280
やってみるだけの価値があるという事を示す

185
00:06:00,910 --> 00:06:02,190
強いサインとなりうる。

186
00:06:03,330 --> 00:06:04,870
つまり、この種のエラー分析は、

187
00:06:05,040 --> 00:06:06,390
実際に手動で

188
00:06:06,690 --> 00:06:08,430
アルゴリズムの犯した過ちを

189
00:06:09,190 --> 00:06:10,540
精査していくプロセスだが、

190
00:06:10,780 --> 00:06:12,220
これは、しばしば、

191
00:06:12,560 --> 00:06:14,620
辿るともっとも実りの多い道を示す助けと、なってくれる事がある。

192
00:06:16,000 --> 00:06:17,410
そしてこれはまた、私がしょっちゅう

193
00:06:17,590 --> 00:06:19,260
アルゴリズムの早くて汚い実装を

194
00:06:19,550 --> 00:06:21,250
推奨する理由も説明している。

195
00:06:22,040 --> 00:06:22,940
我らが本当にしたい事は、

196
00:06:23,260 --> 00:06:24,290
アルゴリズムにとってもっとも分類が困難な手本はどれなのかを

197
00:06:24,310 --> 00:06:26,770
見つけ出す事だ。

198
00:06:27,860 --> 00:06:29,920
そしてだいたいにおいて、

199
00:06:30,460 --> 00:06:31,730
別々のアルゴリズム、別々の学習アルゴリズムであっても、

200
00:06:32,010 --> 00:06:33,500
それらは良く、

201
00:06:33,560 --> 00:06:35,920
類似したカテゴリーの手本を、困難だ、とみなす物だ。

202
00:06:37,010 --> 00:06:37,970
そして早くて汚い実装を

203
00:06:38,060 --> 00:06:39,840
用いる事は、

204
00:06:39,910 --> 00:06:40,850
ある種のエラーを特定する為の

205
00:06:41,430 --> 00:06:43,070
手早い方法を提供してくれる事が多く、

206
00:06:43,620 --> 00:06:44,690
そして何が困難な手本なのかを手早く特定してくれるので、

207
00:06:44,790 --> 00:06:47,760
それに労力を集中出来る。

208
00:06:49,230 --> 00:06:51,220
最後に、学習アルゴリズムを開発する時には、

209
00:06:52,260 --> 00:06:53,880
もう一つ有用な豆知識としては、

210
00:06:54,190 --> 00:06:55,230
あなたの学習アルゴリズムを

211
00:06:55,590 --> 00:06:56,450
数値的に評価する方法を

212
00:06:56,810 --> 00:06:59,710
確認する事だ。

213
00:07:02,130 --> 00:07:03,220
今言った事で私が意味しているのは、

214
00:07:03,460 --> 00:07:04,670
もしあなたが学習アルゴリズムを開発する時には、

215
00:07:05,230 --> 00:07:07,180
あなたの学習アルゴリズムを

216
00:07:08,060 --> 00:07:09,170
評価した時に、単一の実数が帰ってくるような

217
00:07:09,460 --> 00:07:10,830
方法を確保出来たら

218
00:07:11,290 --> 00:07:13,100
信じられない程役に立つ、という事だ。

219
00:07:13,650 --> 00:07:14,880
それは正確さでもいいし、エラーでもいい。

220
00:07:15,620 --> 00:07:18,390
だが何にせよ、それは単一の実数値でなくてはいけなくて、それであなたの学習アルゴリズムがどれだけうまく行っているかを告げる物でなくてはならない。

221
00:07:20,280 --> 00:07:21,330
この特別な概念については、

222
00:07:21,770 --> 00:07:24,650
後のビデオでもっと詳細に議論するが、ここに具体的な例がある。

223
00:07:25,790 --> 00:07:26,600
例えば、我らは

224
00:07:26,690 --> 00:07:27,990
discount, discounts, discounter, discountingなどを

225
00:07:28,060 --> 00:07:29,140
同一の単語として扱うべきかを

226
00:07:29,590 --> 00:07:32,060
決断したいとしよう。

227
00:07:32,370 --> 00:07:33,390
それを行う一つの方法としては

228
00:07:33,520 --> 00:07:34,770
例えば単純に、単語の最初の数文字だけを見る、

229
00:07:35,400 --> 00:07:38,780
というのが考えられる。

230
00:07:38,960 --> 00:07:40,240
例えば、仮にあなたが、

231
00:07:40,300 --> 00:07:41,690
単語の最初の数文字だけを見るとすると、

232
00:07:41,780 --> 00:07:44,640
これらの単語は

233
00:07:44,920 --> 00:07:45,970
だいたい似たような意味である事が

234
00:07:46,130 --> 00:07:47,990
分かるだろう。

235
00:07:50,460 --> 00:07:52,090
自然言語処理において、

236
00:07:52,250 --> 00:07:53,270
これを行う方法としては、実際には

237
00:07:53,510 --> 00:07:55,960
ステムソフトウェア(語幹を取り出すソフトウェア)と言われるソフトウェアを用いる事だ。

238
00:07:56,940 --> 00:07:58,080
もしあなたがこれを自分でやりたい、と

239
00:07:58,160 --> 00:07:59,880
思ったなら、webサーチエンジンで

240
00:07:59,950 --> 00:08:01,240
Porter Stemmerを検索するべし。

241
00:08:01,500 --> 00:08:02,660
そうすれば

242
00:08:02,960 --> 00:08:04,320
この種のステミングを行ってくれる

243
00:08:04,620 --> 00:08:05,830
かなりリーズナブルなソフトウェアを

244
00:08:06,110 --> 00:08:07,020
教えてくれるだろう、

245
00:08:07,130 --> 00:08:08,140
それを使えば、これら全ての

246
00:08:08,800 --> 00:08:10,540
discountやらdiscountsやらを同じ単語とみなしてくれる。

247
00:08:13,950 --> 00:08:15,930
だが、ステムのソフトウェアを使う、というのは、

248
00:08:16,630 --> 00:08:17,710
基本的には単語の

249
00:08:17,830 --> 00:08:19,290
最初の数文字を見る、

250
00:08:19,450 --> 00:08:21,630
というような事をするんであって、それは良くなる事もあるが悪くなる事もある。

251
00:08:22,240 --> 00:08:23,490
何故悪くなる事があるのかというと、

252
00:08:23,900 --> 00:08:25,360
例えばこのソフトウェアは

253
00:08:25,930 --> 00:08:27,850
universeとuniversityを

254
00:08:27,990 --> 00:08:29,980
誤って同じ単語と

255
00:08:30,070 --> 00:08:31,220
みなしてしまうかもしれない。何故なら

256
00:08:31,450 --> 00:08:33,220
これら2つの単語は、どちらも

257
00:08:33,480 --> 00:08:35,480
とても似た文字で、同じアルファベットで始まっているから。

258
00:08:37,300 --> 00:08:39,050
だから、スパム分類器に

259
00:08:39,280 --> 00:08:40,290
ステムソフトウェアを使った方が良いかを

260
00:08:40,630 --> 00:08:42,490
決めるのは、

261
00:08:42,670 --> 00:08:45,960
いつも簡単という訳には行かない。

262
00:08:46,350 --> 00:08:47,810
さらに、エラー分析は

263
00:08:48,510 --> 00:08:49,590
この種のステムが良いアイデアかを

264
00:08:51,030 --> 00:08:52,860
決定するには、

265
00:08:53,060 --> 00:08:54,410
あまり役に立たない。

266
00:08:55,570 --> 00:08:56,740
その代わりに、

267
00:08:57,020 --> 00:08:58,320
あなたの分類器を助けるのに

268
00:08:58,690 --> 00:08:59,970
ステミングソフトウェアが

269
00:09:00,190 --> 00:09:01,570
良いかどうかを判断する一番良い方法は、

270
00:09:01,740 --> 00:09:02,980
とても手早く、実際に試してみて

271
00:09:03,370 --> 00:09:05,170
うまく行くかどうかを確認出来る方法を持っておく事だ。

272
00:09:08,560 --> 00:09:09,530
そしてこれを行う為には、

273
00:09:10,260 --> 00:09:11,350
数値的にあなたのアルゴリズムを評価する方法を確立しておく事は

274
00:09:12,250 --> 00:09:14,570
とても役に立つ事だ。

275
00:09:15,940 --> 00:09:17,670
具体的には、

276
00:09:18,110 --> 00:09:19,190
これを行うもっとも自然なやり方としては、

277
00:09:19,350 --> 00:09:20,250
ステム有りと無しで、アルゴリズムの

278
00:09:20,900 --> 00:09:23,510
クロスバリデーション誤差を見てみる事だ。

279
00:09:24,590 --> 00:09:25,560
つまり、もしあなたが

280
00:09:25,800 --> 00:09:27,190
ステム無しでアルゴリズムを走らせて、

281
00:09:27,330 --> 00:09:28,430
5パーセントの誤差だったとして、

282
00:09:29,080 --> 00:09:31,260
つまり5パーセントの分類誤差だったとして、

283
00:09:31,360 --> 00:09:32,410
そしてステム有りでもう一度走らせて

284
00:09:32,540 --> 00:09:33,780
例えば3パーセントの

285
00:09:34,110 --> 00:09:36,170
分類誤差だったとすると、

286
00:09:36,440 --> 00:09:37,920
この誤差の減少は

287
00:09:38,640 --> 00:09:39,980
一瞬であなたに、

288
00:09:40,310 --> 00:09:42,250
ステムを使うのは良さそうなアイデアだ、と教えてくれる訳だ。

289
00:09:43,080 --> 00:09:44,650
この特定の例に関しては

290
00:09:44,940 --> 00:09:46,560
とても自然な単一実数による

291
00:09:46,830 --> 00:09:50,210
評価指標が存在している。つまり、クロスバリデーション誤差だ。

292
00:09:50,930 --> 00:09:52,700
我らは後に、

293
00:09:53,080 --> 00:09:54,360
この種の単一実数による評価指標を得るのに

294
00:09:54,790 --> 00:09:58,220
もうちょっと作業が必要な例を見る事になる。

295
00:09:58,790 --> 00:09:59,840
だが後のビデオで見るように、

296
00:09:59,930 --> 00:10:01,620
それだけの作業をしてメトリクスを得ておく事は

297
00:10:01,750 --> 00:10:02,860
この種の、例えばステムを使うべきかどうか、

298
00:10:02,990 --> 00:10:04,290
というような意思決定を、

299
00:10:04,760 --> 00:10:06,380
より素早く行う事を可能にしてくれる。

300
00:10:08,700 --> 00:10:09,950
さらにもう一つ簡単な例を挙げておこう。

301
00:10:10,680 --> 00:10:11,670
例えば大文字と小文字の

302
00:10:12,040 --> 00:10:13,450
区別をすべきかを

303
00:10:13,650 --> 00:10:15,710
決めようとしているとしよう。

304
00:10:15,990 --> 00:10:16,910
例えばこのmomという単語、

305
00:10:17,060 --> 00:10:18,850
大文字のMと

306
00:10:19,060 --> 00:10:20,390
小文字のmがある。

307
00:10:20,700 --> 00:10:21,720
これを同じ単語とみなすべきか？

308
00:10:21,780 --> 00:10:23,810
それとも別の単語とみなすべきか？

309
00:10:23,970 --> 00:10:26,890
これは同じフィーチャーをみなすべきだろうか？別のフィーチャーとみなすべきだろうか？

310
00:10:27,010 --> 00:10:28,060
ここでも、

311
00:10:28,350 --> 00:10:29,150
我らのアルゴリズムを

312
00:10:29,300 --> 00:10:30,790
評価する方法を持っているので、

313
00:10:31,060 --> 00:10:32,350
ここで試してみると、

314
00:10:32,650 --> 00:10:34,910
もし大文字と小文字を

315
00:10:35,140 --> 00:10:36,490
区別しないでみたら、

316
00:10:36,600 --> 00:10:38,580
3.2%のエラーとなり、

317
00:10:38,700 --> 00:10:39,820
ゆえに私は

318
00:10:40,020 --> 00:10:41,750
これが単純にステムだけを使うより

319
00:10:42,260 --> 00:10:43,360
悪くなっている事が分かった為、

320
00:10:43,640 --> 00:10:45,110
このようにとても手早く

321
00:10:45,370 --> 00:10:47,420
大文字と小文字を

322
00:10:48,270 --> 00:10:49,720
区別すべきかどうかに関して

323
00:10:49,820 --> 00:10:51,540
意思決定を行い、前に進む事が出来る。

324
00:10:52,140 --> 00:10:53,390
だからあなたが学習アルゴリズムを

325
00:10:53,690 --> 00:10:55,260
開発している時には、

326
00:10:55,650 --> 00:10:56,840
しょっちゅう、たくさんの新しいアイデアとか

327
00:10:57,050 --> 00:10:59,930
新しいバージョンの学習アルゴリズムなどを試す事になるだろう。

328
00:11:00,960 --> 00:11:02,050
もし毎回新しいアイデアを

329
00:11:02,350 --> 00:11:03,740
試す都度、

330
00:11:03,840 --> 00:11:05,610
人力でたくさんの手本を精査する羽目になると

331
00:11:05,750 --> 00:11:06,730
すぐに、ステムを使うべきか？

332
00:11:06,860 --> 00:11:08,530
大文字と小文字を区別すべきか？などの

333
00:11:08,640 --> 00:11:09,410
意思決定を行う時に

334
00:11:09,580 --> 00:11:10,610
良くなるのか、悪くなるのかを見るのが

335
00:11:10,980 --> 00:11:12,410
難しくなっていく事に

336
00:11:12,580 --> 00:11:13,640
気づくだろう。

337
00:11:15,180 --> 00:11:16,590
だが単一の実数値による

338
00:11:16,770 --> 00:11:18,520
評価指標があれば、

339
00:11:18,680 --> 00:11:21,150
単にそれを見て、エラーが増えたか減ったか、を見れば良い。

340
00:11:22,420 --> 00:11:23,620
そしてそれを用いて、

341
00:11:23,940 --> 00:11:25,760
より素早く、

342
00:11:25,840 --> 00:11:27,820
新しいアイデアを試す事が出来て、

343
00:11:27,990 --> 00:11:29,550
ほとんど即座にあなたの新しいアイデアが

344
00:11:29,690 --> 00:11:31,480
学習アルゴリズムのパフォーマンスを

345
00:11:32,440 --> 00:11:33,230
改善するか悪化させるかを知る事が出来る。

346
00:11:33,930 --> 00:11:35,440
そしてこれがしばしば、

347
00:11:35,560 --> 00:11:38,340
あなたをより早く、前進させてくれる。

348
00:11:38,530 --> 00:11:39,720
さて、エラー分析を行うにあたっては、

349
00:11:40,220 --> 00:11:41,790
テストセットでは無く、クロスバリデーションセットで行う事を

350
00:11:42,370 --> 00:11:44,760
強く推奨する。

351
00:11:45,490 --> 00:11:46,970
だが、世の中には

352
00:11:47,240 --> 00:11:48,260
テストセットでこれをやってしまう人もいる、

353
00:11:48,370 --> 00:11:49,480
数学的には確実にそっちの方が

354
00:11:49,730 --> 00:11:51,530
適切で無いやり方なのだが…

355
00:11:52,190 --> 00:11:54,560
クロスバリデーションセットで

356
00:11:54,730 --> 00:11:55,660
エラー分析を行う、という

357
00:11:55,780 --> 00:11:57,240
推奨されている

358
00:11:57,450 --> 00:11:58,760
やり方に比べると。

359
00:11:59,140 --> 00:12:01,160
ではこのビデオのまとめだ。

360
00:12:01,830 --> 00:12:03,340
新しく機械学習の問題に取り組む時には、

361
00:12:03,610 --> 00:12:05,370
ほとんど毎回私が推奨するのは、

362
00:12:05,610 --> 00:12:06,930
あなたの学習アルゴリズムの

363
00:12:07,030 --> 00:12:08,710
早くて汚い実装を行う事だ。

364
00:12:09,780 --> 00:12:11,760
私はほとんど確実に、

365
00:12:12,120 --> 00:12:15,370
早くて汚い実装に、時間を使わなさ過ぎる、という人は見た事が無い。

366
00:12:18,640 --> 00:12:20,210
私が目にするのは、逆に

367
00:12:20,480 --> 00:12:22,050
最初の、早くて汚いはずの実装に

368
00:12:22,370 --> 00:12:23,720
時間をかけすぎる、という方ばかりを

369
00:12:24,580 --> 00:12:25,800
目にする。

370
00:12:26,590 --> 00:12:28,100
だからほんと。手早すぎる、と

371
00:12:29,070 --> 00:12:31,210
心配しないでいい。汚すぎる、と心配しないでいい。

372
00:12:32,120 --> 00:12:33,580
そうでは無く、自分の出来るかぎり早く、

373
00:12:33,690 --> 00:12:35,220
何かしらを実装しよう。

374
00:12:35,450 --> 00:12:37,550
そしてひとたび最初の実装を得たなら、

375
00:12:37,820 --> 00:12:38,860
これはきっと、その次にあなたが

376
00:12:39,230 --> 00:12:40,420
何に時間を使うべきかを決定する、

377
00:12:40,610 --> 00:12:42,170
とてもパワフルなツールとなるだろう。

378
00:12:42,390 --> 00:12:43,390
何故なら、まずそれの出力するエラーを見て、

379
00:12:43,630 --> 00:12:44,720
この種のエラー分析を行って

380
00:12:45,280 --> 00:12:46,360
何が誤りを生んでいるのかを見て、

381
00:12:47,010 --> 00:12:48,420
それを使ってさらなる開発をインスパイアしていける。

382
00:12:49,030 --> 00:12:50,880
次に、あなたの早くて汚い実装が、

383
00:12:51,000 --> 00:12:53,360
単一実数の評価指標と

384
00:12:53,620 --> 00:12:55,700
共に用いる事が出来たなら、

385
00:12:55,940 --> 00:12:57,660
これは様々なアイデアを行き来する

386
00:12:57,730 --> 00:12:58,980
乗り物となってくれる。

387
00:12:59,810 --> 00:13:00,810
そして素早く

388
00:13:01,030 --> 00:13:02,170
別々のアイデアが、

389
00:13:02,440 --> 00:13:03,830
アルゴリズムのパフォーマンスを改善するかを

390
00:13:03,920 --> 00:13:05,420
試していく事を可能にしてくれて、

391
00:13:05,570 --> 00:13:06,470
ゆえに、何は要らないか、

392
00:13:06,860 --> 00:13:08,440
何はアルゴリズムと共に使うと良いかを

393
00:13:08,760 --> 00:13:09,900
素早く意思決定していく事を

394
00:13:10,240 --> 00:13:11,520
可能にしてくれる。