1
00:00:00,290 --> 00:00:01,690
前回のビデオでは

2
00:00:02,060 --> 00:00:03,900
エラー分析と

3
00:00:04,350 --> 00:00:06,070
エラーのメトリクスを持つ必要性を議論した。

4
00:00:06,330 --> 00:00:07,480
エラーのメトリクスとは

5
00:00:08,210 --> 00:00:10,200
学習アルゴリズムがどれだけうまくやっているかを語る

6
00:00:11,020 --> 00:00:13,290
単一の実数値による評価指標の事だった。

7
00:00:14,310 --> 00:00:15,670
評価とエラーのメトリクスという

8
00:00:16,700 --> 00:00:18,320
文脈においては、

9
00:00:18,430 --> 00:00:20,290
一つの重要なケースとして

10
00:00:20,480 --> 00:00:22,180
あなたの学習アルゴリズムに対して

11
00:00:22,510 --> 00:00:24,430
適切なエラーの指標、 適切な評価の指標を得るのが

12
00:00:24,930 --> 00:00:26,990
トリッキーになってまう場合というのがある。

13
00:00:28,040 --> 00:00:29,140
そのケースとは、いわゆる

14
00:00:29,610 --> 00:00:31,310
スキューした(歪んだ)クラス、と言われる物だ。

15
00:00:32,610 --> 00:00:33,480
それがどういう事か、説明しよう。

16
00:00:36,170 --> 00:00:37,550
ガンの分類の問題を考えよう。

17
00:00:38,180 --> 00:00:40,040
医療患者のフィーチャーがあって、

18
00:00:40,300 --> 00:00:41,960
そして彼らがガンかどうかを

19
00:00:42,070 --> 00:00:44,050
判断したいとする。

20
00:00:44,630 --> 00:00:45,790
つまりこれは

21
00:00:46,350 --> 00:00:48,290
以前に見た、腫瘍が

22
00:00:48,930 --> 00:00:50,070
悪性か良性かの分類の例に似ている。

23
00:00:51,140 --> 00:00:52,360
ガンの患者をy=1と、

24
00:00:52,550 --> 00:00:53,780
そしてそれ以外の患者を

25
00:00:54,280 --> 00:00:56,530
y=0としよう。

26
00:00:56,810 --> 00:00:57,460
ロジスティック回帰の分類器をトレーニングして

27
00:00:57,940 --> 00:00:59,780
テストセットに対して

28
00:01:00,000 --> 00:01:01,520
分類器をテストしてみたら、

29
00:01:01,660 --> 00:01:04,470
1パーセントのエラーを得たとする。

30
00:01:04,790 --> 00:01:05,720
つまり99パーセント正しい診断をした。

31
00:01:06,530 --> 00:01:09,610
うーん、これはなかなか素晴らしい結果、、、かしら？

32
00:01:09,910 --> 00:01:10,920
99パーセントの場合は正しいんだから。

33
00:01:12,560 --> 00:01:13,630
でもここで、

34
00:01:13,940 --> 00:01:15,660
トレーニングとテストセットの0.5パーセントの患者しか

35
00:01:16,510 --> 00:01:17,950
実際にガンに

36
00:01:18,160 --> 00:01:19,590
かかってないとする。

37
00:01:20,400 --> 00:01:21,900
つまりたった

38
00:01:21,950 --> 00:01:23,460
1パーセントの半分の患者しか、

39
00:01:23,580 --> 00:01:25,500
スクリーニングプロセスを越えて実際にガンとならない。

40
00:01:26,560 --> 00:01:27,970
この場合、1パーセントのエラーは

41
00:01:28,270 --> 00:01:30,010
もはやそんなに素晴らしくは見えない。

42
00:01:31,130 --> 00:01:32,510
特に、ここにあるコードなら、

43
00:01:32,670 --> 00:01:33,730
これは実の所学習すらしてない

44
00:01:33,850 --> 00:01:35,730
コードで、単に入力として

45
00:01:36,080 --> 00:01:38,260
フィーチャーxを受け取りながらただそれを無視して

46
00:01:38,480 --> 00:01:39,820
y=0と言うだけのコード。

47
00:01:39,950 --> 00:01:41,640
そしてどんな時でも、誰もガンじゃない、と

48
00:01:41,720 --> 00:01:43,920
予測するという物。

49
00:01:44,170 --> 00:01:45,720
このアルゴリズムは実際に

50
00:01:46,000 --> 00:01:47,840
0.5パーセントのエラーを得る。

51
00:01:48,830 --> 00:01:50,280
つまりこんなのですら

52
00:01:50,400 --> 00:01:51,140
さっき得た1パーセントのエラーよりマシになってしまう。

53
00:01:51,240 --> 00:01:52,960
そしてこれは非学習アルゴリズムで

54
00:01:53,160 --> 00:01:54,600
見ての通り、単にどんな時でも

55
00:01:54,800 --> 00:01:56,950
y=0と予測するだけの物だ。

56
00:01:57,990 --> 00:01:59,430
つまり、このような状況、

57
00:02:00,060 --> 00:02:01,980
陽性の手本と陰性の手本の割合が

58
00:02:02,180 --> 00:02:04,130
とても両極端となるような

59
00:02:04,810 --> 00:02:06,480
状況では、

60
00:02:07,040 --> 00:02:08,620
その場合、

61
00:02:08,710 --> 00:02:10,050
陽性の手本の総数が

62
00:02:10,350 --> 00:02:11,310
陰性の手本の総数よりも

63
00:02:11,620 --> 00:02:13,180
ずっと、ずっと少ない、何故なら

64
00:02:13,480 --> 00:02:15,500
y=1はとてもレアだから。

65
00:02:15,730 --> 00:02:16,850
これが我らが

66
00:02:17,000 --> 00:02:18,600
スキューしたクラス、と呼ぶ物だ。

67
00:02:20,790 --> 00:02:21,710
単にある一方のクラスが、

68
00:02:22,000 --> 00:02:23,140
他方のクラスよりも

69
00:02:23,570 --> 00:02:25,040
ずっとたくさんあるような場合。

70
00:02:25,220 --> 00:02:26,560
そういう場合は単にいつでも

71
00:02:26,920 --> 00:02:28,270
y=0と予測しておけば、

72
00:02:28,650 --> 00:02:29,650
またはいつでもy=1と予測しておけば、

73
00:02:29,790 --> 00:02:32,080
アルゴリズムはとてもうまく振る舞う事が出来る。

74
00:02:32,980 --> 00:02:34,050
さて、分類エラー、または分類の正確さを

75
00:02:34,670 --> 00:02:36,210
評価指標として使う際の

76
00:02:36,590 --> 00:02:39,240
問題点は、以下のようになる。

77
00:02:40,430 --> 00:02:41,360
あなたは手元に、99.2%の正確さが得られる

78
00:02:41,700 --> 00:02:43,570
アルゴリズムを持ってたとしよう。

79
00:02:46,530 --> 00:02:47,200
つまりエラーは0.8%だ。

80
00:02:47,330 --> 00:02:50,850
そしてあなたは自分のアルゴリズムに

81
00:02:51,000 --> 00:02:52,000
変更を加えて、

82
00:02:52,810 --> 00:02:53,890
そして今やあなたは

83
00:02:54,280 --> 00:02:56,080
99.5%の正確さを得たとする。

84
00:02:59,280 --> 00:03:02,110
つまり0.5%のエラーだ。

85
00:03:04,230 --> 00:03:06,460
ではこれは、アルゴリズムの改善と言えるだろうか？

86
00:03:06,770 --> 00:03:07,930
単一の実数評価指標を

87
00:03:08,300 --> 00:03:09,990
持っている事の

88
00:03:10,120 --> 00:03:11,480
利点の一つとしては、

89
00:03:11,650 --> 00:03:13,080
これが我らに、アルゴリズムに良い変更をしたかを

90
00:03:13,240 --> 00:03:15,530
素早く判断する助けとなるというのがある。

91
00:03:16,370 --> 00:03:20,160
99.2%の正確さが99.5%の正確さになったら、

92
00:03:21,430 --> 00:03:22,490
何か有用な事をしたのだろうか？それとも

93
00:03:22,780 --> 00:03:23,640
我らのコードを単に

94
00:03:23,770 --> 00:03:25,150
y=0を単により多く

95
00:03:25,320 --> 00:03:26,690
予測するだけのコードに

96
00:03:27,000 --> 00:03:28,830
置き換えたのだろうか？

97
00:03:29,300 --> 00:03:30,430
つまり、とてもスキューしたクラスの場合には、

98
00:03:31,340 --> 00:03:33,280
単に分類の正確さを使うというのは

99
00:03:33,640 --> 00:03:36,000
より難しくなる。何故なら

100
00:03:36,120 --> 00:03:37,730
とても高い分類の正確さを得る、またはとても低いエラーを

101
00:03:38,420 --> 00:03:40,950
得るという事は出来て、

102
00:03:41,110 --> 00:03:42,880
そしてそれがあなたの分類器を

103
00:03:43,070 --> 00:03:44,190
改善したかは、

104
00:03:44,770 --> 00:03:45,780
いつも明らかという訳では無い、

105
00:03:46,400 --> 00:03:48,320
何故ならどんな時でもy=0を予測する、

106
00:03:48,380 --> 00:03:50,710
というのは、そんなに良い分類器とは

107
00:03:51,570 --> 00:03:52,570
思えない。

108
00:03:53,900 --> 00:03:55,500
だが、単にy=0と、より多く予測するだけで、

109
00:03:55,720 --> 00:03:57,300
エラーを減少させる事が

110
00:03:57,830 --> 00:03:59,460
出来てしまい、これは0.5%まで

111
00:03:59,650 --> 00:04:01,120
減らす事が出来る。

112
00:04:01,490 --> 00:04:02,590
スキューしたクラスに

113
00:04:02,770 --> 00:04:04,990
直面している時には、

114
00:04:05,250 --> 00:04:06,350
もっと別のエラーの指標、

115
00:04:06,470 --> 00:04:07,920
あるいは別の評価指標が、

116
00:04:08,320 --> 00:04:09,500
欲しくなる。

117
00:04:10,290 --> 00:04:12,360
そんな評価指標の一つには、

118
00:04:12,870 --> 00:04:14,240
Preicision(精度)とRecall(再現率)という物がある。

119
00:04:15,440 --> 00:04:16,410
これが何なのかを説明していこう。

120
00:04:17,520 --> 00:04:19,890
テストセットに対して分類器を評価しているとしよう。

121
00:04:20,750 --> 00:04:21,800
例えば

122
00:04:21,890 --> 00:04:23,890
テストセットにある

123
00:04:25,450 --> 00:04:26,880
手本の

124
00:04:27,320 --> 00:04:28,440
実際のクラスが

125
00:04:28,550 --> 00:04:29,810
1か0のどちらかとする。

126
00:04:30,440 --> 00:04:32,520
つまりバイナリ分類問題だ。

127
00:04:33,870 --> 00:04:34,960
そして我らの学習アルゴリズムが

128
00:04:35,360 --> 00:04:37,070
行う事は、

129
00:04:37,930 --> 00:04:39,270
そのクラスの何らかの値を予測する事で、

130
00:04:39,450 --> 00:04:41,160
だから我らの学習アルゴリズムは

131
00:04:41,560 --> 00:04:43,300
テストセットの各手本に対して

132
00:04:43,760 --> 00:04:44,830
値を予測し、

133
00:04:44,910 --> 00:04:46,520
その予測する値もまた

134
00:04:46,920 --> 00:04:48,560
1か0のどちらかだ。

135
00:04:50,050 --> 00:04:52,060
そこで以下のように2x2のテーブルを

136
00:04:52,270 --> 00:04:53,340
書いてみよう。

137
00:04:53,910 --> 00:04:55,870
これらのエントリは、

138
00:04:56,320 --> 00:04:57,800
実際のクラスと予測されたクラスに

139
00:04:57,960 --> 00:04:59,350
基づいて埋める。

140
00:05:00,220 --> 00:05:01,270
もし我らが、

141
00:05:01,570 --> 00:05:02,890
実際のクラスが1で

142
00:05:02,970 --> 00:05:03,950
予測されたクラスが1の手本を持つ時には、

143
00:05:04,240 --> 00:05:06,140
それはtrue positive(真陽性)と

144
00:05:07,620 --> 00:05:08,640
呼ばれる手本である。

145
00:05:08,940 --> 00:05:10,300
その意味する所は、我らのアルゴリズムは

146
00:05:10,730 --> 00:05:11,700
それが陽性だと予測して、しかも実際にも陽性の

147
00:05:12,400 --> 00:05:15,780
手本だった場合。

148
00:05:16,240 --> 00:05:17,300
もし我らのアルゴリズムが

149
00:05:17,490 --> 00:05:19,010
ある物を陰性、クラス0と予測して、

150
00:05:19,570 --> 00:05:20,620
そして実際のクラスもまたクラス0だった時には、

151
00:05:20,970 --> 00:05:23,650
それはtrue negative(真陰性）と呼ばれる。

152
00:05:24,070 --> 00:05:26,370
我らは0と予測し、実際に0だ。

153
00:05:27,880 --> 00:05:28,740
その他の二つの箱は、

154
00:05:29,470 --> 00:05:31,120
我らの学習アルゴリズムが

155
00:05:31,360 --> 00:05:33,210
クラス1だと予測したが、

156
00:05:34,340 --> 00:05:36,370
実際のクラスが0の時には、

157
00:05:36,670 --> 00:05:37,910
これはfalse positive (偽陽性)と呼ばれる。

158
00:05:39,350 --> 00:05:40,630
その意味する所は、我らのアルゴリズムは、

159
00:05:40,830 --> 00:05:41,970
ある患者がガンを持っていると予測しておきながら、

160
00:05:42,190 --> 00:05:43,520
実際には患者はガンを持っていなかった。

161
00:05:44,730 --> 00:05:47,340
そして最後の箱は、0、1。

162
00:05:48,200 --> 00:05:50,330
これはfalse negative（偽陰性）と呼ぶ。

163
00:05:51,180 --> 00:05:52,690
何故なら我らのアルゴリズムは0を予測し、

164
00:05:53,450 --> 00:05:56,170
しかし実際のクラスは1だから。

165
00:05:57,230 --> 00:05:59,020
こうして、我らは

166
00:05:59,150 --> 00:06:00,830
小さなある種の2x2のテーブルを得た、

167
00:06:00,990 --> 00:06:02,720
それは実際のクラスと予測されたクラスに

168
00:06:03,250 --> 00:06:05,500
基づいた物だ。

169
00:06:07,080 --> 00:06:08,380
そしてここに、

170
00:06:08,690 --> 00:06:10,310
我らのアルゴリズムのパフォーマンスを評価する

171
00:06:10,420 --> 00:06:11,940
別の方法がある。

172
00:06:12,550 --> 00:06:12,870
我らは二つの数を計算する事にする。

173
00:06:13,310 --> 00:06:14,780
最初の物は、Precision（精度）と呼ばれる物。

174
00:06:14,940 --> 00:06:16,100
それが伝える事は、

175
00:06:17,170 --> 00:06:18,330
我らがガンだと予測した

176
00:06:18,580 --> 00:06:19,580
全ての患者のうち、

177
00:06:20,640 --> 00:06:23,140
どれだけの割合の人が実際にガンだったのか？

178
00:06:24,560 --> 00:06:25,310
これを書き下してみよう。

179
00:06:26,020 --> 00:06:27,300
分類器のPrecisionとは、

180
00:06:27,680 --> 00:06:29,070
true positiveの総数を

181
00:06:29,310 --> 00:06:31,880
陽性と予測した総数で

182
00:06:32,940 --> 00:06:35,190
割った物だ。

183
00:06:37,140 --> 00:06:37,370
いいかい？

184
00:06:39,150 --> 00:06:40,660
つまり、我らが実際に赴いて、

185
00:06:41,090 --> 00:06:43,590
「あなたはガンだと、我らは思ってる」と告げた患者のうち、

186
00:06:43,890 --> 00:06:45,730
それらの患者全員の中で、

187
00:06:45,890 --> 00:06:47,410
実際にガンを持ってる割合はどれだけか？

188
00:06:47,500 --> 00:06:48,920
それがPrecision(精度)と言われる物だ。

189
00:06:49,800 --> 00:06:50,680
そしてこれの別の書き方としては、

190
00:06:50,950 --> 00:06:54,920
true positiveと

191
00:06:55,010 --> 00:06:56,430
そして分母は、

192
00:06:56,670 --> 00:06:59,050
陽性と予測された総数、

193
00:06:59,210 --> 00:07:00,160
それはつまり

194
00:07:00,240 --> 00:07:01,730
テーブルの最初の行の

195
00:07:02,410 --> 00:07:04,510
エントリの和だ。

196
00:07:04,720 --> 00:07:07,760
つまりそれは、true positiveを割る事のtrue positiveに…

197
00:07:08,670 --> 00:07:10,470
ここでpositiveをPOS、と略す事にしよう、

198
00:07:11,220 --> 00:07:12,980
そしてそこに足す事の

199
00:07:13,130 --> 00:07:15,470
false positive、再びpositiveをPOSと

200
00:07:15,890 --> 00:07:18,550
省略して書く。

201
00:07:20,030 --> 00:07:21,850
これがPrecision（精度）と呼ばれる物だ。

202
00:07:21,920 --> 00:07:23,490
見て分かるように、高いPrecisionは良い事だ。

203
00:07:23,660 --> 00:07:24,680
その意味する所は、我らが赴き、

204
00:07:25,070 --> 00:07:27,100
「大変残念ですが、あなたはガンだと思います」と

205
00:07:27,510 --> 00:07:28,960
告げた患者全てに対して、

206
00:07:29,440 --> 00:07:31,750
高いPrecisionが意味する事は、その患者のグループの

207
00:07:31,980 --> 00:07:33,160
大多数が、

208
00:07:33,390 --> 00:07:34,460
我らが正しく予測を行った事になり、

209
00:07:34,820 --> 00:07:36,630
つまり実際にガンを持っている。

210
00:07:38,840 --> 00:07:39,880
我らが計算する二番目の数値は

211
00:07:40,440 --> 00:07:41,730
Recall（再現率）と呼ばれる物で、

212
00:07:42,060 --> 00:07:44,230
Recallが言う事は、

213
00:07:44,480 --> 00:07:46,100
テストセットなり

214
00:07:46,190 --> 00:07:47,510
クロスバリデーションセットなり、

215
00:07:47,620 --> 00:07:48,830
とにかくデータセットのうち全てのガンの患者

216
00:07:48,960 --> 00:07:49,980
に対して、

217
00:07:50,150 --> 00:07:51,550
彼らのうち

218
00:07:52,670 --> 00:07:54,240
どれだけの割合を

219
00:07:54,400 --> 00:07:56,250
正しくガンだと、検出出来たか？という事。

220
00:07:56,950 --> 00:07:57,870
つまり、全ての患者がガンだったとして、

221
00:07:58,090 --> 00:07:59,170
それらのうち、何人の元に

222
00:07:59,400 --> 00:08:01,130
我らは実際におもむき、

223
00:08:01,320 --> 00:08:03,850
正しくも「あなた方には治療が必要だと我らは思っている」と告げる事が出来るだろうか？

224
00:08:05,860 --> 00:08:07,010
つまり、これを書き下すと、

225
00:08:07,360 --> 00:08:08,970
Recall(再現率)は以下のように定義出来る：

226
00:08:09,040 --> 00:08:12,020
陽性の、、、true positiveの

227
00:08:12,470 --> 00:08:14,760
総数、つまり、

228
00:08:15,260 --> 00:08:16,320
実際にガンを持ってる患者の中から、

229
00:08:16,520 --> 00:08:17,890
我らが正しくガンを持っていると

230
00:08:18,030 --> 00:08:19,280
予測出来た総数だが、

231
00:08:20,310 --> 00:08:21,440
それを割る事の、

232
00:08:21,790 --> 00:08:23,510
実際に陽性である患者の

233
00:08:23,740 --> 00:08:29,300
総数で割る。

234
00:08:31,200 --> 00:08:32,070
つまりこれは、

235
00:08:32,510 --> 00:08:35,190
実際にガンを持っている人々の正しい陽性の数だ。

236
00:08:35,850 --> 00:08:37,000
どれだけの割合にフラグ立てして

237
00:08:37,430 --> 00:08:38,950
処置に送れるか？

238
00:08:40,560 --> 00:08:41,780
つまり、これを違う形に

239
00:08:41,930 --> 00:08:44,060
書き直すと、分母は

240
00:08:44,210 --> 00:08:45,160
実際の陽性の数だから、

241
00:08:45,430 --> 00:08:46,990
つまりそれは

242
00:08:47,220 --> 00:08:49,480
ここの最初の列のエントリの和だ。

243
00:08:50,600 --> 00:08:51,660
つまり、別の書き方で書くと、

244
00:08:52,160 --> 00:08:53,470
これはつまり、true positiveの総数を

245
00:08:53,650 --> 00:08:57,120
true positiveの総数 足す事の

246
00:08:59,010 --> 00:09:01,340
false negativeで

247
00:09:02,790 --> 00:09:05,430
割った物、

248
00:09:06,750 --> 00:09:07,690
という事になる。

249
00:09:09,570 --> 00:09:12,180
そしてここでも、高いRecall(再現率)になるのは、良い事だ。

250
00:09:14,180 --> 00:09:15,810
そしてPrecision(精度)とRecall(再現率)を計算する事により、

251
00:09:15,930 --> 00:09:17,100
我らは分類器がどれだけ

252
00:09:17,340 --> 00:09:18,740
うまく振舞っているかについて、

253
00:09:19,140 --> 00:09:20,560
より良い感覚を得られる。

254
00:09:21,620 --> 00:09:22,960
そして例えば、

255
00:09:23,330 --> 00:09:24,740
いつもy=0を予測するような

256
00:09:25,520 --> 00:09:27,020
学習アルゴリズムだとすると、

257
00:09:27,190 --> 00:09:28,290
それが一回もガンだと

258
00:09:28,460 --> 00:09:30,080
予測しないとすると、

259
00:09:30,250 --> 00:09:31,880
その場合、この分類器は

260
00:09:32,070 --> 00:09:33,820
Recall(再現率) = 0となる。

261
00:09:34,370 --> 00:09:35,300
何故ならそこには、

262
00:09:35,570 --> 00:09:36,940
true positiveは全く無いから。

263
00:09:37,190 --> 00:09:37,930
つまりこれは、

264
00:09:38,010 --> 00:09:40,290
分類器がいつもy=0を予測しているという事を知る

265
00:09:40,360 --> 00:09:41,570
簡単な方法となっている。

266
00:09:42,050 --> 00:09:43,350
それはとても良い分類器、とは言えなかろう。

267
00:09:44,000 --> 00:09:46,660
そしてより一般的に言って、

268
00:09:47,450 --> 00:09:48,830
とてもスキューしたクラスの

269
00:09:48,950 --> 00:09:50,800
セッティングにおいても、

270
00:09:51,050 --> 00:09:53,350
アルゴリズムが

271
00:09:53,440 --> 00:09:54,900
ある種のチート（ずる）をして、

272
00:09:55,450 --> 00:09:56,400
とても高いPrecision(精度)と

273
00:09:56,750 --> 00:09:57,930
とても高いRecall(再現率)を

274
00:09:58,010 --> 00:09:59,360
いつもy=0と予測する、というような

275
00:09:59,620 --> 00:10:00,800
何かしら簡単な方法で

276
00:10:01,050 --> 00:10:02,680
達成するのは

277
00:10:02,720 --> 00:10:04,720
不可能だ。

278
00:10:04,960 --> 00:10:06,540
だから、高いPrecisionまたは高いRecallの

279
00:10:06,680 --> 00:10:08,230
分類器というのは、

280
00:10:08,840 --> 00:10:09,780
実際に良い分類器だという事に

281
00:10:10,610 --> 00:10:11,550
より確信を持てる。

282
00:10:12,470 --> 00:10:13,940
そしてこれは我らに、

283
00:10:14,040 --> 00:10:15,660
より有用な評価指標で

284
00:10:15,910 --> 00:10:16,960
我らのアルゴリズムがうまい事やっているかを

285
00:10:17,230 --> 00:10:20,360
より直接的に理解させてくれるような物を、与えてくれる。

286
00:10:21,680 --> 00:10:23,000
さて、Precision（精度）とRecall（再現率）の定義の

287
00:10:23,200 --> 00:10:24,960
最後のコメントとして、

288
00:10:25,150 --> 00:10:26,190
我らはPrecisionとRecallを

289
00:10:26,720 --> 00:10:28,720
普通はy=1が

290
00:10:29,100 --> 00:10:31,970
普通、より稀なクラスが存在している、という方を

291
00:10:32,090 --> 00:10:33,700
コンベンションを用いる。

292
00:10:34,160 --> 00:10:35,410
つまり我らはレアな条件、例えば

293
00:10:35,880 --> 00:10:37,300
ガンなどを検出したい時、

294
00:10:37,720 --> 00:10:38,610
それはレアな条件であって欲しい訳だが、

295
00:10:39,340 --> 00:10:40,950
その時には、PrecisionとRecallは

296
00:10:41,000 --> 00:10:42,440
y=0に対してでは無くy=1に対して

297
00:10:42,790 --> 00:10:43,930
定義される。

298
00:10:44,190 --> 00:10:45,690
つまり我らが検出しようとする

299
00:10:45,820 --> 00:10:47,100
そのレアなクラスが存在する、という場合に

300
00:10:47,250 --> 00:10:50,220
基づいて。

301
00:10:50,450 --> 00:10:51,960
そしてPrecision(精度)とRecall(再現率)を使う事で、

302
00:10:52,890 --> 00:10:54,250
起こる事というと、

303
00:10:54,390 --> 00:10:55,400
とてもスキューしたクラスの

304
00:10:55,610 --> 00:10:57,400
場合だとしても、

305
00:10:57,590 --> 00:10:59,080
アルゴリズムが「チート」（ずる）して、

306
00:10:59,600 --> 00:11:01,060
いかなる時もy=1を予測したり、

307
00:11:01,380 --> 00:11:02,400
あるいはいかなる時でもy=0を

308
00:11:02,760 --> 00:11:03,870
予測する事で、高いPrecision(精度)とかRecall(再現率)を得る事は

309
00:11:03,980 --> 00:11:05,750
不可能である、という事だ。

310
00:11:06,640 --> 00:11:07,830
そして特に、

311
00:11:08,480 --> 00:11:09,700
もし分類器で高いPrecisionとRecallが得られたなら、

312
00:11:09,880 --> 00:11:11,160
我らはアルゴリズムが

313
00:11:11,270 --> 00:11:13,040
とてもうまく機能しているだろう事に

314
00:11:13,590 --> 00:11:15,120
実際にしっかりと確信が持てる、

315
00:11:15,400 --> 00:11:16,620
たとえスキューしたクラスだったとしても。

316
00:11:18,030 --> 00:11:20,360
つまり、スキューしたクラスの問題に関しては、

317
00:11:20,950 --> 00:11:22,560
PrecisionとRecallは我らに

318
00:11:22,780 --> 00:11:24,670
アルゴリズムが実際にどうなってるか、についての

319
00:11:24,910 --> 00:11:26,010
より直接的な洞察を与えてくれて、

320
00:11:26,660 --> 00:11:27,980
そしてこれはしばしば、

321
00:11:28,070 --> 00:11:29,360
我らの学習アルゴリズムを評価する、より良い方法だ。

322
00:11:30,270 --> 00:11:32,200
単に分類エラーや分類の正確さを見るだけに比べると。

323
00:11:32,510 --> 00:11:35,200
クラスがとてもスキューしている時には。