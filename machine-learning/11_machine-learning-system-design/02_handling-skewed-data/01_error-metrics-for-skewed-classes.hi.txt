पिछले वीडियो में, मैंने बात की थी एरर अनालिसिस की और महत्व अपने पास होने का एरर मेट्रिक, अर्थात् होने का केवल एक रियल नम्बर इवैल्यूएशन मेट्रिक आपके लर्निंग अल्गोरिद्म में बताने के लिए कि यह कैसा कर रहा है. संदर्भ में इवैल्यूएशन और एरर मेट्रिक के, है एक महत्वपूर्ण केस, जहां यह है ख़ासतौर पर कठिन बना पाना एक उचित एरर मेट्रिक, या इवैल्यूएशन मेट्रिक, आपके लर्निंग अल्गोरिद्म के लिए. वह है केस जिसे कहते हैं स्क्यूड क्लासिस का केस. चलो मैं आपको बताता हूँ उसका क्या मतलब है. विचार करें प्रॉब्लम पर कैन्सर क्लैसिफ़िकेशन की, जहाँ हमारे पास हैं फ़ीचर्ज़ चिकित्सा रोगियों के और हम चाहते हैं तय करना कि उन्हें कैन्सर है या नहीं. तो यह है जैसे घातक या सौम्य ट्यूमर क्लैसिफ़िकेशन का उदाहरण जो हमारे पास था पहले. तो मान लो y बराबर है 1 यदि मरीज को कैंसर है और y बराबर है 0 यदि उन्हें नहीं है. हमने ट्रेन किया है लॉजिस्टिक क्लैसिफ़ायअर और मान लो हम टेस्ट करते हैं हमारा क्लैसिफ़ायअर एक टेस्ट सेट पर और पाते हैं कि हमें मिलती है 1 प्रतिशत एरर. तो, हम 99% सही निदान कर रहे हैं. लगता है एक वास्तव में प्रभावशाली परिणाम की तरह, सही है. हम सही हैं 99% समय. लेकिन अब, मान लो हम पाते हैं कि केवल 0.5 प्रतिशत रोगी हमारे ट्रेनिंग सेट में हैं जिन्हें वास्तव में कैन्सर है. तो केवल आधा प्रतिशत रोगियों का है जिनको स्क्रीनिंग प्रक्रिया के बाद कैन्सर निकलता है. इस केस में, 1% एरर इतना प्रभावशाली नहीं लग रहा है. और विशेष रूप से, यहाँ है एक हिस्सा कोड का, यहाँ है एक हिस्सा नॉन-लर्निंग कोड का जो लेता है यह इनपुट फ़ीचर्ज़ x की और उसे अनदेखा कर देता है. यह सिर्फ़ सेट करता है y बराबर 0 और हमेशा प्रिडिक्ट करता है, आप जानते है, किसी को कैन्सर नहीं है और इस अल्गोरिद्म को वास्तव में मिलेगी 0.5 प्रतिशत एरर. तो यह बेहतर है 1% एरर से भी जो हमें मिल रही है अब और यह है एक नॉन लर्निंग अल्गोरिद्म जो आप जानते हैं, यह सिर्फ़ प्रिडिक्ट कर रहा है y बराबर 0 हर समय. तो यह सेटिंग जब अनुपात पॉज़िटिव और नेगेटिव इग्ज़ाम्पल्ज़ का है बहुत क़रीब दोनो छोरों में से एक के, जहाँ, इस केस में, संख्या पॉज़िटिव इग्ज़ाम्पल्ज़ की है बहुत, बहुत छोटी, तुलना में संख्या नेगेटिव इग्ज़ाम्पल्ज़ की क्योंकि y बराबर है एक कभी-कभी ही, यह जिसे हम कहते हैं स्क्यूड क्लास का केस. हमारे पास बहुत से और उदाहरण है कि एक क्लास बहुत अधिक है दूसरी क्लास से. और सिर्फ़ प्रिडिक्ट करने से y बराबर 0 हर समय, या शायद हमारे प्रिडिक्ट करने से y बराबर 1 हर समय, एक अल्गोरिद्म बहुत अच्छा कर सकता है. तो समस्या इस्तेमाल करने से क्लैसिफ़िकेशन एरर या क्लैसिफ़िकेशन एक्यूरेसी हमारी इवैल्यूएशन मेट्रिक की तरह है इस प्रकार. मान लो आपके पास है एक लर्निंग अल्गोरिद्म जो दे रहा है 99.2% एक्यूरेसी. तो, वह है एक 0.8% एरर. मान लो आप करते हैं एक बदलाव आपके अल्गोरिद्म में और आपको अब मिल रही है 99.5% एक्यूरेसी. वह है 0.5% एरर. तो, यह है एक सुधार अल्गोरिद्म में या नहीं? एक अच्छी बात होने की एक ही रियल नम्बर की इवैल्यूएशन मेट्रिक है कि यह हमारी सहायता करती है जल्दी से फ़ैसला करने में कि हमें चाहिए एक बढ़िया बदलाव अल्गोरिद्म में या नहीं. 99.2% एक्यूरेसी से 99.5% एक्यूरेसी तक जाने में आप जानते हैं, क्या हमने किया कुछ उपयोगी काम या क्या हमने सिर्फ़ बदल दिया हमारा कोड किसी चीज़ से जो सिर्फ़ प्रिडिक्ट करता है y बराबर ज़ीरो अधिक बार? तो यदि आपके पास है बहुत स्क्यूड क्लास यह होता जाता है बहुत कठिन इस्तेमाल करना सिर्फ़ क्लैसिफ़िकेशन एक्यूरेसी, क्योंकि आपको मिल सकती है बहुत अधिक एक्यूरेसी या बहुत कम एरर, और यह नहीं है हमेशा स्पष्ट यदि ऐसा करने से वास्तव में बेहतर हो रही है गुणवत्ता आपके क्लैसिफ़ायअर की क्योंकि प्रिडिक्ट करने से y बराबर 0 हम समय नही लगता है जैसे एक विशेष रूप से अच्छा क्लैसिफ़ायअर. लेकिन प्रिडिक्ट करने से y बराबर 0 अधिक बार ला सकता है आपकी एरर को कम, आप जानते हैं, शायद 0.5% तक भी. लेकिन जब हमारे सामने है इस तरह की स्क्यूड क्लास इसलिए हम चाहेंगे बनाना एक भिन्न एरर मेट्रिक या एक भिन्न इवैल्यूएशन मेट्रिक. ऐसी ही एक इवैल्यूएशन मेट्रिक है जिसे कहते हैं प्रिसिज़न रिकॉल. चलो मैं समझाता हूँ क्या है वह. मान लो हम जाँच कर रहे हैं एक क्लैसिफ़ायअर की टेस्ट सेट पर. इग्ज़ाम्पल्ज़ के लिए जो हैं टेस्ट सेट में, असली क्लास उस इग्ज़ाम्पल की टेस्ट सेट में होगी या तो एक या ज़ीरो, ठीक है, यदि एक बाइनेरी क्लास क्लैसिफ़िकेशन प्रॉब्लम है. और हमारा लर्निंग अल्गोरिद्म क्या करेगा कि यह करेगा, आप जानते हैं, प्रिडिक्ट कुछ वैल्यू क्लास की और हमारा लर्निंग अल्गोरिद्म प्रिडिक्ट करेगा वैल्यू प्रत्येक इग्ज़ाम्पल्ज़ के लिए मेरे टेस्ट सेट में और प्रिडिक्ट की गई वैल्यू भी होगी या तो एक या ज़ीरो. तो मैं बनाता हूँ एक दो बाई दो का टेबल इस तरह, निर्भर करते हुए सारी इन एंट्रीज़ पर निर्भर करते हुए क्या थी असली क्लास और क्या थी प्रिडिक्ट की गई क्लास. यदि हमारे पास हैं एक उदाहरण जहाँ असली क्लास है एक और प्रिडिक्ट की गई क्लास है एक तब वह कहलाता है एक इग्ज़ाम्पल जो है एक ट्रू पॉज़िटिव, मतलब कि हमारे अल्गोरिद्म ने प्रिडिक्ट किया कि यह है एक पॉज़िटिव और वास्तव में इग्ज़ाम्पल है पॉज़िटिव. यदि हमारे लर्निंग अल्गोरिद्म ने प्रिडिक्ट किया है कि कुछ है नेगेटिव, क्लास ज़ीरो, और असली क्लास भी है क्लास ज़ीरो तब वह है जिसे कहते हैं ट्रू नेगेटिव. हमने प्रिडिक्ट किया ज़ीरो और यह असली में है ज़ीरो. दूसरे दो बॉक्स पाने के लिए, यदि हमारा लर्निंग अल्गोरिद्म प्रिडिक्ट करता है कि क्लास है एक लेकिन असली क्लास है ज़ीरो, तब उसे कहते हैं एक फ़ॉल्स पॉज़िटिव. तो उसका मतलब है कि हमारा अल्गोरिद्म रोगी के लिए प्रिडिक्ट करेगा कि कैन्सर है जबकि वास्तव में रोगी को नहीं है. और अंत में, आख़िरी बॉक्स है ज़ीरो, एक, उसे कहते हैं फ़ॉल्स नेगेटिव क्योंकि हमारा अल्गोरिद्म प्रिडिक्ट करता है ज़ीरो, लेकिन असली क्लास थी एक. और इसलिए, हमारे पास है यह छोटा दो बाई दो का टेबल आधारित कि क्या असली क्लास थी और क्या थी प्रिडिक्ट की गई क्लास. तो यहाँ है एक भिन्न ढंग इवैल्यूएट करने के लिए पर्फ़ॉर्मन्स हमारे अल्गोरिद्म की. हम करेंगे कम्प्यूट दो नम्बर. पहले को कहते हैं प्रिसिज़न- और वह क्या कहता है , सारे रोगियों में से जहाँ हमने प्रिडिक्ट किया है कि उन्हें कैन्सर है, उनमें से कितने अंश को वास्तव में कैंसर है? तो चलिए लिख लेते हैं उसे, प्रिसिज़न एक क्लैसिफ़ायअर का है नम्बर ट्रू पॉज़िटिव विभाजित किया गया नम्बर से जो हमने प्रिडिक्ट किया पॉज़िटिव, ठीक है? तो सभी रोगियों में से जिनको हमने बताया,"हम सोचते हैं आपको कैन्सर है." उन सभी रोगियों में से, कितने अंश को उनमें से वास्तव में कैंसर है? तो उसे कहते हैं प्रिसिज़न. और एक अन्य ढंग लिखने का इसे होगा ट्रू पॉज़िटिव और फिर विभाजक है संख्या प्रिडिक्ट किए गए पॉज़िटिव, और तो वह होगा योग, आप जानते हैं, एंट्रीज़ इस पहली रो में टेबल की. तो वह होगा ट्रू पॉज़िटिव विभाजित किए गया ऐक्चूअल पॉज़िटिव से. मैं संक्षिप्त करूँगा पॉज़िटिव को POS और फिर जमा फ़ॉल्स पॉज़िटिव, फिर से संक्षिप्त करते हुए पॉज़िटिव को POS. तो उसे कहते हैं प्रिसिज़न, और जैसे कि आप बता सकते हैं अधिक प्रिसिज़न अच्छा होगा. उसका मतलब है सारे रोगी जिन्हें हमने कहा, "आप जानते हैं, हमें बहुत अफ़सोस है. हमें लगता है कि आपको कैंसर है," अधिक प्रिसिज़न का मतलब है कि उस समूह में रोगियों के ज़्यादातर के लिए हमने वास्तव में की सटीक प्रिडिक्शन उन पर और उन्हें वाक़ई कैन्सर है. दूसरा नम्बर जो हम कम्प्यूट करेंगे कहलाता है रिकॉल, और क्या रिकॉल बताता है, यदि सभी रोगी जो हैं, मान लो, टेस्ट सेट में या क्रॉस-वैलिडेशन सेट में, लेकिन यदि सारे रोगी जो है डेटा सेट में जिन्हें वाक़ई कैन्सर है, उनमें से कितना अंश हैं जो हमने सही प्रिडिक्ट किया है कि उन्हें कैन्सर है. तो यदि सभी रोगियों को कैन्सर है, कितने उनमें से हैं जिनके पास हम गए और, आप जानते है, सही-सही बताया उन्हें कि हम सोचते हैं उन्हें इलाज की ज़रूरत है. तो, लिखता हूँ इसे, रिकॉल को परिभाषित किया जाता है संख्या पॉज़िटिव्स की, संख्या ट्रू पॉज़िटिव्स की, मतलब कि लोगों की संख्या जिनको कैन्सर है और जो हमने सही प्रिडिक्ट किए है जिनको कैन्सर है और हम लेते हैं वह और विभाजित करते हैं उसे, विभाजित करते हैं उसे ऐक्चूअल पॉज़िटिव्स की संख्या से, तो यह है सही संख्या ऐक्चूअल पॉज़िटिव्स की सभी वे लोग जिनको कैन्सर है. कितना अंश हम सीधे चिन्हित करते हैं और आप जानते है, भेजते हैं इलाज के लिए. तो, इसे दोबारा लिखने के लिए एक भिन्न रूप में, विभाजक होगा संख्या ऐक्चूअल पॉज़िटिव्स की जैसे कि आप जानते हैं, है योग एंट्रीज़ का पहले कॉलम की यहाँ पर. और इसलिए लिखते हुए चीज़ें अलग ढंग से, यह है इसलिए, संख्या ट्रू पॉज़िटिव्स की, विभाजित की गई ट्रू पॉज़िटिव्स की संख्या जमा संख्या फ़ॉल्स नेगेटिव्स से. और इसलिए, एक बार फिर, होना एक रिकॉल होगा एक अच्छी चीज़. तो कम्प्यूट करने से प्रिसिज़न और रिकॉल यह अक्सर देगा हमें एक बेहतर समझ कि कितना सही हमारा क्लैसिफ़ायअर काम कर रहा है. और विशेष रूप से यदि हमारे पास है एक लर्निंग अल्गोरिद्म जो प्रिडिक्ट करता है y बराबर ज़ीरो हर समय, यदि यह प्रिडिक्ट करता है नहीं है किसी को कैन्सर, तब इस क्लैसिफ़ायअर का होगा एक रिकॉल बराबर ज़ीरो के, क्योंकि वहाँ नहीं होंगे एक भी ट्रू पॉज़िटिव्स और इसलिए वह है एक त्वरित ढंग हमारे लिए पहचानने का कि, आप जानते हैं, एक क्लैसिफ़ायअर जो प्रिडिक्ट कर रहा है y बराबर 0 हर समय, नहीं है एक बहुत अच्छा क्लैसिफ़ायअर. और सामान्य रूप में, उन सेटिंगज़ के लिए भी जहाँ हमारे पास है बहुत स्क्यूड क्लास, यह सम्भव नहीं है एक अल्गोरिद्म के लिए एक तरह से "धोखा" करना और किसी भी तरह से पाना एक बहुत अधिक प्रिसिज़न और एक बहुत अधिक रिकॉल करने से कुछ साधारण चीज़ जैसे प्रिडिक्ट करना y बराबर 0 हर समय या प्रिडिक्ट करना y बराबर 1 हर समय. और इसलिए हमें अधिक यक़ीन है कि एक क्लैसिफ़ायअर जिसका अधिक प्रिसिज़न है या अधिक रिकॉल है वास्तव में एक अच्छा क्लैसिफ़ायअर है, और यह देता है हमें एक अधिक उपयोगी इवैल्यूएशन मेट्रिक जो है एक अधिक सीधा मार्ग वास्तव में समझने के लिए कि क्या, आप जानते हैं, हमारा अल्गोरिद्म शायद सही कर रहा है. तो एक अंतिम नोट परिभाषा में प्रिसिज़न और रिकॉल की, कि हम परिभाषित करेंगे प्रिसिज़न और रिकॉल, अक्सर हम इस्तेमाल करते हैं कि y बराबर 1, अधिक दुर्लभ / रेयर क्लास के लिए. तो यदि हम डिटेक्ट करने का प्रयास कर रहे हैं कभी-कभी की स्थिति जैसे कैन्सर, उम्मीद है कि वह कभ-कभार की ही स्थिति है, प्रिसिज़न और रिकॉल परिभाषित करते हैं सेट करके y बराबर 1 बजाय y बराबर 0 के, एक प्रकार से कि उपस्थिति उस दुर्लभ क्लास की जो हम प्रयास कर रहे हैं डिटेक्ट करने का. और इस्तेमाल करने से प्रिसिज़न और रिकॉल, हम पाते हैं, क्या होता है कि यदि हमारे पास है भी बहुत स्क्यूड क्लास, यह नहीं है सम्भव एक अल्गोरिद्म के लिए आप जानते हैं, "धोखा करना" और प्रिडिक्ट करना y बराबर 1 हर समय, या प्रिडिक्ट करना y बराबर 0 हर समय और पाना अधिक प्रिसिज़न और रिकॉल. और विशेष रूप से, यदि एक क्लैसिफ़ायअर को मिल रहा है अधिक प्रिसिज़न और अधिक रिकॉल, तब हमें वास्तव में यक़ीन है कि अल्गोरिद्म को करना ही चाहिए सही, तब भी जब हमारे पास है बहुत स्क्यूड क्लास भी. तो स्क्यूड क्लास की प्रॉब्लम के लिए प्रिसिज़न रिकॉल देते हैं हमें अधिक प्रत्यक्ष पहुँच कि कैसे लर्निंग अल्गोरिद्म कर रहा है और यह है अक्सर एक अधिक बेहतर तरीक़ा इवैल्यूएशन का आपके लर्निंग अल्गोरिद्म्स को, बजाय देखने के क्लैसिफ़िकेशन एरर के या क्लैसिफ़िकेशन एक्यूरेसी पर, जब क्लास हैं बहुत स्क्यूड.