1
00:00:00,240 --> 00:00:04,540
लिनीअर रेग्रेशन के लिए, हमने पहले बनाए थे दो लर्निंग अल्गोरिद्म्स.

2
00:00:04,540 --> 00:00:08,780
एक आधारित था ग्रेडीयंट डिसेंट पर और एक आधारित था नोर्मल इक्वेज़न पर.

3
00:00:08,780 --> 00:00:11,607
इस वीडियो में, हम लेंगे उन दो अल्गोरिद्म्स को और

4
00:00:11,607 --> 00:00:15,087
जनरलाइज करेंगे उन्हें रेगुलेराईज़ड लिनीअर रेग्रेशन के लिए.

5
00:00:17,363 --> 00:00:20,994
यहाँ है ऑप्टिमायज़ेशन अब्जेक्टिव जो हमने बनाया था पिछली बार

6
00:00:20,994 --> 00:00:23,390
रेगुलराइज्ड लिनीअर रेग्रेशन के लिए.

7
00:00:23,390 --> 00:00:27,795
यह पहला हिस्सा है हमारा हमेशा का अब्जेक्टिव लिनीअर रेग्रेशन का.

8
00:00:27,795 --> 00:00:32,682
और अब हमारे पास है यह अतिरिक्त रेगुलराइज़ेशन टर्म, जहाँ लैम्डा

9
00:00:32,682 --> 00:00:37,170
है हमारा रेगुलराइज़ेशन पेरामिटर, और हम चाहते हैं ढूँढना पेरमिटर्स थीटा

10
00:00:37,170 --> 00:00:41,880
जो न्यूनतम करता हैैं इस कॉस्ट फ़ंक्शन को, इस रेगुलराइज्ड कॉस्ट फ़ंक्शन को, जे ऑफ़ थीटा.

11
00:00:41,880 --> 00:00:44,780
पहले हम इस्तेमाल कर रहे थे ग्रेडीयंट डिसेंट

12
00:00:44,780 --> 00:00:49,370
प्रारम्भिक कॉस्ट फ़ंक्शन के लिए, बिना रेगुलराइज़ेशन टर्म के.

13
00:00:49,370 --> 00:00:53,680
और हमारे पास था निम्न अल्गोरिद्म लिनीअर रेग्रेशन के लिए बिना

14
00:00:53,680 --> 00:00:58,490
रेगुलराइज़ेशन के, हम बार-बार अप्डेट करेंगे पेरमिटर्स थीटा j इस प्रकार

15
00:00:58,490 --> 00:01:00,840
j बराबर 0, 1, 2, से n तक के लिए.

16
00:01:02,040 --> 00:01:07,240
तो मैं सिर्फ़ यह लेता हूँ और सिर्फ़ लिखता हूँ केस थीटा 0 का अलग से.

17
00:01:07,240 --> 00:01:12,690
तो मैं सिर्फ़ लिखूँगा थीटा 0 का अप्डेट अलग से

18
00:01:12,690 --> 00:01:17,150
पेरमिटर्स 1, 2, 3 से n तक के अप्डेट से.

19
00:01:17,150 --> 00:01:19,990
और इसलिए यह है, मैंने कुछ भी नहीं बदला है अभी, ठीक है.

20
00:01:19,990 --> 00:01:24,670
यह है सिर्फ़ लिखना अप्डेट थीटा 0 का अलग से बाक़ी के अप्डेट से थीटा 1,

21
00:01:24,670 --> 00:01:26,870
थीटा 2, थीटा 3 आगे थीटा n तक.

22
00:01:26,870 --> 00:01:30,590
और कारण कि मैं यह करना चाहता हूँ है आपको शायद याद होगा कि

23
00:01:30,590 --> 00:01:35,000
हमारे रेग्युलराइज्ड लिनीअर रेग्रेशन के लिए, हम दण्डित करते हैं पेरमिटर्स थीटा 1, थीटा 2,

24
00:01:35,000 --> 00:01:36,740
और आगे थीटा n तक को.

25
00:01:36,740 --> 00:01:38,950
लेकिन हम थीटा 0 दंडित नहीं करते.

26
00:01:38,950 --> 00:01:43,730
तो, जब हम बदलेंगे इस अल्गोरिद्म को रेग्युलराइज्ड लिनीअर रेग्रेशन के लिए,

27
00:01:43,730 --> 00:01:47,480
हम सम्बोधित करेंगे थीटा 0 को थोड़ा भिन्न.

28
00:01:48,550 --> 00:01:52,350
वस्तुतः, हम लेना चाहते हैं इस अल्गोरिद्म को और

29
00:01:52,350 --> 00:01:55,449
बदलना चाहते हैं इसे इस्तेमाल करने के लिए रेग्युलराइज्ड अब्जेक्टिव,

30
00:01:55,449 --> 00:02:00,460
हमें सिर्फ़ आवश्यकता है लेने की इस टर्म को नीचे वाली और बदलना है इसे निम्न तरह से.

31
00:02:00,460 --> 00:02:03,820
हम लेंगे यह टर्म और

32
00:02:03,820 --> 00:02:08,950
जोड़ेंगे माइनस लैम्डा ओवर m गुणा थीटा j.

33
00:02:08,950 --> 00:02:13,090
और यदि आप इम्प्लमेंट करते हैं इसे, तब आपके पास है ग्रेडीयंट डिसेंट

34
00:02:13,090 --> 00:02:18,050
न्यूनतम करने के लिए रेगुलराइज्ड कॉस्ट फ़ंक्शन को, जे ऑफ़ थीटा.

35
00:02:18,050 --> 00:02:22,390
और वस्तुतः, मैं नहीं कर रहा हूँ कैल्क्युलुस साबित करने लिए इसे, लेकिन

36
00:02:22,390 --> 00:02:27,790
वास्तव में यदि आप देखें इस टर्म को, यह टर्म जो मैंने लिखी है वर्ग कोष्ठक में,

37
00:02:27,790 --> 00:02:31,170
यदि आप जानते हैं कैल्क्युलुस यह सम्भव है साबित करना कि वह टर्म

38
00:02:31,170 --> 00:02:35,050
है पर्शियल डेरिवेटिव विद रिस्पेक्ट टु J ऑफ़ थीटा

39
00:02:35,050 --> 00:02:39,722
इस्तेमाल करते हुए नई परिभाषा J ऑफ़ थीटा की रेग्युलराइज़ेशन टर्म के साथ.

40
00:02:39,722 --> 00:02:48,030
और इसी तरह, ऊपर की टर्म जहाँ मैं बना रहा हूँ सियान बॉक्स,

41
00:02:48,030 --> 00:02:53,040
वह भी है पर्शियल डेरिवेटिव विद रिस्पेक्ट टु थीटा ज़ीरो J ऑफ़ थीटा का.

42
00:02:53,040 --> 00:02:56,220
यदि आप देखें थीटा j के अप्डेट को,

43
00:02:56,220 --> 00:02:59,005
यह सम्भव है दिखा पाना कुछ बहुत दिलचस्प चीज़.

44
00:02:59,005 --> 00:03:03,760
थीटा j अपडेट होता है ऐसे, थीटा j माइनस अल्फ़ा टाइम्ज़,

45
00:03:03,760 --> 00:03:07,950
और फिर आपके पास है यह अन्य टर्म यहाँ जो निर्भर करती है थीटा j पर.

46
00:03:07,950 --> 00:03:11,170
तो यदि आप इकट्ठा करते हैं सारी टर्म्ज़ को एक साथ जो निर्भर करती हैं थीटा j पर,

47
00:03:11,170 --> 00:03:15,850
आप दिखा सकते हैं कि यह अप्डेट लिखा जा सकता है समान रूप से निम्न तरह से.

48
00:03:15,850 --> 00:03:20,280
और मैंने सिर्फ़ क्या किया कि जोड़ा थीटा j यहाँ है, तो थीटा j टाइम्ज़ 1.

49
00:03:20,280 --> 00:03:25,650
और यह टर्म है, ठीक है, लैम्डा ओवर m, यहाँ है एक अल्फ़ा यहाँ,

50
00:03:25,650 --> 00:03:29,390
तो आपको मिलता है अल्फ़ा लैम्डा ओवर m गुणा किया थीटा j से.

51
00:03:30,540 --> 00:03:38,090
और यह टर्म यहाँ, 1 माइनस अल्फ़ा गुणा लैम्डा m, है एक काफ़ी दिलचस्प टर्म.

52
00:03:38,090 --> 00:03:39,820
इसका है बहुत दिलचस्प प्रभाव.

53
00:03:42,370 --> 00:03:46,320
वास्तव में यह टर्म, 1 माइनस अल्फ़ा टाइम्ज़ लैम्डा ओवर m,

54
00:03:46,320 --> 00:03:51,340
होगी एक संख्या जो है आमतौर पर एक से थोड़ी कम,

55
00:03:51,340 --> 00:03:55,895
क्योंकि अल्फ़ा टाइम्ज़ लैम्डा ओवर m होगा पॉज़िटिव, और अक्सर

56
00:03:55,895 --> 00:03:59,765
यदि आपकी लर्निंग रेट छोटी हैं और यदि m बड़ा है, यह होता है अक्सर छोटा.

57
00:03:59,765 --> 00:04:03,275
अत: यह टर्म यहाँ होगी एक संख्या जो है आमतौर पर 1 से थोड़ी कम,

58
00:04:03,275 --> 00:04:07,115
तो सोचे इसे एक संख्या जैसे 0.99, मान लो.

59
00:04:07,115 --> 00:04:10,515
और इसलिए प्रभाव हमारे अप्डेट का थीटा j को है,

60
00:04:10,515 --> 00:04:15,915
हम कहेंगे कि थीटा j बदल दिया जाता है थीटा j टाइम्ज़ 0.99 से, ठीक है?

61
00:04:16,915 --> 00:04:21,300
तो थीटा j टाइम्ज़ 0.99 का प्रभाव है

62
00:04:21,300 --> 00:04:23,780
छोटा करना थीटा j थोड़ा सा ज़ीरो की तरफ़.

63
00:04:23,780 --> 00:04:26,070
तो यह बनाता है थीटा j को थोड़ा छोटा.

64
00:04:26,070 --> 00:04:31,510
और अधिक औपचारिक रूप से, स्क्वेर टर्म इस थीटा j की है थोड़ी छोटी.

65
00:04:31,510 --> 00:04:35,980
और तब उसके बाद, दूसरी टर्म यहाँ, वह है वास्तव में

66
00:04:35,980 --> 00:04:40,830
बिल्कुल वही जो थी पहले के ग्रेडीयंट डिसेंट अप्डेट में जो हमारे पास थी,

67
00:04:40,830 --> 00:04:44,250
हमारे ये सब रेगुलराइज़ेशन डालने से पहले.

68
00:04:44,250 --> 00:04:49,188
तो उम्मीद है यह ग्रेडीयंट डिसेंट, उम्मीद है यह अप्डेट समझ आया होगा.

69
00:04:49,188 --> 00:04:52,110
जब हम इस्तेमाल कर रहे हैं एक रेगुलराइज्ड लिनीअर रेग्रेशन और

70
00:04:52,110 --> 00:04:56,190
हम क्या कर रहे हैं कि प्रत्येक इटरेशन में हम गुणा कर रहे हैं थीटा j को एक नम्बर से

71
00:04:56,190 --> 00:05:00,270
जो है थोड़ा छोटा एक से, तो यह छोटा कर रहा है पेरामिटर को थोड़ा, और

72
00:05:00,270 --> 00:05:04,170
और फिर हम कर रहे हैं एक समान अप्डेट पहले जैसे.

73
00:05:04,170 --> 00:05:09,005
निश्चित रूप से वह है सिर्फ़ एक अनुभव कि यह ख़ास अप्डेट क्या कर रहा है.

74
00:05:09,005 --> 00:05:12,995
गणितीय रूप में यह क्या कर रहा है कि यह है वास्तव में ग्रेडीयंट डिसेंट

75
00:05:12,995 --> 00:05:18,175
कॉस्ट फ़ंक्शन J ऑफ़ थीटा पर जो हमने परिभाषित किया था पिछली स्लाइड पर जो इस्तेमाल करता है

76
00:05:18,175 --> 00:05:19,825
रेगुलराइज़ेशन टर्म.

77
00:05:19,825 --> 00:05:24,500
ग्रेडीयंट डिसेंट था सिर्फ़ एक हमारे दो अल्गोरिद्म्स में से

78
00:05:24,500 --> 00:05:26,660
फ़िट करने के लिए लिनीअर रेग्रेशन मॉडल.

79
00:05:26,660 --> 00:05:30,200
दूसरा अल्गोरिद्म आधारित था नोर्मल इक्वेज़न पर,

80
00:05:30,200 --> 00:05:34,840
जहाँ हमने क्या किया था कि हमने बनाया था डिज़ाइन मेट्रिक्स X जहाँ

81
00:05:34,840 --> 00:05:38,900
प्रत्येक रो कॉरेस्पॉंड करती है एक अलग ट्रेनिंग इग्ज़ाम्पल को.

82
00:05:38,900 --> 00:05:45,440
और हमने बनाया एक वेक्टर y, तो यह है एक वेक्टर, जो है एक m डिमेन्शनल वेक्टर.

83
00:05:45,440 --> 00:05:48,480
और उसमें थे लेबल्ज़ मेरे ट्रेनिंग सेट के.

84
00:05:48,480 --> 00:05:57,030
तो जहाँ X है एक m बाई (n+1) डिमेन्शनल मेट्रिक्स, y है एक म डिमेन्शनल वेक्टर.

85
00:05:57,030 --> 00:06:02,970
और न्यूनतम करने के लिए कॉस्ट फ़ंक्शन J, हमने पाया कि एक

86
00:06:02,970 --> 00:06:07,295
ढंग करने का इसे है कि सेट करें थीटा बराबर इसके.

87
00:06:07,295 --> 00:06:13,090
ठीक है, आपके पास है X ट्रान्स्पोज़, X इन्वर्स, X ट्रान्स्पोज़ Y.

88
00:06:13,090 --> 00:06:15,730
मैं यहाँ जा रहा हूँ कमरे से सामान भरने के लिए.

89
00:06:15,730 --> 00:06:20,160
और क्या करती है यह वैल्यू थीटा की कि यह

90
00:06:20,160 --> 00:06:25,040
न्यूनतम करती है कॉस्ट फ़ंक्शन J ऑफ़ थीटा, जब हम नहीं ले रहे रेगुलराइज़ेशन.

91
00:06:26,340 --> 00:06:31,240
अब जब हम कर रहे हैं रेगुलराइज़ेशन, यदि आपको डिराइव करना होता क्या है न्यूनतम,

92
00:06:31,240 --> 00:06:35,060
और सिर्फ़ देने के लिए आपको एक अभिप्राय कि कैसे डिराइव करते हैं न्यूनतम, जिस तरह से आप डिराइव करते हैं इसे

93
00:06:35,060 --> 00:06:39,494
है कि आप लेते हैं पर्शियल डेरिवेटिव विद रिस्पेक्ट टु प्रत्येक पेरामिटर.

94
00:06:39,494 --> 00:06:42,880
सेट करते हैं उसे 0, और फिर करते हैं थोड़ा गणित और

95
00:06:42,880 --> 00:06:48,600
आप तब दिखा सकते हैं यह है एक फ़ॉर्म्युला इस तरह का जो न्यूनतम करता है कॉस्ट फ़ंक्शन.

96
00:06:48,600 --> 00:06:53,930
और वस्तुत:, यदि आप इस्तेमाल कर रहे हैं रेगुलराइज़ेशन,

97
00:06:53,930 --> 00:06:55,940
तब यह फ़ॉर्म्युला बदल जाता है निम्न तरह से.

98
00:06:55,940 --> 00:06:59,490
इस कोष्ठकों के अंदर, आपको मिलती है एक मैट्रिक्स इस तरह की.

99
00:06:59,490 --> 00:07:04,530
0, 1, 1, 1, और इसी प्रकार आगे 1, पूरा नीचे तक.

100
00:07:04,530 --> 00:07:08,060
तो यह चीज़ यहाँ है एक मेट्रिक्स जिसकी सबसे ऊपर बाईं तरफ़ की एंट्री है 0.

101
00:07:08,060 --> 00:07:13,050
विकर्णो पर एक हैं, और ज़ीरो हैं बाक़ी सब जगह इस मेट्रिक्स में.

102
00:07:13,050 --> 00:07:16,780
क्योंकि मैं बना रहा हूँ थोड़े बेकार ढंग से.

103
00:07:16,780 --> 00:07:19,266
लेकिन यह है एक उदाहरण, यदि n = 2,

104
00:07:19,266 --> 00:07:24,370
तब यह होगी एक तीन बाई तीन मेट्रिक्स.

105
00:07:24,370 --> 00:07:31,660
अधिक सामान्य रूप में, यह मेट्रिक्स है एक (n+1) बाई (n+1) डिमेन्शनल मेट्रिक्स.

106
00:07:31,660 --> 00:07:36,070
तो यदि n = 2, तब वह मेट्रिक्स बन जाती है कुछ इस तरह से.

107
00:07:36,070 --> 00:07:39,305
यह होगा 0, और फिर 1 विकर्णो पर, और

108
00:07:39,305 --> 00:07:42,290
फिर 0 बाक़ी सब जगह.

109
00:07:42,290 --> 00:07:46,080
और एक बार फिर से, मैं इस डेरिवेशन को नहीं करूँगा, जो है स्पष्ट रूप से थोड़ा लम्बा

110
00:07:46,080 --> 00:07:51,295
और जटिल, लेकिन यह साबित करना सम्भव है कि यदि आप इस्तेमाल कर रहे हैं नई परिभाषा

111
00:07:51,295 --> 00:07:56,320
J ऑफ़ थीटा की, रेगुलराइज़ेशन अब्जेक्टिव के साथ, तब यह नया फ़ॉर्म्युला

112
00:07:56,320 --> 00:08:00,440
थीटा के लिए है जो हम देते हैं आपको, ग्लोबल मिनिमम J ऑफ़ थीटा का.

113
00:08:01,470 --> 00:08:06,800
और अंत में आप आपको सिर्फ़ जल्दी से बताना चाहता हूँ नॉन-इन्वर्टीबिलिटी के बारे में.

114
00:08:06,800 --> 00:08:10,736
यह अपेक्षाकृत एडवांसड मटीरीयल है, आप इसे वैकल्पिक सोच सकते हैं.

115
00:08:10,736 --> 00:08:13,620
और इसे चाहें तो छोड़ सकते हैं, यदि आप इसे सुनते हैं और

116
00:08:13,620 --> 00:08:16,420
यह वास्तव में समझ नहीं आता है, तो इसकी चिंता न करें.

117
00:08:16,420 --> 00:08:19,720
लेकिन पहले जब हमने बात की थी नोर्मल इक्वेज़नज़ विधि की,

118
00:08:19,720 --> 00:08:23,760
हमारे पास था एक वैकल्पिक वीडियो, नॉन-इन्वर्टीबिलिटी पर.

119
00:08:23,760 --> 00:08:26,420
तो यह है एक और वैकल्पिक हिस्सा उसका,

120
00:08:26,420 --> 00:08:31,658
एक प्रकार से हिस्सा हमारे पहले वैकल्पिक वीडियो का, नॉन-इन्वर्टीबिलिटी पर.

121
00:08:31,658 --> 00:08:36,070
अब सोचो एक स्थिति जहाँ m, संख्या इग्ज़ाम्पल्ज़ की, है कम या

122
00:08:36,070 --> 00:08:38,700
बराबर n के, संख्या फ़ीचर्ज़ की.

123
00:08:38,700 --> 00:08:42,860
यदि आपके पास हैं कम इग्ज़ाम्पल्ज़ तुलना में फ़ीचर्ज़ से, तब यह मेट्रिक्स

124
00:08:42,860 --> 00:08:49,660
X ट्रान्स्पोज़ X होगी नॉन-इन्वर्टिबल, या सिंगुलर.

125
00:08:49,660 --> 00:08:53,050
या अन्य टर्म इस मेट्रिक्स के लिए होगी डिजेनेरेट.

126
00:08:53,050 --> 00:08:57,100
और यदि आप इम्प्लमेंट करते हैं इसे ओकटेव में किसी तरह और आप इस्तेमाल करते हैं pinv

127
00:08:57,100 --> 00:09:01,600
फ़ंक्शन का लेने के लिए स्यूडो इन्वर्स, यह करेगा एक तरह से सही काम, लेकिन

128
00:09:01,600 --> 00:09:05,990
यह स्पष्ट नहीं है कि यह देगा आपको एक अच्छी हायपॉथिसस, जबकि

129
00:09:05,990 --> 00:09:12,270
नूमेरिक्ली, ओकटेव pinv फ़ंक्शन देगा आपको एक परिणाम जो समझ में आता है.

130
00:09:13,270 --> 00:09:16,470
लेकिन यदि आप कर रहे हैं इसे एक भिन्न लैंग्विज में, और

131
00:09:16,470 --> 00:09:21,530
यदि आप ले रहे हैं हमेशा का इन्वर्स, जो ओकटेव में डिनोट करते हैं

132
00:09:21,530 --> 00:09:26,320
फ़ंक्शन inv से, हम प्रयास कर रहे हैं लेने का हमेशा का इन्वर्स X ट्रान्स्पोज़ X का.

133
00:09:26,320 --> 00:09:31,150
तब उस स्थिति में आपको मिलेगा कि X ट्रान्स्पोज़ X है सिंगुलर,

134
00:09:31,150 --> 00:09:35,540
है नॉन-इन्वर्टिबल, और यदि आप कर रहे हैं इसे एक भिन्न लैंग्विज में और

135
00:09:35,540 --> 00:09:39,890
इस्तेमाल कर रहे हैं लिनीअर ऐल्जेब्रा लाइब्रेरी लेने के लिए इन्वर्स इस मेट्रिक्स का,

136
00:09:39,890 --> 00:09:44,690
यह शायद काम न करे क्योंकि वह मेट्रिक्स है नॉन-इन्वर्टिबल या सिंगुलर.

137
00:09:44,690 --> 00:09:48,595
सौभाग्य से, रेग्युलराइज़ेशन से भी यह समस्या हल हो जाती है हमारे लिए.

138
00:09:48,595 --> 00:09:52,280
और वस्तुत:, जब तक रेगुलराइज़ेशन पेरामिटर लैम्डा

139
00:09:52,280 --> 00:09:56,780
है बड़ा 0 से, यह वास्तव में सम्भव है साबित करना कि यह मेट्रिक्स,

140
00:09:56,780 --> 00:10:02,040
X ट्रान्स्पोज़ X जमा लैम्डा गुणा यह मेट्रिक्स यहाँ, यह सम्भव है साबित करना

141
00:10:02,040 --> 00:10:07,430
यह मेट्रिक्स नहीं होगी सिंगुलर और कि यह मेट्रिक्स होगी इन्वर्टीबल.

142
00:10:07,430 --> 00:10:11,990
तो इस्तेमाल करने से रेग्युलराइज़ेशन हल हो जाती है यह समस्या नॉन-इन्वर्हटीबिलिटी

143
00:10:11,990 --> 00:10:15,350
X ट्रान्स्पोज़ X मेट्रिक्स की भी.

144
00:10:15,350 --> 00:10:18,960
तो आप अब जानते हैं कैसे इम्प्लमेंट करना हैरेगुलराइज्ड लिनीअर रेग्रेशन.

145
00:10:18,960 --> 00:10:22,060
इसको इस्तेमाल करने से आप ओवर फ़िटिंग से बच पाएँगे

146
00:10:22,060 --> 00:10:25,470
यदि आपके पास बहुत से फ़ीचर्ज़ भी है एक अपेक्षाकृत छोटे ट्रेनिंग सेट में.

147
00:10:25,470 --> 00:10:28,860
और इससे लिनीअर रेग्रेशन करना चाहिए अधिक बेहतर

148
00:10:28,860 --> 00:10:30,130
बहुत सी प्राब्लम्ज़ के लिए.

149
00:10:30,130 --> 00:10:33,270
अगले वीडियो में हम लेंगे यह रेग्युलराइज़ेशन का सुझाव और

150
00:10:33,270 --> 00:10:35,230
अप्लाई करेंगे इसे लॉजिस्टिक रिग्रेशन को.

151
00:10:35,230 --> 00:10:38,960
ताकि आप बच पाएँ ओवर फ़िटिंग से लॉजिस्टिक रिग्रेशन में और

152
00:10:38,960 --> 00:10:40,020
पर्फ़ॉर्म कर पाएँ अधिक बेहतर.