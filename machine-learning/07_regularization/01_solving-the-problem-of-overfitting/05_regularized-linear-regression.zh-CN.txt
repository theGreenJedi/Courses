对于线性回归的求解 我们之前 推导了两种学习算法 一种基于梯度下降 一种基于正规方程 在这段视频中 我们将继续学习 这两个算法 并把它们推广 到正则化线性回归中去 这是我们上节课推导出的 正则化线性回归的 优化目标 前面的第一部分是 一般线性回归的目标函数 而现在我们有这个额外的 正则化项 其中 λ 是正则化参数 我们想找到参数 θ 能最小化代价函数 即这个正则化代价函​​数 J(θ) 之前 我们使用 梯度下降求解原来 没有正则项的代价函数 我们用 下面的算法求解常规的 没有正则项的线性回归 我们会如此反复更新 参数 θj 其中 j=0, 1, 2...n 让我 照这个把 j=0 即 θ0 的情况单独写出来 我只是把 θ0 的更新 分离出来 剩下的这些参数θ1, θ2 到θn的更新 作为另一部分 所以 这样做其实没有什么变化 对吧？ 这只是把 θ0 的更新 这只是把 θ0 的更新 和 θ1 θ2 到 θn 的更新分离开来 和 θ1 θ2 到 θn 的更新分离开来 我这样做的原因是 你可能还记得 对于正则化的线性回归 我们惩罚参数θ1 θ2...一直到 θn  但是我们不惩罚θ0 所以 当我们修改这个 正则化线性回归的算法时 我们将对 θ0 的方式将有所不同 具体地说 如果我们 要对这个算法进行 修改 并用它 求解正则化的目标函数 我们 需要做的是 把下边的这一项做如下的修改 我们要在这一项上添加一项: λ 除以 m 再乘以 θj 如果这样做的话 那么你就有了 用于最小化 正则化代价函数 J(θ) 的梯度下降算法 我不打算用 微积分来证明这一点 但如果你看这一项 方括号里的这一项 如果你知道微积分 应该不难证明它是 J(θ) 对 θj 的偏导数 这里的 J(θ) 是用的新定义的形式 它的定义中 包含正则化项 而另一项 上面的这一项 我用青色的方框 圈出来的这一项 这也一个是偏导数 是 J(θ)对 θ0 的偏导数 如果你仔细看 θj 的更新 你会发现一些 有趣的东西 具体来说 θj 的每次更新 都是 θj 自己减去 α 乘以原来的无正则项 然后还有这另外的一项 这一项的大小也取决于 θj 所以 如果你 把所有这些 取决于 θj 的合在一起的话 可以证明 这个更新 可以等价地写为 如下的形式 具体来讲 上面的 θj 对应下面的 θj 乘以括号里的1 而这一项是 λ 除以 m 还有一个α 把它们合在一起 所以你最终得到 α 乘以 λ 再除以 m 然后合在一起 乘以 θj 而这一项 1 减去 α 乘以 λ 除以 m 这一项很有意思 具体来说 这一项 1 减去 α 乘以 λ 除以 m 这一项的值 通常是一个具体的实数 而且小于1 对吧？由于 α 乘以 λ 除以 m 通常情况下是正的 如果你的学习速率小 而 m 很大的话 (1 - αλ/m) 这一项通常是很小的 所以这里的一项 一般来说将是一个比1小一点点的值 所以我们可以把它想成 一个像0.99一样的数字 所以 对 θj 更新的结果 我们可以看作是 被替换为 θj 的0.99倍 也就是 θj 乘以0.99 把 θj 向 0 压缩了一点点 所以这使得 θj 小了一点 更正式地说 θj 的平方范数 更小了 另外 这一项后边的第二项 这实际上 与我们原来的 梯度下降更新完全一样 跟我们加入了正则项之前一样 好的 现在你应该对这个 梯度下降的更新没有疑问了 当我们使用正则化线性回归时 我们需要做的就是 在每一个被正规化的参数 θj 上 乘以了一个 比1小一点点的数字 也就是把参数压缩了一点 然后 我们执行跟以前一样的更新 当然 这仅仅是 从直观上认识 这个更新在做什么 从数学上讲 它就是带有正则化项的 J(θ) 的梯度下降算法 我们在之前的幻灯片 给出了定义 梯度下降只是 我们拟合线性回归模型的两种算法 的其中一个 第二种算法是 使用正规方程 我们的做法 是建立这个 设计矩阵 X 其中每一行 对应于一个单独的训练样本 然后创建了一个向量 y 向量 y 是一个 m 维的向量 m 维的向量 包含了所有训练集里的标签 所以 X 是一个 m × (n+1) 维矩阵 y 是一个 m 维向量 y 是一个 m 维向量 为了最小化代价函数 J 我们发现 一个办法就是 一个办法就是 让 θ 等于这个式子 即 X 的转置乘以 X 再对结果取逆 再乘以 X 的转置乘以Y 我在这里留点空间 等下再填满 这个 θ 的值 其实就是最小化 代价函数 J(θ) 的θ值 这时的代价函数J(θ)没有正则项 现在如果我们用了是正则化 我们想要得到最小值 我们想要得到最小值 我们来看看应该怎么得到 我们来看看应该怎么得到 推导的方法是 取 J 关于各个参数的偏导数 并令它们 等于0 然后做些 数学推导 你可以 得到这样的一个式子 它使得代价函数最小 具体的说 如果你 使用正则化 那么公式要做如下改变 括号里结尾添这样一个矩阵 0 1 1 1 等等 直到最后一行 所以这个东西在这里是 一个矩阵 它的左上角的元素是0 其余对角线元素都是1 剩下的元素也都是 0 我画的比较随意 可以举一个例子 如果 n 等于2 那么这个矩阵 将是一个3 × 3 矩阵 更一般地情况 该矩阵是 一个 (n+1) × (n+1) 维的矩阵 一个 (n+1) × (n+1) 维的矩阵 因此 n 等于2时 矩阵看起来会像这样 左上角是0 然后其他对角线上是1 其余部分都是0 同样地 我不打算对这些作数学推导 坦白说这有点费时耗力 但可以证明 如果你采用新定义的 J(θ) 如果你采用新定义的 J(θ) 包含正则项的目标函数 那么这个计算 θ 的式子 能使你的 J(θ) 达到全局最小值 所以最后 我想快速地谈一下不可逆性的问题 这部分是比较高阶的内容 所以这一部分还是作为选学 你可以跳过去 或者你也可以听听 如果听不懂的话 也没有关系 之前当我讲正规方程的时候 我们也有一段选学视频 讲不可逆的问题 所以这是另一个选学内容 可以作为上次视频的补充 可以作为上次视频的补充 现在考虑 m 即样本总数 小与或等于特征数量 n 如果你的样本数量 比特征数量小的话  那么这个矩阵 X 转置乘以 X 将是 不可逆或奇异的(singluar) 或者用另一种说法是 这个矩阵是 退化(degenerate)的 如果你在 Octave 里运行它 无论如何 你用函数 pinv 取伪逆矩阵 这样计算 理论上方法是正确的 但实际上 你不会得到一个很好的假设 尽管 Ocatve 会 用 pinv 函数 给你一个数值解 看起来还不错 但是 如果你是在一个不同的编程语言中 如果在 Octave 中 你用 inv 来取常规逆 你用 inv 来取常规逆 也就是我们要对 X 转置乘以 X 取常规逆 然后在这样的情况下 你会发现 X 转置乘以 X 是奇异的 是不可逆的 即使你在不同的 编程语言里计算 并使用一些 线性代数库 试图计算这个矩阵的逆矩阵 都是不可行的 因为这个矩阵是不可逆的或奇异的 幸运的是 正规化也 为我们解决了这个问题 具体地说 只要正则参数是严格大于0的 实际上 可以 证明该矩阵 X 转置 乘以 X 加上 λ 乘以 这里这个矩阵 可以证明 这个矩阵将不是奇异的 即该矩阵将是可逆的 因此 使用正则化还可以 照顾一些 X 转置乘以 X 不可逆的问题 照顾一些 X 转置乘以 X 不可逆的问题 好的 你现在知道了如何实现正则化线性回归 利用它 你就可以 避免过度拟合 即使你在一个相对较小的训练集里有很多特征 这应该可以让你 在很多问题上更好地运用线性回归 在接下来的视频中 我们将 把这种正则化的想法应用到逻辑回归 这样你就可以 让逻辑回归也避免过度拟合 并让它表现的更好 【教育无边界字幕组】翻译：Badbye 校对：所羅門捷列夫 审核：Naplessss