इस विडीओ में, मैं चाहूँगा बताना आपको, मुख्य इंट्यूशंज / अंतः अनुभव कि रेग्युलराइज़ेशन कैसे काम करता है. और, हम लिखेंगे भी कॉस्ट फ़ंक्शन जो हम इस्तेमाल करेंगे, जब हम करेंगे रेग्युलराइज़ेशन. हाथ से बनाए उदाहरणों के साथ जो हमारे पास हैं इन स्लाइड्ज़ पर, में सोचता हूँ मैं बता पाउँगा कुछ अंतः अनुभव. लेकिन एक इस से भी बेहतर ढंग कि आप स्वयं देख सकें, कि कैसे रेग्युलराइज़ेशन काम करता है, वह है यदि आप इम्प्लमेंट करते हैं इसे, और देखते हैं इसे अपने लिए काम करते हुए. और, यदि आप करते हैं उचित एक्सर्सायज़ेज़ / अभ्यास इसके बाद, आपको मिलता है अवसर स्वयं देखने का रेग्युलराइज़ेशन काम करते हुए आपके लिए. तो, यहाँ है अंतर्ज्ञान. पिछले विडीओ में, हमने देखा कि, यदि हमें फ़िट करना होता एक क्वाड्रैटिक फंक्शन / मॉडल इस डेटा में, यह देता है हमें एक काफ़ी अच्छा फ़िट डेटा को. जबकि, यदि हम करते फ़िट एक अधिक बड़ी उच्च डिग्री का पालिनोमीयल, हमें मिलता अंत में एक कर्व जो शायद फ़िट करता ट्रेनिंग सेट को बहुत अच्छे से, लेकिन, वास्तव में नहीं होता फ़िट बल्कि ओवेरफ़िट होता डेटा को घटिया तरीके से, और, जनरलाइज न हो पाता ढंग से. ग़ौर कीजिए निम्न पर, मान लो हमें दण्डित करना है, और, बनाने हैं पेरामिटर्स थीटा 3 और थीटा 4 बहुत ही छोटे. यहाँ है क्या मेरा मतलब है, यह है हमारा ऑप्टिमायज़ेशन अब्जेक्टिव, या यह है हमारा ऑप्टिमायज़ेशन प्रॉब्लम, जहाँ हम न्यूनतम करते हैं हमारे हमेशा के स्क्वेर्ड एरर कॉस्ट फ़ंक्शन को. मान लो मैं लेता हूँ यह अब्जेक्टिव और बदल देता हूँ इसे और जोड़ देता हूँ इसमें, प्लस 1000 थीटा 3 स्क्वेर्ड, प्लस 1000 थीटा 4 स्क्वेर्ड. 1000 मैं सिर्फ़ लिख रहा हूँ केवल एक बड़ी संख्या के तौर पर. अब, यदि हमें करना होता न्यूनतम इस फ़ंक्शन को, एकमात्र ढंग बनाने के लिए इस नए कॉस्ट फ़ंक्शन को छोटा है यदि थीटा 3 और थीटा 4 छोटे होंगे, सही? क्योंकि अन्यथा, यदि आपके पास है एक हज़ार गुना थीटा 3, यह नया कॉस्ट फ़ंक्शन होगा काफ़ी बड़ा. तो जब हम न्यूनतम करते हैं इस नए कॉस्ट फ़ंक्शन को हमें मिलेगा थीटा 3 0 के आसपास और थीटा 4 भी 0 के आसपास और जैसे हम हटा रहे हों ये दो टर्म्ज़ वहाँ पर. और यदि हम वह करते हैं, अच्छा तब, यदि थीटा 3 और थीटा 4 हैं 0 के आसपास तब हमारे पास बचता है एक क्वाड्रैटिक फ़ंक्शन, और, इसलिए, हमें मिलता हैं एक फ़िट डेटा को, और वह है, आप जानते हैं, क्वाड्रैटिक फ़ंक्शन प्लस शायद, बहुत छोटा सा योगदान छोटी टर्म्ज़ से, थीटा 3, थीटा 4, क्योंकि वे है बहुत नज़दीक 0 के. और, इसलिए, हमें मिलता हैं दरअसल, एक क्वाड्रैटिक फ़ंक्शन, जो अच्छा है. क्योंकि यह है एक अधिक बेहतर हायपॉथिसस. इस ख़ास उदाहरण में, हमने देखा प्रभाव दण्डित करने का दो पेरमिटर्स वैल्यूज़ को बड़ा होने का. साधारणतया, यहाँ है आईडिया / सुझाव रेग्यूलराईज़ेशन का. आईडिया / सुझाव है कि, यदि हमारे पास हैं छोटी वैल्यूज़ पेरमिटर्स के लिए, तब, होना छोटी वैल्यूज़ का पेरमिटर्स के लिए, किसी तरह होगा, बहुधा कॉरेस्पॉंड करेगा एक सरल हायपॉथिसस से. तो, हमारे पिछले उदाहरण के लिए, हमने दण्डित किया केवल थीटा 3 और थीटा 4 को और जब दोनो ये हो गए नज़दीक ज़ीरो के, हमें मिली एक काफ़ी सरल हायपॉथिसस, जो दरअसल थी एक क्वाड्रैटिक फ़ंक्शन. लेकिन साधारणतया,  यदि हम दण्डित करे, सारे पेरमिटर्स को, अक्सर वह, हम सोच सकते हैं उसे, प्रयास की तरह पाने के एक सरल हायपॉथिसस. भी क्योंकि जब, आप जानते हैं, ये पेरमिटर्स हैं काफ़ी नज़दीक ज़ीरो के इस उदाहरण में, जिससे हमें मिला एक क्वाड्रैटिक फ़ंक्शन. लेकिन साधारणतया, यह है संभव दिखाना कि होने से छोटी वैल्यूज़ पेरमिटर्स की कोर्रेसपोड करता हैं अक्सर स्मूद /  सम फ़ंक्शन से और सरल फ़ंक्शन से भी. और जो हैं इसलिए, भी, कम सम्भावित ओवेरफ़िट्टिंग के लिए. मैंने अनुभव किया कि विचार कि क्यों होने चाहिए सारे परमिटर्स छोटे. क्यों वह कॉरेस्पॉंड करता हैं एक सरल हायपॉथिसस को; मैंने यह अनुभव किया कि विचार शायद आपको अभी पूरी तरह स्पष्ट न हो अभी. और यह है एक प्रकार से कठिन समझा पाना जब तक कि आप इम्प्लमेंट नहीं करते अपने आप और देखते इसे अपने लिए. लेकिन मैं आशा करता हूँ कि उदाहरण लेने से थीटा 3 और थीटा 4 को काफ़ी छोटे और कैसे उससे हमें मिली एक अधिक सरल हायपॉथिसस, मैं आशा करता हूँ कि उससे मदद मिली होगी समझने में कि क्यों, कम से कम दिया होगा कुछ अनुभव कि क्यों वह शायद सही होगा. चलिए देखते है एक विशेष उदाहरण. घर की क़ीमत की प्रिडिक्शन के लिए हमारे पास शायद हैं हमारे सौ फ़ीचर्ज़ जिनकी हमने बात की थी जहाँ शायद एक्स 1 है साइज़, एक्स 2 है संख्या शयन कक्षों की, एक्स 3 संख्या मंज़िलों की इत्यादि. और हमारे पास शायद हैं सौ फ़ीचर्ज़. और विपरीत हमारे पालिनोमीयल उदाहरण के, हम नहीं जानते, सही, हम नहीं जानते कि थीटा 3, थीटा 4, हैं हाइअर ऑर्डर पालिनोमीयल टर्म्ज़. तो, यदि हमारे पास है सिर्फ़ एक बैग, यदि हमारे पास है सिर्फ़ एक सेट एक सौ फ़ीचर्ज़ का, यह कठिन होगा चुनना पहले से कि कौन से हैं जो कम सम्भावित हैं उपयुक्त होने के. तो हमारे पास शायद सौ फ़ीचर्ज़ या एक सौ एक पेरमिटर्स. और हम नहीं जानते कौन सा लेना है, हम नहीं जानते कौन सा पेरामिटर लेने का प्रयास करना है, छोटा करने की कोशिश में. अत:, रेगुलराइज़ेशन में, हम क्या करते हैं, कि लेते हैं हमारा कॉस्ट फ़ंक्शन, यहाँ है मेरा कॉस्ट फ़ंक्शन लिनीअर रेग्रेशन के लिए. और मैं क्या करूँगा कि बदलूँगा इस कॉस्ट फ़ंक्शन को छोटे करने के लिए सारे मेरे पेरमिटर्स, क्योंकि, आप जानते हैं, मैं नहीं जानता कौन से एक या दो छोटे करने हैं. तो मैं बदलूँगा मेरा कॉस्ट फ़ंक्शन जोड़ने के लिए एक टर्म अंत में. इस प्रकार हमारे पास हैं स्क्वेर ब्रैकेट्स यहाँ भी. जब मैं जोड़ता हूँ एक अतिरिक्त रेग्युलराईज़ेशन टर्म अंत में छोटे करने के लिए प्रत्येक पेरामिटर को और इसलिए यह टर्म हम प्रयास करते हैं छोटा करने का सारे मेरे पेरमिटर्स को थीटा 1, थीटा 2, थीटा 3 से थीटा 100 तक. वैसे तो, कन्वेन्शन के हिसाब से समेशन यहाँ शुरू होता है एक से अत: मैं नहीं करूँगा दण्डित थीटा ज़ीरो को बड़ा होने के लिए. वह कन्वेन्शन कि, सम आइ ईक्वल्ज़ वन से एन तक, बजाय आइ ईक्वल्ज़ ज़ीरो से एन तक. लेकिन व्यावहारिक रूप में, इससे कोई ज़्यादा अंतर नहीं पड़ता, और, चाहे आप शामिल करें, आप जानते हैं, थीटा ज़ीरो को या नहीं, व्यवहार में, इससे कोई ज़्यादा अंतर नहीं पड़ता परिणाम में. लेकिन कन्वेन्शन से, प्रायः, हम रेग्युलराइज़ करते हैं केवल थीटा एक से थीटा 100 तक. लिखते हैं हमारा रेगुलराइज्ड ऑप्टिमायज़ेशन ओबजेक्टिव, हमारा रेगुलराइज्ड कॉस्ट फ़ंक्शन फिर से. यहाँ है यह. यहाँ है जे ऑफ़ थीटा जहाँ, यह टर्म दाईं तरफ़ है एक रेग्युलरेज़ेशन टर्म और लैम्डा यहाँ है रेग्युलरेज़ेशन पेरामीटर और लैम्डा क्या करता है, यह नियंत्रित करता है एक समझौता दो भिन्न लक्ष्यों में. पहला लक्ष्य है, कैप्चर करें इसे पहले अब्जेक्टिव से, है कि हम ट्रेन करना चाहते हैं, कि हम फ़िट करना चाहते हैं ट्रेनिंग डेटा सही ढंग से. हम फ़िट करना चाहते हैं ट्रेनिंग सेट डेटा सही ढंग से. और दूसरा लक्ष्य है कि. हम रखना चाहते हैं पेरमिटर्स को छोटा, और वह कैप्चर होता है दूसरी टर्म से, रेग्यूलराईज़ेशन अब्जेक्टिव से. और रेग्यूलराईज़ेशन टर्म से. और लैम्डा क्या करता है, जो रेग्यूलराईज़ेशन पेरामिटर है, कि नियंत्रित करता है समझौता बीच में इन दो लक्ष्यों के, बीच में फ़िट करने के ट्रेनिंग सेट सही ढंग से के लक्ष्य और उद्देश्य में रखने के लिए पेरमिटर्स को छोटा और इसलिए रखने के लिए हायपाथिसस को अपेक्षाकृत सरल ओवेरफ़िट्टिंग टालने के लिए. घर की क़ीमत की प्रिडिक्शन के उदाहरण में, यद्यपि, पहले, यदि हमारे पास होता फ़िट एक बहुत अधिक ऑर्डर का पालिनोमीयल, हमें शायद मिलता एक बहुत ही घुमावदार फ़ंक्शन इस तरह का. यदि आप अभी भी फ़िट करते हैं  हाइअर ऑर्डर पालिनोमीयल सारे पालिनोमीयल फ़ीचर्ज़ के साथ वहाँ, लेकिन इसके स्थान पर, आप सिर्फ़ सुनिश्चित करते हैं, कि इस्तेमाल करना है यह एकमात्र रेगुलराइज्ड अब्जेक्टिव, तब क्या आपको मिलता है एक कर्व जो नहीं है एक क्वाड्रैटिक फ़ंक्शन बल्कि है काफ़ी सम और काफ़ी सरल और शायद एक कर्व जैसे मजेंटा लाइन वह, आप जानते हैं, देता है एक अधिक बेहतर हायपॉथिसस इस डेटा के लिए. एक बार फिर, मैं अनुभव करता हूँ यह हो सकता है थोड़ा कठिन देख पाना कि क्यों छोटे करने से पेरमिटर्स को हो सकता है यह प्रभाव, लेकिन यदि आप इम्प्लमेंट करें अपने आप रेगुलराइज़ेशन के साथ आप देख पाएँगे यह प्रभाव स्वयं. रेगुलराइज्ड लिनीअर रेग्रेशन में, यदि रेग्युलरेज़ेशन पेरामीटर लैम्डा को सेट करते हैं बहुत बड़ा, तब क्या होगा कि हम दण्डित कर देंगे पेरमिटर्स थीटा 1, थीटा 2, थीटा 3, थीटा 4 को बहुत अधिक. मतलब कि, यदि हमारी हायपाथिसस है यह जो यहाँ नीचे है. यदि हम दण्डित कर देते हैं थीटा 1, थीटा 2, थीटा 3, थीटा 4 को बहुत अधिक, तब हमें मिलते हैं ये सब पेरमिटर्स ज़ीरो के आसपास, सही? थीटा 1 होगा लगभग ज़ीरो; थीटा 2 होगा लगभग ज़ीरो. थीटा तीन और थीटा चार होंगे लगभग ज़ीरो. और यदि हम वह करते हैं, यह है जैसे कि हम हटा रहे है ये टर्म्ज़ हायपॉथिसस से ताकि हमारे पास रह जाए एक हायपॉथिसस जो कहती है कि यह कहती है कि, अच्छा, घर की क़ीमत है बराबर थीटा ज़ीरो के, और वह समान है फ़िट करने के एक सीधी हॉरिज़ॉंटल लाइन डेटा में. और यह है एक उदाहरण अंडरफ़िटिंग का, और ख़ासतौर पर यह हायपॉथिसस, यह सीधी लाइन यह सिर्फ़ फ़ेल हो जाती है फ़िट करने में ट्रेनिंग सेट को बेहतर ढंग से. यह है सिर्फ़ एक सम सीधी लाइन, यह नहीं जाती हैं, आप जानते हैं, नज़दीक. यह नहीं जाती कहीं भी नज़दीक अधिकांश ट्रेनिंग इग्ज़ाम्पल्ज़ के. और दूसरा ढंग इसे कहने का है कि इस हायपॉथिसस में है बहुत अधिक एक पूर्व कल्पना या बहुत अधिक बायस कि घर की क़ीमतें है केवल बराबर थीटा ज़ीरो के, और बावजूद होने के स्पष्ट डेटा इसके विपरीत, आप जानते हैं चुनती है फ़िट करना एक प्रकार से, सीधी लाइन, केवल एक सम सीधी लाइन. मैंने वह बहुत अच्छे से नहीं बनाई है. यह सिर्फ़ एक सम सीधी / फ़्लैट लाइन डेटा के लिए. अत: रेग्युलराइज़ेशन को सही ढंग से काम करने के लिए, कुछ सावधानी बरतनी चाहिए, चुनने के लिए एक अच्छा विकल्प रेग्युलरेज़ेशन पेरामीटर लैम्डा के लिए भी॰ और जब हम बात करेंगे मल्टी-सिलेक्शन की बाद में इस कोर्स में, हम बात करेंगे एक तरीक़े की, एक विविध प्रकार के तरीक़ों की, अपने आप चुनने के लिए रेग्युलरेज़ेशन पेरामीटर लैम्डा को भी. तो, वह है आइडिया रेगुलराइज़ेशन का और कॉस्ट फ़ंक्शन के रिव्यू का करने के लिए इस्तेमाल रेग्युलराइज़ेशन इसमें. अगले दो विडीओज़ में, चलो लेते हैं ये सुझाव और अप्लाई करते हैं उन्हें लिनीअर रेग्रेशन में और लजिस्टिक रेग्रेशन में, ताकि हम करवा सके उनसे बचाव / अवॉयड ओवरफ़िटिंग.