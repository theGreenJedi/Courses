लॉजिस्टिक रिग्रेशन के लिए हमने पहले बात की थी दो तरह के ऑप्टिमायज़ेशन अल्गोरिद्म्स की. हमने बात की कि कैसे वास्तव में इस्तेमाल करते हैं ग्रेडीयंट डिसेंट करने के लिए ऑप्टिमायज़ कॉस्ट फ़ंक्शन जे ऑफ़ थीटा को. और हमने बात भी की थी एडवांसड ऑप्टिमायज़ेशन तरीक़ों की. वे जिनको आवश्यकता है कि आप दें एक ढंग कम्प्यूट करने के लिए आपका कॉस्ट फ़ंक्शन जे ऑफ़ थीटा और कि आप दें एक तरीक़ा कम्प्यूट करने का डेरीवेटिव्स. इस विडियो में, हम दिखाएँगे कि कैसे आप अनुकूल बना सकते हैं दोनो उन तकनीकों को, दोनो ग्रेडीयंट डिसेंट तथा अधिक एडवांसड ऑप्टिमायज़ेशन तकनीक़ों को करवाने के लिए उन्हें काम रेगुलराइज्ड लॉजिस्टिक रिग्रेशन के लिए. तो, यह है सुझाव. हमने देखा पहले कि लॉजिस्टिक रेग्रेशन का झुकाव भी हो सकता है ओवर फ़िटिंग की तरफ़ यदि आप फ़िट करते हैं इसे एक बहुत, एक प्रकार से, ऊँची डिग्री के पालिनोमीयल फ़ीचर्ज़ से इस तरह. जहाँ G है सिग्मोईड फ़ंक्शन और विशेष रूप से आपको मिलती है हायपॉथिसस, आप जानते हैं, जिसकी निर्णायक सीमा रेखा है सिर्फ़ एक प्रकार से बहुत जटिल और बहुत अधिक घुमावदार फ़ंक्शन जो वास्तव में नहीं है एक बहुत बढ़िया हायपॉथिसस इस ट्रेनिंग सेट के लिए, और सामान्य रूप में यदि आपके पास है लॉजिस्टिक रेग्रेशन बहुत से फ़ीचर्ज़ के साथ. ज़रूरी नहीं है कि पालिनोमीयल फ़ीचर्ज़ हों, लेकिन केवल बहुत से फ़ीचर्ज़ के साथ आपको मिल सकते है ओवरफ़िटिंग. यह था हमारा कॉस्ट फ़ंक्शन लॉजिस्टिक रेग्रेशन के लिए. और यदि हम चाहते हैं बदलना इसे ताकि यह इस्तेमाल करे रेगुलराइज़ेशन, हमें सिर्फ़ करना है कि जोड़ें इसमें निम्न टर्म प्लस वन ओवर 2M, सम J बराबर 1 से, और हमेशा की तरह सम है J बराबर 1 से. बजाय कि सम है J बराबर 0 से, थीटा J स्क्वेर्ड का. और इसका होना चाहिए प्रभाव इसलिए, दंडित करने का पेरमिटर्स थीटा 1 थीटा 2 और आगे थीटा n तक ताकि वे बहुत बड़े न हों. और यदि आप यह करते हैं, तो इसका होगा प्रभाव कि भले ही आप फिट कर रहे हों एक बहुत ऊँची डिग्री का पालिनोमीयल बहुत से पेरमिटर्स के साथ. जब आप कर रहे हैं अप्लाई रेगुलराइज़ेशन और रखते हैं पेरमिटर्स को छोटे आपको एक निर्णायक सीमा रेखा मिलने की अधिक सम्भावना है. आप जानते हैं, जो शायद ऐसी दिखेगी. यह दिखती है अधिक उचित अलग करने के लिए पॉज़िटिव और नेगेटिव इग्ज़ाम्पल को. अत:, जब आप इस्तेमाल कर रहे हैं रेगुलराइज़ेशन तब भी जब हमारे पास हैं बहुत से फ़ीचर्ज़, रेगुलराइज़ेशन कर सकता है सहायता ओवरफ़िटिंग समस्या में. कैसे हम वास्तव में इसे अप्लाई करते हैं? ठीक है, प्रारम्भिक ग्रेडीयंट डिसेंट अल्गोरिद्म में, यह था अप्डेट जो हमारे पास था. हम बार-बार करेंगे निम्न अप्डेट थीटा J को. यह स्लाइड दिखती है काफ़ी कुछ पिछली स्लाइड जैसी लिनीअर रेग्रेशन वाली. लेकिन क्या करुंगा मैं कि लिखूँगा थीटा 0 का अप्डेट अलग से तो, पहली लाइन है थीटा 0 का अप्डेट और दूसरी लाइन है अब थीटा 1 के लिए मेरा अप्डेट थीटा N तक. यहाँ, मैं ले रहा हूँ थीटा 0 को अलग से और करने के लिए बदलाव इस अल्गोरिद्म में, इस्तेमाल करने के लिए एक रेगुलराइज्ड कॉस्ट फ़ंक्शन, मुझे सिर्फ़ क्या करना है काफ़ी समान है जो हमने किया लिनीअर रेग्रेशन के लिए है वास्तव में केवल बदलाव इस दूसरे अप्डेट नियम में निम्न तरह से. और, एक बार फिर, यह, आप जानते हैं देखने में लगता है समान जो हमारे पास था लिनीअर रेग्रेशन के लिए. लेकिन निश्चय ही यह नहीं है समान अल्गोरिद्म जो हमारे पास था, क्योंकि अब हायपॉथिसस है परिभाषित इस्तेमाल करते हुए इसे. तो यह नहीं है समान अल्गोरिद्म रेगुलराइज्ड लिनीअर रेग्रेशन जैसे. क्योंकि हायपॉथिसस भिन्न है. जबकि यह अप्डेट जो मैंने लिखा. यह वास्तव में दिखता है समान जैसा हमारे पास पहले था. हम कर रहे थे ग्रेडीयंट डिसेंट रेगुलराइज्ड लिनीअर रेग्रेशन के लिए. तो, समाप्त करते हुए इस चर्चा को, यह टर्म यहाँ वर्ग कोष्ठक में, इसलिए यह टर्म यहाँ, यह टर्म है, निश्चय ही, नया पर्शियल डेरिवेटिव विद रिस्पेक्ट टु थीटा J कॉस्ट फ़ंक्शन जे ऑफ़ थीटा का. जहाँ J ऑफ़ थीटा यहाँ है कॉस्ट फ़ंक्शन जो हमने परिभाषित किया था पिछली स्लाइड पर जो इस्तेमाल करता है रेगुलराइज़ेशन. तो, वह था ग्रेडीयंट डिसेंट रेगुलराइज्ड लिनीअर रेग्रेशन के लिए. चलो बात करते हैं कि कैसे रेगुलराइज्ड लिनीअर रेग्रेशन को काम करवाते हैं इस्तेमाल करते हुए अधिक एडवांसड ऑप्टिमायज़ेशन तरीक़ों की. और बस आपको याद दिला दूँ कि उन तरीक़ों के लिए हमें क्या चाहिए था करना कि परिभाषित करें फ़ंक्शन जिसे कहते हैं कॉस्ट फ़ंक्शन, जो लेता है इनपुट पेरामिटर वेक्टर थीटा और एक बार फिर इक्वेज़न में हम लिख रहे हैं हमने इस्तेमाल किया है 0 इंडेक्स वेक्टर. तो हमारे पास था थीटा 0 से थीटा N तक. लेकिन क्योंकि ओकटेव के इंडेक्स करता है वेक्टर को 1 से शुरू करते हुए. थीटा 0 लिखा जाता है ओकटेव में थीटा 1. थीटा 1 लिखा जाता है ओकटेव में थीटा 2, और इसी प्रकार आगे थीटा N प्लस 1 तक. तो हमें क्या चाहिए था करना कि दें एक फ़ंक्शन. चलो देते हैं एक फ़ंक्शन जिसे कहते हैं कॉस्ट फ़ंक्शन जो हम करेंगे तब पास उसमें जो हमारे पास है, जो हमने पहले देखा था. हम इस्तेमाल करेंगे fminunc और तब जानते हैं कॉस्ट फ़ंक्शन पर, और इसी तरह, ठीक है. लेकिन F min, u और c था F min अनकोंस्ट्रैंड और यह करेगा काम fminunc के साथ था कि यह लेगा कॉस्ट फ़ंक्शन और न्यूनतम करेगा इसे हमारे लिए. इसलिए दो मुख्य बातें है कि कॉस्ट फ़ंक्शन को देना चाहिए वपिस पहली J-val. और उसके लिए, हमें जरूरत है लिखने की कोड कम्प्यूट करने के लिए कॉस्ट फ़ंक्शन जे ऑफ़ थीटा. अब, जब हम इस्तेमाल कर रहे हैं रेगुलराइज्ड लॉजिस्टिक रेग्रेशन, निश्चय ही कॉस्ट फ़ंक्शन जे ऑफ़ थीटा बदल जाता है और, विशेष रूप से, अब एक कॉस्ट फ़ंक्शन को चाहिए लेना यह अतिरिक्त रेगुलराइज़ेशन टर्म भी अंत में. तो जब आप कम्प्यूट करते हैं जे ऑफ़ थीटा तब न भूले शामिल करना उस टर्म को अंत में. और तब, दूसरी चीज़ जो इस कॉस्ट फ़ंक्शन को डिराइव करना एक ग्रेडीयंट से. तो ग्रेडीयंट एक होना चाहिए सेट पार्शियल डेरिवेटिव जे ऑफ़ थीटा का विद रिस्पेक्ट टु थीटा ज़ीरो, ग्रेडीयंट दो होना चाहिए सेट उसको, और इसी प्रकार आगे. एक बार फिर, इंडेक्स शुरू है एक से. ठीक है, क्योंकि इंडेक्सिंग है एक से ओकटेव में. और देखने पर इन टर्म्ज़ को. यह टर्म यहाँ. हमने वास्तव में किया इसे एक पिछली स्लाइड पर है वास्तव में बराबर इसके. यह नहीं बदलती है. क्योंकि थीटा ज़ीरो का डेरिवेटिव नहीं बदलता है. तुलना में वर्ज़न के बिना रेगुलराइज़ेशन के. और अन्य टर्म्ज़ अवश्य बदल जाती हैं. और विशेष रूप से डेरिवेटिव विद रिस्पेक्ट टु थीटा एक. हमने यह भी पिछली स्लाइड में किया था. है बराबर, आप जानते हैं, प्रारम्भिक टर्म के फिर माइनस लैम्डा ओवर M गुणा थीटा j. सिर्फ़ हम सुनिश्चित करते हैं कि हम पास करते हैं इसे सही ढंग से. और हम कोष्ठकों को यहां जोड़ सकते हैं. ठीक है, तो समेशन आगे नहीं जाता है. और इसी तरह, आप जानते हैं, यह अन्य टर्म यहाँ दिखती है ऐसी, इस अतिरिक्त के साथ जो हमारे पास थी पिछली स्लाइड पर, वह कॉरेस्पॉंड करती है ग्रेडीयंट को उनके रेगुलराइज़ेशन ओबजेक्टिव से. तो यदि आप इम्प्लमेंट करते हैं इस कॉस्ट फ़ंक्शन को और पास करते हैं इसे fminunc में या किसी एडवांसड ऑप्टिमायज़ेशन तकनीक को, जो करेगा न्यूनतम/ मिनमायज़ नए रेगुलराइज्ड कॉस्ट फ़ंक्शन जे ऑफ़ थीटा को. और पेरमिटर्स जो आपको मिलते हैं होगे वे जो कॉरेस्पॉंड करते हैं लॉजिस्टिक रिग्रेशन को रेगुलराइज़ेशन के साथ. तो, अब आप जानते हैं कैसे करते हैं इम्प्लमेंट रेगुलराइज्ड लॉजिस्टिक रिग्रेशन. जब मैं सिलिकॉन वैली के आस पास टहलता हूँ, मैं सिलीकॉन वैली में रहता हूँ, वहाँ हैं बहुत से एंज़िनियर्स जो स्पष्टत:, बना रहे हैं बहुत सा पैसा उनकी कम्पनीज़ के लिए इस्तेमाल करके मशीन लर्निंग अल्गोरिद्म्स. और मुझे पता है हम आप जानते हैं, पढ़ रहे हैं यह सब कुछ ही समय से. लेकिन यदि आप समझते हैं लिनीअर रेग्रेशन, एडवांसड ऑप्टिमायज़ेशन अल्गोरिद्म्स और रेगुलराइज़ेशन, अब तक, स्पष्टत:, आप शायद जानते हैं काफ़ी अधिक मशीन लर्निंग तुलना में बहुत से, निश्चित रूप से अब, लेकिन आप शायद जानते हैं काफ़ी अधिक मशीन लर्निंग अब तुलना में स्पष्ट रूप से, बहुत से सिलिकन वैली एंजिनीयर्स से जिनका करियर काफ़ी सफल है. आप जानते हैं, बना रहे हैं बहुत पैसे उनकी कम्पनीज़ के लिए. या बना रहे हैं प्रॉडक्ट्स इस्तेमाल करके मशीन लर्निंग अल्गोरिद्म्स. तो,बधाई हो. आप वास्तव में काफ़ी दूर निकल आए हैं. और आप वास्तव में कर सकते हैं, आप वास्तव में जानते हैं पर्याप्त अप्लाई करने के लिए इसे और काम करवा सकते हैं कई प्राब्लम्ज़ के लिए. तो इसके लिए बधाई. लेकिन ज़ाहिर है, वहाँ है अभी भी काफ़ी कुछ जो हम पढ़ाना चाहते हैं आपको, और वीडियो के अगले सेट में इसके बाद, हम शुरू करेंगे बात करना एक काफ़ी प्रभावशाली क्लास की नॉन-लिनीअर क्लैसिफ़ायअर की. तो जबकि लिनीअर रेग्रेशन, लॉजिस्टिक रेग्रेशन, आप जानते हैं आप बना सकते हैं पालिनोमीयल टर्म्ज़, लेकिन यह होता है कि ऐसी बहुत अधिक प्रभावशाली नॉन-लिनीअर क्लैसिफ़ायअर हैं जो कर सकते हैं तब पालिनोमीयल रेग्रेशन. और अगले सेट में वीडियो के इसके बाद, मैं शुरू करूँगा और बताना आपको उनके बारे में. ताकि आप के पास हीं और भी अधिक प्रभावशाली लर्निंग अल्गोरिद्म्स तुलना में जो हैं आपके पास अब अप्लाई करने के लिए भिन्न प्राब्लम्ज़ को.