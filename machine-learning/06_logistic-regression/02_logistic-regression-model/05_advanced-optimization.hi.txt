पिछले विडीओ में, हमने बात की ग्रेडीयंट डिसेंट के बारे में, मिनिमाईज़ / न्यूनतम करने के लिए कॉस्ट फ़ंक्शन जे ऑफ थीटा को लौजिस्टिक रिग्रेशन के लिए. इस विडीओ में, मैं चाहूँगा आपको बताना कुछ एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म्स और कुछ एडवांस्ड ऑप्टिमायज़ेशन कोन्सेप्ट्स / सिद्धांत. इन में से कुछ सिद्धांतों का प्रयोग करते हुए, हम करवा पाएँगे लजिस्टिक रिग्रेशन को रन करना और अधिक तेज़ी से उससे जो सम्भव है ग्रेडीयंट डिसेंट के साथ. और इससे यह भी होगा कि अल्गोरिद्म्स को ज़्यादा अच्छी तरह से स्केल कर पाएँगे बहुत बड़ी मशीन लर्निंग की समस्याओं के लिए, जैसे कि अगर हमारे पास बहुत अधिक संख्या में फ़ीचर्ज़ हों. यहाँ पर एक दूसरा व्यू है उसका कि ग्रेडीयंट डिसेंट क्या कर रहा है. हमारे पास कोई कॉस्ट फ़ंक्शन जे है और हम उसे मिनिमाईज़ / न्यूनतम करना चाहते हैं. तो हमें करने की ज़रूरत है कि हमें लिखना चाहिए कोड जो ले सकता है इनपुट पेरामिटरज़ थीटा को और और वे कम्प्यूट कर सकते हैं  दो चीज़ें: जे ऑफ थीटा और ये पार्शल डेरिवेटिव टर्म्ज़ फॉर, आप जानते हैं, जे इकुअल्ज़ 0, 1 एन तक. दिया गया कोड जो यह दो चीज़ें कर सकता है, क्या ग्रेडीयंट डिसेंट करता है कि यह रीपिटिडली (बार बार दोहराते हुए) फोलोविंग (आगे का) अपडेट करता है. ठीक? तो दिया गया कोड जो हमने लिखा कम्प्यूट करने के लिए ये पार्शल डेरिवेटिवज़, ग्रेडीयंट डिसेंट प्लग इन होता (जुड़ता)  है यहाँ और उसको यूज़ करता है हमारे पेरामिटरज़ थीटा को अप्डेट करने के लिए. तो दूसरा तरीक़ा सोचने का ग्रेडीयंट डिसेंट के बारे में है कि हमें कोड सप्लाई करना है जे ऑफ थीटा को कम्प्यूट करने के लिए और इन डेरिवेटिवज़ को, और तब तब ये प्लगड हो जाते हैं ग्रेडीयंट डिसेंटस में, जो तब कोशिश कर सकता है फ़ंक्शन को हमारे लिए मिनिमाईज़ करने की॰ ग्रेडीयंट डिसेंट के लिए, मेरा अनुमान है तकनीकी तौर पर आपको वास्तव में कोड की जरूरत नहीं है कम्प्यूट करने के लिए कॉस्ट फ़ंक्शन जे ऑफ थीटा. आपको चाहिए कोड सिर्फ़ कम्प्यूट करने के लिए डेरिवेटिव टर्म्ज़. लेकिन अगर आप सोचते हो अपने कोड को कन्वर्जेन्स मॉनिटर करते हुए भी ऐसे किसी / कुछ की, हम केवल सोचेंगे अपने आप को कोड प्रोवाईड करते (देते) हुए कम्प्यूट करने के लिए दोनो कॉस्ट फ़ंक्शन और डेरिवेटिव टर्म्ज़ को. अतः, कोड लिख चुकने के बाद इन दोनो चीजों को कम्प्यूट करने के लिए, एक अल्गोरिद्म जो हम प्रयोग कर सकते हैं वह है ग्रेडीयंट डिसेंट. लेकिन ग्रेडीयंट डिसेंट ही एक अल्गोरिद्म नहीं है जो हम प्रयोग कर सकते हैं. और अन्य अल्गोरिद्म्स भी हैं, ज़्यादा एडवांस्ड, ज़्यादा सोफिस्टीकेटिड (प्रगतिशील), जिनको, अगर हम सिर्फ़ प्रोवाईड कर दें एक वे / तरीक़ा कम्प्यूट करने का इन दोनों चीजों को, तब ये अलग अलग पद्धतियाँ हैं ऑप्टिमायज़ करने की कॉस्ट फ़ंक्शन को हमारे लिए. अत: कॉंजुगेट ग्रेडीयंट बीएफ़जीएस और एल-बीएफ़जीएस उदाहरण हैं और अधिक सोफिस्टीकेटिड ऑप्टिमायज़ेशन अल्गोरिद्म्स के जिन्हें जरूरत होती है एक वे (तरीक़ा) की कम्प्यूट करने के लिए जे ऑफ थीटा को, और चाहिए होता है एक वे डेरिवेटिवज़ को कम्प्यूट करने के लिए, और तब प्रयोग कर सकते हैं और अधिक सोफिस्टीकेटिड स्ट्रेटिजीज / युक्तियों को ग्रेडीयंट डिसेंट के अलावा कॉस्ट फ़ंक्शन को न्यूनतम करने के लिए. वह विस्तृत जानकारी कि वास्तव में क्या हैं ये तीन अल्गोरिद्म्स इस पाठ्यक्रम के विषय क्षेत्र से बाहर है. और असल में आप प्रायः लगा चुकते हैं, आप जानते हैं, कई दिन, या कुछ सप्ताह इन अल्गोरिद्म्स के अध्ययन में. अगर आप एक क्लास लें और नूमेरिकल कम्प्यूटिंग एडवांस करें. परंतु मैं बताता हूँ आपको उनकी कुछ प्रॉपर्टीज़ के बारे में॰ इन तीन अल्गोरिद्म्स की बहुत सी ऍडवेंटिजिज / लाभ हैं. एक है कि, इन में से किसी अल्गोरिद्म्स के साथ आपको प्रायः नहीं आवश्यकता है मैन्युअली पिक करने की लर्निंग रेट अल्फ़ा को. तो एक तरीक़ा सोचने का इन अल्गोरिद्म्स के बारे में यह है कि दिया गया है तरीक़ा कम्प्यूट करने का डेरिवेटिव और कॉस्ट फ़ंक्शन को. आप सोच सकते हैं इन अल्गोरिद्म्स को एक चतुर इंटर-लूप सहित. और, वास्तव में, इनमें एक चतुर इंटर-लूप है जिसे कहते हैं लाइन सर्च अल्गोरिद्म जो ओटोमेटिकली / स्वतः परीक्षण करता है  अलग अलग संख्याएँ लर्निंग रेट अल्फ़ा के लिए और अपने आप पिक करता है एक अच्छा लर्निंग रेट अल्फ़ा ताकि यह पिक भी कर सके एक अलग लर्निंग रेट हर आइटरेशन के लिए. और तब आपको आवश्यकता नहीं ख़ुद उसको चुनने की. ये अल्गोरिद्म्स वास्तव में करते हैं ज़्यादा प्रगतिशील चीज़ें बजाय सिर्फ़ एक अच्छा लर्निंग रेट पिक करने के, और इसलिए वे प्रायः एंड अप होते हैं अधिक तेज़ी से कन्वर्ज होते हुए ग्रेडीयंट डिसेंट की तुलना में. ये अल्गोरिद्म्स वास्तव में करते हैं अधिक प्रगतिशील चीज़ें बजाय सिर्फ़ पिक करने के एक अच्छा लर्निंग रेट, और इसलिए वे प्रायः एंड अप होते हैं अधिक तेज़ी से कन्वर्ज होते हुए ग्रेडीयंट डिसेंट की तुलना में, परंतु विस्तृत चर्चा कि वास्तव में वे क्या करते हैं  इस पाठ्य क्रम के विषय क्षेत्र से बाहर है. वास्तव में, मैं वास्तव में प्रयोग किया करता था इन अल्गोरिद्म्स का एक लम्बे समय से, शायद एक दशक से ज़्यादा, अक्सर, और यह सिर्फ़, आप जानते हैं, कुछ ही साल पहले था कि मैं वास्तव में समझ पाया अपने लिए विस्तार से कि क्या करते हैं कॉंजुगेट ग्रेडीयंट, बीएफ़जीएस और ओ-बीएफ़जीएस. अत: यह वास्तव में पूरी तरह सम्भव है इन अल्गोरिद्म्स का सफलता पूर्वक प्रयोग करना और उनका इस्तेमाल करना विभिन्न लर्निंग समस्याओं में बिना पूरी तरह समझे इंटर-लूप को उसके जो ये अल्गोरिद्म्स करती हैं॰ अगर इन अल्गोरिद्म्स में एक डिसएडवेंटेज / अलाभ है, मैं कहूँगा कि प्रमुख अलाभ है कि ये काफ़ी पेचीदा हैं ग्रेडीयंट डिसेंट की तुलना मैं. और विशेषत:, आपको शायद इम्प्लमेंट नहीं करना चाहिए इन अल्गोरिद्म्स को - कॉंजुगेट ग्रेडीयंट, एल-बीजीएफ़एस, बीएफ़जीएस- अपने आप जब तक आप निपुण नहीं हो जाते नूमेरिकल कम्प्यूटिंग में. उसके स्थान पर, जैसे मैं रेकमेंड नहीं करूँगा कि आप लिखें आपका अपना कोड कम्प्यूट करने के लिए स्क्वेर रूट संख्याओं का या कम्प्यूट करना मेट्रिसीज़ के इन्वर्स का, इन अल्गोरिद्म्स के लिए भी मैं रेकमेंड करूँगा कि आप केवल एक सॉफ़्ट्वेर लाइब्रेरी का प्रयोग करें. तो, आप जानते हैं, लेने के लिए स्क्वेर रूट क्या करते हैं हम सब वह है कि कोई फ़ंक्शन का प्रयोग करते हैं जो किसी और ने लिखा है कम्प्यूट करने के लिए स्क्वेर रूट हमारी संख्याओं का. और सौभाग्य से, ओकटेव और और उससे नजदीकी संबन्धित लैंग्विज मैटलैब - जिसका हम प्रयोग करेंगे - ओकटेव में काफ़ी अच्छी और सम्पन्न लाइब्रेरी है जिसमें इम्प्लमेंट किए है इनमें से कुछ एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म्स. और इसलिए यदि आप सिर्फ़ इस्तेमाल करें बिल्ट- इन लाइब्रेरी, आप जानते हैं, आपको काफ़ी अच्छे परिणाम मिलते हैं. मैं तो कहूँगा कि एक अंतर होता है अच्छे और बुरे इम्प्लमेंटेशन में इन अल्गोरिद्म्स के. और इसलिए, अगर आप प्रयोग कर रहे है एक अलग लैंग्विज आपकी मशीन लर्निंग ऐप्लिकेशन के लिए, अगर आप प्रयोग कर रहे हैं सी, सी प्लस प्लस, जावा, और इत्यादि, आप ट्राइ करना चाहेंगे कुछ अलग लाइब्रेरीज़ को यह सुनिश्चित करने के लिए कि आपको मिल सके एक अच्छी लाइब्रेरी इन अल्गोरिद्म्स को इम्प्लमेंट करने के लिए. क्योंकि अंतर होता है कार्य क्षमता में एक अच्छी इम्प्लमेंटेशन की, आप जानते हैं, कांटुर ग्रेडीयंट की या एलपीएफ़जीएस के मुक़ाबले में एक कम अच्छी इम्प्लमेंटेशन कांटुर ग्रेडीयंट या एलपीएफ़जीएस की. तो चलो अब मैं समझाता हूँ कि कैसे प्रयोग करते हैं इन अल्गोरिद्म्स का, मैं ऐसा एक उदाहरण के साथ करूँगा. मान लेते हैं कि आप के पास एक प्रॉब्लम है दो पेरामीटर्स इकुअल्ज़ थीटा ज़ीरो और थीटा वन. और मान लेते हैं कि आपका कॉस्ट फ़ंक्शन है जे ऑफ़ थीटा इकुअल्ज़ थीटा वन माइनस फ़ाइव स्क्वेर्ड, प्लस थीटा टू माइनस फ़ाइव स्क्वेर्ड. तो इस कॉस्ट फ़ंक्शन के साथ. आप जानते है वैल्यू थीटा 1 और थीटा 2 की. अगर आप न्यूनतम करना चाहते हैं जे ऑफ़ थीटा को एज़ ए फ़ंक्शन ऑफ थीटा. वैल्यू जो इसे न्यूनतम करती है वह होगी थीटा 1 इकुअल्ज़ 5, थीटा 2 इकुअल्ज़ पाँच. अब, फिर से, मैं जानता हूँ कि आप में से कुछ दूसरों से ज़्यादा कैल्क्युलुस जानते हैं, लेकिन डेरिवेटिव कॉस्ट फ़ंक्शन जे का आता है ये दो इक्स्प्रेशंज़. मैंने कैल्क्युलुस किया है. इसलिए अगर आप अप्लाई करना चाहते हैं एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म में से कोई एक कॉस्ट फ़ंक्शन जे को मिनिमाईज़ करने के लिए. तो, आप जानते हैं, अगर हमें नहीं पता कि न्यूनतम वैल्यू 5,5 पर है, लेकिन अगर आप चाहते हैं लेना कॉस्ट फ़ंक्शन को न्यूनतम जानना नूमेरिक्ली प्रयोग करके कुछ ऐसा जैसे ग्रेडीयंट डिसेंट लेकिन प्रेफर करते हुए अधिक एड्वान्सड ग्रेडीयंट डिसेंट के मुक़ाबले, क्या करेंगे आप कि इम्प्लमेंट करें एक ओकटेव फ़ंक्शन इस तरह, तो हम इम्प्लमेंट करते हैं एक कॉस्ट फ़ंक्शन, कॉस्ट फ़ंक्शन थीटा, फ़ंक्शन ऐसे, और यह करता है कि यह रिटर्न करता है दो अरगुमेंट्स, पहली जे-वैल, है ऐसे जैसे हम कम्प्यूट करेंगे कॉस्ट फ़ंक्शन जे. और यह बताता है जे-वैल बराबर है, आप जानते है, थीटा वन माइनस फ़ाइव स्क्वेर्ड, प्लस थीटा टू माइनस फ़ाइव स्क्वेर्ड. तो यह केवल कम्प्यूट कर रहा है इस कॉस्ट फ़ंक्शन को यहाँ. और दूसरा आर्ग्युमेंट जो यह फ़ंक्शन रिटर्न करता है वह है ग्रेडीयंट. तो ग्रेडीयंट होगा एक दो बाई एक वेक्टर, और दो एलिमेंटस ग्रेडीयंट वेक्टर के कोरेस्पोंड करते हैं दो पार्शल डेरिवेटिव टर्म्ज़ से यहाँ पर. इस कॉस्ट फ़ंक्शन को इम्प्लमेंट करने के बाद, आप, आप तब कॉल कर सकते हैं एडवांस्ड ऑप्टिमायज़ेशन फ़ंक्शन जिसे कहते हैं एफमिनअंक - जिसका मतलब है फ़ंक्शन मिनीमाईजेशन अनकन्स्ट्रेंड इन ओकटेव - और जैसे उसे कॉल करते हैं वह इस प्रकार है. आप कुछ ऑप्शंज़ सेट करते हैं. यह एक ऑप्शंज़ डेटा स्ट्रक्चर की तरह है जो स्टोर करता है ऑप्शंज़ को जो आप चाहते हैं॰ तो ग्रैंट अप ऑन, यह सेट करता है ग्रेडीयंट अब्जेक्टिव पैरामीटर को ऑन पर॰ इसका सिर्फ मतलब है कि आप वाक़ई में देने वाले है एक ग्रेडीयंट इस अल्गोरिद्म को. मैं सेट करने जा रहा हूँ अधिकतम संख्या आइटरेशंस की, मान लीजिए, एक सौ. हम देंगे इसे इनिशियल गैस्स थीटा के लिए. यह एक 2 बाई 1 वेक्टर है. और फिर यह कमांड कॉल करती है एफमिनअंक को. यह @ चिन्ह देता है पोईंटर कॉस्ट फ़ंक्शन को जो हमने वहाँ ऊपर परिभाषित किया था. और अगर आप इसे कॉल करते हैं, यह कम्प्यूट करेगा, आप जानते हैं, प्रयोग करेगा अधिक एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म में से कोई एक. और अगर आप सोचना चाहते हैं इसे ग्रेडीयंट डिसेंट जैसा ही. लेकिन अपने आप चुनता है लर्निंग रेट अल्फ़ा आपके लिए ताकि आपको वह न करना पड़े अपने आप, लेकिन तब यह कोशिश करेगा प्रयोग करने की इस प्रकार के एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म्स. जैसे ग्रेडीयंट डिसेंट स्टेरॉड्ज़ पर. ढूँढने के लिए थीटा की ओप्टिमल वैल्यू आपके लिए. चलिए मैं आपको वास्तव में दिखाता हूँ यह कैसा दिखता है ओकटेव में. तो मैंने लिखा है यह कॉस्ट फ़ंक्शन थीटा फ़ंक्शन का बिलकुल वैसे जैसे पिछली लाइन में था. यह कम्प्यूट करता है जे-वैल जो कॉस्ट फ़ंक्शन है. और यह कम्प्यूट करता है ग्रेडीयंट जिसमें दो एलिमेंट हैं पार्शल डेरिवेटिव कॉस्ट फ़ंक्शन के जो हैं संदर्भ में, आप जानते हैं, दो पेरामिटर्स के, थीटा वन और थीटा टू. अब चलिए जाते हैं मेरी ओकटेव विंडो पर. मैं वे कमांड्ज़ टाइप करता हूँ जो अभी मेरे पास थीं. तो, ऑप्शंज़ इकूअल्ज़ ओप्टिमसेट. यह है नोटेशन सेट करने के लिए मेरे पेरमिटर्स मेरी ऑप्शंज़ पर, मेरे ऑप्टिमायज़ेशन अल्गोरिद्म के लिए. ग्रैंट आप्शन ऑन, मैक्सआइटर , 100 तो इसका मतलब है 100 आइटरेशंस, और मैं देने जा रहा हूँ ग्रेडीयंट मेरे अल्गोरिद्म को. मान लेते हैं कि ईनिशीयल थीटा बराबर है ज़ीरोज़, दो बाई एक. तो वह मेरा शुरू का गैस्स है थीटा के लिए. और अब मेरे पास है थीटा का फ़ंक्शन वैल एग्ज़िट फ़्लैग इकुअल्ज़ एफमिनअंक कन्स्ट्रेंट. एक पोईंटर कॉस्ट फ़ंक्शन को. और देता हूँ मेरा ईनिशीयल ग़ैस्स. और ऑप्शंज़ भी वैसे ही. और यदि मैं एंटर बटन दबाता हूँ यह रन करेगा ऑप्टिमायज़ेशन अल्गोरिद्म . और यह काफ़ी जल्दी रिटर्न करता है. यह हास्यमय फ़ॉर्मैटिंग है वह इसलिए क्योंकि मेरी लाइन, आप जानते हैं, मेरा कोड रैप अराउंड / दोहरा हो गया. अतः, यह हास्यमय चीज़ केवल इसलिए है क्योंकि मेरी कमांड लाइन दोहरी हो गई थी. परंतु यह क्या कहता है कि यह नूमेरिक्ली रेंडर / बनाता है, आप जानते हैं, सोचें इसे ग्रेडीयंट डिसेंट की तरह स्टेरॉड्ज़ पर, उन्हें मिली ओप्टिमल वैल्यू एक थीटा की थीटा 1 बराबर है 5, थीटा 2 बराबर है पाँच, बिलकुल वैसा जैसा हम उम्मीद कर रहे थे. फ़ंक्शन की वैल्यू ओप्टिमम पर है दर असल 10 की पावर माइनस 30. तो वह वास्तव में शून्य है, जिसकी भी हम उम्मीद कर रहे थे. और एग्ज़िट फ़्लैग है 1, और यह बताता है कि इसका कन्वर्जेन्स स्टेटस क्या है. और अगर आप चाहें तो आप कर सकते हैं सहायता एफमिनअंक की डॉक्युमेंटेशन पढ़ने में कि कैसे मतलब निकालना है एग्ज़िट फ़्लैग का. लेकिन एग्ज़िट फ़्लैग आपको  करने देता है वेरिफ़ाई / सुनिश्चित कि यह अल्गोरिद्म कन्वर्ज हुआ है या नहीं॰ तो ऐसे आप रन करते हैं ये अल्गोरिद्म्स ओकटेव में. मुझे बताना चाहिए, वैसे तो, कि ओकटेव इम्प्लमेंटेशन के लिए, यह वैल्यू थीटा की, आपका पेरामिटर वेक्टर थीटा का, होना चाहिए आरडी में जहाँ डी बड़ा है या बराबर है 2 के. तो यदि थीटा सिर्फ़ रियल नम्बर है. अत:, यदि यह नहीं है कम से कम दो डिमेन्शन का वेक्टर या कोई दो डिमेन्शन से बड़ा वेक्टर, यह एफमिनअंक शायद काम न करे, इसलिए और यदि आपके पास है एक एक डिमेन्शन का फ़ंक्शन जो आप प्रयोग करते हैं ऑप्टिमायज़ करने के लिए, आप देख सकते हैं ओकटेव डॉक्युमेंटेशन में एफमिनअंक की अधिक जानकारी के लिए. तो इस प्रकार हम ऑप्टिमायज़ करते हैं हमारा आज़माइश का उदाहरण है जो है सरल तुरंत ड्राइविंग कॉस्ट फ़ंक्शन. हालाँकि, हम इसे अप्लाई करते है लजिस्टिक रेग्रेशन के लिए. लजिस्टिक रिग्रेशन में हमारे पास है एक पेरामिटर वेक्टर थीटा, और मैं प्रयोग करूँगा एक मिली जुली ओकटेव की नोटेशन तथा एक प्रकार से गणित की नोटेशन. लेकिन मैं आशा करता हूँ कि यह व्याख्या समझ आएगी, लेकिन हमारा पेरामिटर वेक्टर थीटा बना है इन पेरामिटर्स थीटा 0 से थीटा एन तक क्योँकि ऑक्टेव के इंडेक्सेस, वेक्टर्स प्रयोग करते हैं इन्डेक्सेस 1 से, आप जानते हैं, थीटा 0 वास्तव में लिखा जाता है थीटा 1 ऑक्टेव में, थीटा 1  लिखा जाएगा थीटा 2  की तरह ऑक्टेव में और थीटा एन लिखा जाएगा थीटा एन प्लस 1, सही है? और वह इसलिए क्योँकि ऑक्टेव के इन्डेक्सेस वेक्टर्स में शुरू होते हैं इंडेक्स 1 से बजाय इंडेक्स 0 से. तो हमें क्या चाहिए करना कि लिखें एक कॉस्ट फंक्शन जो कैप्चर करता है कॉस्ट फंक्शन लॉजिस्टिक रिग्रेशन के लिए. वस्तुत:, कॉस्ट फंक्शन को रिटर्न करना चाहिए जे -वैल, जो है, आप जानते हैं, जे- वैल ऐसा जो आपको चाहिए कुछ कोड थीटा के जे को कम्प्यूट करने के लिए और हमें इसे देना पड़ेगा ग्रेडिएंट भी. अत:, ग्रेडिएंट 1 होगा कुछ कोड कंप्यूट करने के लिए पार्शियल डेरिवेटिव इन रेस्पेक्ट टू थीटा 0, अगला पार्शियल डेरिवेटिव रेस्पेक्ट टू थीटा 1 और इसी प्रकार आगे  भी. एक बार फिर, यह है ग्रेडिएंट 1, ग्रेडिएंट 2, और इसी प्रकार आगे, बजाय ग्रेडिएंट 0, ग्रेडिएंट 1, क्योँकि ऑक्टेव के इन्डेक्सेस वेक्टर्स में शुरू होते हैं एक से बजाय जीरो के. लेकिन मूल सिद्धांत मैं आशा करता हूँ जो आपको इस स्लाइड से लेना चाहिए वह है, आपको क्या करने की आवश्यकता है, कि एक फंक्शन लिखें जो रिटर्न करता है कॉस्ट फंक्शन और रिटर्न करता है ग्रेडिएंट. और इसलिए यह लॉजिस्टिक रिग्रेशन में अप्लाई करने के लिए या यहाँ तक कि लीनियर रिग्रेशन को भी, यदि आप प्रयोग करना चाहते हैं ये ऑप्टिमाइजेशन अल्गोरिद्म्स लीनियर रिग्रेशन के लिए आपको क्या करना है कि प्लग इन करना है उचित कोड कंप्यूट करने के लिए ये चीजें यहाँ पर. तो, अब आप जानते हैं कि कैसे प्रयोग करने हैं ये एडवांस्ड ऑप्टिमाइजेशन क्योँकि, प्रयोग करने के लिए ये अल्गोरिद्म्स, आप प्रयोग कर रहे हैं एक प्रगतिशील ऑप्टिमाइजेशन लाइब्रेरी, यह बनाता है केवल थोड़ा सा ज्यादा अपारदर्शक और इसलिए सिर्फ थोड़ा ज्यादा कठिन डिबग करना. लेकिन क्योँकि ये अल्गोरिद्म्स प्राय: काफी तेज रन करते हैं ग्रेडिएंट डिसेंट की तुलना में, प्राय: विशिष्ट रूप से जब जब मेरे पास एक बड़ी मशीन लर्निंग प्रॉब्लम होती है, मैं प्रयोग करता हूँ ये अल्गोरिद्म्स  बजाय ग्रेडिएंट डिसेंट प्रयोग करने के. और इन सुझावोँ के साथ, उम्मीद है आप कर पाएंगे लॉजिस्टिक रिग्रेशन और लीनियर रिग्रेशन भी बड़ी प्रोब्लेम्स पर. तो यह है एडवांस्ड ऑप्टिमाइजेशन के सिद्धांत. और अगले और अंतिम विडियो में लॉजिस्टिक रिग्रेशन पर मैं आपको बताना चाहूंगा कि कैसे ले कर जाना है लॉजिस्टिक रिग्रेशन को जो आप पहले से जानते हैं और उसे काम कराना है मल्टी-क्लास क्लासिफिकेशन प्रॉब्लम पर.