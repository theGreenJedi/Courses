पिछले वीडियो में, हमने बात की थी कि कैसे इस्तेमाल करते हैं बैक प्रॉपगेशन का कम्प्यूट करने के लिए डेरिवेटिव्स आपके कोस्ट फंक्शन के. इस वीडियो में, मैं चाहता हूँ जल्दी से आपको देना एक इम्प्लमेंटेशन की विस्तृत जानकारी कि केसे अनरोल करने हैं आपके पेरमिटर्स मेट्रिसीज़ से वेक्टर्स में, जो हमें चाहिए इस्तेमाल करने के लिए एडवांसड ऑप्टिमायज़ेशन रूटीन्स. ठोस रूप में, मान लो आपने इम्प्लमेंट किया है एक कॉस्ट फ़ंक्शन जो लेता है यह इनपुट, आप जानते हैं, पेरमिटर्स थीटा और देता है कॉस्ट फ़ंक्शन और देता है डेरिवेटिव्स. तब आप दे सकते हैं इसे एक एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म को fminunc के द्वारा और fminunc ही नहीं है सिर्फ़ एक वैसे तो. दूसरे एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म्स भी हैं. लेकिन वे सब क्या करते हैं कि लेते हैं वे इनपुट पास करते हैं उन्हें कॉस्ट फ़ंक्शन को, और थीटा की कुछ प्रारंभिक वैल्यूज़. और दोनो, और ये रूटीन्स मान कर चलती हैं कि थीटा और थीटा की प्रारंभिक वैल्यू, कि ये हैं पेरामिटर वेक्टर, शायद Rn या Rn + 1. लेकिन ये हैं वेक्टर्स और यह भी मान लेता हैं, आप जानते हैं, आपका कॉस्ट फ़ंक्शन देगा एक दूसरी रिटर्न वैल्यू यह ग्रेडीयंट जो भी है Rn और Rn + 1. तो एक वेक्टर ही. यह सही काम कर रहा था जब हम इस्तेमाल कर रहे थे लॉजिस्टिक रेग्रेशन लेकिन अब जब हम इस्तेमाल कर रहे हैं एक न्यूरल नेटवर्क हमारे पेरमिटर्स हैं अब वेक्टर्स नहीं, बल्कि वे हैं ये मेट्रिसीज़ जहाँ एक पूरे न्यूरल नेटवर्क के लिए हमारे पास होंगी पेरमिटर मेट्रिसीज़ थीटा 1, थीटा 2, थीटा 3 जो हम रेप्रेज़ेंट करेंगे ओकटेव में इन मेट्रिसीज़ थीटा 1, थीटा 2, थीटा 3 की तरह. और इसी प्रकार, ये ग्रेडीयंट जो हम उम्मीद कर रहे थे मिलेंगी. ठीक है, पिछले वीडियो में, हमने दिखाया था कैसे कम्प्यूट करते हैं ये ग्रेडीयंट मेट्रिसीज़, जो थी कैपिटल D1, कैपिटल डी2, कैपिटल D3, जो हम शायद रेप्रेज़ेंट करें ओकटेव में मेट्रिसीज़ D1, D2, D3 की तरह. इस वीडियो में मैं चाहता हूँ जल्दी से आपको बताना सुझाव के बारे में कि कैसे लेनी हैं ये मेट्रिसीज़ और अनरोल करना है उन्हें वेक्टर्स में. ताकि वे आ जाएँ एक उपयुक्त फ़ॉर्मैट में करने के लिए उन्हें पास थीटा जैसे यहाँ पाने के लिए एक ग्रेडीयंट वहाँ. ठोस रूप में, मान लो हमारे है एक न्यूरल नेटवर्क एक इनपुट लेयर का जिसमें दस यूनिट्स हैं, हिडन लेयर का जिसमें दस यूनिट्स हैं और एक आउट्पुट लेयर जिसमें केवल एक यूनिट्स है, तो s1 है संख्या यूनिट्स की लेयर एक में और s2 है संख्या यूनिट्स की लेयर दो में, और s3 है एक संख्या यूनिट्स की लेयर तीन में. इस केस में, डिमेन्शन आपकी मेट्रिसीज़ थीटा और D की होंगी दी हुई इन इक्स्प्रेशन्स से. उदाहरण के लिए, थीटा एक होगा एक 10 बाई 11 मेट्रिक्स और इसी तरह आगे. तो अगर आप चाहते हैं कन्वर्ट करना इन मेट्रिसीज़ को वेक्टर्स में, आप क्या कर सकते हैं कि लें आपका थीटा 1, थीटा 2, थीटा 3, और लिखें यह हिस्सा कोड का और यह लेगा सारे एलिमेंट्स आपके तीन थीटा मेट्रिसीज़ के और लेगा सारे एलिमेंट्स थीटा एक के, सारे एलिमेंट्स थीटा 2 के, सारे एलिमेंट्स थीटा 3 के, और अनरोल करेगा उन्हें और रखेगा सारे एलिमेंट्स एक बड़े लम्बे वेक्टर में. जो है theetaVec और इसी प्रकार दूसरी कमांड लेगी सारी आपकी D मेट्रिसीज़ और अनरोल करेगी उन्हें एक बड़े लंबे वेक्टर में और कहेंगे उन्हें DVec. और अंत में यदि आप वापिस जाना चाहते हैं वेक्टर रेप्रेज़ेंटेशन से मेट्रिक्स रेप्रेज़ेंटेशन पर, आप क्या करते हैं लेते हैं वापिस थीटा एक और लेते है theetaVec और निकाल लेते हैं पहले 110 एलिमेंट्स. तो थीटा 1 में है 110 एलिमेंट्स क्योंकि यह है एक 10 बाई 11 मेट्रिक्स अत: निकाल लेते हैं पहले 110 एलिमेंट्स और फिर आप कर सकते हैं इस्तेमाल reshape कमांड का बदलने के लिए वापिस उन्हें थीटा 1 में. और इसी प्रकार, पाने के लिए वापिस थीटा 2 आप निकालते हैं अगले 110 एलिमेंट्स और रीशेप करते हैं उसे. और थीटा 3 के लिए, आप निकालते है अंतिम ग्यारह एलिमेंट्स और रन करते हैं reshape पाने के लिए थीटा 3. यहाँ है एक त्वरित ऑक्टेव डेमो उस प्रक्रिया का. तो इस उदाहरण के लिए चलो सेट करते हैं थीटा 1 बराबर एक के इस 10 बाई 11 मेट्रिक्स में, तो यह है मेट्रिक्स सारे एक की. और सिर्फ़ इसे आसान बनाने के लिए, चलो सेट करते हैं थीटा 2 को 2 गुणा एक, 10 बाई 11 और चलो सेट करते हैं थीटा 3 बराबर 3 गुणा 1 एक 1 बाई 11 का वेक्टर. तो यह है 3 भिन्न मेट्रिसीज़: थीटा 1, थीटा 2, थीटा 3. हम चाहते हैं रखना ये सब एक वेक्टर के रूप में. ThetaVec बराबर है थीटा 1; थीटा 2 थीटा 3. ठीक है, वह एक कॉलन है मध्य में और इस तरह और अब thetavec होगा एक बहुत लम्बा वेक्टर. वह है 231 एलिमेंट्स. अगर मैं इसे डिस्प्ले करता हूँ, मुझे मिलता है कि यह बहुत लम्बा वेक्टर जिसमें सारे एलिमेंट्स हैं पहली मेट्रिक्स के, सारे एलिमेंट्स हैं दूसरी मैट्रिक्स के, फिर सारे एलिमेंट्स हैं तीसरी मेट्रिक्स के. और यदि मैं वापिस प्राप्त करना चाहता हूँ मेरी मूल मेट्रिसीज़, मैं कर सकता हूँ रीशेप thetaVec को. चलो निकाल लेते हैं पहले 110 एलिमेंट्स और रीशेप करते हैं उन्हें एक 10 बाई 11 मेट्रिक्स में. यह देता है मुझे वापिस थीटा 1. और अगर मैं फिर निकाल लेता हूँ अगले 110 एलिमेंट्स. तो वे है इंडेक्स 111 से 220 तक. मुझे मिल जाते हैं मेरे सारे 2. और यदि मैं जाता हूँ 221 से ऊपर आखिरी एलिमेंट तक, जो है एलिमेंट 231, और रीशेप करता हूँ उसे 1 बाई 11, मुझे मिलता है थीटा 3. इस प्रक्रिया को वास्तव में ठोस बनाने के लिए, यहाँ है कैसे हम इस्तेमाल करते हैं अनरोलिंग का सुझाव इम्प्लमेंट करने के लिए हमारा लर्निंग अल्गोरिद्म. मान लो आपके पास है कुछ प्रारंभिक वैल्यूज़ पेरमिटर्स थीटा 1, थीटा 2, थीटा 3 की. क्या करेंगे हम कि लेंगे इन्हें और अन रोल करेंगे उन्हें एक लम्बे वेक्टर में हम कॉल करेंगे प्रारम्भिक थीटा को पास करेंगे इसे fminunc में प्रारम्भिक सेटिंग जैसे पेरमिटर्स थीटा की. एक और काम जो हमें करने कि आवश्यकता है इम्प्लमेंट करने के लिए इस कॉस्ट फ़ंक्शन को. यहाँ है मेरा इम्प्लमेंटेशन कॉस्ट फ़ंक्शन का. कॉस्ट फ़ंक्शन देगा हमें इनपुट, thetaVec, जो होंगे सारे मेरे पेरामिटर्स वेक्टर थीटा जो हैं फ़ॉर्म में जो अन रोल किए हुए हैं एक वेक्टर में. तो पहली चीज़ मैं करूँगा कि मैं प्रयोग करूँगा thetaVec और मैं करूँगा प्रयोग रीशेप फ़ंक्शन्स का. तो मैं निकालूँगा एलिमेंट्स thetaVec से और इस्तेमाल करूँगा reshape वापिस पाने के लिए मेरी प्रारम्भिक पेरमिटर मेट्रिसीज़, थीटा 1, थीटा 2, थीटा 3. तो ये होंगी मेट्रिसीज़ जो मुझे मिलेंगी. और इसलिए वह मुझे देता है एक अधिक सुविधाजनक फ़ॉर्म जिसमें इस्तेमाल की जा सकती हैं ये मेट्रिसीज़ ताकि मैं रन कर सकूँ फ़ॉर्वर्ड प्रॉपगेशन और बैक प्रॉपगेशन कम्प्यूट करने के लिए मेरे डेरिवेटिव्स, और कम्प्यूट करने के लिए मेरा कॉस्ट फ़ंक्शन जे ऑफ़ थीटा. और अंत में, मैं तब ले सकता हूँ मेरे डेरिवेटिव्स और अनरोल करता हूँ उन्हें, रखते हुए एलिमेंट्स को समान क्रम में जिसमें मैंने किया था जब मैंने अनरोल किए थे मेरे थीटा. लेकिन मैं अनरोल करूँगा D1, D2, D3, पाने के लिए gradientVec जो अब मेरा कॉस्ट फ़ंक्शन दे सकता है. यह दे सकता है एक वेक्टर इन डेरिवेटिव्स का. तो, उम्मीद है कि, अब आपको होगी एक बेहतर समझ कैसे कनवर्ट करना है आगे और पीछे आपस में मेट्रिक्स रेप्रेज़ेंटेशन पेरमिटर्स बनाम वेक्टर रेप्रेज़ेंटेशन पेरमिटर्स की. लाभ मैट्रिक्स रेप्रेज़ेंटेशन का है कि जब पेरमिटर्स स्टोर किए हैं मेट्रिसीज़ जैसे यह ज़्यादा सुविधाजनक है जब कर रहे हैं फ़ॉर्वर्ड प्रॉपगेशन और बैक प्रॉपगेशन और यह ज़्यादा आसान है जब आपके पेरमिटर्स स्टोर किए हैं मेट्रिसीज़ के रुप में, लाभ लेने के लिए एक प्रकार से, वेक्टराइज्ड इम्प्लमेंटेशन्स का. जबकि इसके विपरीत लाभ लेने के लिए वेक्टर रेप्रेज़ेंटेशन का, जब आपके पास है thetaVec या Dvec है कि जब आप इस्तेमाल कर रहे हैं एडवांसड ऑप्टिमायज़ेशन अल्गोरिद्म्स, वे अल्गोरिद्म्स की प्रवृति होती है मान कर चलने की कि आपके पास हैं सारे आपके पेरमिटर्स अनरोल किए हुए एक बड़े लम्बे वेक्टर में. और इसके साथ जो हमने अभी किया, उम्मीद है अब आप शीघ्रता से कन्वर्ट कर सकते हैं दोनो में जैसी ज़रूरत है.