在之前几个视频里，我们讨论了如何进行前向传播 以及后向传播，从而计算导数 但，后向传播有很多细节， 这些细节有点复杂 有一个不幸的消息是， 它们有很多细节会导致一些BUG 如果你用梯度下降来计算， 你会发现表面上它可以工作 实际上， J 虽然每次迭代都在下降 但是可能， 仍然你的代码有很多BUG 所以，表面上关于theta的函数J在减小 但是你可能最后得到的结果 实际上有很大的误差 你这时候可能知道，有一些小的BUG导致 这种不好的算法性能表现 所以，怎么办呢 有一个想法叫梯度检验 Gradient Checking 它能减少这种错误的概率 就我个人而言，每次我使用后向传播 我都会[]用这种方法 即使是其他比较复杂的模型，我都会做这种检查 如果你这么做，你会对你的模型更有自信 这样，你会更加确信的模型是100%正确的 从我看到的情况，这种方法， 很大程度可以减少错误的可能性 在之前的视频里，我让你们相信 我给你们的公式是正确的， 我还让你们相信，这就是支付函数的梯度值 但，一旦你使用梯度检验， 也就是我们这个视频的主题，你会证明你的代码 实际上就是梯度函数 所以，这就是我们的想法，来看一个例子 假设我们有一个关于theta的函数H 我现在有它的一个值，假设是实数 我们说，我想要预测它的倒数， 所以倒数是等于这里的斜度 现在我用这种方法来接近， 我们不采用数值的计算倒数， 这里我用epsilon， 同样也有一个减去epsilon的值 然后把他们链接起来 我将得到一条直线 我用这个红色线来近似我的导数 恩，真正的斜率是蓝色的线。 所以，你可以看到这是一个很好的近似。 数学上，这里的红线垂直高度 除以这个水平宽度，就是我们的斜率 所以，这个点，就是J() 这个点，(theta减掉epsilon) 我们有一个垂直的差值()减去 这两个点的差值，以及水平宽度2epsilon 所以我们可以近似来表示 这是近似的值， 它等于J加上epsilon减去J减去epsilon对应的函数值，除以2倍的epsilon 通常， 这个epsilon非常小，可能就是10的-4次方 而误差值往往很大， 所以近似效果很好。实际上 如果让epsilon无穷小，这就是导数的定义 恩，它就是导数。 所以， 但我们不希望epsilon太小，否则会有计算上的问题 一般来说在10的-4次方比较合适 通常，你可能见到这个类似的公式 恩。 所以，右边的叫做单边导数 左边的叫做双边导数 后者的精确度更高， 当然，一般我们用后者 所以，具体来说，当你用octave， 你计算近似梯度时候， 我们用的是这个公式。 恩。。就是红色标注的双边导数近似公式，除以的是2倍 所以，我们有一个近似的值 在这个例子，它看起来非常好地近似我们的结果 在之前的PPT里 我们考虑了theta是一个向量 现在，我们来看一般的情况 我们说theta是一个矩阵 我们有一个舒展的参数版本， 所以，这里theta是从1到n的向量 我们， 可以用近似的方式来进行计算 可以看到，我们列出各个近似的求导公式 theta 1套前面的公式是这样， 如此种种。 恩。。 这里都是偏导数。 只改变theta 1的值，其他的值固定 分母一样，还是2 epsilon 我们现在可以得到我们想要的近似结果 恩， 所以这个公式组给出了近似的方法 对于任意一个theta我们都有 完整地，你可以这样应用。 我们用octave来数值计算， 比如， 对于i=1:n，其中n是我们参数的个数 一般我们习惯是舒展的向量而不是矩阵 所以theta是长长的参数清单 这里设置thetaPlus = theta 之后增加(i)项epsilon 恩，这就等于我们 thetaPlus(i)， theta1, theta2如此种种 thetal ，一直到N 所以，这是thetaPlus的含义 类似的 我们现在也有l 减去epsilon 最后你会使用这个gradApprox(i) 并且能够给你一个偏微分单数 对于i 这就是我们使用的方法 我们可以用一个循环来写 来检验这个近似计算的结果是不是等于我们的计算结果 也就是反向传播算法计算的梯度 Dvec就是我们得到的导数 好的， 反向传播是一个非常高效的算法， 针对所有的参数 我们通常做的是数值计算的结果 也就是刚才所做的 确信这是相等的， 应该说非常接近 所以DVec，我们从反向传播得到， 如果得到同一个结果 或者相近的结果，只相差一些小数位 我们很确信这个反向传播的算法是正确的 如果我代入梯度计算 一些高级的算法 我们会更加确信我们的导数计算是正确的 因此，我们的代码不仅正确，而且在优化上性能很好 最后，我想总结一下 告诉你梯度检验的相关内容 这是我通常做的事情 首先，使用反向传播来计算，它是很好的算法 这里就是前面介绍的流程 这里的参数我们把矩阵展开成向量 然后 我们使用数值的梯度来检验 这是刚刚介绍的内容 我们要确信这两个方法算出来结果一致 你知道，就差一点 最后，也是最重要的步骤 就是在你开始学习之前， 一定要关掉我们的梯度检验， 也就是我们讨论的数值计算方法 原因是这个计算过程， 实际上代价更高，复杂度也很高 这不是一个很好的计算导数的方法 相反，我们前面讨论的反向传播算法 很早以前介绍的内容 你知道D1 D2 D3对于DVEC 相对来说非常高效。 恩 所以，一旦你检验证明你的算法没有错误 就要把梯度检验关掉 所以，你一定要关掉 在你开始迭代训练之前 对于其他很多优化算法也一样 为了训练你的分类器 具体来说，如果你一定要用数值方法 来计算梯度， 那么你的算法会非常慢。 在你的支付函数的循环过程当中 因为，正如前面所说 我们再重复一下...它很慢 记得，我们这里计算(4)(3)(2)等等 这是我们的反向传播算法 它快得多 所以，再说一遍...检验完了后向传播没有问题 关掉梯度检验，重要的事情说三遍 当你在训练你的算法的时候， 所以数值的计算， 这是你的检验方法而已。 对我而言，每当我要使用梯度算法，比如后向传播 我都会用梯度检验一下这个算法是否正确 这会让我更加自信我的算法是正确的。