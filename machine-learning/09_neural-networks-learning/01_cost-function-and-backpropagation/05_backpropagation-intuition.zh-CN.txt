在之前的视频里，我们介绍了反向传播算法 对许多人来说， 第一次看到它的印象是，这是一个非常复杂的算法 并且这里有很多步骤，人们很难搞清楚是怎么统一起来 看起来像是一个复杂的黑箱 如果你也是这么觉得，其实很正常 反向传播，很大程度上数学步骤比较复杂 并不是一个简单的算法 比起线性回归和逻辑回归而言。 我实际上使用反向传播算法许多年， 也很成功。 但即使是今天，有时候我还是感觉不太好把握， 或者忽然觉得迷茫。 因此，对于即将做编程的同学， 你们不用担心，我们会有数学的具体步骤， 它将帮助你来一步一步完成。 所以，你将能够自主独立实现。 在这个视频，我要做的， 是再一步一步介绍这个算法，让你更有体会。 这些机械的步骤，将使你信服， 让你认为这是一个非常合理的算法。 如果这个视频之后， 你还是觉得这个算法非常复杂， 其实也没有太大关系。 正如之前所说，对我而言有时候也很难。 但，希望这个视频可以有所帮助。 为了更好地理解反向传播算法， 我们来看看正向传播 这个神经网络有两个输入层单元，当然不算上偏置单元 两个隐层单元，有两层 还有一个输出单元 当然，我们都不算偏置单元 为了更好地展示前向传播 我这次要用另外一种画法 特别地，我要把每个神经元 画的更扁平一些，所以我可以在里面写字 当进行前向传播算法的时候，我们可能有一些特别的例子 比如，xi，yi 我们将把它输入到这个网络当中 所以，xi1和xi2将是我们对输入层的设置 当我们进入第一个隐层， 我们会计算z(2)1和z(2)2 那么，这些是我们要的值 然后我们来用冲击函数计算 它作用与z值 这里是激励值 所以我们有a(2)1和a(2)2 之后我们把这些值赋予给z(3)1 然后使用sigmoid函数 我们会得到a(3)1 类似的，我们一直得到z(4)1 再次计算， 我们有a(4)1，这是最后的结果 我们擦掉这些箭头，来得到更多空间 如果你仔细看我们的计算过程， 我们可以说， 我们要加上这个权重 (2)1 0，这里的编号不重要 这个方向，我用红色高亮 是theta(2)11以及权重 这里用青色标注theta(2)12 所以，z(3)1是 z(3)1等于这个值 所以我们有(2)10x1 然后加上红色标注的权值 得到theta(2)11乘以a(2)1 最后我们再用青色来乘 也就是加上theta(2)12乘以a(2)1 那么这就是前向传播 这我们之前看到过 而反向传播做的很类似 除了这些计算从左到右， 现在是从右到左 同时计算流程相似 我用两页PPT来描述这个过程 首先来看其支付函数 这是只有一个输出单元时候的支付函数 如果有多个 那就需要编号并且求和 如果只有一个，用这个函数就行 我们在一个例子里做前向和后向传播 来关注一个例子x(i)和y(i) 并且来看输出值 所以y(i)是一个实数 我们现在不考虑标准化，所以lambda为0 所以最后一项去掉 如果你来看这个求和公式 你会发现，这个支付项 和我们的训练数据x(i)和y(i)有关 这由我们的表达式给出 所以，正如下述所写的 支付函数所做的和这个箭头相似 我们不看这个复杂的表达式 如果你考虑支付， 这里就是我们的插值 和之前逻辑回归很像， 我们用了Log 但，从直觉上来说， 这其实就是平方误差函数 所以cost(i)描述了 这个网络的表现，对于特定的结果i 那么到底这个计算结果和真实值y(i)多接近呢 我们来看反向传播在做什么 一个很有用的例子就是反向传播 计算了deltai下标j 这是我们的理解方法， 我们在l层得到单元j 正式一点说， 这个对于熟悉微积分的人来说更恰当 所以，这就是delta项 它就是一个偏微分，针对z,l,j 这是权重， 针对这些量的偏微分，所得到的支付函数 所以，具体来说， 这个h x输出值， 如果我们走进这个神经网络， 并且只稍微改变一下zl j值 那么这就会改变我们的输出 也会改变我们的支付函数 同样，还是针对那些微积分比较好的同学 如果你适应偏微分 这些就是对支付函数的偏微分， 针对中间变量 并且，他们衡量了我们要如果改变网络的权值 当然，这是为了影响我们的计算结果 所以，为了改变计算结果h(x) 以及对整个支付函数的影响 上下的这个偏微分的理解， 如果你不能理解 不要太担心 我们可以撇开它来谈 我们就来看看到底反向传播算法做了什么 首先，设置这个delta项 delta(4) 1正如y(i)我们对前向传播算法 和后向传播对训练数据i的做法一样。 这表达的是y(i)减去a(4)1 所以就是误差，对吧 这就是真实结果和 我们预测结果的误差，所以我们结算delta(4)1 接下来，我们来把这些值反向传播回去 我会马上解释， 这最后就是计算前向的结果 我们会得到delta(3)1 delta3(2) 然后，我们进一步往前， 得到delta(2)1和delta(2)2 现在 看起来就像是又重演前向传播 只不过我们现在反过来做了，这就是我之前所说的 我们来看看最后我们如何得到delta(2)2 所以我们得到delta(2)2 和前向传播类似， 这个权值，我用青色来表示 加入它是theta(2)12 然后，我用红色来高亮 这个我们说是theta(2) 22 如果，我们来看delta(2)2 如何计算。 结果，我们发现 我们就把这个值乘以它权值，并加上这个值乘以权值 所以，就是一个加权求和 权值是每一条边的强度 所以，我们来看delta(2)2 theta(2)12是delta(3)1 加上 我们红色标注的东西 theta(2)2乘以delta(3)2 所以，这个红色值乘以这个值 加上品红色的权值 恩， 另一个例子，我们来看这个值怎么求 如果得到呢 恩，一样的步骤 如果这个权值，我用绿色来描述 它等于delta(3)12 然后我们有delta(3)2将等于它的绿色权值 theta(3)12乘以delta(4)1 顺便一提，我只写隐层单元 忽略了偏置单元 这要看你如何定义算法 或者你如何应用 你也可能要用这些单元 这些偏置单元总是为1 所以他们就是1，我们不会改变他们 所以，要看你的应用思路 以及使用方法 我们计算完了这些值 我们扔掉它， 因为我们最后得到的不过是 计算导数的一个部分 希望这就可以给一个更好的直观体会 关于反向传播算法 如果仍然感觉很迷茫， 像是黑箱，在下一个视频 我会再把他们总结起来 但，这是一个很难讲解的算法 难以可视化 但， 幸运的是很多人都在成功使用它 如果你使用这个算法 它将是非常有效的，尽管它内部的机制很难可视化。