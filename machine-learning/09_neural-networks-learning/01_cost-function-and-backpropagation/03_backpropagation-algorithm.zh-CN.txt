在上一个视频里 我们讲解了 神经网络的代价函数 在这个视频里 让我们来说说 让代价函数最小化的算法 具体来说 我们将主要讲解反向传播算法 这个就是我们上一个视频里写好的 代价函数 我们要做的就是 设法找到参数 使得J(θ)取到最小值 为了使用梯度下降法或者 其他某种高级优化算法 我们需要做的就是 写好一个可以通过输入 参数 θ 然后计算 J(θ) 和这些 偏导数项的代码 记住 这些神经网络里 对应的参数 也就是 θ 上标 (l) 下标 ij 的参数 这些都是实数 所以这些都是我们需要计算的 偏导数项 为了计算代价函数 J(θ) 我们就是用上面这个公式 所以我们在本节视频里大部分时间 想要做的都是 重点关注 如何计算这些 偏导数项 我们从只有一个 训练样本的情况 开始说起 假设 我们整个训练集 只包含一个训练样本 也就是实数对 我这里不写成x(1) y(1) 就写成这样 把这一个训练样本记为 (x, y) 让我们粗看一遍 使用这一个训练样本 来计算的顺序 首先我们 应用前向传播方法来 计算一下在给定输入的时候 假设函数是否会真的输出结果 具体地说 这里的 a(1) 就是第一层的激励值 也就是输入层在的地方 所以我准备设定他为 然后我们来计算 z(2) 等于 θ(1) 乘以 a(1) 然后 a(2) 就等于 g(z(2)) 函数 其中g是一个S型激励函数 这就会计算出第一个 隐藏层的激励值 也就是神经网络的第二层 我们还增加这个偏差项 接下来我们再用2次 前向传播 来计算出 a(3) 和 最后的 a(4) 同样也就是假设函数 h(x) 的输出 所以这里我们实现了把前向传播 向量化 这使得我们可以计算 神经网络结构里的 每一个神经元的 激励值 接下来 为了计算导数项 我们将 采用一种叫做反向传播(Backpropagation)的算法 反向传播算法从直观上说 就是对每一个结点 我们计算这样一项 δ下标 j 上标(l) 这就用某种形式 代表了第 l 层的第 j 个结点的 误差 我们还记得 a 上标 (l) 下标 j 表示的是第 l 层第 j 个单元的 激励值 所以这个 δ 项 在某种程度上 就捕捉到了我们 在这个神经节点的激励值的误差 所以我们可能希望这个节点的 激励值稍微不一样 具体地讲 我们用 右边这个有四层 的神经网络结构做例子 所以这里大写 L 等于4 对于每一个输出单元 我们准备计算δ项 所以第四层的第j个单元的δ就等于 这个单元的激励值 减去训练样本里的 真实值0 所以这一项可以 同样可以写成 h(x) 下标 j 所以 δ 这一项就是 假设输出 和训练集y值 之间的差 这里 y 下标 j 就是 我们标记训练集里向量 的第j个元素的值 顺便说一下 如果你把 δ a 和 y 这三个 都看做向量 那么你可以同样这样写 向量化地实现 也就是 δ(4)等于 a(4) 减去 y 这里 每一个变量 也就是 δ(4) a(4) 和 y 都是一个向量 并且向量维数等于 输出单元的数目 所以现在我们计算出 网络结构的 误差项 δ(4) 我们下一步就是计算 网络中前面几层的误差项 δ 这个就是计算 δ(3) 的公式 δ(3) 等于 θ(3) 的转置乘以 δ(4) 然后这里的点乘 这是我们从 MATLAB 里知道的 对 y 元素的乘法操作 所以 θ(3) 转置乘以 δ(4) 这是一个向量 g'(z(3)) 同样也是一个向量 所以点乘就是 两个向量的元素间对应相乘 其中这一项 g'(z(3)) 其实是对激励函数 g 在输入值为 z(3) 的时候 所求的 导数 如果你掌握微积分的话 你可以试着自己解出来 然后可以简化得到我这里的结果 但是我只是从实际角度告诉你这是什么意思 你计算这个 g' 这个导数项其实是 a(3) 点乘 (1-a(3)) 这里a(3)是 激励向量 1是以1为元素的向量 a(3) 又是 一个对那一层的 激励向量 接下来你应用一个相似的公式 来计算 δ(2) 同样这里可以利用一个 相似的公式 只是在这里 是 a(2) 这里我并没有证明 但是如果你懂微积分的话 证明是完全可以做到的 那么这个表达式从数学上讲 就等于激励函数 g函数的偏导数 这里我用 g‘来表示 最后 就到这儿结束了 这里没有 δ(1) 项 因为 第一次对应输入层 那只是表示 我们在训练集观察到的 所以不会存在误差 这就是说 我们是不想改变这些值的 所以这个例子中我们的 δ 项就只有 第2层和第3层 反向传播法这个名字 源于我们从 输出层开始计算 δ项 然后我们返回到上一层 计算第三隐藏层的 δ项 接着我们 再往前一步来计算 δ(2) 所以说 我们是类似于把输出层的误差 反向传播给了第3层 然后是再传到第二层 这就是反向传播的意思 最后 这个推导过程是出奇的麻烦的 出奇的复杂 但是如果你按照 这样几个步骤计算 就有可能简单直接地完成 复杂的数学证明 如果你忽略标准化所产生的项 我们可以证明 我们要求的偏导数项 恰好就等于 激励函数和这些 δ 项 这里我们忽略了 λ 或者说 标准化项 λ 是等于 0 我们将在之后完善这一个 关于正则化项 所以到现在 我们通过 反向传播 计算这些δ项 可以非常快速的计算出 所有参数的 偏导数项 好了 现在讲了很多细节了 现在让我们把所有内容整合在一起 然后说说 如何实现反向传播算法 来计算关于这些参数的偏导数 当我们有 一个非常大的训练样本时 而不是像我们例子里这样的一个训练样本 我们是这样做的 假设我们有 m 个样本的训练集 正如此处所写 我要做的第一件事就是 固定这些 带下标 i j 的 Δ 这其实是 大写的希腊字母 δ 我们之前写的那个是小写 这个三角形是大写的 Δ 我们将对每一个i 和 j 对应的 Δ 等于0 实际上 这些大写 Δij 会被用来计算 偏导数项 就是 J(θ) 关于 θ 上标(l) 下标 i j 的 偏导数 所以 正如我们接下来看到的 这些 δ 会被作为累加项 慢慢地增加 以算出这些偏导数 接下来我们将遍历我们的训练集 我们这样写 写成 For i = 1 to m 对于第 i 个循环而言 我们将取训练样本 (x(i), y(i)) 我把1999年的值画在一列里 我们要做的第一件事是 设定a(1) 也就是 输入层的激励函数 设定它等于 x(i) x(i) 是我们第 i 个训练样本的 输入值 接下来我们运用正向传播 来计算第二层的激励值 然后是第三层 第四层 一直这样 到最后一层 L层 接下来 我们将用 我们这个样本的 输出值 y(i) 来计算这个输出值 所对应的误差项 δ(L) 所以 δ(L) 就是 假设输出减去 目标输出 接下来 我们将 运用反向传播算法 来计算 δ(L-1) δ(L-2) 一直这样直到 δ(2) 再强调一下 这里没有 δ(1) 因为我们不需要对输入层考虑误差项 最后我们将用 这些大写的 Δ 来累积我们在前面写好的 偏导数项 顺便说一下 如果你再看下这个表达式 你可以把它写成向量形式 具体地说 如果你把 δij 看作一个矩阵 i j代表矩阵中的位置 那么 如果 δ(L) 是一个矩阵 我们就可以写成 Δ(l) 等于 Δ(l) 加上 小写的 δ(l+1) 乘以 a(l) 的转置 这就是用向量化的形式 实现了对所有 i 和 j 的自动更新值 最后 执行这个 for 循环体之后 我们跳出这个 for 循环 然后计算下面这些式子 我们按照如下公式计算 大写 我们对于 j=0 和 j≠0 分两种情况讨论 在 j=0 的情况下 对应偏差项 所以当 j=0 的时候 这就是为什么 我们没有写额外的标准化项 最后 尽管严格的证明对于 你来说太复杂 你现在可以说明的是 一旦你计算出来了这些 这就正好是 代价函数对 每一个参数的偏导数 所以你可以把他们用在 梯度下降法 或者其他一种更高级的 优化算法上 这就是反向传播算法 以及你如何计算 神经网络代价函数的 偏导数 我知道这个里面 细节琐碎 步骤繁多 但是在后面的编程作业 和后续的视频里 我都会给你一个 清晰的总结 这样我们就可以把算法的所有细节 拼合到一起 这样 当你想运用反向传播算法 来计算你的神经网络的代价函数 关于这些参数的偏导数的时候 你就会清晰地知道 你要的是什么 【教育无边界字幕组】翻译:reanghect 校对/审核:所罗门捷列夫