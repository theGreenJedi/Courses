神经网络是当今 最强大的学习算法之一 在本节课视频 和后面几次课程中 我将开始讲述一种 在给定训练集下 为神经网络拟合参数的学习算法 正如我们讨论大多数 学习算法一样 我们准备从拟合神经网络参数的 代价函数开始讲起 我准备重点讲解 神经网络在分类问题 中的应用 假设我们有一个如左边所示的 神经网络结构 然后假设我们有一个 像这样的训练集 m个训练样本x(i) y(i) 我用大写字母 L 来表示 这个神经网络结构的总层数 所以 对于左边的网络结构 我们得到 L等于4 然后我准备用 sl表示 第L层的单元的数量 也就是神经元的数量 这其中不包括L层的偏差单元 比如说 我们得到s1 也就是输入层 是等于3的单元 s2在这个例子里等于5个单位 然后输出层s4 也就是sl 因为L本身等于4 在左边这个例子中输出层 有4个单位 我们将会讨论两种分类问题 第一种是二元分类 在这里y只能等于0或1 在这个例子中 我们有一个输出单元 上面这个神经网络的有四个输出单元 但是如果我们 用二元分类的话 我们就只能有一个输出结果 也就是计算出来的h(x) 神经网络的输出结果 h(x)就会是 一个实数 在这类问题里 输出单元的个数 sl L同样代表最后一层的序号 因为这就是我们 在这个网络结构中的层数 所以我们在输出层的单元数目 就将是1 在这类问题里 为了简化记法 我会把K设为1 这样你可以把K看作 输出层的 单元数目 我们要考虑的第二类分类问题 就是多类别的分类问题 也就是会有K个不同的类 比如说 如果我们有四类的话 我们就用这样的表达形式来代表y 在这类问题里 我们就会有K个输出单元 我们的假设输出 就是一个K维向量 输出单元的个数 就等于K 通常这类问题里 我们都有K大于 或等于3 因为如果只有两个类别 我们就不需要 使用这种一对多的方法 我们只有在K大于 或者等于3个类的时候 才会使用这种 一对多的方法 因为如果只有两个类别 我们就只需要一个输出单元就可以了 现在我们来为神经网络定义代价函数 我们在神经网络里 使用的代价函数 应该是逻辑回归里 使用的代价函数的一般化形式 对于逻辑回归而言 我们通常使代价函数 J(θ) 最小化 也就是-1/m 乘以后面这个代价函数 然后再加上这个额外正则化项 这里是一个 j从1到n的求和形式 因为我们 并没有把偏差项 0正则化 对于一个神经网络来说 我们的代价函数是这个式子的一般化形式 这里不再是仅有一个 逻辑回归输出单元 取而代之的是K个 所以这是我们的代价函数 神经网络现在输出了 在K维的向量 这里K可以取到1 也就是 原来的二元分类问题 我准备用这样一个记法 h(x)带下标i 来表示第i个输出 也就是h(x)是一个K维向量 下标 i 表示 选择了神经网络输出向量的 第i个元素 我的代价函数 J(θ) 将成为下面这样的形式 -1/m乘以 一个类似于我们在 逻辑回归里所用的 求和项 除了这里我们求的是 k从1到K的所有和 这个求和项主要是 K个输出单元的求和 所以如果我有四个输出单元 也就是我的神经网络最后一层 有四个输出单元 那么这个求和就是 这个求和项就是 求k等于从1到4的 每一个的逻辑回归算法的代价函数 然后按四次输出的顺序 依次把这些代价函数 加起来 所以你会特别注意到 这个求和符号应用于 yk和hk  因为 我们主要是讨论 K个输出单元 并且把它和yk的值相比 yk的值就是 这些向量里表示 它应当属于哪个类别的量 最后 这里的第二项 这就是类似于我们在逻辑回归里所用的 正则化项 这个求和项看起来 确实非常复杂 它所做的就是把这些项全部相加 也就是对所有i j和l 的θji的值都相加 正如我们在逻辑回归里一样 这里要除去那些对应于偏差值的项 那些项我们是不加进去的 那些项我们是不加进去的 具体地说 我们不把 那些对于i等于0的项 加入其中 这是因为 当我们计算神经元的激励值时 我们会有这些项 θi0 加上θi1 乘以x1 再加上 等等等等 这里我认为 我们可以加上2的上标 如果这是第一个隐含层的话 所以这些带0的项 所以这些带0的项 对应于乘进去了 x0 或者是a0什么的 这就是一个类似于 偏差单元的项 类比于我们在做 逻辑回归的时候 我们就不应该把这些项 加入到正规化项里去 因为我们并不想正规化这些项 并把这些项设定为0 但这只是一个合理的规定 即使我们真的把他们加进去了 也就是i从0加到sL 这依然成立 并且不会有大的差异 但是这个"不把偏差项正规化" 的规定可能只是会 更常见一些 好了 这就是我们准备 应用于神经网络的代价函数 在下一个视频中 我会开始讲解一个算法 来最优化这个代价函数 【教育无边界字幕组】翻译:reanghect 校对:Roy薛~ 审核:柳桦