W trakcie tego filmu porozmawiamy o drugim głównym rodzaju zagadnień uczenia maszynowego, zwanym uczeniem bez nadzoru. W poprzednim filmie rozmawialiśmy o uczeniu z nadzorem. Przypominam: mieliśmy zbiór danych wyglądających w ten sposób, gdzie każdy przykład oznaczyliśmy jako wynik pozytywny lub negatywny, tzn. jako nowotwór złośliwy lub nie. Tak więc dla każdego przypadku w uczeniu z nadzorem, powiedziano nam wprost, jaka jest "prawidłowa" odpowiedź, tzn. czy nowotwór jest złośliwy, czy nie. W przypadku uczenia bez nadzoru, mamy dane, które wyglądają inaczej. Dane, które wyglądają w ten sposób i nie mają żadnych oznaczeń albo wszystkie mają to samo oznaczenie lub nie mają ich w ogóle. A więc mamy taki zbiór danych i nie powiedziano nam, co z nim zrobić ani nie powiedziano nam czym jest każdy punkt w zbiorze danych. Zamiast tego powiedziano nam po prostu: "Oto zbiór danych. Czy możesz znaleźć w nim jakąś wewnętrzną strukturę?" Na podstawie tego zbioru danych algorytm uczenia bez nadzoru może zdecydować, że dane skupione są w dwóch różnych obszarach (klastrach). A więc tu mamy pierwszy klaster, a tu - drugi. I algorytm uczenia bez nadzoru jest w stanie rozbić te dane na dwa rozdzielne klastry. Dlatego też algorytm ten nazywamy klasteryzującym. Okazuje się, że ma to wiele zastosowań. Jednym z przykładów użycia klasteryzacji jest Google News - jeśli nigdy wcześniej o nim nie słyszałeś/aś, możesz odwiedzić ten adres: news.google.com i rzucić okiem. Każdego dnia Google News skanuje i czyta dziesiątki tysięcy lub setki tysięcy newsów w sieci i grupuje je w spójne zestawy newsów. Na przykład spójrzmy na to. Te adresy prowadzą do różnych newsów dotyczących szybu naftowego firmy BP Oil. Kliknijmy więc jeden z linków oraz jeden z tych linków. Dzięki temu otrzymamy taką oto stronę. Tutaj mamy artykuł z Wall Street Journal, dotyczący wycieków ropy naftowej z szybu, pod tytułem: "BP zabija Macondo". a Macondo to nazwa tej plamy ropy, a jeśli klikniesz inny link z tej grupy, możesz zobaczyć inny news. Tutaj znowu mamy artykuł CNN dot. wycieku ropy BP Oil, a jeśli klikniesz z kolei trzeci link, zobaczysz jeszcze inny artykuł. Tutaj mamy artykuł UK Guardian dotyczący wycieku ropy BP Oil. Tak więc Google News przegląda dziesiątki tysięcy artykułów z newsami i automatycznie dzieli je na grupy. Dzięki temu artykuły o tej samej tematyce są wyświetlane w jednym miejscu. Okazuje się, że algorytmy klasteryzujące oraz algorytmy uczenia bez nadzoru wykorzystywane są też w przypadku innych problemów. Przykładem jest zrozumienie genomu. Mamy tutaj przykład mikrotablicy danych DNA. Idea jest taka, żeby połączyć w grupy różne osoby, a potem dla każdej z nich określić, w jakim stopniu posiadają lub nie posiadają one określonego genu. Technicznie rzecz biorąc, mierzymy, w jakim stopniu geny się manifestują. Tak więc te kolory: czerwony, zielony, szary itd., pokazują stopień, w jakim różne osoby posiadają lub nie posiadają określonego genu. I to, co możesz zrobić, to odpalić algorytm klasteryzujący, aby podzielić osoby na różne grupy czy różne typy ludzi. Tak więc jest to uczenie bez nadzoru, ponieważ nie mówimy algorytmowi z góry, że ci ludzie to typ nr 1, ci - typ nr 2, tamci - typ nr 3, a więc zamiast tego mówimy: "OK, tu są dane." "Nie wiem, co w nich jest." "Nie wiem, kto należy do którego typu." "Nie wiem nawet, czym są różne" "typy ludzi, ale" "czy możesz automatycznie odkryć strukturę" "danych? Czy możesz automatycznie" "podzielić osoby na typy," "których nie mogę znać z góry?" Ponieważ nie podajemy algorytmowi "prawidłowej" odpowiedzi dla poszczególnych przykładów ze zbioru danych, jest to uczenie bez nadzoru. Uczenie bez nadzoru lub klasteryzacja ma też wiele innych zastosowań. Używa się go, aby tworzyć duże klastry komputerów. Mam paru znajomych, którzy patrzą na duże centra danych, tzn. duże klastry komputerów, i próbują zorientować się, które z maszyn pracują razem, oraz czy można połączyć je w grupę tak, aby centrum danych pracowało z większą wydajnością. Drugim zastosowaniem jest analiza sieci społecznościowych. Mając wiedzę o tym, z którymi znajomymi najczęściej piszesz poprzez e-mail, lub o Twoich znajomych z Facebooka czy kręgach Google+, czy możemy automatycznie odkryć spójne grupy znajomych, a także grupy ludzi, którzy znają siebie nawzajem? Segmentacja rynku. Wiele firm posiada ogromne bazy danych klientów. Czy możemy więc spojrzeć na te dane i automatycznie odkryć segmenty rynku, i automatycznie przypisać klientów do różnych segmentów rynku tak, aby w sposób automatyczny i bardziej wydajny sprzedawać lub reklamować produkty dla różnych segmentów rynku? Po raz kolejny: jest to uczenie bez nadzoru, bo mamy te wszystkie dane klientów, nie wiemy jednak z góry, jakie istnieją segmenty rynku oraz którzy klienci z naszego zbioru danych, rozumiesz, nie wiemy z góry kto zalicza się do segmentu rynku nr 1, kto jest w segmencie nr 2 itd. Musimy jednak pozwolić algorytmowi odkryć to wszystko jedynie na podstawie tych danych. Wreszcie, okazuje się, że uczenie bez nadzoru stosuje się też, co zaskakujące, do analizy danych astronomicznych, i te algorytmy klasteryzujące tworzą zaskakująco ciekawe i użyteczne teorie dotyczące tego, jak powstawały galaktyki. Wszystko to są przykłady klasteryzacji, która jest tylko jednym rodzajem uczenia bez nadzoru. Pozwól, że opowiem Ci o jeszcze jednym. Opowiem Ci teraz o problemie przyjęcia koktajlowego. Byłaś/eś kiedyś na przyjęciu koktajlowym, prawda? Cóż, możesz wyobrazić sobie, że mamy przyjęcie, salę pełną ludzi, wszyscy siedzą i rozmawiają jednocześnie, więc mamy wiele nakładających się głosów, bo wszyscy mówią naraz, więc trudno jest Ci zrozumieć osobę, która siedzi przed Tobą. Tak więc załóżmy, że mamy przyjęcie koktajlowe na dwie osoby - dwie osoby mówiące jednocześnie (jest to poniekąd dość małe przyjęcie). Mamy więc zamiar zainstalować dwa mikrofony w sali. Tak więc mamy mikrofony, a ponieważ mikrofony te znajdują się w dwóch różnych odległościach od rozmówców, każdy z mikrofonów rejestruje inną kombinację głosów każdego z rozmówców. Być może rozmówca nr 1 jest jest trochę głośniejszy na mikrofonie nr 1, a rozmówca nr 2 jest trochę głośniejszy na mikrofonie nr 2, ponieważ te dwa mikrofony są w różnych odległościach od obydwu rozmówców, jednak każdy z mikrofonów skutkowałby kombinacją nakładających się głosów obu rozmówców. Tutaj mamy rzeczywiste nagranie dwóch rozmówców, wykonane przez badacza. Zobaczmy najpierw, jak brzmi mikrofon nr 1. One (uno), two (dos), three (tres), four (quatro), five (cinco), six (seis), seven (siete), eight (ocho), nine (nueve), ten (y diez). OK, może nie jest to najbardziej interesujące przyjęcie na świecie. Mamy dwóch ludzi liczących od jednego do dziesięciu w dwóch językach, ale, rozumiesz, usłyszałaś/eś właśnie nagranie z pierwszego mikrofonu. Oto nagranie z drugiego: Uno (one), dos (two), tres (three), quatro (four), cinco (five), seis (six), siete (seven), ocho (eight), nueve (nine) y diez (ten). Tak więc możemy wziąć te dwa mikrofony i pokazać je algorytmowi uczenia bez nadzoru, zwanemu algorytmem przyjęcia koktajlowego, i powiedzieć algorytmowi: "Znajdź mi jakąś zależność, strukturę, w tych danych." Algorytm z kolei wysłucha tych nagrań, i powie: "Wiesz, "brzmi to tak, jak gdyby" "nałożono na siebie dwa nagrania" "albo jakby zsumowano je ze sobą" "tak, że otrzymaliśmy takie, a nie inne nagranie." Co więcej, algorytm przyjęcia koktajlowego rozdzieli te dwa źródła dźwięku, które dodano do siebie lub nałożono na siebie tak, że powstały rzeczywiste nagrania. I rzeczywiście: oto pierwszy wynik działania algorytmu przyjęcia koktajlowego. One, two, three, four, five, six, seven, eight, nine, ten. Tak więc wyekstrahowałem angielski głos do oddzielnego nagrania. A oto i drugi wynik: Uno, dos, tres, quatro, cinco, seis, siete, ocho, nueve y diez. Całkiem nieźle. Podam jeszcze jeden przykład. Oto kolejne nagranie podobnej sytuacji. Oto pierwszy mikrofon: One, two, three, four, five, six, seven, eight, nine, ten. OK, a więc mamy biednego gościa, który przyszedł do domu z przyjęcia, a teraz siedzi sam w pokoju i gada do radia. A oto i nagranie z drugiego mikrofonu: One, two, three, four, five, six, seven, eight, nine, ten. Jeśli pokażemy te dwa nagrania temu samemu algorytmowi, po raz kolejny powie on: "Słuchaj, brzmi to tak, jakby" "były dwa źródła dźwięku." Co więcej - algorytm powie: "Oto "pierwsze z dwóch źródeł dźwięku, które znalazłem:" One, two, three, four, five, six, seven, eight, nine, ten. Tak więc wynik nie jest idealny - mamy głos, jednak mamy też w tle trochę muzyki. Mamy też drugi wynik działania algorytmu: Nie jest źle. W drugim nagraniu pozbyliśmy się głosu całkowicie. Tak więc "wyczyściliśmy" muzykę, pozbywając się liczenia od jednego do dziesięciu. Być może patrzysz na taki algorytm uczenia bez nadzoru jak ten i zastanawiasz się, jak bardzo skomplikowana jest jego implementacja, prawda? Być może, aby stworzyć taką aplikację, wykonującą przetwarzanie dźwięku, trzeba napisać mnóstwo kodu? Może trzeba dołączyć mnóstwo bibliotek Javy czy C++ do przetwarzania dźwięku? Wygląda to na bardzo skomplikowany program: przetwarzanie dźwięku, rozdzielenie głosów i tak dalej... Okazuje się, że algorytm robiący to wszystko można zawrzeć w jednej linii kodu - takiej jak ta. Badaczom wiele czasu zajęło dojście do tej jednej linii kodu. Nie twierdzę, że jest to łatwy problem. Okazuje się jednak, że jeśli korzystasz z odpowiedniego środowiska programistycznego, wiele algorytmów uczących się może mieć postać naprawdę malutkich programów. Właśnie dlatego w trakcie tych zajęć będziemy korzystać ze środowiska programistycznego Octave. Octave jest darmowym oprogramowaniem o otwartym kodzie źrodłowym. Korzystając z narzędzi takich jak Octave czy Matlab, wiele algorytmów uczących się staje się po prostu paroma liniami kodu do zaimplementowania. W dalszej części zajęć, nauczę Cię trochę o tym, jak korzystać z Octave'a, a potem będziesz implementować niektóre z tych algorytmów w Octave'ie. Lub też, jeśli masz Matlaba, możesz korzystać też z niego. Okazuje się, że w Dolinie Krzemowej, w przypadku wielu algorytmów uczenia maszynowego, najpierw tworzymy prototyp oprogramowania w Octave'ie, ponieważ to oprogramowanie pozwala niesłychanie szybko zaimplementować te samouczące się algorytmy. Tutaj każda z tych funkcji, np. funkcja SVD, odpowiadająca za rozkład według wartości osobliwych; okazuje się jednak, że jest to funkcja algebry liniowej, która jest już wbudowana w Octave. Jeśli próbowałbyś/próbowałabyś zaimplementować ją w C++ lub Javie, byłoby to wiele linii kodu z dołączonymi skomplikowanymi bibliotekami C++ lub Javy. Tak więc możesz to implementować np. w C++, Javie czy Pythonie - jest to po prostu o wiele bardziej skomplikowane. Ucząc uczenia maszynowego już prawie 10 lat, zauważyłem, że uczysz się dużo szybciej, jeśli korzystasz z Octave'a jako środowiska programistycznego, i jeśli korzystasz z Octave'a jako narzędzia do nauki i prototypowania, pozwoli Ci to uczyć się i prototypować algorytmy uczące się znacznie szybciej. I w praktyce jest tak, że wiele osób w firmach z Doliny Krzemowej wykorzystuje algorytm taki jak Octave, aby najpierw wykonać prototyp algorytmu, a dopiero, gdy zacznie on działać, wtedy przepisuje się go w C++, Javie czy czymkolwiek innym. Okazuje się, że robiąc to w ten sposób, możesz często otrzymać działający algorytm znacznie szybciej, niż gdybyś zaczęła/zaczął od razu w C++. Tak więc wiem, że jako instruktor, mogę mówić: "Zaufaj mi w tym punkcie" jedynie skończoną liczbę razy, jednak tych z Was, którzy nigdy przedtem nie korzystali ze środowisk takich jak Octave, poproszę o to, abyście zaufali mi w tej kwestii. Myślę, że Twój czas, Twój czas rozwoju oprogramowania, jest jednym z najcenniejszych zasobów. I obserwując wielu takich ludzi, myślę, że Ty - jako badacz uczenia maszynowego, czy też deweloper uczenia maszynowego - będziesz znacznie bardziej produktywna/ym, jeśli nauczysz się zaczynać od prototypu, zaczynać od Octave'a, a dopiero potem przechodzić na inny język. Wreszcie, aby podsumować ten film, mam dla Ciebie jedno szybkie pytanie na powtórzenie materiału. Rozmawialiśmy o uczeniu bez nadzoru, które polega na tym, że dajesz algorytmowi tony danych, i prosisz go, aby znalazł nam wewnętrzną strukturę w tych danych. Spośród następujących czterech przykładów, jak myślisz, które z tych czterech byłyby algorytmem uczenia bez nadzoru, a które zagadnieniem uczenia z nadzorem? Spośród czterech pól wyboru po lewej zaznacz te, w przypadku których uważasz, że uczenie bez nadzoru byłoby dobrym algorytmem, a następnie kliknij przycisk w dolnym prawym rogu, aby sprawdzić swoją odpowiedź. Tak więc gdy film się zatrzyma, odpowiedz proszę na pytanie na tym slajdzie. Tak więc, mam nadzieję, że pamiętałeś/aś zagadnienie filtru antyspamowego. Jeśli masz dane z etykietą, tzn. z e-mailami, które są spamem lub nie, potraktowalibyśmy to jako zagadnienie uczenia z nadzorem. Przykład z newsami to dokładnie przykład Google News, który widzieliśmy w tym filmie. Widzieliśmy, jak można wykorzystać algorytm klasteryzujący, aby zgrupować razem artykuły, więc jest to uczenie bez nadzoru. W przypadku segmentacji rynku, o której mówiłem wcześniej, możesz do tego podejść jak do uczenia bez nadzoru, ponieważ chcę dać mojemu algorytmowi dane i poprosić, aby automatycznie odkrył on segmenty rynku. Co do ostatniego przykładu - cukrzycy. Cóż, właściwie jest to dokładnie to samo, co w przypadku przykładu raka piersi z poprzedniego filmu. Tylko że zamiast dobrych i złych nowotworów, czy też złośliwych lub niezłośliwych nowotworów, mamy cukrzycę lub jej brak. Tak więc podejdziemy do tego, rozwiążemy ten problem jako zagadnienie uczenia z nadzorem tak, jak w przypadku nowotworów piersi. To tyle, jeśli chodzi o uczenie bez nadzoru. W następnym filmiku, wejdziemy głębiej w niektóre algorytmy uczące się i zaczniemy rozmawiać o tym, jak one działają oraz jak możemy podejść do ich implementacji.