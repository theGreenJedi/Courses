В этом видео мне хотелось бы рассказать вам, как писать управляющие операторы для ваших программ на Octave, такие как "for", "while" и "if", а также как описывать и использовать функции. Вот окно Octave. Сначала я покажу, как используется цикл for. Для начала я задам нулевой вектор v размера 10х1. Теперь я создам цикл, в котором переменная i принимает значения от 1 до 10. Таков смысл выражения "for i=1:10". И давайте посмотрим, я собираюсь назначить v(i) равным 2 в степени i и наконец написать ключевое пишем end. Пробелы не имеют значения, таким образом, я их добавляю, чтобы код выглядел хорошо читаемым, но вы помните, что больше ни на что они не влияют. Если я запущу этот код, v будет принимать значения два в степени один, два в степени два, и так далее. Синтаксис цикла выглядит как i=1:10, и i изменяется в пределах от 1 до 10. Кстати, то же самое можно сделать, присвоив indices=1:10, так что indices равно вектору чисел от 1 до 10. Вы также можете написать: for i=indices Это то же самое, что i=1:10. Команда disp(i) покажет, что это одно и то же. Итак, это цикл "for". Если вы знакомы с операторами "break" и "continue", то их вы также можете использовать внутри цикла в Octave. Но позвольте мне сначала показать вам, как работает цикл "while". Итак, вот мой вектор V. Давайте напишем цикл while. i=1; while i<=5, скажем, мы присваиваем v(i) значение 100 и увеличиваем i на единицу, end. Что это означает? Изначально i равно единице. Элементу v(i) я присваиваю значение 100 и увеличиваю i на один до тех пор, пока i не станет больше пяти. В результате если раньше v представлял собой вектор степеней двоек, теперь первые пять элементов вектора были изменены на значение 100. Итак, это синтаксис для цикла while. Давайте рассмотрим другой пример. i=1; while true, и далее мы будем учиться использовать оператор break. В теле цикла: V(i) присвоим 999, увеличим счетчик i на 1 и добавим условие если i == 6 то прерываем цикл оператором break, пишем end. Здесь мы впервые использовали оператор условия if, я надеюсь логика его использования понятна. Изначально i равно 1, и увеличивается на 1 с каждым шагом цикла. В цикле V(i) присваивается значение, счетчик i увеличивается на 1, и когда i увеличивается до 6 происходит прерывание цикла оператором break и в результате работы цикла первые 5 элементов вектора должны быть равны 999. И, да, действительно, мы перезаписали первые пять элементов V значением 999. Итак, таков синтаксис операторов if и while, и обратите внимание на оператор end. У нас тут два ключевых слова end. Первый end заканчивает условие if, второй end заканчивает цикл while. Сейчас я продемонстрирую более общий синтаксис для связки if-else. Итак, v(1)=999. Ради примера присвоим v(1) значение 2. Создадим условие: если v(1) равно 1, то отобразить текст "Значение равно 1". Вот как применяется оператор else, вернее, elseif. Если v(i) равно 2, то отобразится текст "Значение равно 2", во всех остальных случаях - "Значение не равно 1 или 2". Хорошо, вот так мы заканчиваем выражение if-elseif. Конечно, так как мы только что присвоили v(1) зачение 2, и да, мы видим текст "Значение равно 2". Наконец, кажется, я об этом еще не говорил, но если вы хотите выйти из Octave, вы можете использовать команду exit. Команда quit также завершит работу Octave. Наконец, давайте поговорим о функциях, их определении и использовании. Вот мой рабочий стол, где я уже подготовил заранее созданный файл с именем "squarethisnumber.m". Так в Octave обозначаются функции. Вы создаете файл с именем функции и присваиваете ему расширение ".m". Когда Octave находит файл "squarethisnumber.m", то понимает, что в нем нужно искать определение функции "squarethisnumber". Давайте откроем этот файл. Заметьте, что я использую программу Microsoft Wordpad, чтобы открыть этот файл. Я рекомендую, если вы используете Microsoft Windows, для работы с этими файлами вместо Блокнота использовать Wordpad, или какой-нибудь другой редактор. Блокнот иногда повреждает форматирование. Если у вас есть только Блокнот, его вы тоже можете использовать. Но если у вас есть выбор, лучше используйте Wordpad или другой текстовый редактор. Итак, как в Octave Определяются функции? Позвольте мне немного увеличить. И этот файл содержит всего лишь три строки. Первая строка сигнализирует Octave, что функция возвращает переменную y; результатом функции будет одна переменная, которая будет храниться в y. Кроме того, тут указано, что у этой функции всего один аргумент, аргумент х. В теле функции значение y вычисляется как квадратный корень из х. Давайте попробуем вызвать эту  функцию для числа 5. У нас ничего не получится: Octave говорит, что функция squareThisNumber не определена. Это потому, что Octave не знает, где найти этот файл. Как обычно, командами pwd и cd давайте перейдем в каталог c:\users\ang\desktop. Это мой рабочий стол. Упс, маленькая опечатка. Если я теперь вызову squareThisNumber с аргументом 5, мне вернется 25. Заметка из разряда "для продвинутых", для тех из вас, кто знает, что такое пути поиска. Пусть это идет как дополнительный материал. В Octave можно модифицировать путь поиска. Те из вас, кто знаком с понятиями пути поиска и правами, могут использовать команду addpath('C:\users\ANG\desktop') для добавления папки, в которой Octave будет искать файлы. Даже если вы находитесь в другой папке, Octave будет знать, что в папке рабочего стола пользователя ANG можно поискать файл squareThisNumber, пусть даже я по-прежнему остаюсь в другой директории. Понятно? Но, если вы не знакомы с понятием пути поиска, не беспокойтесь об этом. Просто убедитесь, что с помощью команды cd перешли в папку с файлом функции перед ее вызовом, и все будет работать. В Octave есть то, чего нет во многих других языках программирования, он позволяет Вам определять функции возвращающие множество аргументов. Вот пример. Определим функцию squareAndCubeThisNumber от х. Как видите, она возвращает два значения, y1 и y2. Далее я определяю, что y1 равно x в квадрате, y2 равно x в кубе. В конечном итоге мне возвращаются два числа. В зависимости от предпочитаемых вами языков программирования, вы можете знать С++, например. Часто считается, что функция должна возвращать всего одно значение. Но синтаксис языка Octave таков, что функция может возвращать несколько значений. Сейчас вернемся в окно Octave. Если я наберу [a,b]=squareAndCubeThisNumber(5), то а станет равно 25, а b станет равно 5 в кубе, то есть 125. Это удобно в случаях, когда определяемая функция должна возвращать несколько значений. Наконец, я собираюсь показать вам еще один, более сложный, пример функции. Допустим, у меня есть набор данных с координатами точек 1, 1; 2, 2; 3, 3. И я бы хотел написать функцию Octave, которая вычисляла бы функцию стоимости J для различных значений тета. Сначала давайте введем данные в Octave. Итак, моя матрица плана будет: X=[1 1; 2 2; 3 3] И вот моя матрица плана х с элементом х0, с первым столбцом и вторым столбцом, содержащим х-координаты исследуемых точек. И пусть y=[1; 2; 3], это будут у-координаты точек. Предположим, что theta=[1; 2]. Я рабочем столе я подготовил файл функции стоимости J, и если я открою его, то увижу, что функция выглядит следующим образом. В первой строке выражение для функции. Потом идут комментарии касательно параметров. Затем m присваивается количество примеров, то есть число строк в х. Вычислим прогнозы как X умножить на тета. Далее после знака % идет следующий комментарий. Вычисление ошибок прогнозирования как разницу между прогнозом и значением y с поэлементным возведением в квадрат. Наконец, вычисление значения J. Octave знает, что эту величину нужно вернуть мне, потому что я указал это при определении функции. Кстати, не стесняйтесь ставить видео на паузу и внимательно изучать текст функции, чтобы лучше понимать, что она делает. Я запускаю ее в Octave, вводя j = costFunctionJ(x,y,theta). Вычисляется результат.Ой, тут опечатка. Надо было использовать заглавную Х. В результате J равно 0, так как вводя 1, 2 и 3, 1, 2 и 3, с theta(0) равным 0 и theta(1) равным 1, я получаю прямую под углом 45 градусов, которая идеально соответствует моим данным. А вот если я присвою theta=[0;0], то моя гипотеза предсказывает нули во всех точках; theta(0) равно 0, theta(1) равно 0, и функция стоимости получается равной 2.333. Это значение рассчитывается как 1 в квадрате, то есть квадрат ошибки в первом случае, плюс 2 в квадрате, плюс 3 в квадрате, и все это поделить на 2*m, то есть удвоенное число образцов. Результат действительно равен 2.333, значит, в этом примере мы правильно рассчитали функцию затрат. То есть наша проверка показала, что costFunctionJ, определенная следующим образом, действительно вычисляет функцию стоимости, по крайней мере на нашем простом примере с простыми парами координат X и Y Итак, вы познакомились с операторами циклов for и while, с оператором условного перехода if в Octave, а также научились пользоваться функциями. В следующем видео я вкратце познакомлю вас с процессом решения и проверки ваших самостоятельных заданий, с нашей системой загрузки результатов. Наконец, в последнем видеоуроке по Octave я расскажу о векторизации, способе значительно ускорить выполнение ваших программ в Octave.