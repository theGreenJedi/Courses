Você agora sabe um monte sobre aprendizado de máquina. Neste vídeo, eu gostaria de lhe ensinar uma linguagem de programação, Octave, através da qual você será capaz de implementar rapidamente os algoritmos de aprendizado que nós já vimos, e também os algoritmos de aprendizado que veremos mais adiante neste curso. No passado, eu tentei ensinar aprendizado de máquinas utilizando uma grande variedade de linguagens de programação diferentes incluindo C++, Java, Pyton, NumPy, além de Octave, e o que eu descobri foi que os alunos eram capazes de aprender de forma mais produtiva e rápida ao prototipar seus algoritmos utilizando uma linguagem de mais alto nível, como Octave. Na verdade, o que eu vejo com frequência no Vale do Silício que se você quiser construir lançar um algoritmo de aprendizado em larga escala, costuma-se primeiro fazer um prototótipo, onde a linguagem utilizada é Octave, que é uma ótima linguagem para prototipar, permitindo colocar o algoritmo para funcionar rapidamente. E só então, se você precisar, passar a uma implementação em larga escala. Somente então você gastaria seu tempo reimplementando o algoritmo para C++, Java ou alguma outra linguagem semelhante. Porque uma das as lições que aprendemos é que o tempo do programador ou desenvolvedor, o seu tempo. é extremamente valioso. E se você pode fazer seus algoritmos de aprendizagem funcionarem mais rápidos em Octave, em geral você tem uma enorme economia de tempo ao desenvolver os algoritmos em Octave, e depois implementá-los em C++, Java, somente após termos as ideias funcionando. As linguagens mais comuns que eu vejo pessoas utilizarem para aprendizado de máquinas são: Octave, MATLAB, Pyton, NumPy, e R. Octave é bom porque é open source. E MATLAB funciona bem também, mas é caro para muitas pessoas. Mas se você tiver acesso a uma cópia de MATLAB, você também pode utilizá-lo nesta aula. Se você sabe Python, NumPy ou R, e eu vejo algumas pessoas utilizarem, mas, o que eu vejo é as pessoas demorando mais para desenvolver nessas linguagens. Porque a sintaxe de Pyton e NumPy é um pouco mais difícil que a sintaxe do Octave. E,  por causa disso, e porque porque nós estamos liberando o esqueleto dos códigos em Octave, recomendo fortemente que você não faça os exercícios desta aula em NumPy ou R. Mas recomendo que, ao invés disso, você faça os exercícios de programação para esta aula em Octave. O que farei neste vídeo é passar por uma lista de comandos muito, muito rapidamente, e o objetivo é mostrar rapidamente a gama de comandos e coisas que você pode fazer em Octave. O website do curso terá anotações de tudo o que vou fazer, então após assistir a este vídeo você pode consultar as anotações publicadas no site do curso quando você quiser encontrar um comando. O que eu recomendo é que você primeiro assista aos vídeos tutoriais e, depois de assistí-los até o fim, instale o Octave em seu computator. E depois, que você vá ao site do curso, baixe as anotações das aulas que você viu nesta sessão, e digite quaisquer comandos que pareçam interessantes para você no Octave, para que, no seu próprio computador, você possa vê-lo rodando. E com isso vamos começar. Esta é minha área de trabalho do Windows, e eu vou abrir o Octave. E agora estou no Octave. E esse é o meu prompt do Octave. Deixe-me mostrar primeiro as operações básicas que você pode fazer em Octave. Digite 5 + 6. Que lhe dá a resposta 11. 3 - 2. 5 x 8, 1/2, 2^6 dá 64. Então essas são as operações matemáticas elementares. Você também pode fazer operações lógicas. Então, um é igual a dois. O que é avaliado como falso. O comando por cento, aqui, significa um comentário. Então, um é igual a dois, é avaliado como falso. O que é representado por zero. Um não é igual a dois. Isto é verdadeiro. Então isso retorna o valor um. Note que um sinal de diferença é este símbolo "~=". E não "!=", como muitas outras linguagens de programação usam. Vamos ver operações lógicas um e zero use o sinal & duas vezes para o AND lógico. E isto é avaliado como falso. "1 || 0" é a operação OR. E está é avaliada como verdadeira. E eu posso fazer um XOR entre 1 e 0, e isto é avaliado como um. Isto mais à esquerda, este "Octave 3.2.3.exe:11" é o prompt padrão do Octave. Ele mostra em qual versão está o Octave, entre outras coisas. Se você não quiser este prompt, há um comando um tanto enigmático: PS('>> ') dessa maneira, que você pode usar para mudar o prompt. E isso dentro das aspas é uma string. Sua string, ">> ". É assim que gosto do meu Octave. Então, se eu apertar Enter. Opa, me desculpe. Desta forma. PS1, desta forma. Agora meu prompt de Octave mudou para ">> ". O que tem uma melhor aparência. Agora vamos falar sobre as variáveis do Octave. Eu posso tomar a variável A e atribuir a ela o valor 3. E apertar o Enter. E agora A é igual a 3. Caso você queira atribuir um valor a uma variável, mas não quer imprimir o resultado, coloque um ";" no final, ele suprime a impressão da saída. Então fazendo isso, depois Enter, ele não imprime nada. Enquanto A igual a 3 atribui e imprime o resultado, A igual a 3, ponto e vírgula, não imprime nada. Eu também posso fazer atribuição de string. B igual a 'hi' Agora, se eu digitar B ele imprime a variável B. Então B é a string hi C = 3 >= 1. Então, agora C é avaliado como verdadeiro. Se você quer imprimir na tela ou mostrar uma variável, é assim que você fará: Deixe-me definir A igual a Pi. Se eu quero imprimir A na tela, eu posso simplesmente digitar A, e ela vai aparecer. Para impressões mais complexas existe também o comando "disp()", que significa Display. disp(A) imprime na tela A. Você também pode imprimir strings. disp( sprintf( '2 decimals: %0.2f', a ) ) disp( sprintf( '2 decimals: %0.2f', a ) ) disp( sprintf( '2 decimals: %0.2f', a ) ) vai imprimir a string: "2 decimals: 3.14". Esta é uma espécie de sintaxe C estilo antigo. Para aqueles de vocês que já programaram em C antes, isto é essencialmente, a sintaxe utilizada para mostrar valores. Assim, o sprintf gera uma string, gera "2 decimals: 3.14" como string. Este "%0.2f" significa substituir a aqui, mostrando apenas dois dígitos após o ponto decimal. e disp pega a string gerada pelo comando "sprintf". "sprintf". O comando "sprintf". E disp realmente exibe essa string. E para mostrá-los outro exemplo: sprintf('6 decimals: %0.6f',a) sprintf('6 decimals: %0.6f',a) Isso imprimirá Pi com seis casas decimais. E finalmente, A aparece assim. Existem alguns atalhos úteis, se você digitar "format long" isto faz strings, por padrão, serem impressas com muito mais casas decimais. E o comando "format short" restaura ao padrão com impressão de poucos dígitos. É assim que você trabalha com variáveis. Agora vamos analisar vetores e matrizes. Digamos que eu queira atribuir a A uma matriz. Deixe-me mostrar um exemplo: [1 2; 3 4; 5 6]. Isto gera uma matriz A três por dois, cuja primeira linha é 1, 2. A segunda linha é 3,4. Terceira linha, 5, 6. O que o ponto e vírgula faz é essencialmente, ir para a próxima linha da matriz. Existem outras formas de faze isso. Digite A = [1, 2; 3, 4; 5, 6]. Essa é uma maneira equivalente de atribuit a A o valor da matriz três por dois. De forma similar, você pode criar vetores. V = [1, 2, 3] é um vetor linha. Ou um vetor 3 x 1. onde este é um vetor linha y, desculpe-me, esta é uma matriz 1 x 3, não 3 x 1. Se eu quiser atribuir a este vetor um vetor coluna, o que eu devo fazer é V= [ 1; 2; 3]. E isso vai me dar uma 3 x 1. Aqui está um vetor 1 x 3. Esté será um vetor coluna. Aqui estão algumas notações úteis. V = 1: 0.1: 2. Isso calcula atribuir a v um conjunto de elementos que começa por 1 e incrementa em passos de 0.1 até chegar em 2. Então se eu fizer isso, v será este vetor linha, que é uma matriz 1x11. É 1, 1.1, 1.2, 1.3 e assim por diante, até alcançar 2. E eu também posso definir V = 1:6 e isto atribui a V os números de 1 a 6. Agora, aqui estão outras maneiras de gerar matrizes. O comando "ones(2, 3)" gera uma matriz 2x3 cujos valores são todos 1. Então se eu definir c = 2 * ones (2, 3) isso gera uma matriz dois por três preenchida com o valor 2. Você pode pensar nisso como uma forma mais simples de escrever c = []2 2 2; 2 2 2], que daria o mesmo resultado. Digamos que W é uma matriz 1 x 3  de 1's, a que é um vetor linha ou uma linha de três 1's, e de modo similar pode-se usar w = zeros(1,3), e isto gera uma matriz 1x3 preenchida com zeros. Apenas mais algumas maneiras de gerar matrizes. Se eu fizer w = rand(1, 3) isto me dá uma matriz 1x3 de números aleatórios. Se eu fizer rand(3 x 3), isto me dá uma matriz 3x3 de números aleatórios aleatórios extraídos da distribuição uniforme entre zero e um. Então toda vez que faço isso, eu gero um conjunto diferente de números aleatórios entre zero e um. Para aqueles de vocês que sabem o que é uma variável aleatória gaussiana ou para aqueles que sabem o que é uma variável aleatória normal você também pode definir w =  randn( 1, 3) E assim estes serão os três valores extraídos de uma distribuição gaussiana, com média zero e variância, ou desvio padrão igual a um. E você pode definir coisas mais complexas, como w = -6 + sqrt (10) * randn(1, 10000)) w = -6 + sqrt (10) * randn(1, 10000)) w = -6 + sqrt (10) * randn(1, 10000)) E eu vou colocar um ponto e vírgula no final, porque eu não quero que isto seja impresso. Este vai ser o quê? Bem, isso será um vetor de dez mil elementos. Sabe de uma coisa? Vamos imprimi-lo. Então, isso vai gerar essa matriz. OK? Com 10.000 elementos. Então este é o resultado de W. E se eu agora plotar um histograma de W com o comando hist(). O comando hist() do Octave leva alguns segundos para abrir, mas gera o histograma da minha variável aleatória w. Havia menos 6 mais zero dez vezes esta variável gaussiana aleatória. E eu posso plotar um histograma com mais barras, com por exemplo, 50 barras. E este é o meu histograma de uma gaussinana de média -6. Porque eu tenho -6, mais a raiz quadrada de 10 vezes este então a variância desta variável aleatória gaussiana é 10, e o desvio padrão é raiz quadrada de 10, que é 3.1 Finalmente, um comando especial para gerar matrizes, que é o comando eye(). Eye vem de um trocadilho com a palavra Identidade. Então vamos fazer eye(4) que gera a matriz identidade 4 x 4 Fazendo I = eye(4), eu tenho a matriz identidade 4 x 4 E I = eye(6) me dá uma matriz identidade 6x6 E eye(3) é a matriz identidade 3 por 3. Finalmente, para encerrar este vídeo, tenho mais um comando útil. Que é o comando Help. Então você pode digitar help eye e isso traz a função de ajuda para a matriz identidade. Digite "Q" para sair. E você também pode digitar Help Rand. Abre documentação para o comando rand, ou a função que gera números aleatórios. Ou mesmo help help, que mostra a ajuda sobre a função de ajuda. Então, esseas são as operações básicas em Octave. E com isso, você deve ser capaz de gerar algumas matrizes, multiplicar, somar. e usar as operações básicas. No próximo vídeo eu começarei falando sobre comandos mais sofisticados, e como usar e processar dados no Octave.
Tradução: Priscila Holanda | Revisão: Eduardo Bonet