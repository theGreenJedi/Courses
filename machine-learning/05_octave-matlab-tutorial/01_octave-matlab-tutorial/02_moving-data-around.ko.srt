1
00:00:00,111 --> 00:00:02,628
이 두 번째 튜토리얼 비디오에

2
00:00:02,630 --> 00:00:03,904
데이터를 Octave에 옮기는 방법에 대해

3
00:00:03,930 --> 00:00:07,322
이야기해 보겠습니다

4
00:00:07,340 --> 00:00:08,783
기계 학습에 쓸 데이터가 있다면

5
00:00:08,783 --> 00:00:12,125
그 데이터를 어떻게 Octave에 불러올 수 있을까요?

6
00:00:12,125 --> 00:00:13,693
어떻게 행렬에 집어넣을까요?

7
00:00:13,693 --> 00:00:15,284
어떻게 이 행렬들을 조작할까요?

8
00:00:15,290 --> 00:00:16,982
어떻게 결과를 저장할까요?

9
00:00:17,000 --> 00:00:22,185
어떻게 데이터를 옮기고 다룰까요?

10
00:00:22,900 --> 00:00:25,044
이전처럼 여기에 제 Octave 창이 있고

11
00:00:25,044 --> 00:00:29,256
지난번 비디오에서 끝난 부분부터 시작하겠습니다

12
00:00:29,290 --> 00:00:31,132
A를 입력하면

13
00:00:31,140 --> 00:00:32,258
이것은 행렬이고,

14
00:00:32,258 --> 00:00:35,197
= 1 2; 3 4; 5 6

15
00:00:35,197 --> 00:00:38,152
명령어로 만들 수 있습니다

16
00:00:38,190 --> 00:00:40,696
이것은 3 x 2 행렬입니다

17
00:00:40,710 --> 00:00:42,415
size 명령어는

18
00:00:42,430 --> 00:00:46,361
행렬의 크기를 말해줍니다

19
00:00:46,361 --> 00:00:48,207
그래서 size A는 3 2를 반환합니다

20
00:00:48,207 --> 00:00:50,160
Clustering 과
unsupervised learning은

21
00:00:50,180 --> 00:00:52,155
이 size 명령 자체는 실제로

22
00:00:52,155 --> 00:00:54,591
1 x 2 행렬을 반환합니다

23
00:00:54,591 --> 00:00:56,598
그래서 SZ를 A의 크기로

24
00:00:56,598 --> 00:00:58,370
설정할 수 있고

25
00:00:58,380 --> 00:00:59,597
SZ는 첫 번째 요소가

26
00:00:59,597 --> 00:01:01,627
3이고 두 번째 요소가 2인

27
00:01:01,640 --> 00:01:04,689
1 x 2 행렬입니다

28
00:01:04,700 --> 00:01:07,494
그래서 size SZ를 입력하면

29
00:01:07,494 --> 00:01:08,898
SZ는

30
00:01:08,898 --> 00:01:10,862
두 개의 요소가

31
00:01:10,862 --> 00:01:13,721
행렬 A의 차원을 나타내는

32
00:01:13,721 --> 00:01:15,279
1 x 2 행렬입니다

33
00:01:15,279 --> 00:01:17,787
또한 size A 1 을 입력해

34
00:01:17,787 --> 00:01:19,505
A의 첫 번째 차원을

35
00:01:19,510 --> 00:01:21,542
알 수 있고

36
00:01:21,542 --> 00:01:22,662
첫 번째 차원의 크기

37
00:01:22,680 --> 00:01:24,108
그래서 이것이 행의 갯수이고

38
00:01:24,110 --> 00:01:26,307
size A 2로

39
00:01:26,320 --> 00:01:28,361
2를 반환하는데

40
00:01:28,361 --> 00:01:29,598
이 숫자는 행렬A의

41
00:01:29,598 --> 00:01:31,942
열의 갯수입니다

42
00:01:31,950 --> 00:01:34,034
벡터 V가 있다면

43
00:01:34,034 --> 00:01:36,016
V에 1 2 3 4

44
00:01:36,030 --> 00:01:38,089
를 대입하고

45
00:01:38,089 --> 00:01:40,830
length(V)를 입력합니다

46
00:01:40,830 --> 00:01:42,097
이것은 가장 긴 차원의

47
00:01:42,097 --> 00:01:44,123
길이를 반환합니다

48
00:01:44,170 --> 00:01:45,609
length(A)도 입력할 수 있고

49
00:01:45,609 --> 00:01:48,487
왜냐 하면

50
00:01:48,500 --> 00:01:49,856
A는 3 x 2 행렬이기 때문에

51
00:01:49,860 --> 00:01:52,305
더 긴 차원의

52
00:01:52,330 --> 00:01:53,825
길이가 3 입니다

53
00:01:53,825 --> 00:01:56,145
그래서 3를 출력해야 합니다

54
00:01:56,145 --> 00:01:58,805
그러나 보통 벡터의 길이를 찾기 위해 length를 씁니다

55
00:01:58,810 --> 00:02:00,194
length 1 2

56
00:02:00,200 --> 00:02:02,222
3 4 5

57
00:02:02,230 --> 00:02:04,010
행렬에는 length를 잘 사용하지 않습니다

58
00:02:04,010 --> 00:02:07,205
왜냐하면 헷갈리기 때문입니다

59
00:02:07,620 --> 00:02:10,122
이제,

60
00:02:10,122 --> 00:02:11,843
데이터를 불러오고

61
00:02:11,860 --> 00:02:13,732
파일에서 데이터를 찾는 방법을 알아보겠습니다

62
00:02:13,732 --> 00:02:15,254
Octave를 시작했을 때

63
00:02:15,254 --> 00:02:16,882
우리는 보통, 자주

64
00:02:16,920 --> 00:02:19,098
Octave가 위치한

65
00:02:19,098 --> 00:02:21,738
경로에 있습니다

66
00:02:21,750 --> 00:02:24,042
PWD 명령어는

67
00:02:24,060 --> 00:02:25,619
현재 디렉토리 또는

68
00:02:25,640 --> 00:02:28,738
Octave가 위치한 현재 경로를 보여줍니다

69
00:02:28,738 --> 00:02:31,932
지금은 데이터 위치에서 조금 먼 디렉토리에 있습니다

70
00:02:31,932 --> 00:02:33,999
CD명령어는

71
00:02:34,000 --> 00:02:35,322
디렉토리 변경을 나타냅니다

72
00:02:35,330 --> 00:02:40,681
C:/Users/Ang/Desktop에 이동할 수 있고

73
00:02:40,681 --> 00:02:43,657
이제 제 Desktop에 왔습니다

74
00:02:43,657 --> 00:02:45,925
ls 입력하면

75
00:02:45,925 --> 00:02:49,447
ls는 유닉스 또는 리눅스 명령어에서 유래합니다

76
00:02:49,447 --> 00:02:50,648
ls는 desktop에 있는

77
00:02:50,648 --> 00:02:52,435
디렉토리를 나열합니다

78
00:02:52,435 --> 00:02:54,137
제 Desktop에 있는

79
00:02:54,140 --> 00:02:58,184
파일들이 있네요

80
00:03:15,850 --> 00:03:17,838
제 desktop에

81
00:03:17,838 --> 00:03:19,920
두 개의 파일이 있는데

82
00:03:19,920 --> 00:03:21,689
기계 학습 문제를 풀기위한

83
00:03:21,689 --> 00:03:23,596
featureX 와 priceY 입니다

84
00:03:23,620 --> 00:03:25,830
여기가 제 desktop이고

85
00:03:25,830 --> 00:03:29,144
이게 featuresX

86
00:03:29,144 --> 00:03:31,598
featuresX 는 이 창입니다

87
00:03:31,630 --> 00:03:34,492
죄송합니다, featuresX는 데이터 두개 열이 있는 파일입니다

88
00:03:34,492 --> 00:03:36,702
실제로 제 집값 데이터입니다

89
00:03:36,750 --> 00:03:38,374
제 생각엔

90
00:03:38,374 --> 00:03:40,652
데이터 셋은 47 행이고

91
00:03:40,652 --> 00:03:42,344
첫 번째 집은

92
00:03:42,350 --> 00:03:43,966
2104 제곱피트 크기고

93
00:03:43,970 --> 00:03:46,172
3개의 침실이 있습니다

94
00:03:46,190 --> 00:03:47,367
두 번째 집은 1600 제곱피트이고

95
00:03:47,367 --> 00:03:49,862
3개의 침실이 있습니다, 등등

96
00:03:49,880 --> 00:03:52,302
priceY는

97
00:03:52,302 --> 00:03:55,020
이 파일입니다

98
00:03:55,040 --> 00:03:57,575
학습 셋에 있는 가격 데이터입니다

99
00:03:57,575 --> 00:03:59,735
featuresX와

100
00:03:59,735 --> 00:04:03,061
priceY는 데이터를 가진 단순 텍스트 파일입니다

101
00:04:03,061 --> 00:04:04,770
어떻게 이 데이터를 Octave에 불러올까요?

102
00:04:04,770 --> 00:04:06,050
그럼,

103
00:04:06,090 --> 00:04:08,163
load featuresX.dat 명령어를 입력하고

104
00:04:08,163 --> 00:04:10,069
이것으로

105
00:04:10,069 --> 00:04:11,991
featuresX를 불러옵니다

106
00:04:11,991 --> 00:04:15,772
load priceY.dat 도 할 수 있습니다

107
00:04:15,772 --> 00:04:17,323
그건 그렇고, 데이터를 불러오는 여러가지 방법이 있습니다

108
00:04:17,323 --> 00:04:19,245
이 명령어는

109
00:04:19,245 --> 00:04:20,916
featuresX.dat을 문자열로

110
00:04:20,916 --> 00:04:22,533
여기에 입력하면 이렇게 불러옵니다

111
00:04:22,550 --> 00:04:25,477
오타가 났네요

112
00:04:25,490 --> 00:04:27,317
이것은 동일한 명령입니다

113
00:04:27,317 --> 00:04:29,334
그래서 이 방법으로

114
00:04:29,360 --> 00:04:31,985
그냥 파일 이름의 문자열을 넣고

115
00:04:32,000 --> 00:04:34,148
초기화 할 때

116
00:04:34,148 --> 00:04:35,716
문자열으로

117
00:04:35,716 --> 00:04:38,902
Octave는 작은 따옴표를

118
00:04:38,930 --> 00:04:41,876
문자열을 나타내기위해 사용합니다

119
00:04:41,910 --> 00:04:42,837
그래서 이것은 문자열이고

120
00:04:42,860 --> 00:04:45,517
주어진 문자열로 시작하는

121
00:04:45,517 --> 00:04:48,324
파일을 불러올 수 있습니다

122
00:04:48,324 --> 00:04:50,919
이제 WHO 명령어는

123
00:04:50,960 --> 00:04:52,538
제 Octave 워크스페이스에

124
00:04:52,538 --> 00:04:54,605
어떤 변수들이 있는지 보여줍니다

125
00:04:54,605 --> 00:04:56,310
그래서 WHO는 Octave의 변수들이

126
00:04:56,330 --> 00:04:59,952
메모리에 존재하는지 보여줍니다

127
00:04:59,952 --> 00:05:01,367
FeaturesX와 priceY가

128
00:05:01,370 --> 00:05:02,991
이 사이에 있네요

129
00:05:02,991 --> 00:05:04,120
또한 앞서 만들었던

130
00:05:04,170 --> 00:05:06,311
변수들도 있네요

131
00:05:06,311 --> 00:05:09,198
featuresx를 입력해서

132
00:05:09,198 --> 00:05:11,062
featuresX를 출력할 수 있습니다

133
00:05:11,062 --> 00:05:14,164
제 데이터입니다

134
00:05:14,200 --> 00:05:16,419
size featuresx를 입력할 수 있습니다

135
00:05:16,419 --> 00:05:18,022
이게 저의

136
00:05:18,022 --> 00:05:20,519
47 x 2 행렬입니다

137
00:05:20,519 --> 00:05:22,307
priceY를 입력해서

138
00:05:22,320 --> 00:05:23,729
이것은

139
00:05:23,729 --> 00:05:26,753
47 x 1 행렬을 반환합니다

140
00:05:26,753 --> 00:05:30,125
47원 벡터입니다

141
00:05:30,125 --> 00:05:32,080
이것은 모두 제 학습 세트에 있는

142
00:05:32,080 --> 00:05:35,231
price Y를 가진 공통 벡터입니다

143
00:05:35,240 --> 00:05:37,584
who 함수는

144
00:05:37,600 --> 00:05:40,086
현재 워크스페이스에 있는 변수를 보여줍니다

145
00:05:40,086 --> 00:05:42,195
whos 함수도 있는데

146
00:05:42,195 --> 00:05:45,369
변수에 대한 상세한 보기를 제공합니다

147
00:05:45,369 --> 00:05:47,252
s를 붙이면

148
00:05:47,270 --> 00:05:48,574
또한 변수들을 나열하는데

149
00:05:48,574 --> 00:05:49,979
이제는

150
00:05:49,979 --> 00:05:51,782
크기도 나옵니다

151
00:05:51,790 --> 00:05:52,759
A 는

152
00:05:52,759 --> 00:05:54,764
3 x 2 행렬이고

153
00:05:54,764 --> 00:05:56,545
featuresX는 47 x2 행렬

154
00:05:56,545 --> 00:05:59,327
priceY는 47 x 1 행렬입니다

155
00:05:59,327 --> 00:06:01,098
이것이 벡터라는 것을 의미합니다

156
00:06:01,130 --> 00:06:03,438
그리고 메모리를 얼마나 차지하는지 보여줍니다

157
00:06:03,438 --> 00:06:06,020
행렬이 어떤 데이터 유형인지도 보여줍니다

158
00:06:06,020 --> 00:06:07,765
double은 double position형

159
00:06:07,765 --> 00:06:08,915
부동소수점을 뜻합니다

160
00:06:08,915 --> 00:06:13,148
즉 실수, 부동소수점 수를 뜻합니다

161
00:06:13,148 --> 00:06:14,190
변수를 없애고 싶다면

162
00:06:14,190 --> 00:06:17,316
clear 명령어를 사용할 수 있습니다

163
00:06:17,340 --> 00:06:21,124
clear featuresX를 하고 whos를 다시 입력하세요

164
00:06:21,130 --> 00:06:23,448
featuresX 변수가

165
00:06:23,448 --> 00:06:26,465
이제 사라진것을 볼 수 있습니다

166
00:06:27,270 --> 00:06:28,567
그러면 어떻게 데이터를 저장할까요?

167
00:06:28,567 --> 00:06:29,221
한번 봅시다.

168
00:06:29,221 --> 00:06:30,411
변수 V를

169
00:06:30,411 --> 00:06:33,075
priceY 1; 10으로 합니다

170
00:06:33,075 --> 00:06:34,826
이것은 V를

171
00:06:34,826 --> 00:06:38,574
벡터 Y의 앞에서 10개의 원소로

172
00:06:38,860 --> 00:06:43,215
설정합니다. who 또는 whos를 입력해봅시다

173
00:06:43,220 --> 00:06:46,612
priceY는 47 x 1 벡터이고

174
00:06:46,612 --> 00:06:48,474
V는 10 x 1입니다

175
00:06:48,474 --> 00:06:50,809
V 를 priceY

176
00:06:50,809 --> 00:06:52,451
1; 10 으로 하면 V를

177
00:06:52,451 --> 00:06:53,520
Y의 앞에서부터 10개의 요소로

178
00:06:53,520 --> 00:06:55,705
설정합니다

179
00:06:55,705 --> 00:06:57,398
이것을 디스크에 저장하고 싶다고 해봅시다

180
00:06:57,398 --> 00:07:00,129
save 명령어와 hello.mat

181
00:07:00,129 --> 00:07:02,302
v 는

182
00:07:02,310 --> 00:07:04,357
변수 v를

183
00:07:04,370 --> 00:07:05,690
hello.mat이라고 하는 파일에 저장합니다

184
00:07:05,720 --> 00:07:08,490
한번 해보죠

185
00:07:08,640 --> 00:07:10,965
이제 이 파일이

186
00:07:11,030 --> 00:07:13,181
제 바탕 화면에 나타났습니다

187
00:07:13,181 --> 00:07:15,066
이름은 hello.mat 입니다

188
00:07:15,066 --> 00:07:16,509
저는 MATLAB이 설치되어 있습니다

189
00:07:16,530 --> 00:07:17,962
그래서

190
00:07:17,962 --> 00:07:19,711
이 아이콘이 나타납니다

191
00:07:19,711 --> 00:07:21,621
왜냐하면 윈도우가

192
00:07:21,621 --> 00:07:23,559
MATLAB 파일을 인식하기 때문입니다

193
00:07:23,559 --> 00:07:24,882
하지만 이 파일의

194
00:07:24,890 --> 00:07:26,051
아이콘이 다르게 생겼어도

195
00:07:26,051 --> 00:07:28,778
걱정하지 마세요

196
00:07:28,778 --> 00:07:31,017
변수들을 모두 지운다고 해 봅시다

197
00:07:31,020 --> 00:07:32,602
아무것도 없이 clear를 입력하면

198
00:07:32,602 --> 00:07:36,061
워크스페이스에 있는 모든 변수를 제거합니다

199
00:07:36,080 --> 00:07:39,078
이제 워크스페이스에 아무것도 없습니다

200
00:07:39,078 --> 00:07:41,856
load hello.mat를 하면

201
00:07:41,856 --> 00:07:44,388
제 변수 v를

202
00:07:44,388 --> 00:07:46,054
다시 불러올 수 있습니다

203
00:07:46,054 --> 00:07:47,830
v는 전에

204
00:07:47,830 --> 00:07:51,035
hallo.mat 파일에 저장했던 데이터입니다

205
00:07:51,035 --> 00:07:54,636
방금 전에 hello.mat을 저장하기 위해 hello.mat을 했습니다

206
00:07:54,636 --> 00:07:55,877
이것은 데이터를

207
00:07:55,877 --> 00:07:57,811
이진 형식으로 저장합니다

208
00:07:57,850 --> 00:07:59,702
약간 더 압축 된 이진 형식입니다

209
00:07:59,702 --> 00:08:01,077
그래서 v 가

210
00:08:01,077 --> 00:08:03,899
많은 데이터를 가지고 있으면, 더 많이 압축될것이고

211
00:08:03,899 --> 00:08:05,645
적은 공간을 차지합니다

212
00:08:05,650 --> 00:08:06,784
데이터를

213
00:08:06,784 --> 00:08:08,959
사람이 읽을 수 있는 형식으로 저장하려면

214
00:08:08,959 --> 00:08:11,870
save hello.text

215
00:08:11,870 --> 00:08:14,055
v를 입력하고 다음에 -ascii를 입력하세요

216
00:08:14,110 --> 00:08:16,083
이 명령어는 데이터를

217
00:08:16,083 --> 00:08:18,787
텍스트파일 또는

218
00:08:18,840 --> 00:08:21,352
ASCII형식의 텍스트로 저장합니다

219
00:08:21,352 --> 00:08:22,802
이제, 이것을 하고 나면

220
00:08:22,802 --> 00:08:24,973
이 파일이 있습니다

221
00:08:24,973 --> 00:08:26,115
hello.text가

222
00:08:26,130 --> 00:08:28,463
제 바탕화면에 나타났습니다

223
00:08:28,463 --> 00:08:29,951
이것을 열면

224
00:08:29,951 --> 00:08:31,016
데이터가 저장된

225
00:08:31,016 --> 00:08:33,958
텍스트 파일임을 볼 수 있습니다

226
00:08:33,958 --> 00:08:36,698
이것이 데이터를 불러오고 저장하는 방법입니다

227
00:08:36,698 --> 00:08:38,832
이제 데이터를 조작하는 방법에 대해 조금 이야기 해 보겠습니다

228
00:08:38,832 --> 00:08:40,526
A를 또다시 행렬로 설정하고

229
00:08:40,526 --> 00:08:44,910
이것은 3 x 2 행렬입니다

230
00:08:45,710 --> 00:08:46,778
원소를 찾는 것 입니다

231
00:08:46,778 --> 00:08:48,493
A 3,2를 입력하면

232
00:08:48,493 --> 00:08:51,219
A의 3,2 원소를

233
00:08:51,219 --> 00:08:52,917
찾습니다

234
00:08:52,917 --> 00:08:54,308
이것은

235
00:08:54,370 --> 00:08:56,320
알다시피

236
00:08:56,400 --> 00:08:57,488
보통 이렇게 적습니다

237
00:08:57,510 --> 00:09:00,421
A_ {3, 2}

238
00:09:00,430 --> 00:09:02,280
또는 A_

239
00:09:03,570 --> 00:09:05,320
3,2

240
00:09:05,380 --> 00:09:07,028
이것이

241
00:09:07,028 --> 00:09:08,664
3번째 행 2번째 열에 있는 원소

242
00:09:08,664 --> 00:09:11,539
6입니다

243
00:09:11,590 --> 00:09:13,820
또한 A 2

244
00:09:14,550 --> 00:09:16,770
,:을 입력해서

245
00:09:16,770 --> 00:09:18,851
두 번째 행을 전부 가져올 수 있습니다

246
00:09:18,851 --> 00:09:22,806
: 는

247
00:09:22,810 --> 00:09:27,381
행 또는 열에 있는 모든 원소를 의미합니다

248
00:09:27,420 --> 00:09:29,274
A의 2,: 은

249
00:09:29,274 --> 00:09:32,425
A의 두 번째 행입니다

250
00:09:32,470 --> 00:09:35,662
비슷하게, : , 2를 하면

251
00:09:35,680 --> 00:09:38,262
이것은 A의 두 번째 열 전체를

252
00:09:38,262 --> 00:09:41,328
의미합니다. 그래서 이것은 2 4 6을 반환합니다

253
00:09:41,328 --> 00:09:42,921
이것은

254
00:09:42,930 --> 00:09:45,467
A의 전체, 두번째 열 을 의미합니다

255
00:09:45,500 --> 00:09:46,967
그래서 이게

256
00:09:46,970 --> 00:09:49,636
A의 2, 4, 6 요소가 있는 두 번째 열입니다

257
00:09:49,650 --> 00:09:51,267
이제

258
00:09:51,280 --> 00:09:54,148
연산에서 가장 복잡한 인덱싱을 사용할 수 있습니다

259
00:09:54,148 --> 00:09:56,575
예제를 하나씩 해 보겠습니다

260
00:09:56,575 --> 00:09:58,537
아마도 자주 쓰지는 않겠지만

261
00:09:58,550 --> 00:10:02,231
A 1 3 , : 을 하면

262
00:10:02,231 --> 00:10:03,471
이것은 첫 번째 인덱스가 1 또는 3인

263
00:10:03,500 --> 00:10:07,444
모든 원소를 가져옴을 뜻합니다

264
00:10:07,450 --> 00:10:08,765
A의 첫 번째와 세 번째 행

265
00:10:08,765 --> 00:10:10,588
모든 원소를

266
00:10:10,603 --> 00:10:12,780
모든 열에서 가져옴을

267
00:10:13,240 --> 00:10:13,240
뜻합니다

268
00:10:14,163 --> 00:10:16,430
이것이

269
00:10:16,800 --> 00:10:18,260
행렬 A고

270
00:10:18,440 --> 00:10:21,872
A [1 3], : 은

271
00:10:21,900 --> 00:10:23,222
첫 번째 행과

272
00:10:23,250 --> 00:10:25,023
두 번째 행

273
00:10:25,023 --> 00:10:27,172
세 번째 행 전부를 가져온다는 뜻이고

274
00:10:27,172 --> 00:10:28,313
: 은

275
00:10:28,313 --> 00:10:29,585
첫 번째와 두 번째

276
00:10:29,585 --> 00:10:31,045
열 전부를 뜻합니다

277
00:10:31,045 --> 00:10:32,842
그래서 이것은 1 2 5 6 를 반환합니다

278
00:10:32,842 --> 00:10:34,353
이러한 고급 첨자 인덱스의

279
00:10:34,353 --> 00:10:37,182
사용 빈도는

280
00:10:37,182 --> 00:10:39,819
다소 낮을지도 모릅니다

281
00:10:40,210 --> 00:10:41,453
이 외에도 할 수 있는 것을 보여드리겠습니다

282
00:10:41,453 --> 00:10:43,617
여기 A 행렬이 있고

283
00:10:43,617 --> 00:10:47,276
A : , 2 로 두 번째 열을 가져옵니다

284
00:10:47,276 --> 00:10:49,773
이것을 대입에 사용할 수 있습니다

285
00:10:49,773 --> 00:10:51,178
A의 두 번째 열을 가져와서

286
00:10:51,190 --> 00:10:52,949
그것에

287
00:10:52,950 --> 00:10:55,605
10 11 12를 할당합니다

288
00:10:55,670 --> 00:10:58,084
이렇게 하면 이제는

289
00:10:58,120 --> 00:10:59,220
A의 두 번째 열을 가져와서

290
00:10:59,290 --> 00:11:02,768
열벡터 10 11 12를 대입했습니다

291
00:11:02,768 --> 00:11:05,440
이제 A 행렬은 1 3 5

292
00:11:05,480 --> 00:11:08,760
두 번째 열은 10 11 12로 바뀌었습니다

293
00:11:08,760 --> 00:11:14,513
그리고 다른 연산이 있습니다

294
00:11:14,680 --> 00:11:15,917
A를

295
00:11:15,917 --> 00:11:17,738
A, [100 101 102]로 해 봅시다

296
00:11:17,750 --> 00:11:21,605
이것은

297
00:11:21,605 --> 00:11:24,109
다른 열 벡터를

298
00:11:24,120 --> 00:11:28,025
오른쪽에

299
00:11:28,047 --> 00:11:29,855
붙입니다

300
00:11:29,890 --> 00:11:33,230
이제는

301
00:11:33,260 --> 00:11:36,798
제가 좀 실수한 것 같네요

302
00:11:36,800 --> 00:11:41,065
세미콜론을 부였어야 했는데

303
00:11:41,700 --> 00:11:43,910
이제 A는 이것과 같습니다

304
00:11:43,910 --> 00:11:44,564
알겠죠?

305
00:11:44,564 --> 00:11:45,479
잘 이해하셨기를 바랍니다

306
00:11:45,479 --> 00:11:46,480
100 101 102

307
00:11:46,480 --> 00:11:48,804
이것은 열 벡터이고

308
00:11:48,820 --> 00:11:51,668
우리가 한 것은

309
00:11:51,668 --> 00:11:53,386
A를 가져와서

310
00:11:53,386 --> 00:11:56,156
원래 정의대로 설정하고

311
00:11:56,156 --> 00:11:57,368
뒤에 열 벡터를

312
00:11:57,380 --> 00:11:59,192
넣었습니다

313
00:11:59,192 --> 00:12:00,217
그래서 행렬 A를

314
00:12:00,217 --> 00:12:04,288
가져왔고

315
00:12:04,288 --> 00:12:05,405
왼쪽에 있는 여섯개의 원소입니다

316
00:12:05,405 --> 00:12:06,785
행렬 A를 가져와서

317
00:12:06,810 --> 00:12:08,564
다른 열벡터를

318
00:12:08,564 --> 00:12:09,793
오른쪽에 붙입니다

319
00:12:09,793 --> 00:12:11,814
이게 A가 보시는 대로

320
00:12:11,814 --> 00:12:16,083
3 x 3 행렬인 이유입니다

321
00:12:16,200 --> 00:12:18,005
마지막으로

322
00:12:18,010 --> 00:12:19,802
이 요령을 가끔 사용합니다

323
00:12:19,810 --> 00:12:22,022
A(:)를 이렇게 하면

324
00:12:22,022 --> 00:12:25,585
특별한 경우의 문법입니다

325
00:12:25,590 --> 00:12:28,695
A에 있는 모든 원소를

326
00:12:28,695 --> 00:12:30,751
하나의 열 벡터에 넣으라는 뜻입니다

327
00:12:30,850 --> 00:12:34,513
9 x 1 벡터를 반환합니다

328
00:12:34,513 --> 00:12:38,584
단순히 다른 원소들을 하나로 합칩니다

329
00:12:39,700 --> 00:12:45,258
몇 가지 예제를 더하자면

330
00:12:45,300 --> 00:12:52,073
A를 1 2 3 4 5 6 로 설정해 봅시다

331
00:12:52,181 --> 00:12:54,035
그리고

332
00:12:54,060 --> 00:12:55,674
B를

333
00:12:55,680 --> 00:12:58,984
11 12 13 14 15 16로 설정합니다

334
00:12:58,984 --> 00:13:00,346
A B로

335
00:13:00,346 --> 00:13:03,161
새로운 행렬을 만들 수 있습니다

336
00:13:03,200 --> 00:13:05,010
이것이 뜻하는 것은

337
00:13:05,080 --> 00:13:06,666
행렬 A

338
00:13:06,666 --> 00:13:08,426
행렬 B가 있고

339
00:13:08,426 --> 00:13:11,053
C를 A, B로 설정합니다

340
00:13:11,070 --> 00:13:12,225
제가 하는 것은

341
00:13:12,225 --> 00:13:15,438
이 두개의 행렬을 가져와서 서로를 연결합니다

342
00:13:15,438 --> 00:13:18,408
왼쪽에는, 행렬 A가 왼쪽이고

343
00:13:18,420 --> 00:13:20,786
행렬 B가 오른쪽에 있습니다

344
00:13:20,800 --> 00:13:23,738
이렇게 두개를 합쳐

345
00:13:23,830 --> 00:13:27,145
행렬 C를 만들었습니다

346
00:13:27,145 --> 00:13:28,927
또한 마찬가지로 C를

347
00:13:28,927 --> 00:13:31,975
A; B로 하고

348
00:13:32,000 --> 00:13:35,552
이 세미콜론 표기는

349
00:13:35,552 --> 00:13:38,881
다음 행렬을 아래에 넣겠다는 의미입니다

350
00:13:38,881 --> 00:13:39,880
그래서

351
00:13:39,910 --> 00:13:41,169
A; B를 합니다

352
00:13:41,170 --> 00:13:42,408
행렬 A 와

353
00:13:42,460 --> 00:13:44,048
B를 합치는데

354
00:13:44,048 --> 00:13:46,408
상하로 연결됩니다

355
00:13:46,408 --> 00:13:49,675
따라서 A가 위, B가 아래이고

356
00:13:49,675 --> 00:13:52,038
C는 이제 6 x 2 행렬입니다

357
00:13:52,038 --> 00:13:54,263
세미콜론은

358
00:13:54,270 --> 00:13:56,705
보통 다음 행으로 가는것을 의미합니다

359
00:13:56,705 --> 00:13:58,463
그래서 C는 A와

360
00:13:58,463 --> 00:13:59,598
그 아래로 가서

361
00:13:59,598 --> 00:14:00,610
아래에 배치된

362
00:14:00,690 --> 00:14:02,320
B로 구성됩니다

363
00:14:02,390 --> 00:14:04,225
[A B]는

364
00:14:04,225 --> 00:14:05,734
[A, B]와 동일합니다

365
00:14:05,750 --> 00:14:09,106
둘 다 같은 결과를 줍니다

366
00:14:10,310 --> 00:14:11,916
이것으로 바라건데

367
00:14:11,916 --> 00:14:14,256
어떻게 행렬을 구성하는지 알고

368
00:14:14,260 --> 00:14:17,207
빠르게 행렬을

369
00:14:17,207 --> 00:14:18,223
만들고

370
00:14:18,223 --> 00:14:19,822
그 행렬을 이용해

371
00:14:19,850 --> 00:14:21,913
합쳐서 더 큰 행렬을 만드는데

372
00:14:21,940 --> 00:14:23,390
사용하는 명령어들을

373
00:14:23,390 --> 00:14:24,984
소개했습니다

374
00:14:25,000 --> 00:14:27,009
단 몇 줄의

375
00:14:27,009 --> 00:14:28,962
코드로요

376
00:14:28,962 --> 00:14:30,770
Octave는

377
00:14:30,770 --> 00:14:32,683
빠르게 복잡한 행렬을 만들고

378
00:14:32,683 --> 00:14:36,033
데이터를 조작한다는 점에서 편리합니다

379
00:14:36,050 --> 00:14:38,027
그래서, 이것이 데이터를 조작하는 방법입니다

380
00:14:38,027 --> 00:14:39,347
다음 비디오에서는

381
00:14:39,347 --> 00:14:40,783
여기서 실제로 우리의 데이터를 가지고

382
00:14:40,860 --> 00:14:46,232
어떻게 복잡한 연산을 하는지에 대해 이야기해 보겠습니다

383
00:14:46,830 --> 00:14:48,256
단 몇 개의 명령어로

384
00:14:48,256 --> 00:14:49,961
어떻게 Octave 에서

385
00:14:49,961 --> 00:14:51,049
빠르게 데이터를 조작하는지

386
00:14:51,049 --> 00:14:54,573
감각을 알게 되었기를 바랍니다

387
00:14:54,590 --> 00:14:56,164
벡터와 행렬을 불러오고 저장하고

388
00:14:56,180 --> 00:14:58,059
데이터도 불러오고 저장합니다

389
00:14:58,090 --> 00:15:00,201
더 큰 행렬을 생성하기 위해

390
00:15:00,201 --> 00:15:02,990
행렬을 만듭니다

391
00:15:02,990 --> 00:15:05,021
행렬에서 특정 원소를 색인하거나 선택합니다

392
00:15:05,021 --> 00:15:06,015
매우 많은 명령어를

393
00:15:06,015 --> 00:15:06,944
다뤘다는 것을 알고 있습니다

394
00:15:06,980 --> 00:15:08,244
제일 좋은 것은

395
00:15:08,244 --> 00:15:09,741
이후에

396
00:15:09,741 --> 00:15:12,248
제가 입력한 스크립트를 보는 것 입니다

397
00:15:12,248 --> 00:15:13,286
여기를 보십시오

398
00:15:13,286 --> 00:15:14,661
이 수업의 사이트를 보고

399
00:15:14,661 --> 00:15:15,927
세션의 스크립트를 다운로드 하세요

400
00:15:15,950 --> 00:15:17,479
스크립트를 살펴보고

401
00:15:17,479 --> 00:15:18,820
Octave에 스스로

402
00:15:18,820 --> 00:15:21,942
명령어들을 입력해 보세요

403
00:15:21,942 --> 00:15:24,752
이 명령어를 가지고 놀고 작동시켜 보세요

404
00:15:24,752 --> 00:15:28,113
분명히, 이 모든 명령어를 외우려는 시도는 의미가 없습니다

405
00:15:28,113 --> 00:15:30,030
당신이 해야 하는 것은 그냥

406
00:15:30,030 --> 00:15:31,852
이 비디오에서

407
00:15:31,852 --> 00:15:32,910
여러분이 할 수 있는 것에 대한

408
00:15:32,910 --> 00:15:35,065
감을 잡았길 바랍니다

409
00:15:35,100 --> 00:15:36,519
그래서 이후에

410
00:15:36,520 --> 00:15:37,902
직접 학습 알고리즘을

411
00:15:37,902 --> 00:15:39,630
짜려고 할 때

412
00:15:39,630 --> 00:15:40,921
Octave에서 가능하다고 생각한

413
00:15:40,930 --> 00:15:42,455
특정 명령어를 찾으려고 노력한다면

414
00:15:42,455 --> 00:15:43,878
왜냐하면

415
00:15:43,878 --> 00:15:45,325
아마도 여기에서 그 명령어를 봤다고 생각하기 때문에

416
00:15:45,325 --> 00:15:47,300
이 세션의 스크립트를 참조해서

417
00:15:47,300 --> 00:15:48,545
사용하길 원하는 명령어를 찾기 위해

418
00:15:48,560 --> 00:15:51,693
훑어보세요

419
00:15:51,693 --> 00:15:53,069
이것이 행렬과 벡터의 곱셈입니다.

420
00:15:53,069 --> 00:15:54,841
데이터를 조작하는 것과

421
00:15:54,841 --> 00:15:56,060
다음 비디오에서는

422
00:15:56,120 --> 00:15:57,699
데이터를 가지고 실제로

423
00:15:57,740 --> 00:15:59,257
어떻게 복잡한 연산을 하는지

424
00:15:59,257 --> 00:16:01,404
그리고

425
00:16:01,410 --> 00:16:03,548
어떻게 데이터를 연산하고

426
00:16:03,550 --> 00:16:04,866
실제로 학습 알고리즘을 실행하는지에 대해

427
00:16:04,866 --> 00:16:06,560
말해보겠습니다