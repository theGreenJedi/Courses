Nesse segundo vídeo sobre Octave, eu gostaria de ensinar como se movimentam dados em Octave. Então, se você tem dados para um problema de aprendizado de máquina, como você faria para carregá-los em Octave? Como colocá-los numa matriz? Como manipular essas matrizes? Como salvar os resultados? Como mover esses dados e operar sobre deles? Aqui está minha janela do Octave como antes, retomando de onde paramos no último vídeo. Se eu digitar A, essa é a matriz que criamos, certo, com o comando A = [1 2; 3 4; 5 6], com o comando A = [1 2; 3 4; 5 6], que é uma matriz 3x2. O comando 'size' em Octave diz qual o tamanho da matriz. Então size(A) retornará [3 2]. Desse modo, o comando size na realidade está retornando uma matriz 1x2. Então você consegue definir sz =  size(A) e sz é agora uma matriz 1x2 onde o primeiro elemento é três, e o segundo elemento é dois. Então, se você digitar size(sz), sz é uma matriz 1x2 onde os dois elementos contém as dimensões de A. Você também pode digitar size(A,1) que retornará o tamanho da primeira dimensão de A, dimensão de A, que é o número de linhas, e size(A,2) retornará 2, que é o número de colunas da matriz A. 
Se você tiver um vetor v, digamos que v = [1 2 3 4] e você digitar v = [1 2 3 4] e você digitar length(v), a função retornará o tamanho da maior dimensão. Então você também pode digitar length(A) e como A é uma matriz 3x2, a dimensão mais longa tem tamanho 3, a função deveria imprimir 3. Mas normalmente nós usamos 'length' apenas com vetores, ou seja, length([1; 2; 3; 4; 5]) em vez de ou seja, length([1; 2; 3; 4; 5]) em vez de aplicar length em matrizes, por ser um pouco mais confuso. Agora, vamos dar uma olhada em como carregar dados e encontrar dados no sistema de arquivos. Quando abrimos o Octave nós normalmente estamos na na pasta referente ao local onde o Octave foi instalado. Então, o comando 'pwd' mostra a pasta atual, o caminho até o Octave. Agora nós estamos em um diretório meio obscuro. O comando 'cd' vem de "change directory" (mudar diretório), então eu posso ir para C:\Users\ang\Desktop e agora eu estou no meu desktop e se eu digitar 'ls', onde ls é um comando que vem do Unix e Linux, 'ls' listará os diretórios na minha área de trabalho e esses são os arquivos que estão na minha área de trabalho nesse momento. Na minha área de trabalho existem dois arquivos: 'featuresX' e 'priceY', que talvez tenham vindo de algum problema de aprendizado de máquina que eu tentei resolver. Então essa é minha área de trabalho. Aqui está featuresX, que é esse arquivo com duas colunas de dados. Esses são na realidade meus dados de preços de casas. Acho que eu tenho 47 linhas nesse conjunto de dados. A primeira casa tem tamanho 240 pés quadrados, com três banheiros. A segunda casa tem 1600 pés quadrados, com 3 banheiros, e assim por diante. E priceY é este arquivo que contém os preços dos meus dados no conjunto de treino. Então, featuresX e priceY nada mais são que arquivos de texto com meus dados. Como eu carrego esses dados no Octave? Eu apenas escrevo o comando load featuresX.dat e se eu fizer isso eu vou carregar featuresX e posso carregar também priceY.dat. Na verdade, existem várias maneiras de se fazer isso. Nesse comando, se você colocar load('featuresX.dat') e carregar desse jeito, opa, faltou o 's', Esse é um comando equivalente. Então você pode colocar o nome do arquivo numa string em Octave, usando apóstrofes para representar strings, desse jeito. Então isso é uma string, e nós conseguimos carregar o arquivo cujo nome é dado por essa string. O comando 'who' me mostra quais variáveis estão presentes minha área de trabalho do Octave. Então who me mostra quais as variáveis que o Octave tem atualmente na memória. featuresX e priceY estão entre delas, assim como as variáveis que criamos mais cedo neste vídeo. Então eu posso digitar featuresX para mostrar featuresX. Aqui estão meus dados. E eu consigo também digitar size(featuresX) que mostrará que é uma matriz 47x2. E da mesma maneira, size(priceY) me dirá que priceY é um vetor 47x1 Isso é um vetor com 47 dimensões. isso é um vetor coluna que contem todos os preços no meu conjunto de treino. A função who mostra os todos os valores que estão na área de trabalho atual. Existe também o comando 'whos' que dá uma visão mais detalhada. Então esse comando com 's' no final também lista minha variáveis, mas agora ele também mostra os tamanhos. Então A é uma matriz 3x2 e featuresX é uma matriz 47x2. priceY é uma matriz 47x1, ou seja, é apenas um vetor. Aqui mostra a memória em bytes sendo usada, assim como o tipo dos dados. Double significa ponto flutuante com dupla precisão, o que indica que são valores reais. Agora, se você quiser se livrar de uma variável você pode usar o comando 'clear'. Então, 'clear featuresX' e digite whos novamente. Você verá que a variável featuresX desapareceu. E como salvamos os dados? Veremos. Vamos pegar a variável v e e atribuir priceY(1:10) Isso atribui a v os 10 primeiros elementos do vetor Y. Então vamos digitar who ou whos. Onde priceY era um vetor 47x1, v é agora 10x1, porque v = priceY(1:10) atribui a v apenas os 10 primeiros elementos de priceY. 10 primeiros elementos de priceY. Digamos que eu queira salvar os dados em disco. Posso usar o comando 'save hello.mat v', que irá salvar a variável v em um arquivo chamado hello.mat. Então, vamos fazer isso. E agora um arquivo apareceu na minha área de trabalho, chamado hello.mat. Como eu tenho MATLAB instalado no Windows, este ícone tem essa aparência por que o Windows reconheceu a extensão como um arquivo MATLAB, mas não se preocupe se esse arquivo tiver um ícone diferente no seu computador. Se eu remover todas as minhas variáveis, se eu digitar 'clear', sem nenhum parâmetro, ele remove tudo na área de trabalho, eu não vou ter mais nada na minha área de trabalho. E se eu carregar hello.mat eu consigo de volta minha variável v, que são os dados que eu salvei previamente no arquivo hello.mat. Então, o que acabamos de fazer foi 'save hello.mat v', que salva o dados em formato binário, um formato de arquivo mais comprimido. Então se v tiver muita informação, isso irá comprimir melhor os dados. Irá utilizar menos espaço. Se você quiser salvar seus dados em um formato mais legível por humanos então seria melhor usar 'save hello.txt v -ASCII'. Esse comando salvará como texto, como formato de texto ASCII. E, tendo feito isso, eu obtenho esse arquivo. hello.txt acabou de aparecer na minha área de trabalho, e se eu abri-lo, eu vejo que é um arquivo de texto com todos os meus dados salvos. Então é assim que você carrega e salva dados. Agora vamos conversar um pouco sobre como manipular dados. Vamos definir A como aquela matriz 3x2. Com relação a indexação. Se eu digitar A(3,2) Isso indexa o elemento (3,2) da matriz A. Assim, isso é o que normalmente escreveríamos como A₃₂ como A₃₂ como A₃₂ que acessa o elemento da terceira linha e segunda coluna de A, que é o elemento 6. E posso também digitar A(2,:) para buscar toda a segunda linha. Então, os dois pontos significam todos os elementos ao longo daquela linha ou coluna Então A(2,:) é a segunda linha de A. E, similarmente, se eu fizer A(:,2) isso irá me retornar toda a segunda coluna de A, que é [2; 4; 6]. Isso significa Tudo da segunda coluna de A. Então é essa minha segunda coluna de A, que é [2; 4; 6]. Agora, você também consegue usar operações de indexação mais sofisticadas. Vou mostrar um exemplo rápido. E você provavelmente usará isso com menos frequência, mas vamos digitar A([1 3], :). Isso significa pegar todos os elementos de A cujos primeiros índices sejam 1 ou 3. Ou seja, significa pegar tudo da primeira e terceira linhas de A de todas as colunas. de A de todas as colunas. Então, essa era a matriz A, e A([1 3], :) retorna tudo da primeira linha e da terceira linha, e da terceira linha, e os dois pontos significam tanto a primeira quanto a segunda colunas e isso me dará [1 2; 5 6]. Embora você use essa forma de operações de indexação mais sofisticadas menos frequentemente, quero mostrar o que mais elas podem fazer. Aqui está a matriz A e A(:, 2) me retornará a segunda coluna. Você também pode usar isso para atribuições, então eu posso pegar a segunda coluna de A e atribuir a ela [10 11 12], e se eu fizer isso, pegar a segunda coluna de A e atribuir a ela o vetor coluna [10 11 12], a matriz agora será [1 3 5] e a segunda coluna será substituída por [10 11 12]. Mais uma operação. Vamos definir A como A = [A, [100, 101, 102 ]], dessa maneira e isso irá anexar outro vetor coluna à direita. Opa, eu acho que cometi um pequeno erro, Deveria ter posto ponto e vírgulas aqui, então A agora é igual a isso. OK? Espero que isso faça sentido. Então [100 101 102] é um vetor coluna, e o que fizemos foi pegar A e atribuir a ela sua definição original, mais esse vetor coluna à direita e acabamos pegando a matriz A, que antes tinha 6 elementos, pegamos essa matriz e anexamos um outro vetor coluna a direita, por isso agora A é uma matriz 3x3 dessa forma. E finalmente, um truque legal que eu uso as vezes é fazer A(:) Isso é de certa forma um caso especial de sintaxe. O que isso faz é colocar todos os elementos de A em um único vetor coluna, um vetor 9x1 com todos os valores de A em sequência. Mais alguns exemplos. Digamos que A seja igual a [1 2; 3 4; 5 6] e digamos que B seja igual a [11 12; 13 14; 15 16]. Eu posso criar uma nova matriz C = [A B] Isso representa pegar matriz A, pegar a matriz B e atribuir a C o valor de [A B]. O que estou fazendo é pegar essas duas matrizes e concatenando-as. Então, eu tenho a matriz A à esquerda e a matriz B à direita. E assim eu criei essa matriz C, juntando as duas. Também consigo fazer C = [A; B]. Ponto e vírgula significa colocar o próximo termo embaixo. Então, eu faria C = [A; B] . Isso também junta as matrizes A e B exceto que agora uma fica em cima da outra. Agora eu tenho A em cima de B e C é uma matriz 6x2. Então, o ponto e vírgula geralmente significa ir para a próxima linha. Então, C é formado por A e então vá para baixo e coloque B embaixo. Aliás, [A B] é igual a [A, B] e ambas nos dão o mesmo resultado. Com isso, eu espero que você saiba como construir matrizes e eu começarei a mostrar alguns dos comandos que você usará para rapidamente colocar matrizes e buscar matrizes e juntá-las para formar matrizes maiores, e com apenas algumas linha de código, Octave é bastante conveniente com relação ao quão rápido nós podemos montar matrizes complexas e movimentar dados. Então, isso é tudo sobre movimentação de dados. No próximo vídeo, começaremos a conversar sobre como fazer operações complexas sobre os nossos dados. Então, eu espero que isso lhe dê uma noção de como, com apenas alguns comandos simples, você pode mover dados em Octave. Você carrega e salva vetores e matrizes, carrega e salva dados, junta matrizes para criar matrizes maiores, indexa ou seleciona elementos específicos nas matrizes. Eu sei que mencionei muitos comandos, então eu acho que a melhor coisa a se fazer é depois dar uma olhada nas anotações do que eu estava digitando. Dê uma olhada nisso. Abra o site do curso e baixe as anotações da sessão e dê uma olhada nas anotações, e tente alguns dos comandos você mesmo, e comece a brincar com esses comandos e fazê-los funcionar. E obviamente, não tem por que tentar memorizar todos esses comandos. O que você deveria fazer é, eu espero que com esses videos você tenha tido uma noção do que você consegue fazer, de forma que mais tarde quando você esteja tentando programar um  algoritmo de aprendizagem por você mesmo, você esteja tentando encontrar um comando específico talvez você lembre que Octave consegue fazer isso por ter visto aqui, você deveria se dirigir às anotações da sessão e dar uma olhada para encontrar o comando que você queria usar. Então, isto é tudo para como mover dados e no próximo vídeo eu gostaria de começar a conversar sobre como exatamente realizar operações complexas nos nossos dados, e como operar sobre os dados, e realmente começar a implementar algoritmos de aprendizagem.
Tradução: Eduardo Bonet | Revisão: Marcel Dall'Agnol