En este video, me gustaría hablarte sobre la idea de vectorización. Entonces, ya sea que estés usando Octave o un lenguaje similar como MATLAB, o si estás usando Python y NumPy o Java, C, C++. Todos estos lenguajes tienen integrado o tienen a la mano diferentes librerías numéricas de álgebra lineal. Generalmente están muy bien escritas, altamente optimizadas y, a menudo, han sido desarrolladas por personas que, ya sabes, tienen doctorados en computación numérica o que realmente se han especializado en computación numérica. Y cuando estás implementando algoritmos de aprendizaje automático, si puedes aprovechar estas librerías de álgebra lineal o de estas librerías numéricas de álgebra lineal y combinar las llamadas de rutina para ellas en lugar de llamarlas tú mismo para hacer cosas que esas librerías podrían estar haciendo. Si haces eso, entonces, con frecuencia, llegas a la conclusión de que, primero, es más eficiente. O sea, sencillamente se ejecuta más rápido y aprovecha mejor cualquier hardware paralelo que tu computadora pueda tener, y así. Y, segundo, también significa que terminarás con menos código del que necesitas escribir. Y también tiene una implementación más simple, es decir, que probablemente tenga menos errores. Y como ejemplo concreto, en lugar de escribir el código tú mismo para multiplicar matrices, si dejas que Octave lo haga ingresando a por b, usará una rutina muy eficiente para multiplicar las 2 matrices. Y hay un montón de ejemplos como cuando usas las implementaciones vectorizadas apropiadas. Obtienes un código mucho más simple y mucho más eficiente. Veamos algunos ejemplos. Aquí hay una hipótesis usual de regresión lineal, y si quisieras calcular H de X, nota que hay una suma a la derecha,. Y una cosa que podrías hacer es calcular tu mismo la suma de J igual a 0 a J igual a N. Otra form de ver esto es ver H de X como «theta» transpuesta de X, y lo que puedes hacer es pensar en esto como, ya sabes, calcular esto en un producto entre 2 vectores en donde «theta» es, ya sabes, tu vector, digamos, «theta» 0, «theta» 1, «theta» 2, si tienes 2 variables. Si N igual a 2 y si piensas en X como este vector X0, X1, X2 y estas 2 visualizaciones pueden darte 2 diferentes implementaciones. Esto es lo que quiero decir. Aquí hay una implementación no vectorizada para cómo calcular H de X sin una vectorización, quiero decir, sin vectores. Primero podemos inicializar, ya sabes, que la predicción sea 0.0. Esto, eventualmente, va a ser voy a hacer un ciclo for para H de X, y luego voy a hacer un ciclo for para J igual a 1 hasta n+1. La predicción se incrementa en «theta» J veces XJ. Entonces, es como esta expresión aquí., Por cierto, debo mencionar que en estos vectores de aquí, estos vectores comenzaron con el índice 0. Entonces, si tengo «theta» 0 «theta» 1, «theta» 2, dado que MATLAB es un índice, «theta» 0 en MATLAB, podríamos terminar representando como «theta» 1 y este segundo elemento termina siendo «theta» 2 y este tercer elemento puede terminar siendo «theta» 3 sólo porque los vectores en MATLAB están indexados comenzando desde 1, aunque nuestro «theta» y X reales comiencen a ser indexados desde 0, y es por eso que tengo un ciclo for J que va desde 1 hasta n+1 en lugar de J hasta 0 hasta n, ¿cierto? Pero entonces, esta es una implementación no vectorizada en la que tenemos un ciclo for para la sumatoria de los n elementos de la suma. En contraste, así es como se escribe una implementación vectorizada, que es en la que podrías pensar en X de «theta» como vectores, y sólo se establece que la predicción es igual a «theta» transpuesta por X. Sólo estás calculando así. En lugar de escribir todas estas líneas de código para el ciclo for, sólo tienes una línea de código, y lo que esta línea de código en la derecha, hará, será usar las altamente optimizadas rutinas algebraicas de Octave para calcular su producto interior entre los dos vectores, «theta» y X.
Y la implementación vectorizada no es sólo más simple, sino que también se ejecutará más eficientemente. Entonces, eso fue Octave, pero el problema de la vectorización aplica a otros lenguajes de programación también. Veamos un ejemplo en C++. Así es como se podría ver una implementación no vectorizada. Nuevamente, inicializamos la predicción, ya sabes, para 0.0 y ahora tenemos un ciclo for completo para J0 hasta N.  Predicción + es igual a «theta» K veces XJ, en donde, nuevamente, tienes este x+ para el ciclo for que escribiste tú mismo. En contraste, usando una buena librería numérica de álgebra lineal en C++, te podría servir escribir la función o, en cambio, En contraste, usando una buena librería numérica de álgebra lineal en C++, puedes escribir código que puede verse así. Entonces, dependiendo de los detalles de tu librería numérica de álgebra lineal, puedes ser capaz de tener un objeto que sea un objeto de C++, que es vector «theta» y un objeto C++ que es un vector X, y sólo tomas el «theta»q punto transpuesto por X en donde esta multiplicación se vuelve C++ para sobrecargar al operador, de forma que puedes sólo multiplicar estos vectores en C++. Y, dependiendo de, ya sabes, los detalles de tu librería numérica de álgebra lineal, puedes terminar usando una sintaxis ligeramente diferente, pero dependiendo de una librería para hacer esto en un producto. Puedes obtener una pieza mucho más simple de código y mucho más eficiente. Ahora veamos un ejemplo más sofisticado. Sólo como recordatorio, aquí está nuestra regla e actualización para el gradiente de descenso para una regresión lineal y, así, actualizamos «theta» J usando esta regla para todos los valores de j Igual a 0, 1, 2 y así sucesivamente. Y si sólo escribo estas ecuaciones para «theta» 0, «theta» 1, «theta» 2. Asumiendo que tengo dos variables. Entonces N es igual a 2. Entonces estas son las actualizaciones que realizamos a «theta» 0, «theta» 1, «theta» 2, y puedes recordar lo que dije en un video anterior, sobre que estas deberían ser actualizaciones simultáneas. Entonces, veamos si podemos desarrollar una implementación vectorizada de esto. Aquí están mis mismas 3 ecuaciones escritas en una fuente ligeramente más pequeña y puedes imaginar que 1 espera para implementar estas tres líneas de código, es para tener un ciclo for que diga, ya sabes, J igual a 0, 1 hasta 2, la actualización «theta» J o algo parecido. Pero, en cambio, vamos a desarrollar una implementación vectorizada y veamos si encontramos una forma más simple. Entonces, básicamente hay que comprimir estas tres líneas de código, o un