1
00:00:00,180 --> 00:00:01,178
在这段视频中

2
00:00:01,178 --> 00:00:02,587
告诉你怎样

3
00:00:02,600 --> 00:00:03,842
为你的 Octave 程序写控制语句

4
00:00:03,842 --> 00:00:05,672
诸如

5
00:00:05,700 --> 00:00:07,280
"for" "while" "if" 这些语句

6
00:00:07,350 --> 00:00:12,176
并且如何定义和使用方程

7
00:00:12,480 --> 00:00:13,980
这是我们的 Octave 窗口

8
00:00:13,980 --> 00:00:16,502
我先告诉你如何使用 “for” 循环

9
00:00:16,502 --> 00:00:17,888
首先 我要将 v 值设为

10
00:00:17,888 --> 00:00:18,852
一个10行1列

11
00:00:18,870 --> 00:00:20,808
的零向量

12
00:00:20,830 --> 00:00:22,209
现在 我要写一个 “for" 循环

13
00:00:22,240 --> 00:00:25,071
让 i 等于 1 到 10

14
00:00:25,090 --> 00:00:27,608
写出来就是 i = 1:10

15
00:00:27,608 --> 00:00:29,905
让我们来看看

16
00:00:29,905 --> 00:00:31,466
我要设 v(i) 的值

17
00:00:31,466 --> 00:00:33,214
等于 2 的 i 次方

18
00:00:33,220 --> 00:00:36,848
循环最后

19
00:00:36,848 --> 00:00:37,671
结束 (end)

20
00:00:37,671 --> 00:00:39,082
这里的空格没关系

21
00:00:39,090 --> 00:00:40,538
所以我就加一些空格

22
00:00:40,538 --> 00:00:41,960
让缩进后的代码看起来结构更清晰

23
00:00:41,990 --> 00:00:44,385
但是你要知道这里的空格没有意义

24
00:00:44,420 --> 00:00:46,163
如果按我这样做 那么

25
00:00:46,163 --> 00:00:48,626
向量 v 的值就是

26
00:00:48,626 --> 00:00:49,420
这样一个集合 2的一次方

27
00:00:49,500 --> 00:00:51,478
2的二次方 依此类推

28
00:00:51,490 --> 00:00:52,665
于是这就是我的 i 等于 1 到 10

29
00:00:52,665 --> 00:00:55,410
的语句结构

30
00:00:55,410 --> 00:00:57,429
让 i 遍历 1 到 10

31
00:00:57,440 --> 00:00:59,662
的值

32
00:00:59,662 --> 00:01:00,830
另外 你还可以通过

33
00:01:00,830 --> 00:01:02,481
设置你的 indices (索引) 等于 1

34
00:01:02,481 --> 00:01:04,795
一直到10

35
00:01:04,800 --> 00:01:07,260
来做到这一点

36
00:01:07,270 --> 00:01:09,305
这时 indices 就是一个从1到10的序列

37
00:01:09,305 --> 00:01:13,249
你也可以写 i = indices

38
00:01:15,040 --> 00:01:17,805
这实际上和我直接把 i 写到 1 到 10 是一样

39
00:01:17,820 --> 00:01:19,459
你可以写 disp(i)

40
00:01:19,480 --> 00:01:23,498
也能得到一样的结果

41
00:01:23,498 --> 00:01:24,698
所以 这就是一个 “for” 循环

42
00:01:24,698 --> 00:01:27,201
如果你对 “break” 和 “continue” 语句比较熟悉

43
00:01:27,230 --> 00:01:29,375
Octave里也有 “break” 和 “continue” 语句

44
00:01:29,375 --> 00:01:30,809
你也可以在 Octave环境里

45
00:01:30,809 --> 00:01:32,061
使用那些循环语句

46
00:01:32,061 --> 00:01:33,902
但是首先让我告诉你

47
00:01:33,902 --> 00:01:36,550
一个 while 循环是如何工作的

48
00:01:36,570 --> 00:01:39,088
这是我的 v 向量

49
00:01:39,120 --> 00:01:40,912
让我们写个 while 循环

50
00:01:40,920 --> 00:01:44,037
i = 1 ;

51
00:01:44,037 --> 00:01:45,259
while i <= 5 ;

52
00:01:45,259 --> 00:01:47,662
让我们设置

53
00:01:47,662 --> 00:01:51,082
v(i) 等于 100

54
00:01:51,530 --> 00:01:54,449
然后 i 加 1

55
00:01:54,449 --> 00:01:56,644
结束 (end)

56
00:01:56,700 --> 00:01:58,090
所以这是什么意思呢

57
00:01:58,090 --> 00:01:59,932
我让 i 取值从 1 开始

58
00:01:59,970 --> 00:02:01,359
然后我要

59
00:02:01,380 --> 00:02:02,629
让 v(i) 等于 100

60
00:02:02,629 --> 00:02:04,249
再让 i 递增 1

61
00:02:04,260 --> 00:02:07,666
直到 i 大于 5停止

62
00:02:07,690 --> 00:02:09,377
现在来看一下结果

63
00:02:09,377 --> 00:02:13,022
原来的向量 v 是2的这些次方

64
00:02:13,022 --> 00:02:14,573
我现在已经取出了

65
00:02:14,580 --> 00:02:17,225
向量的前五个元素

66
00:02:17,260 --> 00:02:19,618
把他们用100覆盖掉

67
00:02:19,618 --> 00:02:22,797
这就是一个while循环的句法结构

68
00:02:23,140 --> 00:02:24,503
现在我们来分析另外一个例子

69
00:02:24,503 --> 00:02:26,600
i = 1; while true,

70
00:02:26,600 --> 00:02:28,491
这里我将向你展示

71
00:02:28,500 --> 00:02:31,892
如何使用break语句

72
00:02:31,892 --> 00:02:34,040
比方说 v(i) = 999

73
00:02:34,070 --> 00:02:37,331
然后让 i = i+1

74
00:02:38,110 --> 00:02:45,900
当 i 等于6的时候 break (停止循环)

75
00:02:47,910 --> 00:02:47,910
结束 (end)

76
00:02:48,410 --> 00:02:49,425
当然这也是我们第一次

77
00:02:49,425 --> 00:02:51,945
使用一个 if 语句 所以

78
00:02:51,945 --> 00:02:53,308
我希望你们可以理解这个逻辑

79
00:02:53,308 --> 00:02:57,297
让 i 等于1 然后开始下面的增量循环

80
00:02:57,340 --> 00:02:59,900
while语句重复设置 v(i) 等于1 (此处口误 应为999 译者注)

81
00:02:59,900 --> 00:03:01,527
不断让i增加

82
00:03:01,527 --> 00:03:02,901
然后当 i 达到6

83
00:03:02,920 --> 00:03:04,451
做一个

84
00:03:04,451 --> 00:03:05,757
中止循环的命令

85
00:03:05,757 --> 00:03:07,284
尽管有while循环 语句也就此中止

86
00:03:07,284 --> 00:03:08,596
所以最后的效果是

87
00:03:08,596 --> 00:03:09,929
取出向量 v 的前5个元素

88
00:03:09,929 --> 00:03:11,748
并且把它们设置为999

89
00:03:11,748 --> 00:03:14,832
然后运行 的确如此

90
00:03:14,832 --> 00:03:18,345
我们用999覆盖了 v 的前五个元素

91
00:03:18,345 --> 00:03:20,172
所以 这就是

92
00:03:20,172 --> 00:03:21,974
if 语句和 while 语句的句法结构

93
00:03:21,974 --> 00:03:25,058
并且要注意 要有end

94
00:03:25,070 --> 00:03:27,159
这里是有两个 end 的

95
00:03:27,170 --> 00:03:29,719
这里的 end 结束的是 if 语句

96
00:03:29,730 --> 00:03:33,228
第二个 end 结束的是 while 语句

97
00:03:33,250 --> 00:03:35,265
现在让我告诉你使用 if-else 语句时

98
00:03:35,265 --> 00:03:37,763
更一般的句法结构

99
00:03:37,763 --> 00:03:40,274
举个例子 v(1)

100
00:03:40,274 --> 00:03:42,776
等于999 假设我们

101
00:03:42,860 --> 00:03:46,996
令 v(1) 等于2

102
00:03:47,020 --> 00:03:48,758
所以 让我输入

103
00:03:48,758 --> 00:03:55,050
if v(1) == 1, disp('The value is one');

104
00:03:56,855 --> 00:03:58,588
这里出现了一个else语句

105
00:03:58,588 --> 00:04:00,040
或者更确切地说 这里是一个

106
00:04:00,040 --> 00:04:03,853
elseif语句 elseif v(1) == 2,

107
00:04:03,853 --> 00:04:07,815
这就是说 如果这种情况下命题为真

108
00:04:07,815 --> 00:04:12,268
执行 disp('The value is two');

109
00:04:13,650 --> 00:04:17,960
否则(else) 执行 disp('The value is not one or two');

110
00:04:17,990 --> 00:04:21,699
好了 这就是一个if-else语句

111
00:04:21,700 --> 00:04:23,889
if-else语句 记得最后有end

112
00:04:23,889 --> 00:04:25,271
当然了 我们刚刚设置过

113
00:04:25,271 --> 00:04:27,589
v(1)等于2 所以显然

114
00:04:27,610 --> 00:04:30,729
显示的是 "The value is two"

115
00:04:30,780 --> 00:04:32,844
最后 我觉得现在

116
00:04:32,880 --> 00:04:34,143
提醒一件事

117
00:04:34,143 --> 00:04:35,622
如果你需要退出 Octave

118
00:04:35,622 --> 00:04:36,947
你可以键入 exit 命令然后

119
00:04:36,947 --> 00:04:38,373
回车就会退出 Octave

120
00:04:38,400 --> 00:04:39,981
或者命令 ‘quit’

121
00:04:39,981 --> 00:04:42,428
也可以

122
00:04:42,450 --> 00:04:43,857
最后 让我们来说说

123
00:04:43,857 --> 00:04:45,292
函数 (functions)

124
00:04:45,310 --> 00:04:48,592
如何定义和调用函数

125
00:04:48,620 --> 00:04:49,680
这是我的桌面

126
00:04:49,720 --> 00:04:52,078
我在桌面上存了一个

127
00:04:52,078 --> 00:04:56,818
预先定义的文件 名为 “squarethisnumber.m”

128
00:04:56,830 --> 00:04:59,471
这就是在 Octave 环境下定义的函数

129
00:04:59,480 --> 00:05:01,681
你需要创建一个文件

130
00:05:01,681 --> 00:05:03,958
用你的函数名来命名 然后以 .m 的后缀结尾

131
00:05:03,960 --> 00:05:05,694
当 Octave 发现这文件

132
00:05:05,730 --> 00:05:07,643
它知道应该在什么位置

133
00:05:07,680 --> 00:05:12,322
寻找 squareThisNumber.m 这个函数的定义

134
00:05:12,340 --> 00:05:14,076
让我们打开这个文件

135
00:05:14,076 --> 00:05:15,717
请注意 我使用的是

136
00:05:15,717 --> 00:05:19,352
微软的写字板程序来打开这个文件

137
00:05:19,352 --> 00:05:20,250
我只是想建议你

138
00:05:20,250 --> 00:05:23,379
如果你也使用微软的 Windows 系统

139
00:05:23,379 --> 00:05:25,075
那么可以使用写字板程序

140
00:05:25,110 --> 00:05:27,477
而不是记事本 来打开这些文件

141
00:05:27,490 --> 00:05:28,557
如果你有别的什么

142
00:05:28,557 --> 00:05:29,938
文本编辑器 那也可以

143
00:05:29,938 --> 00:05:33,325
但记事本有时会把代码的间距弄得很乱

144
00:05:33,350 --> 00:05:34,775
如果你只有记事本程序

145
00:05:34,800 --> 00:05:36,312
那也能用

146
00:05:36,312 --> 00:05:37,779
但最好是

147
00:05:37,779 --> 00:05:39,354
如果你有写字板的话

148
00:05:39,354 --> 00:05:40,609
我建议你用写字板

149
00:05:40,610 --> 00:05:45,053
或者其他可以编辑函数的文本编辑器

150
00:05:45,060 --> 00:05:47,155
现在我们来说如何在 Octave 里定义函数

151
00:05:47,155 --> 00:05:49,816
我们先来放大一点

152
00:05:49,816 --> 00:05:52,516
这个文件只有三行

153
00:05:52,516 --> 00:05:54,440
第一行写着 function y = squareThisNumber(x)

154
00:05:54,440 --> 00:05:56,448
这就告诉 Octave

155
00:05:56,448 --> 00:05:57,705
我想返回一个 y 值

156
00:05:57,705 --> 00:06:00,025
我想返回一个值

157
00:06:00,025 --> 00:06:01,315
并且返回的这个值

158
00:06:01,315 --> 00:06:02,375
将被存放于

159
00:06:02,375 --> 00:06:04,443
变量 y 里

160
00:06:04,443 --> 00:06:06,003
另外 它告诉了 Octave

161
00:06:06,003 --> 00:06:08,068
这个函数有一个参数

162
00:06:08,070 --> 00:06:10,408
就是参数 x

163
00:06:10,420 --> 00:06:11,846
还有定义的函数体

164
00:06:11,846 --> 00:06:15,156
也就是 y 等于 x 的平方

165
00:06:15,180 --> 00:06:16,553
现在让我们尝试调用这个函数

166
00:06:16,553 --> 00:06:19,071
SquareThisNumber(5)

167
00:06:19,071 --> 00:06:21,854
这实际上

168
00:06:21,854 --> 00:06:23,115
是行不通的

169
00:06:23,115 --> 00:06:25,693
Octave 说这个方程未被定义

170
00:06:25,693 --> 00:06:28,902
这是因为 Octave 不知道在哪里找这个文件

171
00:06:28,902 --> 00:06:30,682
所以像之前一样 我们​​使用 pwd

172
00:06:30,690 --> 00:06:32,592
现在不在我的目录下

173
00:06:32,592 --> 00:06:36,151
因此我们把路径设为 "C:\User\ang\desktop"

174
00:06:36,151 --> 00:06:39,888
这就是我的桌面的路径

175
00:06:39,888 --> 00:06:41,276
噢 打错了

176
00:06:41,276 --> 00:06:42,848
应该是 "Users"

177
00:06:42,848 --> 00:06:44,157
现在如果我

178
00:06:44,157 --> 00:06:46,728
键入SquareThisNumber(5)

179
00:06:46,728 --> 00:06:48,505
返回值是25

180
00:06:48,505 --> 00:06:50,347
还有一种更高级的功能

181
00:06:50,347 --> 00:06:51,972
这只是对那些知道

182
00:06:51,972 --> 00:06:54,596
“search path (搜索路径)” 这个术语的人使用的

183
00:06:54,596 --> 00:06:55,945
所以如果你

184
00:06:55,945 --> 00:06:57,497
想要修改 Octave

185
00:06:57,497 --> 00:06:58,863
的搜索路径

186
00:06:58,863 --> 00:06:59,866
你可以把下面这部分

187
00:06:59,866 --> 00:07:01,827
作为一个进阶知识

188
00:07:01,827 --> 00:07:03,292
或者选学材料

189
00:07:03,292 --> 00:07:04,214
仅适用于那些

190
00:07:04,214 --> 00:07:05,484
熟悉编程语言中

191
00:07:05,484 --> 00:07:07,642
搜索路径概念的同学

192
00:07:07,650 --> 00:07:08,962
你可以使用

193
00:07:08,962 --> 00:07:11,875
addpath 命令添加路径

194
00:07:11,880 --> 00:07:16,241
添加路径 “C:\Users\ang\desktop”

195
00:07:16,241 --> 00:07:17,972
将该目录添加到

196
00:07:17,972 --> 00:07:19,744
Octave 的搜索路径

197
00:07:19,744 --> 00:07:21,065
这样即使你跑到

198
00:07:21,065 --> 00:07:22,611
其他路径底下

199
00:07:22,611 --> 00:07:24,510
Octave依然知道

200
00:07:24,510 --> 00:07:26,005
会在 Users\ang\desktop

201
00:07:26,005 --> 00:07:29,214
目录下寻找函数

202
00:07:29,214 --> 00:07:30,521
这样 即使我现在

203
00:07:30,521 --> 00:07:31,868
在不同的目录下 它仍然

204
00:07:31,868 --> 00:07:35,297
知道在哪里可以找到 “SquareThisNumber” 这个函数

205
00:07:35,297 --> 00:07:35,935
明白?

206
00:07:35,935 --> 00:07:37,407
但是 如果你不熟悉

207
00:07:37,407 --> 00:07:39,184
搜索路径的概念

208
00:07:39,184 --> 00:07:40,068
不用担心

209
00:07:40,068 --> 00:07:40,889
只要确保

210
00:07:40,889 --> 00:07:42,053
在执行函数之前 先用 cd 命令

211
00:07:42,053 --> 00:07:43,926
设置到你函数所在的目录下

212
00:07:43,940 --> 00:07:47,441
实际上也是一样的效果

213
00:07:47,441 --> 00:07:49,587
Octave 还有一个

214
00:07:49,600 --> 00:07:51,058
其他许多编程语言都没有的概念

215
00:07:51,058 --> 00:07:52,969
那就是它可以

216
00:07:52,969 --> 00:07:54,909
允许你定义一个函数

217
00:07:54,909 --> 00:07:58,873
使得返回值是多个值或多个参数

218
00:07:58,873 --> 00:08:00,889
这是一个例子

219
00:08:00,889 --> 00:08:02,931
定义一个函数叫

220
00:08:02,931 --> 00:08:04,964
“SquareAndCubeThisNumber(x)” (x的平方以及x的立方)

221
00:08:04,964 --> 00:08:06,644
这说的就是

222
00:08:06,660 --> 00:08:08,547
函数返回值是两个 y1 和 y2

223
00:08:08,547 --> 00:08:09,955
接下来就是

224
00:08:09,960 --> 00:08:13,603
y1是被平方后的数 y2是被立方后的结果

225
00:08:13,603 --> 00:08:16,972
这就是说 函数会真的返回2个值

226
00:08:16,980 --> 00:08:18,855
所以 有些同学可能会根据

227
00:08:18,855 --> 00:08:20,195
你使用的编程语言

228
00:08:20,195 --> 00:08:22,931
比如你们可能熟悉的C或C++

229
00:08:22,940 --> 00:08:26,051
通常情况下 认为作为函数返回值只能是一个值

230
00:08:26,051 --> 00:08:27,847
但 Octave 的语法结构就不一样

231
00:08:27,847 --> 00:08:31,679
可以返回多个值

232
00:08:32,430 --> 00:08:34,087
现在回到 Octave 窗口

233
00:08:34,087 --> 00:08:37,914
如果我键入

234
00:08:37,914 --> 00:08:41,263
[a,b] = SquareAndCubeThisNumber(5)

235
00:08:41,263 --> 00:08:44,599
然后

236
00:08:44,610 --> 00:08:46,338
a 就等于25

237
00:08:46,338 --> 00:08:47,778
b 就等于

238
00:08:47,778 --> 00:08:49,729
5的立方 125

239
00:08:49,729 --> 00:08:51,645
所以说如果你需要定义一个函数

240
00:08:51,670 --> 00:08:53,010
并且返回多个值

241
00:08:53,010 --> 00:08:56,447
这一点常常会带来很多方便

242
00:08:56,447 --> 00:08:57,480
最后 我来给大家演示一下

243
00:08:57,480 --> 00:09:01,123
一个更复杂一点的函数的例子

244
00:09:01,130 --> 00:09:02,361
比方说 我有一个数据集

245
00:09:02,370 --> 00:09:04,400
像这样 数据点为[1,1], [2,2], [3,3]

246
00:09:04,430 --> 00:09:07,636
我想做的事是

247
00:09:07,636 --> 00:09:09,113
定义一个 Octave 函数来计算代价函数 J(θ)

248
00:09:09,113 --> 00:09:10,798
就是计算

249
00:09:10,830 --> 00:09:14,341
不同 θ 值所对应的代价函数值 J

250
00:09:14,360 --> 00:09:16,157
首先让我们把数据放到 Octave 里

251
00:09:16,160 --> 00:09:17,694
我把我的矩阵设置为

252
00:09:17,700 --> 00:09:20,998
X = [1 1; 1 2; 1 3];

253
00:09:21,010 --> 00:09:24,043
这就是我的设计矩阵 X

254
00:09:24,050 --> 00:09:26,073
第一列表示x0项

255
00:09:26,073 --> 00:09:27,428
矩阵的第一列

256
00:09:27,428 --> 00:09:28,746
第二列表示

257
00:09:28,770 --> 00:09:32,375
我的三个训练样本的 x 值

258
00:09:32,375 --> 00:09:33,594
现在我再来

259
00:09:33,594 --> 00:09:35,488
设置 y 值为 [1; 2; 3]

260
00:09:35,488 --> 00:09:38,793
就像这样 是y轴对应值

261
00:09:38,810 --> 00:09:40,431
现在我们设定 theta

262
00:09:40,431 --> 00:09:43,714
为 [0;1]

263
00:09:43,730 --> 00:09:45,652
现在我的桌面上

264
00:09:45,660 --> 00:09:47,483
已经有我预定义的代价函数 J

265
00:09:47,490 --> 00:09:49,008
如果我打开函数

266
00:09:49,010 --> 00:09:52,019
函数的定义应该是下面这样的

267
00:09:52,019 --> 00:09:53,579
所以 函数J 就写成

268
00:09:53,580 --> 00:09:55,192
J = costFunctionJ(X, y, theta)

269
00:09:55,192 --> 00:09:57,151
这里有一些注释

270
00:09:57,151 --> 00:09:59,546
主要用于解释输入变量

271
00:09:59,560 --> 00:10:01,383
接下来几步

272
00:10:01,383 --> 00:10:02,995
设定 m 为训练样本的数量

273
00:10:03,020 --> 00:10:05,495
也就是 X 的行数

274
00:10:05,510 --> 00:10:07,596
计算预测值 predictions

275
00:10:07,596 --> 00:10:10,137
预测值等于 X 乘以 theta

276
00:10:10,170 --> 00:10:11,670
这里是注释行

277
00:10:11,710 --> 00:10:14,693
是上一个注释行拐过来的部分

278
00:10:14,720 --> 00:10:16,823
下面就是计算平方误差 公式就是

279
00:10:16,823 --> 00:10:18,637
预测值减去 y 值

280
00:10:18,640 --> 00:10:20,265
然后取出来每一项进行平方

281
00:10:20,265 --> 00:10:22,126
最后就可以

282
00:10:22,140 --> 00:10:24,376
计算代价函数 J

283
00:10:24,376 --> 00:10:26,128
并且 Octave 知道

284
00:10:26,128 --> 00:10:27,439
J 是一个我想返回的值

285
00:10:27,439 --> 00:10:31,383
因为 J 出现在了我函数的定义里

286
00:10:31,420 --> 00:10:34,127
另外 你可以随时

287
00:10:34,170 --> 00:10:35,292
暂停一下视频

288
00:10:35,292 --> 00:10:36,712
如果你想

289
00:10:36,712 --> 00:10:38,820
仔细看一下这个函数的定义

290
00:10:38,820 --> 00:10:44,031
确保你明白了定义中的每一步

291
00:10:44,031 --> 00:10:45,184
现在当我

292
00:10:45,184 --> 00:10:46,630
在 Octave 里运行时

293
00:10:46,630 --> 00:10:51,197
我键入 j = costFunctionJ(x, y, theta)

294
00:10:51,197 --> 00:10:55,142
然后他就开始计算 噢 又打错了

295
00:10:55,142 --> 00:10:57,018
这里应该是大写 X

296
00:10:57,018 --> 00:11:00,472
它就计算出 j 等于0

297
00:11:00,510 --> 00:11:03,367
这是因为 如果我的数据集

298
00:11:03,367 --> 00:11:06,963
x 为 [1;2;3] y 也为 [1;2;3] 然后设置 θ0 等于0

299
00:11:06,980 --> 00:11:08,741
θ1 等于1

300
00:11:08,770 --> 00:11:11,259
这给了我恰好45度的斜线

301
00:11:11,259 --> 00:11:15,559
这条线是可以完美拟合我的数据集的

302
00:11:15,600 --> 00:11:16,887
而相反地 如果我设置

303
00:11:16,887 --> 00:11:19,828
theta 等于[0; 0]

304
00:11:19,830 --> 00:11:22,524
那么这个假设就是

305
00:11:22,540 --> 00:11:24,050
0是所有的预测值

306
00:11:24,050 --> 00:11:25,803
和刚才一样 设置θ0 = 0

307
00:11:25,810 --> 00:11:27,139
θ1 也等于0

308
00:11:27,139 --> 00:11:29,345
然后我计算的代价函数

309
00:11:29,370 --> 00:11:31,830
结果是2.333

310
00:11:31,830 --> 00:11:35,495
实际上 他就等于1的平方

311
00:11:35,520 --> 00:11:36,745
也就是第一个样本的平方误差

312
00:11:36,745 --> 00:11:39,789
加上2的平方

313
00:11:39,800 --> 00:11:42,377
加上3的平方

314
00:11:42,440 --> 00:11:45,288
然后除以2m

315
00:11:45,288 --> 00:11:47,091
也就是训练样本数的两倍

316
00:11:47,091 --> 00:11:50,643
这就是2.33

317
00:11:50,643 --> 00:11:53,289
因此这也反过来验证了

318
00:11:53,330 --> 00:11:54,909
我们这里的函数

319
00:11:54,909 --> 00:11:56,302
计算出了正确的代价函数

320
00:11:56,302 --> 00:11:58,212
这些就是我们

321
00:11:58,250 --> 00:12:00,222
用简单的训练样本

322
00:12:00,222 --> 00:12:03,433
尝试的几次试验

323
00:12:03,490 --> 00:12:04,914
这也可以作为我们对

324
00:12:04,960 --> 00:12:08,689
定义的代价函数 J

325
00:12:08,720 --> 00:12:10,202
进行了完整性检查

326
00:12:10,230 --> 00:12:12,992
确实是可以计算出正确的代价函数的

327
00:12:12,992 --> 00:12:14,908
至少基于这里的 X

328
00:12:14,920 --> 00:12:17,424
和 y 是成立的

329
00:12:17,430 --> 00:12:18,835
也就是我们

330
00:12:18,835 --> 00:12:20,823
这几个简单的训练集

331
00:12:20,823 --> 00:12:25,189
至少是成立的

332
00:12:25,230 --> 00:12:26,285
好啦 现在你知道

333
00:12:26,285 --> 00:12:28,171
如何在 Octave 环境下写出正确的控制语句

334
00:12:28,171 --> 00:12:29,838
比如 for 循环、while 循环和 if 语句

335
00:12:29,838 --> 00:12:33,197
以及如何定义和使用函数

336
00:12:33,197 --> 00:12:34,530
在接下来的视频中

337
00:12:34,530 --> 00:12:36,123
我会非常快的

338
00:12:36,123 --> 00:12:38,144
介绍一下

339
00:12:38,144 --> 00:12:39,873
如何在这门课里

340
00:12:39,873 --> 00:12:41,664
完成和提交作业

341
00:12:41,664 --> 00:12:45,212
如何使用我们的提交系统

342
00:12:45,230 --> 00:12:46,794
在此之后

343
00:12:46,794 --> 00:12:48,856
在最后的 Octave 教程视频里

344
00:12:48,856 --> 00:12:51,400
我会讲解一下向量化

345
00:12:51,400 --> 00:12:52,938
这是一种可以使你的 Octave 程序运行非常快的思想

346
00:12:52,938 --> 00:12:56,126
【教育无边界字幕组】翻译：Jaminalia、reanghect 校对：所罗门捷列夫 审核：Naplessss