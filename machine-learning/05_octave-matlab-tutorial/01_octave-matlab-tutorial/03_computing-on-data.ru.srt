1
00:00:00,280 --> 00:00:02,820
Теперь вы умеете загружать и

2
00:00:02,820 --> 00:00:05,100
сохранять данные в Octave,

3
00:00:05,100 --> 00:00:10,028
создавать из них

4
00:00:10,028 --> 00:00:14,880
матрицы и так далее.

5
00:00:14,880 --> 00:00:15,870
В этом видео я покажу, как производить

6
00:00:17,130 --> 00:00:17,810
операции над

7
00:00:19,650 --> 00:00:21,040
Вот окно Octave.

8
00:00:21,040 --> 00:00:25,900
использовать эти операции при реализации наших обучающихся алгоритмов.

9
00:00:25,900 --> 00:00:33,470
Начнем.

10
00:00:33,470 --> 00:00:37,855
Вот мое окно Octave.

11
00:00:39,195 --> 00:00:42,235
Я по-быстрому определю

12
00:00:42,235 --> 00:00:47,195
несколько переменных в

13
00:00:47,195 --> 00:00:52,215
качестве

14
00:00:52,215 --> 00:00:57,145
примера. Зададим А размера 3х2.

15
00:00:57,145 --> 00:01:02,580
Зададим матрицу В

16
00:01:02,580 --> 00:01:06,208
размера 3х2, матрицу С

17
00:01:06,208 --> 00:01:11,230
размера 2х2,

18
00:01:11,230 --> 00:01:17,140
вот так.

19
00:01:17,140 --> 00:01:20,840
Скажем, я хочу перемножить две из этих матриц.

20
00:01:20,840 --> 00:01:23,200
Пусть я хочу перемножить А иС.

21
00:01:23,200 --> 00:01:27,440
Я просто пишу: AxC.

22
00:01:27,440 --> 00:01:31,494
Я перемножаю матрицу 3х2 на матрицу 2х2.

23
00:01:31,494 --> 00:01:36,500
Что даст мне матрицу 3 на 2.

24
00:01:36,500 --> 00:01:39,440
Вы также можете

25
00:01:41,100 --> 00:01:42,560
производить поэлементные

26
00:01:42,560 --> 00:01:46,230
операции.

27
00:01:46,230 --> 00:01:52,010
Команда А.*В перемножит

28
00:01:52,010 --> 00:01:56,040
каждый элемент А на соответствующий

29
00:01:56,040 --> 00:02:00,610
элемент В.

30
00:02:02,760 --> 00:02:08,173
Итак, вот А, вот В, вот А.*В.

31
00:02:08,173 --> 00:02:15,080
Например, 1 на 11

32
00:02:15,080 --> 00:02:20,300
дает 11.

33
00:02:20,300 --> 00:02:25,600
Второй элемент образуется

34
00:02:25,600 --> 00:02:31,040
как 2*12 и равен 24, и так далее.

35
00:02:31,040 --> 00:02:36,660
Итак, это поэлементное

36
00:02:36,660 --> 00:02:42,973
умножение двух матриц.

37
00:02:42,973 --> 00:02:45,930
В целом, точка в

38
00:02:45,930 --> 00:02:48,720
Octave

39
00:02:48,720 --> 00:02:54,024
означает

40
00:02:54,024 --> 00:02:56,050
поэлементные операции.

41
00:02:56,050 --> 00:02:57,240
Вот матрица А, и я

42
00:02:57,240 --> 00:02:58,360
выполню A.^2.

43
00:02:58,360 --> 00:03:01,700
Этим я поэлементно

44
00:03:01,700 --> 00:03:06,590
возведу элементы А в квадрат. 1 в

45
00:03:06,590 --> 00:03:11,430
квадрате равно 1, 2 в квадрате

46
00:03:11,430 --> 00:03:14,590
равно 4, и так далее.

47
00:03:14,590 --> 00:03:21,520
Зададим вектор V, вектор-столбец

48
00:03:21,520 --> 00:03:27,260
с элементами 1, 2, 3.

49
00:03:27,260 --> 00:03:33,620
Можно набрать 1, точка, слэш, V.

50
00:03:33,620 --> 00:03:38,950
Это поэлементное

51
00:03:40,000 --> 00:03:44,190
вычисление обратной величины. Этим я

52
00:03:44,190 --> 00:03:45,450
делю один на один, один на два,

53
00:03:45,450 --> 00:03:50,840
один на три.

54
00:03:52,470 --> 00:03:55,490
Это справедливо и для матриц.

55
00:03:55,490 --> 00:03:59,520
Так, 1./A вычислит

56
00:03:59,520 --> 00:04:03,720
обратные величины

57
00:04:03,720 --> 00:04:08,350
для элементов А.

58
00:04:08,350 --> 00:04:11,260
Точка снова обозначает

59
00:04:11,260 --> 00:04:18,330
поэлементное выполнение операции.

60
00:04:18,330 --> 00:04:19,700
Можно выполнить log(v),

61
00:04:19,700 --> 00:04:22,970
это натуральный

62
00:04:25,160 --> 00:04:27,570
логарифм от v. exp(v), возведение е

63
00:04:27,570 --> 00:04:34,300
в степень элементов v. Это е,

64
00:04:34,300 --> 00:04:38,880
это е в квадрате, это е в

65
00:04:38,880 --> 00:04:42,970
кубе. Команда abs(v) вычислит

66
00:04:42,970 --> 00:04:48,430
модуль

67
00:04:48,430 --> 00:04:52,940
для каждого

68
00:04:52,940 --> 00:04:58,790
элемента v.

69
00:04:58,790 --> 00:05:03,230
В нашем v все элементы

70
00:05:03,230 --> 00:05:07,920
были положительные, давайте

71
00:05:07,920 --> 00:05:09,860
возьмем

72
00:05:11,610 --> 00:05:14,760
модуль от -1, 2, -3.

73
00:05:14,760 --> 00:05:19,630
Поэлементное

74
00:05:19,630 --> 00:05:24,030
вычисление

75
00:05:24,030 --> 00:05:24,970
модуля

76
00:05:24,970 --> 00:05:29,970
возвращает

77
00:05:29,970 --> 00:05:36,590
эти неотрицательные числа. -v возвращает

78
00:05:36,590 --> 00:05:42,970
v со знаком

79
00:05:42,970 --> 00:05:47,440
минус. Это аналогично -1*v, но

80
00:05:47,440 --> 00:05:53,615
обычно пишут просто -v. Что еще

81
00:05:53,615 --> 00:05:55,235
можно сделать?

82
00:05:55,235 --> 00:05:59,545
Вот еще один удобный прием.

83
00:05:59,545 --> 00:06:05,205
Посмотрим.

84
00:06:05,205 --> 00:06:08,985
Скажем, я беру v и хочу увеличить все его элементы на 1.

85
00:06:08,985 --> 00:06:15,370
Первый способ это сделать:

86
00:06:15,370 --> 00:06:20,830
создать вектор 3х1, состоящий из

87
00:06:20,830 --> 00:06:23,690
единиц, и прибавить

88
00:06:23,690 --> 00:06:28,830
его к v. Это делается так.

89
00:06:28,830 --> 00:06:34,450
Это увеличивает элементы v с 1,2,3 на 2,3,4.

90
00:06:34,450 --> 00:06:38,788
Я командой length(v) узнал

91
00:06:38,788 --> 00:06:41,751
длину v, это 3.

92
00:06:41,751 --> 00:06:44,300
ones(length(v),1) создает

93
00:06:44,300 --> 00:06:48,820
матрицу единиц

94
00:06:48,820 --> 00:06:53,760
размером 3х1.

95
00:06:53,760 --> 00:06:58,886
Получаем три единицы.

96
00:06:58,886 --> 00:07:04,231
Всё правильно.

97
00:07:04,231 --> 00:07:07,740
Я добавил к v этот вектор,

98
00:07:07,740 --> 00:07:11,750
состоящий из единиц, и

99
00:07:11,750 --> 00:07:13,270
все элементы в v

100
00:07:13,270 --> 00:07:14,360
увеличились на

101
00:07:14,360 --> 00:07:17,740
единицу.

102
00:07:17,740 --> 00:07:24,270
Казалось бы, это можно

103
00:07:24,270 --> 00:07:28,820
сделать проще: v+1. Так?

104
00:07:28,820 --> 00:07:30,220
Вот v, и команда v+1

105
00:07:30,220 --> 00:07:34,180
тоже означает увеличение

106
00:07:34,180 --> 00:07:38,020
элементов v на

107
00:07:38,020 --> 00:07:40,130
единицу.

108
00:07:40,130 --> 00:07:44,270
Теперь поговорим о других операциях.

109
00:07:44,270 --> 00:07:48,140
Вот наша матрица А. Мы хотим ее транспонировать.

110
00:07:48,140 --> 00:07:50,940
Это делается так: A'.

111
00:07:50,940 --> 00:07:54,225
Добавляется символ апострофа.

112
00:07:54,225 --> 00:08:01,630
Одиночная кавычка.

113
00:08:01,630 --> 00:08:06,600
С клавиатуры также можно

114
00:08:06,600 --> 00:08:10,900
вводить открывающиеся и

115
00:08:10,900 --> 00:08:13,330
закрывающиеся кавычки.

116
00:08:13,330 --> 00:08:16,720
А вам нужна

117
00:08:16,720 --> 00:08:21,790
простая

118
00:08:21,790 --> 00:08:27,000
одинарная кавычка. Вот

119
00:08:27,000 --> 00:08:30,680
моя транспонированная матрица.

120
00:08:30,680 --> 00:08:33,150
Конечно, если

121
00:08:34,490 --> 00:08:37,515
я транспонирую ее

122
00:08:37,515 --> 00:08:38,280
еще раз, я

123
00:08:38,280 --> 00:08:43,050
получу исходную

124
00:08:43,050 --> 00:08:48,270
матрицу А.

125
00:08:48,270 --> 00:08:53,580
Давайте присвоим а

126
00:08:53,580 --> 00:08:58,260
элементы 1, 15, 2, 0.5.

127
00:08:58,260 --> 00:08:59,960
Как видите, это матрица 1х4.

128
00:08:59,960 --> 00:09:04,194
Давайте вычислим val=max(a).

129
00:09:05,200 --> 00:09:08,780
Команда вернет максимальный

130
00:09:08,780 --> 00:09:12,480
элемент в а, равный 15.

131
00:09:12,480 --> 00:09:17,210
Можно

132
00:09:17,210 --> 00:09:23,570
посчитать [val,ind]=max(a).

133
00:09:24,760 --> 00:09:30,050
В итоге val будет

134
00:09:30,050 --> 00:09:34,880
равно модулю

135
00:09:34,880 --> 00:09:39,660
наибольшего элемента, а

136
00:09:39,660 --> 00:09:45,130
ind - его номеру в а.

137
00:09:45,130 --> 00:09:50,160
То есть второй элемент в а равен 15.

138
00:09:52,130 --> 00:09:56,220
Теперь ind - индекс этого числа.

139
00:09:56,220 --> 00:10:00,700
Имейте в виду: если вы

140
00:10:00,700 --> 00:10:03,650
наберете max(A), где A - матрица.

141
00:10:03,650 --> 00:10:06,280
Формула найдет максимальный элемент в

142
00:10:06,280 --> 00:10:07,470
каждом столбце. Мы поговорим об

143
00:10:07,470 --> 00:10:12,050
этом через секунду.

144
00:10:12,050 --> 00:10:15,550
Продолжаем использовать

145
00:10:15,550 --> 00:10:20,150
нашу а. Напишем a<3.

146
00:10:20,150 --> 00:10:21,978
Это тоже поэлементная операция.

147
00:10:21,978 --> 00:10:26,870
Поэлементное сравнение.

148
00:10:26,870 --> 00:10:32,950
Значит, первый элемент а

149
00:10:32,950 --> 00:10:36,110
оказался меньше 3. Он равен 1.

150
00:10:36,110 --> 00:10:39,800
Второй элемент а не меньше 3,

151
00:10:39,800 --> 00:10:45,558
он равен 15, поэтому

152
00:10:45,558 --> 00:10:52,330
результат ложный.

153
00:10:52,330 --> 00:10:56,290
Третий и четвертый

154
00:10:56,290 --> 00:11:00,970
элементы а тоже меньше

155
00:11:00,970 --> 00:11:05,820
трех.

156
00:11:05,820 --> 00:11:11,130
То есть эти единицы, это

157
00:11:11,130 --> 00:11:17,830
просто поэлементное

158
00:11:17,830 --> 00:11:20,260
сравнение элементов а с 3. Результат

159
00:11:20,260 --> 00:11:22,340
ложный или истинный

160
00:11:22,340 --> 00:11:27,410
в зависимости от

161
00:11:27,410 --> 00:11:29,791
того, больше элемент тройки или меньше.

162
00:11:29,791 --> 00:11:31,600
Если я наберу find(a<3),

163
00:11:31,600 --> 00:11:34,790
то я узнаю порядковые

164
00:11:34,790 --> 00:11:38,390
номера элементов, которые

165
00:11:38,390 --> 00:11:40,685
меньше трех. В а это

166
00:11:40,685 --> 00:11:45,760
первый,

167
00:11:45,760 --> 00:11:50,090
третий и

168
00:11:50,090 --> 00:11:52,020
четвертый элементы.

169
00:11:52,020 --> 00:11:54,262
В следующем

170
00:11:54,262 --> 00:11:59,470
примере

171
00:11:59,470 --> 00:12:02,890
присвоим A=magic(3).

172
00:12:02,890 --> 00:12:06,480
Функция magic возвращают следующее.Посмотрим справку по magic.

173
00:12:08,780 --> 00:12:12,750
Вот что возвращает функция magic.

174
00:12:12,750 --> 00:12:16,820
Возвращает так называемые магические квадраты.

175
00:12:16,820 --> 00:12:20,340
У них есть такое свойство, что

176
00:12:20,340 --> 00:12:23,120
сумма чисел в каждой

177
00:12:23,120 --> 00:12:27,830
строке, столбце,

178
00:12:27,830 --> 00:12:34,130
на каждой диагонали одинакова.

179
00:12:34,130 --> 00:12:38,110
Насколько

180
00:12:38,110 --> 00:12:41,650
я знаю, в

181
00:12:44,210 --> 00:12:45,596
машинном обучении это не

182
00:12:45,596 --> 00:12:50,630
особо нужно, просто я так

183
00:12:50,630 --> 00:12:55,548
сгенерировал матрицу 3х3,

184
00:12:55,548 --> 00:12:59,760
вот этот магический

185
00:12:59,760 --> 00:13:04,342
квадрат.

186
00:13:04,342 --> 00:13:06,260
Каждая строка и столбец

187
00:13:06,260 --> 00:13:09,255
имеют длину 3,

188
00:13:09,255 --> 00:13:13,340
в каждом из них и на диагоналях сумма чисел