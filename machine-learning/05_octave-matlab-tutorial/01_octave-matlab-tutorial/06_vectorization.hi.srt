1
00:00:00,320 --> 00:00:03,682
इस वीडियो में मैं आप को बताना चाहता हूँ वेक्टराइज़ेशन के बारे में.

2
00:00:03,682 --> 00:00:08,380
तो, चाहे आप इस्तेमाल कर रहे हैं ओकटेव या ऐसी एक लैंग्विज जैसे मैटलैब या

3
00:00:08,380 --> 00:00:12,540
चाहे आप इस्तेमाल कर रहे हैं पाइथान, [सुनाई नहीं दिया], R, जावा, C++,

4
00:00:12,540 --> 00:00:17,470
इन सभी लैंग्विजेज़ में है या तो बिल्ट-इन या नियमित रूप में और

5
00:00:17,470 --> 00:00:21,840
सुलभ विभिन्न नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरीज़.

6
00:00:21,840 --> 00:00:24,400
वे अक्सर बहुत अच्छे से लिखी होती हैं, काफ़ी ऑप्टिमायज़्ड ढंग से,

7
00:00:24,400 --> 00:00:29,250
प्रायः बनाई गई होती है उन लोगों द्वारा जो पीएचडी होते हैं नूमेरिकल कम्प्यूटिंग में या

8
00:00:29,250 --> 00:00:32,070
वे विशेषज्ञ होते हैं नूमेरिकल कम्प्यूटिंग के.

9
00:00:32,070 --> 00:00:35,590
और जब आप इम्प्लमेंट करते हैं मशीन लर्निंग अल्गोरिद्म्स, यदि आप

10
00:00:35,590 --> 00:00:39,880
उठा सकते हैं लाभ इन लिनीअर ऐल्जेब्रा लाइब्रेरीज़ या इन नूमेरिकल

11
00:00:39,880 --> 00:00:44,510
लिनीअर ऐल्जेब्रा लाइब्रेरीज़ का, और कर सकते हैं कुछ रूटीन कॉल्ज़ उन्हें बजाय एक तरह से

12
00:00:44,510 --> 00:00:48,470
लिखने से कोड अपने आप करने के लिए काम जो ये लाइब्रेरीज़ कर सकती हैं.

13
00:00:48,470 --> 00:00:51,970
यदि आप वैसा करते हैं, तब अक्सर आपको मिलता है कोड, जो, अधिक कुशलता से काम करता है, अत:

14
00:00:51,970 --> 00:00:53,170
आप उसे रन कर सकते हैं अधिक गति से और

15
00:00:53,170 --> 00:00:58,120
ले सकते हैं बेहतर लाभ किसी समानांतर हार्डवेयर का जो आपके कम्प्यूटर में शायद हो और इसी तरह कुछ.

16
00:00:58,120 --> 00:01:03,080
और दूसरा, इसका मतलब यह भी है कि आपको कम कोड लिखना पड़ता है,

17
00:01:03,080 --> 00:01:07,330
इसलिए यह है एक सरलतर इम्प्लमेंटेशन जो इसलिए शायद हो सकते हैं थोड़ा अधिक

18
00:01:07,330 --> 00:01:08,540
फ़्री.

19
00:01:08,540 --> 00:01:13,450
और एक ठोस उदाहरण के रूप में, बजाय कोड खुद लिखने से

20
00:01:13,450 --> 00:01:18,170
गुणा करने के लिए मेट्रिसीज़ को, यदि आप ओकटेव को यह करने देते हैं टाइप करके a गुणा b,

21
00:01:18,170 --> 00:01:22,220
वह इस्तेमाल करेगा एक अधिक कुशल रूटीन गुणा करने के लिए दो मेट्रिसीज़ को.

22
00:01:22,220 --> 00:01:26,090
ऐसे बहुत से उदाहरण है इस तरह के, जहाँ यदि आप प्रयोग करते हैं उचित

23
00:01:26,090 --> 00:01:30,310
वेक्टराइज़ेशन इम्प्लमेंटेशन आपको मिलता है अपेक्षाकृत सरल कोड और अधिक कुशल कोड.

24
00:01:30,310 --> 00:01:31,470
चलो देखते है कुछ और उदाहरण.

25
00:01:33,090 --> 00:01:36,110
यह है हमारी हमेशा की हायपॉथिसस लिनीअर रेग्रेशन के लिए, और

26
00:01:36,110 --> 00:01:40,010
यदि आप कम्प्यूट करना चाहते हैं h(x), ध्यान दें वहाँ एक सम है दाईं तरफ़.

27
00:01:40,010 --> 00:01:46,660
और इसलिए एक काम जो आप कर सकते हैं, कम्प्यूट करें सम j=0 से j= n तक अपने आप.

28
00:01:46,660 --> 00:01:51,920
अन्य ढंग सोचने का इसे है कि सोचे h(x) को थीटा ट्रान्स्पोज़ x की तरह,

29
00:01:51,920 --> 00:01:56,330
और आप क्या कर सकते हैं, सोचें इसे कि आप कम्प्यूट कर रहे हैं इनर प्रोडक्ट

30
00:01:56,330 --> 00:02:03,220
दो वेक्टर्ज़ के बीच में जहाँ थीटा है आपका वेक्टर, मान लो, थीटा 0, थीटा 1, थीटा 2.

31
00:02:03,220 --> 00:02:07,221
यदि आपके पास हैं दो फ़ीचर्ज़, यदि n बराबर है दो, और

32
00:02:07,221 --> 00:02:11,632
यदि आप सोचते हैं x को इस वेक्टर की तरह, x0, x1, x2, और

33
00:02:11,632 --> 00:02:17,590
ये दो व्यूज़ दे सकते हैं आपको दो भिन्न इम्प्लमेंटेशन्स.

34
00:02:17,590 --> 00:02:18,820
मेरा मतलब ऐसे है.

35
00:02:18,820 --> 00:02:23,623
यहाँ है एक अनवेक्टराइज्ड इम्प्लमेंटेशन कि कैसे कम्प्यूट करना है और अनवेक्टराइज्ड से

36
00:02:23,623 --> 00:02:25,360
मेरा मतलब है बिना वेक्टराइज़ेशन के.

37
00:02:25,360 --> 00:02:30,160
हम पहले ईनिशीयलाइज करते हैं प्रिडिक्शन को सिर्फ़ 0.0

38
00:02:30,160 --> 00:02:36,057
अंतत: प्रिडिक्शन होगा h(x), और तब मैं करूँगा एक फ़ॉर

39
00:02:36,057 --> 00:02:42,320
लूप j=1 से n +1 तक, प्रिडिक्शन बढ़ती है थीटा(j)* x(j) से.

40
00:02:42,320 --> 00:02:44,740
इसलिए, यह इस तरह का इक्स्प्रेशन है यहाँ पर.

41
00:02:44,740 --> 00:02:45,736
वैसे, मुझे उल्लेख करना चाहिए,

42
00:02:45,736 --> 00:02:51,100
इन वेक्टर्स में जो मैंने लिखे यहाँ, मेरे पास थे ये वेक्टर्स 0 इंडेक्स्ड.

43
00:02:51,100 --> 00:02:53,270
तो मेरे पास था थीटा 0, थीटा 1, थीटा 2.

44
00:02:53,270 --> 00:02:58,543
लेकिन क्योंकि मैटलैब है एक इंडेक्स्ड, मैटलैब में थीटा 0 होगा, हमें मिलना चाहिए

45
00:02:58,543 --> 00:03:03,557
थीटा 1 के रूप में और दूसरा एलिमेंट होगा थीटा 2 की तरह और

46
00:03:03,557 --> 00:03:08,570
यह तीसरा एलिमेंट शायद हो थीटा 3, सिर्फ़ इसलिए कि हमारे वेक्टर्स

47
00:03:08,570 --> 00:03:13,411
मैटलैब में इंडेक्स होते है शुरू 1 से, जबकि मैंने लिखा था थीटा और

48
00:03:13,411 --> 00:03:18,620
x यहाँ, शुरू करते हुए इंडेक्सिंग 0 से, जिस वजह से यहाँ मेरे पास है एक फ़ॉर लूप.

49
00:03:18,620 --> 00:03:25,480
j जाता है 1 से n + 1 तक, बजाय जाने के 0 से n तक, ठीक है?

50
00:03:25,480 --> 00:03:30,286
लेकिन तो यह है एक अनवेक्टराइज्ड इम्प्लमेंटेशन जिसमें हमारे पास है फ़ॉर

51
00:03:30,286 --> 00:03:33,940
लूप जो सम कर रहा है n एलिमेंट्स को सम के.

52
00:03:33,940 --> 00:03:39,251
इसके विपरीत, यहाँ है कि कैसे आप लिखेंगे एक वेक्टराइज्ड इम्प्लमेंटेशन,

53
00:03:39,251 --> 00:03:43,290
जो है कि आप सोचेंगे x और थीटा को वेक्टर्स की तरह.

54
00:03:43,290 --> 00:03:46,620
और आप सिर्फ़ कहेंगे प्रिडिक्शन = थीटा ' * x.

55
00:03:46,620 --> 00:03:48,150
आप सिर्फ़ कम्प्यूट कर रहे हो इतना ही.

56
00:03:48,150 --> 00:03:52,077
तो बजाय लिखने के ये सब लाइन्स कोड की फ़ॉर लूप के साथ,

57
00:03:52,077 --> 00:03:54,620
आपके पास इसके स्थान पर है एक लाइन कोड की.

58
00:03:54,620 --> 00:03:57,764
और यह लाइन कोड की दाईं तरफ़ जो करेगी वह है,

59
00:03:57,764 --> 00:04:02,604
यह इस्तेमाल करेगी ओकटेव की उच्च ऑप्टिमायज़्ड नूमेरिकल लिनीअर ऐल्जेब्रा रूटीन्स

60
00:04:02,604 --> 00:04:07,823
कम्प्यूट करने के लिए यह इनर प्रोडक्ट दो वेक्टर्स के बीच में, थीटा और x, और न केवल है

61
00:04:07,823 --> 00:04:13,250
वेक्टराइज्ड इम्प्लमेंटेशन सारा, यह रन करेगा अधिक कुशलता से.

62
00:04:15,850 --> 00:04:17,590
तो वह था ओकटेव, लेकिन

63
00:04:17,590 --> 00:04:22,080
वेक्टराइज़ेशन का मुद्दा अप्लाई होता है अन्य प्रोग्रामिंग लैंग्विजेज़ में भी.

64
00:04:22,080 --> 00:04:24,740
चलो देखते हैं एक उदाहरण C++ में.

65
00:04:24,740 --> 00:04:27,820
यहाँ है एक अनवेक्टराइज्ड इम्प्लमेंटेशन कैसे दिखती है.

66
00:04:27,820 --> 00:04:31,468
हम फिर से ईनिशीयलाइज करते हैं प्रिडिक्शन को 0.0 और

67
00:04:31,468 --> 00:04:35,650
फिर हमारे पास अब है एक फ़ॉर लूप j = 0 से n तक.

68
00:04:35,650 --> 00:04:40,598
प्रिडिक्शन + = थीटा j * x [j], जहां फिर से, आपके यह स्पष्ट फ़ॉर

69
00:04:40,598 --> 00:04:42,620
लूप है जो आप स्वयं लिखते हैं.

70
00:04:42,620 --> 00:04:47,720
इसके विपरीत, इस्तेमाल करके एक अच्छी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी C++ की,

71
00:04:47,720 --> 00:04:50,950
आप लिख सकते थे एक फ़ंक्शन ऐसा, या बजाय,

72
00:04:54,410 --> 00:04:59,000
इसके विपरीत, इस्तेमाल करके एक अच्छी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी C++ की,

73
00:04:59,000 --> 00:05:02,500
इसके स्थान पर आप लिख सकते हैं कोड जो शायद दिखे इस तरह का.

74
00:05:02,500 --> 00:05:06,540
अत: निर्भर करते हुए विस्तृत जानकारी पर आपकी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी पर,

75
00:05:06,540 --> 00:05:11,230
आपके पास हो सकती है एक ऑब्जेक्ट, यह है एक C++ ऑब्जेक्ट, जो है वेक्टर थीटा,

76
00:05:11,230 --> 00:05:17,540
और एक C++ ऑब्जेक्ट जो है वेक्टर x, और आप सिर्फ़ लेते हैं थीटा.ट्रान्स्पोज़ * x,

77
00:05:17,540 --> 00:05:22,270
जहाँ यह गुणा बन जाता है एक C++ का एक प्रकार से ओवरलोडेड ऑपरेटर तो

78
00:05:22,270 --> 00:05:26,380
आप बस गुणा कर सकते हैं ये दो वेक्टर्स C++ में.

79
00:05:26,380 --> 00:05:30,390
अत: निर्भर करते हुए विस्तृत जानकारी पर आपकी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी पर,

80
00:05:30,390 --> 00:05:32,880
आप शायद लिखें एक थोड़ा भिन्न सिंटैक्स, लेकिन

81
00:05:32,880 --> 00:05:35,800
निर्भर करने से लाइब्रेरी पर इस इनर प्रोडक्ट को करने के लिए,

82
00:05:35,800 --> 00:05:39,290
आपको मिल सकता है एक अधिक सरल हिस्सा कोड का और एक अधिक कुशल भी.

83
00:05:40,660 --> 00:05:43,590
चलो अब देखते हैं एक और अधिक परिष्कृत उदाहरण को.

84
00:05:43,590 --> 00:05:45,840
सिर्फ़ आपको याद दिलाने के लिए, यहाँ है हमाराअप्डेट नियम

85
00:05:45,840 --> 00:05:48,260
ग्रेडीयंट डिसेंट का लिनीअर रेग्रेशन के लिए.

86
00:05:48,260 --> 00:05:55,070
और तो हम अप्डेट करते हैं थीटा j उपयोग करते हुए इस नियम का, सारी वैल्यूज़ j = 0, 1, 2, और आगे.

87
00:05:55,070 --> 00:05:59,575
और यदि मैं सिर्फ़ लिखता हूँ ये इक्वेज़न्स थीटा 0, थीटा 1,

88
00:05:59,575 --> 00:06:03,410
थीटा 2 के लिए, मानते हुए कि हमारे पास हैं दो फ़ीचर्ज़, तो n = 2.

89
00:06:03,410 --> 00:06:08,377
तब ये अप्डेट्स जो हम करते हैं थीटा 0, थीटा 1, थीटा 2, के लिए, जहाँ आपको शायद

90
00:06:08,377 --> 00:06:13,230
याद हो मेरा बताना एक पहले के वीडियो मैं, कि ये होने चाहिए एक साथ अप्डेट्स.

91
00:06:14,850 --> 00:06:19,580
तो, चलो देखते हैं कि क्या हम बना पाते हैं एक वेक्टराइज्ड नोटेशन इसकी.

92
00:06:20,754 --> 00:06:24,120
यहाँ हैं मेरी वही तीन इक्वेज़न्स, लिखी हुई थोड़े छोटे फ़ॉंट मैं, और

93
00:06:24,120 --> 00:06:28,110
आप कल्पना कर सकते हैं कि एक ढंग इम्प्लमेंट करने का कोड की इन तीन लाइन्स को है कि बनाएँ एक फ़ॉर

94
00:06:28,110 --> 00:06:35,500
लूप जो कहता है j = 0 , 1, से 2 तक अप्डेट करें थीटा j, या वैसा कुछ.

95
00:06:35,500 --> 00:06:39,570
लेकिन इसके स्थान पर, चलो बनाते हैं एक वेक्टराइज्ड इम्प्लमेंटेशन और देखें क्या

96
00:06:39,570 --> 00:06:43,830
है हमारे पास एक सरल ढंग मूलरूप से कम्प्रेस करने का कोड की इन तीन लाइन्स को या

97
00:06:43,830 --> 00:06:48,540
एक फ़ॉर लूप जो प्रभावशाली ढंग से करता है ये तीन स्टेप्स, एक बार में एक सटेप.

98
00:06:48,540 --> 00:06:50,070
चलो देखते हैं यदि हम ले सकते हैं ये तीन स्टेप्स और

99
00:06:50,070 --> 00:06:54,220
कम्प्रेस कर सकते हैं उन्हें वेक्टराइज्ड कोड की एक लाइन में.

100
00:06:54,220 --> 00:06:55,500
यह है सुझाव.

101
00:06:55,500 --> 00:06:58,538
क्या करुंगा मैं कि,

102
00:06:58,538 --> 00:07:03,458
मैं सोचूँगा थीटा को एक वेक्टर की तरह,

103
00:07:03,458 --> 00:07:08,090
और मैं अपडेट करूँगा थीटा को थीटा-

104
00:07:08,090 --> 00:07:12,723
अल्फ़ा टाइम्ज़ कोई अन्य वेक्टर डेल्टा,

105
00:07:12,723 --> 00:07:18,511
जहाँ डेल्टा है बराबर 1 ओवर m,

106
00:07:18,511 --> 00:07:21,740
सम i= 1 से m तक.

107
00:07:21,740 --> 00:07:28,100
और तब यह टर्म दाईं तरफ़, ठीक है?

108
00:07:28,100 --> 00:07:29,840
तो, मैं समझाता हूँ क्या हो रहा है यहाँ.

109
00:07:31,310 --> 00:07:34,920
यहाँ, मैं ले रहा हूँ थीटा को एक वेक्टर की तरह, तो

110
00:07:34,920 --> 00:07:38,170
यह है एक n प्लस एक डिमेन्शनल वेक्टर, और

111
00:07:38,170 --> 00:07:43,610
मैं कह रहा हूँ थीटा हो जाता है अप्डेट क्योंकि वह है एक वेक्टर, Rn+1.

112
00:07:43,610 --> 00:07:50,080
अल्फ़ा है एक रियल नम्बर, और डेल्टा, यहाँ है एक वेक्टर.

113
00:07:50,080 --> 00:07:54,920
तो, यह है घटा करने का ऑपरेशन, वह है वेक्टर घटा करना, ठीक है?

114
00:07:54,920 --> 00:07:58,380
क्योंकि अल्फ़ा गुणा डेल्टा है एक वेक्टर, और इसलिए

115
00:07:58,380 --> 00:08:04,270
मैं कह रहा हूँ कि थीटा को मिलता है यह वेक्टर, अल्फ़ा गुणा डेल्टा घटाने से इससे.

116
00:08:04,270 --> 00:08:06,580
तो, एक वेक्टर डेल्टा क्या है?

117
00:08:06,580 --> 00:08:10,959
ठीक है यह वेक्टर डेल्टा, दिखता है ऐसा, और

118
00:08:10,959 --> 00:08:17,040
इसके होने का अभिप्राय है यह वास्तव में हैं यह चीज़ यहाँ पर.

119
00:08:17,040 --> 00:08:22,066
वास्तव में, डेल्टा है एक n प्लस एक डिमेन्शनल वेक्टर, और

120
00:08:22,066 --> 00:08:27,570
पहला ही एलिमेंट वेक्टर डेल्टा का होगा बराबर उसके.

121
00:08:27,570 --> 00:08:32,203
तो, यदि हमारे पास है डेल्टा, यदि हम इंडेक्स करते हैं इसे 0 से,

122
00:08:32,203 --> 00:08:37,288
यदि यह है डेल्टा 0, डेल्टा 1, डेल्टा 2, मैं क्या चाहता हूँ कि

123
00:08:37,288 --> 00:08:42,730
डेल्टा 0 है बराबर इस हरे बॉक्स के ऊपर यहाँ.

124
00:08:42,730 --> 00:08:48,621
और वास्तव में, आप अपने आप को यक़ीन करा सकते हो

125
00:08:48,621 --> 00:08:53,964
कि डेल्टा 0 है यह 1 से m सम h(x) का,

126
00:08:53,964 --> 00:08:58,360
x(i) माइनस y(i) गुणा x(i) 0.

127
00:08:58,360 --> 00:09:01,352
तो, मैं सुनिश्चित करता हूँ कि हम एक ही चीज़ समझ रहे हैं

128
00:09:01,352 --> 00:09:04,010
कि कैसे डेल्टा वास्तव में कम्प्यूट होता है.

129
00:09:04,010 --> 00:09:09,930
डेल्टा है 1 ओवर m टाइम्ज़ यह सम यहाँ पर, और क्या है यह सम?

130
00:09:09,930 --> 00:09:15,782
ठीक है, यह टर्म यहाँ, वह है एक रियल नम्बर,

131
00:09:15,782 --> 00:09:19,772
और दूसरी टर्म यहाँ पर, x i,

132
00:09:19,772 --> 00:09:24,427
यह टर्म वहाँ है एक वेक्टर, ठीक है,

133
00:09:24,427 --> 00:09:29,481
क्योंकि x(i) शायद हो सकता है एक वेक्टर जो होगा,

134
00:09:29,481 --> 00:09:34,136
मान लो, x(i)0, x(i)1, x(i)2,

135
00:09:34,136 --> 00:09:38,150
ठीक है, और क्या है यह समेशन?

136
00:09:38,150 --> 00:09:44,142
ठीक है, क्या यह समेशन कह रहा है कि,

137
00:09:44,142 --> 00:09:49,504
यह टर्म, कि यह टर्म यहाँ पर,

138
00:09:49,504 --> 00:09:54,707
यह है बराबर (h of(x(1))-

139
00:09:54,707 --> 00:10:00,700
y(1))* x(1) + (h(x(2))-

140
00:10:00,700 --> 00:10:06,080
y(2)*x(2)) + इसी तरह आगे, ठीक है?

141
00:10:06,080 --> 00:10:10,041
क्योंकि यह है समेशन i का, तो जैसे i जाता है i=1 से m तक,

142
00:10:10,041 --> 00:10:15,100
आपको मिलती हैं ये भिन्न टर्म्ज़, और आप जोड़ रहे हैं ये टर्म्ज़ यहाँ.

143
00:10:15,100 --> 00:10:19,990
और मतलब इन टर्म्ज़ का, यह है काफ़ी कुछ यदि आपको याद हो वास्तव में,

144
00:10:19,990 --> 00:10:23,760
इसकी पिछली क्विज़ से, ठीक है, आपने देखी थी यह इक्वेज़न.

145
00:10:23,760 --> 00:10:30,680
हमने कहा था कि वेक्टराइज़ करने के लिए इस कोड को, हम इसके स्थान पर कहेंगे u= 2v + 5w.

146
00:10:30,680 --> 00:10:34,760
तो हम कह रहे हैं कि वेक्टर u बराबर है दो गुणा वेक्टर v

147
00:10:34,760 --> 00:10:36,470
जमा पाँच गुणा वेक्टर w.

148
00:10:36,470 --> 00:10:40,530
तो यह है एक उदाहरण कि कैसे जोड़ना है विभिन्न वेक्टर्स को और

149
00:10:40,530 --> 00:10:42,940
यह समेशन है वही चीज़.

150
00:10:42,940 --> 00:10:49,740
यह कह रहा है कि समेशन यहाँ पर है सिर्फ़ कुछ रियल नम्बर्ज़, ठीक है?

151
00:10:49,740 --> 00:10:54,370
यह है एक प्रकार से नम्बर दो या कोई और नम्बर गुणा वेक्टर, x1.

152
00:10:54,370 --> 00:10:59,213
तो यह है जैसे 2v या मान लो कोई और नम्बर गुणा x1, और

153
00:10:59,213 --> 00:11:04,244
तब जमा बजाय 5w हमारे पास इसके स्थान पर है कोई और रियल नम्बर,

154
00:11:04,244 --> 00:11:09,739
जमा कोई और वेक्टर, और तब आप जोड़ते हो अन्य वेक्टर्ज़, जमा डॉट,

155
00:11:09,739 --> 00:11:14,580
डॉट, डॉट, जमा अन्य वेक्टर्स, जिस वजह से, पूरी,

156
00:11:14,580 --> 00:11:20,670
यह चीज़ यह, यह पूरी मात्रा, वह डेल्टा है सिर्फ़ कोई वेक्टर.

157
00:11:22,240 --> 00:11:27,592
और वस्तुत:, तीन एलिमेंट्स डेल्टा के कॉरेस्पॉंड करते है यदि n = 2,

158
00:11:27,592 --> 00:11:32,800
तीन एलिमेंट्स डेल्टा के कॉरेस्पॉंड करते हैं इसी ही चीज़ को.

159
00:11:32,800 --> 00:11:35,920
दूसरी चीज़ को , और तीसरी चीज़ को.

160
00:11:35,920 --> 00:11:41,050
यही वजह है कि जब आप अप्डेट करते हैं थीटा को थीटा-अल्फ़ा डेल्टा के अनुसार,

161
00:11:41,050 --> 00:11:44,610
हम कर पाते हैं बिलकुल वही अप्डेट्स एक साथ

162
00:11:44,610 --> 00:11:46,670
उस अप्डेट नियम के अनुसार जो हमारे पास है ऊपर.

163
00:11:47,980 --> 00:11:51,940
तो, मैं जानता हूँ वह बहुत कुछ था जो हुआ इस स्लाइड पर, लेकिन फ़िर से,

164
00:11:51,940 --> 00:11:57,010
रोक सकते हैं इस वीडियो को और यदि आप निश्चित नहीं है कि

165
00:11:57,010 --> 00:12:02,590
क्या हुआ अभी मैं प्रोत्साहित करूँगा आपको कि देखें इस स्लाइड को करने के लिए

166
00:12:02,590 --> 00:12:08,435
सुनिश्चित कि आप समझ पाए हैं कि क्यों है अप्डेट यहाँ डेल्टा की इस परिभाषा के साथ,

167
00:12:08,435 --> 00:12:12,870
ठीक है, क्यों है कि यह है बराबर इस अप्डेट के जो ऊपर है?

168
00:12:12,870 --> 00:12:18,430
और अगर यह अभी भी स्पष्ट नहीं है, एक अंतर्दृष्टि है कि, यह चीज़ यहाँ पर,

169
00:12:18,430 --> 00:12:21,960
यह है वास्तव में वेक्टर x, और इसलिए

170
00:12:21,960 --> 00:12:26,560
हम सिर्फ़ ले रहे हैं ये तीनों कॉम्प्यूटेशन्स, और कम्प्रेस कर रहे हैं उनको

171
00:12:26,560 --> 00:12:31,420
एक सटेप में इस वेक्टर डेल्टा से, जिस वजह से हम बना सकते हैं

172
00:12:31,420 --> 00:12:36,000
एक वेक्टराइज्ड इम्प्लमेंटेशन इस स्टेप की इस तरह से.

173
00:12:37,010 --> 00:12:41,630
तो, मुझे आशा है कि यह स्टेप समझ में आया है और अवश्य देखें वीडियो और

174
00:12:41,630 --> 00:12:44,030
जाने कि आप इसे समझ पाए हैं.

175
00:12:44,030 --> 00:12:47,230
यदि आपको नहीं समझा है पूरी तरह से समानता इस मैप की,

176
00:12:47,230 --> 00:12:50,620
यदि आप इम्प्लमेंट करते हैं इसे, यह देगा वैसे भी सही उत्तर.

177
00:12:50,620 --> 00:12:53,839
तो, यदि आप नहीं ही समझ पाए हैं समानता,

178
00:12:53,839 --> 00:12:58,610
यदि आप सिर्फ़ इसे इम्प्लेमेट करते हैं इस तरह, आप करवा पाएँगे लिनीअर रेग्रेशन को काम.

179
00:12:58,610 --> 00:13:03,142
लेकिन यदि आप समझ पाए हैं कि क्यों ये दो स्टेप्स समान है,

180
00:13:03,142 --> 00:13:08,710
तब उम्मीद हैं वह देगा आपको एक बेहतर समझ वेक्टराइज़ेशन की भी.

181
00:13:08,710 --> 00:13:13,210
और अंत में, यदि आप इम्प्लमेंट कर रहे हैं लिनीअर रेग्रेशन इस्तेमाल करते हुए एक से अधिक या

182
00:13:13,210 --> 00:13:17,915
दो फ़ीचर्ज़, तो कभी-कभी हम इस्तेमाल करते हैं लिनीअर रेग्रेशन 10 या 100 या

183
00:13:17,915 --> 00:13:19,650
1000 फ़ीचर्ज़ के साथ.

184
00:13:19,650 --> 00:13:23,140
लेकिन यदि आप करते हैं वेक्टराइज्ड इम्प्लमेंटेशन लिनीअर रेग्रेशन की,

185
00:13:23,140 --> 00:13:27,465
आप देखेंगे कि वह रन करेगा अधिक तेज़ तुलना में यदि आपके पास होता, मान लो, आपका पुराना फ़ॉर

186
00:13:27,465 --> 00:13:31,500
लूप जो अप्डेट कर रहा था थीटा ज़ीरो, तब थीटा एक, तब थीटा दो ख़ुद.

187
00:13:31,500 --> 00:13:34,220
तो इस्तेमाल करने से एक वेक्टराइज्ड इम्प्लमेंटेशन, आप को

188
00:13:34,220 --> 00:13:37,860
मिलनी चाहिए एक अधिक कुशल इम्प्लमेंटेशन लिनीअर रेग्रेशन की.

189
00:13:37,860 --> 00:13:41,820
और जब आप वेक्टराइज़ करेंगे बाद के अलगोरिद्म्स जो हम देखेंगे इस क्लास में,

190
00:13:41,820 --> 00:13:45,110
यह है एक तरकीब, चाहे ओकटेव हो या कोई अन्य लैंग्विज जैसे C++, जावा,

191
00:13:45,110 --> 00:13:47,700
चलाने के लिए आपके कोड को अधिक कुशलता से.