在这段视频中 我将介绍有关向量化的内容 无论你是用Octave 还是别的语言 比如MATLAB 或者你正在用Python NumPy 或 Java C C++ 所有这些语言都具有 各种线性代数库 这些库文件都是内置的 容易阅读和获取 他们通常写得很好 已经经过高度优化 通常是数值计算方面的博士 或者专业人士开发的 而当你实现机器学习算法时 如果你能 好好利用这些 线性代数库或者说 数值线性代数库 并联合调用它们 而不是自己去做那些 函数库可以做的事情 如果是这样的话 那么 通常你会发现 首先 这样更有效 也就是说运行速度更快 并且更好地利用 你的计算机里可能有的一些并行硬件系统 等等 第二 这也意味着 你可以用更少的代码来实现你需要的功能 因此 实现的方式更简单 代码出现问题的有可能性也就越小 举个具体的例子 与其自己写代码 做矩阵乘法 如果你只在Octave中 输入 a乘以b 就是一个非常有效的 两个矩阵相乘的程序 有很多例子可以说明 如果你用合适的向量化方法来实现 你就会有一个简单得多 也有效得多的代码 让我们来看一些例子 这是一个常见的线性回归假设函数 如果 你想要计算 h(x) 注意到右边是求和 那么你可以 自己计算 j =0 到 j = n 的和 但换另一种方式来想想 是把 h(x) 看作 θ 转置乘以 x 那么 你就可以写成 两个向量的内积 其中 θ 就是 θ0  θ1 θ2 如果你有两个特征量 如果 n 等于2 并且如果 你把 x 看作 x0 x1 x2 这两种思考角度 会给你两种不同的实现方式 比如说 这是未向量化的代码实现方式 计算 h(x) 是未向量化的 我的意思是 没有被向量化 我们可能首先要初始化变量 prediction 的值为0.0 而这个 变量 prediction 的最终结果就是 h(x) 然后 变量 prediction 的最终结果就是 j 取值 0 到 n+1 变量prediction 每次就通过 自身加上 theta(j) 乘以 x(j) 更新值 这个就是算法的代码实现 顺便我要提醒一下 这里的向量 我用的下标是 0 所以我有 θ0 θ1 θ2 但因为 MATLAB 的下标从1开始 在 MATLAB 中 θ0 我们可能会 用 theta(1) 来表示 这第二个元素 最后就会变成 theta(2) 而第三个元素 最终可能就用 theta(3) 表示 因为 MATLAB 中的下标从1开始 即使我们实际的 θ 和 x 的下标从0开始 这就是为什么 这里我的 for 循环 j 取值从 1 直到 n+1 而不是 从 0 到 n 清楚了吗？ 但这是一个 未向量化的代码实现方式 我们用一个 for 循环 对 n 个元素进行加和 作为比较 接下来是 向量化的代码实现 你把 x 和 θ 看做向量 而你只需要 令变量 prediction 等于 theta转置 乘以 x 你就可以这样计算 与其写所有这些 for 循环的代码 你只需要一行代码 这行代码 右边所做的 就是 利用 Octave 的高度优化的数值 线性代数算法来计算 两个向量的内积 θ 以及 x 这样向量化的实现不仅仅是更简单 它运行起来也将更加高效 这就是 Octave 所做的 而向量化的方法 在其他编程语言中同样可以实现 让我们来看一个 C++ 的例子 这就是未向量化的代码实现的样子 我们再次初始化变量 prediction 为 0.0 然后我们现在有一个完整的 从 j 等于 0 直到 n 变量 prediction += theta[j] 乘以 x[j] 再一次 你有这样的自己写的 for 循环 与此相反 使用一个比较好的 C++ 数值线性代数库 你就可以用这个方程 来写这个函数 与此相反 使用较好的 C++ 数值线性代数库 你可以写出 像这样的代码 因此取决于你的 数值线性代数库的内容 你可以有一个对象 (object) 像这个 C++ 对象 theta 和一个 C++ 对象 向量 x 你只需要用 theta.transpose ( ) 乘以 x 而这次是让 C++ 来实现运算 因此 你只需要在 C++ 中将两个向量相乘 根据你所使用的 数值和线性代数库的使用细节的不同 你最终使用的代码表达方式 可能会有些许不同 但是通过 一个库来做内积 你可以得到一段更简单 更有效的代码 现在 让我们来看一个更为复杂的例子 提醒一下 这是线性回归算法梯度下降的更新规则 所以 我们用这条规则对 j 等于 0 1 2 等等的所有值 更新 对象 θj 我只是 用 θ0 θ1 θ2 来写方程 那就是假设我们有两个特征量 所以 n等于2 这些都是我们需要对 θ0 θ1 θ2 进行更新 你可能还记得 在以前的视频中说过 这些都应该是同步更新 因此 让我们来看看 我们是否可以拿出一个 向量化的代码实现 这里是和之前相同的三个方程 只不过写得小一点而已 你可以想象 实现这三个方程的方式之一 就是用 一个 for 循环 就是让 j 等于0 等于 等于2 来更新 θj 但让我们 用向量化的方式来实现 看看我们是否能够有一个更简单的方法 基本上用三行代码 或者一个 for 循环