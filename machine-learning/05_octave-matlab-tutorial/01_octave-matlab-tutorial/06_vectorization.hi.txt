इस वीडियो में मैं आप को बताना चाहता हूँ वेक्टराइज़ेशन के बारे में. तो, चाहे आप इस्तेमाल कर रहे हैं ओकटेव या ऐसी एक लैंग्विज जैसे मैटलैब या चाहे आप इस्तेमाल कर रहे हैं पाइथान, [सुनाई नहीं दिया], R, जावा, C++, इन सभी लैंग्विजेज़ में है या तो बिल्ट-इन या नियमित रूप में और सुलभ विभिन्न नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरीज़. वे अक्सर बहुत अच्छे से लिखी होती हैं, काफ़ी ऑप्टिमायज़्ड ढंग से, प्रायः बनाई गई होती है उन लोगों द्वारा जो पीएचडी होते हैं नूमेरिकल कम्प्यूटिंग में या वे विशेषज्ञ होते हैं नूमेरिकल कम्प्यूटिंग के. और जब आप इम्प्लमेंट करते हैं मशीन लर्निंग अल्गोरिद्म्स, यदि आप उठा सकते हैं लाभ इन लिनीअर ऐल्जेब्रा लाइब्रेरीज़ या इन नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरीज़ का, और कर सकते हैं कुछ रूटीन कॉल्ज़ उन्हें बजाय एक तरह से लिखने से कोड अपने आप करने के लिए काम जो ये लाइब्रेरीज़ कर सकती हैं. यदि आप वैसा करते हैं, तब अक्सर आपको मिलता है कोड, जो, अधिक कुशलता से काम करता है, अत: आप उसे रन कर सकते हैं अधिक गति से और ले सकते हैं बेहतर लाभ किसी समानांतर हार्डवेयर का जो आपके कम्प्यूटर में शायद हो और इसी तरह कुछ. और दूसरा, इसका मतलब यह भी है कि आपको कम कोड लिखना पड़ता है, इसलिए यह है एक सरलतर इम्प्लमेंटेशन जो इसलिए शायद हो सकते हैं थोड़ा अधिक फ़्री. और एक ठोस उदाहरण के रूप में, बजाय कोड खुद लिखने से गुणा करने के लिए मेट्रिसीज़ को, यदि आप ओकटेव को यह करने देते हैं टाइप करके a गुणा b, वह इस्तेमाल करेगा एक अधिक कुशल रूटीन गुणा करने के लिए दो मेट्रिसीज़ को. ऐसे बहुत से उदाहरण है इस तरह के, जहाँ यदि आप प्रयोग करते हैं उचित वेक्टराइज़ेशन इम्प्लमेंटेशन आपको मिलता है अपेक्षाकृत सरल कोड और अधिक कुशल कोड. चलो देखते है कुछ और उदाहरण. यह है हमारी हमेशा की हायपॉथिसस लिनीअर रेग्रेशन के लिए, और यदि आप कम्प्यूट करना चाहते हैं h(x), ध्यान दें वहाँ एक सम है दाईं तरफ़. और इसलिए एक काम जो आप कर सकते हैं, कम्प्यूट करें सम j=0 से j= n तक अपने आप. अन्य ढंग सोचने का इसे है कि सोचे h(x) को थीटा ट्रान्स्पोज़ x की तरह, और आप क्या कर सकते हैं, सोचें इसे कि आप कम्प्यूट कर रहे हैं इनर प्रोडक्ट दो वेक्टर्ज़ के बीच में जहाँ थीटा है आपका वेक्टर, मान लो, थीटा 0, थीटा 1, थीटा 2. यदि आपके पास हैं दो फ़ीचर्ज़, यदि n बराबर है दो, और यदि आप सोचते हैं x को इस वेक्टर की तरह, x0, x1, x2, और ये दो व्यूज़ दे सकते हैं आपको दो भिन्न इम्प्लमेंटेशन्स. मेरा मतलब ऐसे है. यहाँ है एक अनवेक्टराइज्ड इम्प्लमेंटेशन कि कैसे कम्प्यूट करना है और अनवेक्टराइज्ड से मेरा मतलब है बिना वेक्टराइज़ेशन के. हम पहले ईनिशीयलाइज करते हैं प्रिडिक्शन को सिर्फ़ 0.0 अंतत: प्रिडिक्शन होगा h(x), और तब मैं करूँगा एक फ़ॉर लूप j=1 से n +1 तक, प्रिडिक्शन बढ़ती है थीटा(j)* x(j) से. इसलिए, यह इस तरह का इक्स्प्रेशन है यहाँ पर. वैसे, मुझे उल्लेख करना चाहिए, इन वेक्टर्स में जो मैंने लिखे यहाँ, मेरे पास थे ये वेक्टर्स 0 इंडेक्स्ड. तो मेरे पास था थीटा 0, थीटा 1, थीटा 2. लेकिन क्योंकि मैटलैब है एक इंडेक्स्ड, मैटलैब में थीटा 0 होगा, हमें मिलना चाहिए थीटा 1 के रूप में और दूसरा एलिमेंट होगा थीटा 2 की तरह और यह तीसरा एलिमेंट शायद हो थीटा 3, सिर्फ़ इसलिए कि हमारे वेक्टर्स मैटलैब में इंडेक्स होते है शुरू 1 से, जबकि मैंने लिखा था थीटा और x यहाँ, शुरू करते हुए इंडेक्सिंग 0 से, जिस वजह से यहाँ मेरे पास है एक फ़ॉर लूप. j जाता है 1 से n + 1 तक, बजाय जाने के 0 से n तक, ठीक है? लेकिन तो यह है एक अनवेक्टराइज्ड इम्प्लमेंटेशन जिसमें हमारे पास है फ़ॉर लूप जो सम कर रहा है n एलिमेंट्स को सम के. इसके विपरीत, यहाँ है कि कैसे आप लिखेंगे एक वेक्टराइज्ड इम्प्लमेंटेशन, जो है कि आप सोचेंगे x और थीटा को वेक्टर्स की तरह. और आप सिर्फ़ कहेंगे प्रिडिक्शन = थीटा ' * x. आप सिर्फ़ कम्प्यूट कर रहे हो इतना ही. तो बजाय लिखने के ये सब लाइन्स कोड की फ़ॉर लूप के साथ, आपके पास इसके स्थान पर है एक लाइन कोड की. और यह लाइन कोड की दाईं तरफ़ जो करेगी वह है, यह इस्तेमाल करेगी ओकटेव की उच्च ऑप्टिमायज़्ड नूमेरिकल लिनीअर ऐल्जेब्रा रूटीन्स कम्प्यूट करने के लिए यह इनर प्रोडक्ट दो वेक्टर्स के बीच में, थीटा और x, और न केवल है वेक्टराइज्ड इम्प्लमेंटेशन सारा, यह रन करेगा अधिक कुशलता से. तो वह था ओकटेव, लेकिन वेक्टराइज़ेशन का मुद्दा अप्लाई होता है अन्य प्रोग्रामिंग लैंग्विजेज़ में भी. चलो देखते हैं एक उदाहरण C++ में. यहाँ है एक अनवेक्टराइज्ड इम्प्लमेंटेशन कैसे दिखती है. हम फिर से ईनिशीयलाइज करते हैं प्रिडिक्शन को 0.0 और फिर हमारे पास अब है एक फ़ॉर लूप j = 0 से n तक. प्रिडिक्शन + = थीटा j * x [j], जहां फिर से, आपके यह स्पष्ट फ़ॉर लूप है जो आप स्वयं लिखते हैं. इसके विपरीत, इस्तेमाल करके एक अच्छी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी C++ की, आप लिख सकते थे एक फ़ंक्शन ऐसा, या बजाय, इसके विपरीत, इस्तेमाल करके एक अच्छी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी C++ की, इसके स्थान पर आप लिख सकते हैं कोड जो शायद दिखे इस तरह का. अत: निर्भर करते हुए विस्तृत जानकारी पर आपकी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी पर, आपके पास हो सकती है एक ऑब्जेक्ट, यह है एक C++ ऑब्जेक्ट, जो है वेक्टर थीटा, और एक C++ ऑब्जेक्ट जो है वेक्टर x, और आप सिर्फ़ लेते हैं थीटा.ट्रान्स्पोज़ * x, जहाँ यह गुणा बन जाता है एक C++ का एक प्रकार से ओवरलोडेड ऑपरेटर तो आप बस गुणा कर सकते हैं ये दो वेक्टर्स C++ में. अत: निर्भर करते हुए विस्तृत जानकारी पर आपकी नूमेरिकल लिनीअर ऐल्जेब्रा लाइब्रेरी पर, आप शायद लिखें एक थोड़ा भिन्न सिंटैक्स, लेकिन निर्भर करने से लाइब्रेरी पर इस इनर प्रोडक्ट को करने के लिए, आपको मिल सकता है एक अधिक सरल हिस्सा कोड का और एक अधिक कुशल भी. चलो अब देखते हैं एक और अधिक परिष्कृत उदाहरण को. सिर्फ़ आपको याद दिलाने के लिए, यहाँ है हमाराअप्डेट नियम ग्रेडीयंट डिसेंट का लिनीअर रेग्रेशन के लिए. और तो हम अप्डेट करते हैं थीटा j उपयोग करते हुए इस नियम का, सारी वैल्यूज़ j = 0, 1, 2, और आगे. और यदि मैं सिर्फ़ लिखता हूँ ये इक्वेज़न्स थीटा 0, थीटा 1, थीटा 2 के लिए, मानते हुए कि हमारे पास हैं दो फ़ीचर्ज़, तो n = 2. तब ये अप्डेट्स जो हम करते हैं थीटा 0, थीटा 1, थीटा 2, के लिए, जहाँ आपको शायद याद हो मेरा बताना एक पहले के वीडियो मैं, कि ये होने चाहिए एक साथ अप्डेट्स. तो, चलो देखते हैं कि क्या हम बना पाते हैं एक वेक्टराइज्ड नोटेशन इसकी. यहाँ हैं मेरी वही तीन इक्वेज़न्स, लिखी हुई थोड़े छोटे फ़ॉंट मैं, और आप कल्पना कर सकते हैं कि एक ढंग इम्प्लमेंट करने का कोड की इन तीन लाइन्स को है कि बनाएँ एक फ़ॉर लूप जो कहता है j = 0 , 1, से 2 तक अप्डेट करें थीटा j, या वैसा कुछ. लेकिन इसके स्थान पर, चलो बनाते हैं एक वेक्टराइज्ड इम्प्लमेंटेशन और देखें क्या है हमारे पास एक सरल ढंग मूलरूप से कम्प्रेस करने का कोड की इन तीन लाइन्स को या एक फ़ॉर लूप जो प्रभावशाली ढंग से करता है ये तीन स्टेप्स, एक बार में एक सटेप. चलो देखते हैं यदि हम ले सकते हैं ये तीन स्टेप्स और कम्प्रेस कर सकते हैं उन्हें वेक्टराइज्ड कोड की एक लाइन में. यह है सुझाव. क्या करुंगा मैं कि, मैं सोचूँगा थीटा को एक वेक्टर की तरह, और मैं अपडेट करूँगा थीटा को थीटा- अल्फ़ा टाइम्ज़ कोई अन्य वेक्टर डेल्टा, जहाँ डेल्टा है बराबर 1 ओवर m, सम i= 1 से m तक. और तब यह टर्म दाईं तरफ़, ठीक है? तो, मैं समझाता हूँ क्या हो रहा है यहाँ. यहाँ, मैं ले रहा हूँ थीटा को एक वेक्टर की तरह, तो यह है एक n प्लस एक डिमेन्शनल वेक्टर, और मैं कह रहा हूँ थीटा हो जाता है अप्डेट क्योंकि वह है एक वेक्टर, Rn+1. अल्फ़ा है एक रियल नम्बर, और डेल्टा, यहाँ है एक वेक्टर. तो, यह है घटा करने का ऑपरेशन, वह है वेक्टर घटा करना, ठीक है? क्योंकि अल्फ़ा गुणा डेल्टा है एक वेक्टर, और इसलिए मैं कह रहा हूँ कि थीटा को मिलता है यह वेक्टर, अल्फ़ा गुणा डेल्टा घटाने से इससे. तो, एक वेक्टर डेल्टा क्या है? ठीक है यह वेक्टर डेल्टा, दिखता है ऐसा, और इसके होने का अभिप्राय है यह वास्तव में हैं यह चीज़ यहाँ पर. वास्तव में, डेल्टा है एक n प्लस एक डिमेन्शनल वेक्टर, और पहला ही एलिमेंट वेक्टर डेल्टा का होगा बराबर उसके. तो, यदि हमारे पास है डेल्टा, यदि हम इंडेक्स करते हैं इसे 0 से, यदि यह है डेल्टा 0, डेल्टा 1, डेल्टा 2, मैं क्या चाहता हूँ कि डेल्टा 0 है बराबर इस हरे बॉक्स के ऊपर यहाँ. और वास्तव में, आप अपने आप को यक़ीन करा सकते हो कि डेल्टा 0 है यह 1 से m सम h(x) का, x(i) माइनस y(i) गुणा x(i) 0. तो, मैं सुनिश्चित करता हूँ कि हम एक ही चीज़ समझ रहे हैं कि कैसे डेल्टा वास्तव में कम्प्यूट होता है. डेल्टा है 1 ओवर m टाइम्ज़ यह सम यहाँ पर, और क्या है यह सम? ठीक है, यह टर्म यहाँ, वह है एक रियल नम्बर, और दूसरी टर्म यहाँ पर, x i, यह टर्म वहाँ है एक वेक्टर, ठीक है, क्योंकि x(i) शायद हो सकता है एक वेक्टर जो होगा, मान लो, x(i)0, x(i)1, x(i)2, ठीक है, और क्या है यह समेशन? ठीक है, क्या यह समेशन कह रहा है कि, यह टर्म, कि यह टर्म यहाँ पर, यह है बराबर (h of(x(1))- y(1))* x(1) + (h(x(2))- y(2)*x(2)) + इसी तरह आगे, ठीक है? क्योंकि यह है समेशन i का, तो जैसे i जाता है i=1 से m तक, आपको मिलती हैं ये भिन्न टर्म्ज़, और आप जोड़ रहे हैं ये टर्म्ज़ यहाँ. और मतलब इन टर्म्ज़ का, यह है काफ़ी कुछ यदि आपको याद हो वास्तव में, इसकी पिछली क्विज़ से, ठीक है, आपने देखी थी यह इक्वेज़न. हमने कहा था कि वेक्टराइज़ करने के लिए इस कोड को, हम इसके स्थान पर कहेंगे u= 2v + 5w. तो हम कह रहे हैं कि वेक्टर u बराबर है दो गुणा वेक्टर v जमा पाँच गुणा वेक्टर w. तो यह है एक उदाहरण कि कैसे जोड़ना है विभिन्न वेक्टर्स को और यह समेशन है वही चीज़. यह कह रहा है कि समेशन यहाँ पर है सिर्फ़ कुछ रियल नम्बर्ज़, ठीक है? यह है एक प्रकार से नम्बर दो या कोई और नम्बर गुणा वेक्टर, x1. तो यह है जैसे 2v या मान लो कोई और नम्बर गुणा x1, और तब जमा बजाय 5w हमारे पास इसके स्थान पर है कोई और रियल नम्बर, जमा कोई और वेक्टर, और तब आप जोड़ते हो अन्य वेक्टर्ज़, जमा डॉट, डॉट, डॉट, जमा अन्य वेक्टर्स, जिस वजह से, पूरी, यह चीज़ यह, यह पूरी मात्रा, वह डेल्टा है सिर्फ़ कोई वेक्टर. और वस्तुत:, तीन एलिमेंट्स डेल्टा के कॉरेस्पॉंड करते है यदि n = 2, तीन एलिमेंट्स डेल्टा के कॉरेस्पॉंड करते हैं इसी ही चीज़ को. दूसरी चीज़ को , और तीसरी चीज़ को. यही वजह है कि जब आप अप्डेट करते हैं थीटा को थीटा-अल्फ़ा डेल्टा के अनुसार, हम कर पाते हैं बिलकुल वही अप्डेट्स एक साथ उस अप्डेट नियम के अनुसार जो हमारे पास है ऊपर. तो, मैं जानता हूँ वह बहुत कुछ था जो हुआ इस स्लाइड पर, लेकिन फ़िर से, रोक सकते हैं इस वीडियो को और यदि आप निश्चित नहीं है कि क्या हुआ अभी मैं प्रोत्साहित करूँगा आपको कि देखें इस स्लाइड को करने के लिए सुनिश्चित कि आप समझ पाए हैं कि क्यों है अप्डेट यहाँ डेल्टा की इस परिभाषा के साथ, ठीक है, क्यों है कि यह है बराबर इस अप्डेट के जो ऊपर है? और अगर यह अभी भी स्पष्ट नहीं है, एक अंतर्दृष्टि है कि, यह चीज़ यहाँ पर, यह है वास्तव में वेक्टर x, और इसलिए हम सिर्फ़ ले रहे हैं ये तीनों कॉम्प्यूटेशन्स, और कम्प्रेस कर रहे हैं उनको एक सटेप में इस वेक्टर डेल्टा से, जिस वजह से हम बना सकते हैं एक वेक्टराइज्ड इम्प्लमेंटेशन इस स्टेप की इस तरह से. तो, मुझे आशा है कि यह स्टेप समझ में आया है और अवश्य देखें वीडियो और जाने कि आप इसे समझ पाए हैं. यदि आपको नहीं समझा है पूरी तरह से समानता इस मैप की, यदि आप इम्प्लमेंट करते हैं इसे, यह देगा वैसे भी सही उत्तर. तो, यदि आप नहीं ही समझ पाए हैं समानता, यदि आप सिर्फ़ इसे इम्प्लेमेट करते हैं इस तरह, आप करवा पाएँगे लिनीअर रेग्रेशन को काम. लेकिन यदि आप समझ पाए हैं कि क्यों ये दो स्टेप्स समान है, तब उम्मीद हैं वह देगा आपको एक बेहतर समझ वेक्टराइज़ेशन की भी. और अंत में, यदि आप इम्प्लमेंट कर रहे हैं लिनीअर रेग्रेशन इस्तेमाल करते हुए एक से अधिक या दो फ़ीचर्ज़, तो कभी-कभी हम इस्तेमाल करते हैं लिनीअर रेग्रेशन 10 या 100 या 1000 फ़ीचर्ज़ के साथ. लेकिन यदि आप करते हैं वेक्टराइज्ड इम्प्लमेंटेशन लिनीअर रेग्रेशन की, आप देखेंगे कि वह रन करेगा अधिक तेज़ तुलना में यदि आपके पास होता, मान लो, आपका पुराना फ़ॉर लूप जो अप्डेट कर रहा था थीटा ज़ीरो, तब थीटा एक, तब थीटा दो ख़ुद. तो इस्तेमाल करने से एक वेक्टराइज्ड इम्प्लमेंटेशन, आप को मिलनी चाहिए एक अधिक कुशल इम्प्लमेंटेशन लिनीअर रेग्रेशन की. और जब आप वेक्टराइज़ करेंगे बाद के अलगोरिद्म्स जो हम देखेंगे इस क्लास में, यह है एक तरकीब, चाहे ओकटेव हो या कोई अन्य लैंग्विज जैसे C++, जावा, चलाने के लिए आपके कोड को अधिक कुशलता से.