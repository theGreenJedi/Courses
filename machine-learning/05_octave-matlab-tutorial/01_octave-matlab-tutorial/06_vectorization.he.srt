1
00:00:00,320 --> 00:00:03,682
בסרטון הזה אני רוצה לספר לכם על הרעיון של וקטוריזציה.

2
00:00:03,682 --> 00:00:08,380
אז אם אתה משתמש אוקטבה או שפה דומה כמו MATLAB או

3
00:00:08,380 --> 00:00:12,540
אם אתה משתמש בפייתון, ++NumPy, R, Java, C,

4
00:00:12,540 --> 00:00:17,470
או כל אחת מהשפות הללו, קיימות בתוכם או שהוספו על גביהן

5
00:00:17,470 --> 00:00:21,840
ספריות נגישות של אלגברה לינארית נומרית.

6
00:00:21,840 --> 00:00:24,400
בדרך כלל הן כתובות היטב, יעילות במיוחד,

7
00:00:24,400 --> 00:00:29,250
לעתים קרובות הן פותחו על ידי אנשים שיש להם תואר דוקטור במחשוב נומרי

8
00:00:29,250 --> 00:00:32,070
או שהם ממש מומחים במחשוב נומרי.

9
00:00:32,070 --> 00:00:35,590
וכאשר אנחנו מיישמים אלגוריתמים של למידה חישובית, אם אנחנו

10
00:00:35,590 --> 00:00:39,880
יכולים לנצל את הספריות האלה של אלגברה ליניארית או אלגברה

11
00:00:39,880 --> 00:00:44,510
לינארית נומרית, ולקרוא לפונקציות בתוכן במקום

12
00:00:44,510 --> 00:00:48,470
לקודד בעצמנו את אותם דברים שהספריה אולי עושה,

13
00:00:48,470 --> 00:00:51,970
אם אנחנו עושים את זה, אז בדרך כלל נקבל קוד שהוא, ראשית, יעיל יותר,

14
00:00:51,970 --> 00:00:53,170
פשוט רץ מהר יותר,

15
00:00:53,170 --> 00:00:58,120
ומנצל יותר טוב כל חומרה מקבילית שייתכן שקיימת במחשב.

16
00:00:58,120 --> 00:01:03,080
ושנית, זה גם אומר שבסופו של דבר יש לך פחות קוד שאתה בעצמך צריך לכתוב,

17
00:01:03,080 --> 00:01:07,330
אז היישום יוצא יותר פשוט ולכן יש לו גם סיכוי יותר גבוה

18
00:01:07,330 --> 00:01:08,540
להיות נקי משגיאות.

19
00:01:08,540 --> 00:01:13,450
וכדוגמה קונקרטית, במקום לכתוב בעצמך קוד

20
00:01:13,450 --> 00:01:18,170
להכפלת מטריצות, אם תיתן לאוקטבה לעשות זאת על ידי הקלדת A כפול B,

21
00:01:18,170 --> 00:01:22,220
היא תשתמש בפונקציה מאוד יעילה כדי לכפול את המטריצות.

22
00:01:22,220 --> 00:01:26,090
ויש קבוצה של דוגמאות כאלה, שבהן אם תשתמש ביישומי

23
00:01:26,090 --> 00:01:30,310
וקטוריזציה מתאימים תקבל קוד הרבה יותר פשוט והרבה יותר יעיל.

24
00:01:30,310 --> 00:01:31,470
בואו נראה מספר דוגמאות.

25
00:01:33,090 --> 00:01:36,110
הנה פונקצית ההשערה הרגילה שלנו לרגרסיה ליניארית,

26
00:01:36,110 --> 00:01:40,010
ואם אתה רוצה לחשב את (h(x, שימו לב שיש כאן סכום מימין.

27
00:01:40,010 --> 00:01:46,660
אז אחת האפשרויות שלך היא לחשב את הסכום מ-j = 0 ועד j = n בעצמך.

28
00:01:46,660 --> 00:01:51,920
דרך נוספת לחשוב על זה היא לחשוב על (h(x כתטא משוחלפת כפול x,

29
00:01:51,920 --> 00:01:56,330
ואז מה שאפשר לעשות הוא לחשוב על זה כעל מכפלה פנימית

30
00:01:56,330 --> 00:02:03,220
בין שני וקטורים, שבה תטא הוא הוקטור, נניח, תטא-0, תטא-1, תטא-2

31
00:02:03,220 --> 00:02:07,221
אם יש שתי תכונות, אם n שווה שתיים,

32
00:02:07,221 --> 00:02:11,632
ואם אתה חושב על x כעל וקטור x0, x1, x2.

33
00:02:11,632 --> 00:02:17,590
ושתי הגישות האלה יכולות להניב שני מימושים שונים.

34
00:02:17,590 --> 00:02:18,820
אסביר את כוונתי.

35
00:02:18,820 --> 00:02:23,623
הנה יישום של החישוב שהוא לא וקטורי וכשאני אומר לא וקטורי,

36
00:02:23,623 --> 00:02:25,360
אני מתכוון שאין בו וקטוריזציה.

37
00:02:25,360 --> 00:02:30,160
הנה דוגמא של יישום, אנו נאתחל משתנה בשם "תחזית" ל-0.0.

38
00:02:30,160 --> 00:02:36,057
בסוף התהליך "תחזית" תהיה (h(x, ועכשו נריץ

39
00:02:36,057 --> 00:02:42,320
לולאה עבור j = 1 עד n + 1, נוסיף ל"תחזית" את תטא-j כפול (x(j

40
00:02:42,320 --> 00:02:44,740
זה הביטוי הזה כאן.

41
00:02:44,740 --> 00:02:45,736
אגב, אני צריך להזכיר

42
00:02:45,736 --> 00:02:51,100
שהוקטורים האלה שכתבתי כאן הם וקטורים עם אינדקסים שמתחילים מ-0.

43
00:02:51,100 --> 00:02:53,270
ולכן כאן יש לנו תטא-0, תטא-1 ותטא-2.

44
00:02:53,270 --> 00:02:58,543
אבל מאחר וב-MATLAB האברים בוקטור מתחילים מאחת,

45
00:02:58,543 --> 00:03:03,557
תטא-0 ב-MATLAB נקרא תטא-1 והאיבר הבא נקרא תטא-2

46
00:03:03,557 --> 00:03:08,570
והשלישי תטא-3, אבל רק בגלל שהווקטורים שלנו

47
00:03:08,570 --> 00:03:13,411
ב-MATLAB מבוססי אינדקס 1. לכן, למרות

48
00:03:13,411 --> 00:03:18,620
שקראתי כאן לוקטורים תטא ו-x, שהם מתחילים מ-0, בלולאת for שלנו

49
00:03:18,620 --> 00:03:25,480
j הולך מ 1 עד n + 1 ולא מ-0 עד n, ברור?

50
00:03:25,480 --> 00:03:30,286
אבל בכל אופן, זה יישום לא-וקטורי כי יש לנו כאן

51
00:03:30,286 --> 00:03:33,940
לולאת for שמסכמת את n האלמנטים שמרכיבים את הסכום.

52
00:03:33,940 --> 00:03:39,251
לעומת זאת, הנה דוגמה של כתיבה וקטורית,

53
00:03:39,251 --> 00:03:43,290
שבה אנחנו חושבים על x ותטא כעל וקטורים.

54
00:03:43,290 --> 00:03:46,620
כאן פשוט נכתוב "תחזית" = תטא * x.

55
00:03:46,620 --> 00:03:48,150
מחשבים את זה פשוט כך.

56
00:03:48,150 --> 00:03:52,077
אז במקום לכתוב את כל שורות הקוד האלה עם לולאת for,

57
00:03:52,077 --> 00:03:54,620
צריך רק שורת קוד אחת.

58
00:03:54,620 --> 00:03:57,764
ומה ששורת הקוד מימין תעשה הוא

59
00:03:57,764 --> 00:04:02,604
פשוט להשתמש בשגרות המאוד אופטימליות של אלגברה לינארית נומרית באוקטבה

60
00:04:02,604 --> 00:04:07,823
כדי לחשב את המכפלה הפנימית הזו בין שני הוקטורים, תטא ו-X, ובנוסף לכך

61
00:04:07,823 --> 00:04:13,250
שהיישום הוקטורי הוא פשוט בהרבה, הוא גם הרבה יותר יעיל.

62
00:04:15,850 --> 00:04:17,590
זה היה באוקטבה, אבל

63
00:04:17,590 --> 00:04:22,080
הנושא של וקטוריזציה קיים גם בשפות תכנות אחרות.

64
00:04:22,080 --> 00:04:24,740
בואו נסתכל על דוגמה ב++C.

65
00:04:24,740 --> 00:04:27,820
זו דוגמא של יישום שאיננו וקטורי.

66
00:04:27,820 --> 00:04:31,468
אנחנו שוב מאתחלים את "תחזית" ל-0.0

67
00:04:31,468 --> 00:04:35,650
ואז מבצעים לולאת for עבור j = 0 עד n.

68
00:04:35,650 --> 00:04:40,598
"תחזית" + = תטא-j כפול  [x[j, וכאן שוב יש לולאת for מפורשת

69
00:04:40,598 --> 00:04:42,620
שאנחנו כותבים בעצמנו.

70
00:04:42,620 --> 00:04:47,720
לעומת זאת, בשימוש בספריה בסיסית טובה של אלגברה לינארית נומרית ב-++C,

71
00:04:47,720 --> 00:04:50,950
אפשר לכתוב פונקציה כזו, או ליתר דיוק,

72
00:04:54,410 --> 00:04:59,000
לעומת זאת, בשימוש בספריה בסיסית טובה של אלגברה לינארית נומרית ב-++C,

73
00:04:59,000 --> 00:05:02,500
אפשר במקום זאת לכתוב קוד שנראה משהו כמו זה.

74
00:05:02,500 --> 00:05:06,540
תלוי בפרטים המדויקים של איזו ספרייה יש לכם לפעולות אלגברה לינארית נומרית,

75
00:05:06,540 --> 00:05:11,230
ייתכן שאפשר ליצור אובייקט, אובייקט של ++ C, שהוא הוקטור תטא,

76
00:05:11,230 --> 00:05:17,540
ועוד אובייקט ++C שהוא הוקטור x, וצריך פשוט לכתוב  theta.transpose * x,

77
00:05:17,540 --> 00:05:22,270
בו הכפל הוא מה שנקרא ב++C בשם Operator Overload

78
00:05:22,270 --> 00:05:26,380
שמאפשר להגדיר כפל על אובייקטים מסוג וקטורים, ולכן אפשר פשוט להכפיל את שני הוקטורים האלה ב ++C.

79
00:05:26,380 --> 00:05:30,390
ובתלות בפרטים של הספריית הזו של אלגברה לינארית נומרית,

80
00:05:30,390 --> 00:05:32,880
ייתכן שתצטרך תחביר קצת שונה, אבל

81
00:05:32,880 --> 00:05:35,800
בכל אופן על ידי כך שהספרייה בעצם תבצע את המכפלה הפנימית הזו בין הוקטורים,

82
00:05:35,800 --> 00:05:39,290
נקבל פיסת קוד הרבה יותר פשוטה וגם הרבה יותר יעילה.

83
00:05:40,660 --> 00:05:43,590
עכשיו בואו נראה דוגמא יותר מתוחכמת.

84
00:05:43,590 --> 00:05:45,840
רק להזכיר לכם, הנה כלל העדכון שלנו

85
00:05:45,840 --> 00:05:48,260
של ירידה בשיפוע ברגרסיה ליניארית.

86
00:05:48,260 --> 00:05:55,070
באמצעות הכלל הזה אנחנו מעדכנים את תטא-j עבור כל הערכים של j = 0, 1, 2, וכו'.

87
00:05:55,070 --> 00:05:59,575
אז נכתוב את המשוואות הללו עבור תטא-0, תטא-1

88
00:05:59,575 --> 00:06:03,410
ותטא-2, בהנחה שיש לנו שתי תכונות, זאת אומרת ש-n = 2.

89
00:06:03,410 --> 00:06:08,377
אלה הם העדכונים שאנו עושים לתטא-0, תטא-1 ותטא-2, ואולי אתם

90
00:06:08,377 --> 00:06:13,230
זוכרים שאמרתי בסרטון קודם שהעדכונים צריכים להיות סימולטניים.

91
00:06:14,850 --> 00:06:19,580
בואו נראה אם ​​אנחנו יכולים לכתוב את זה בצורה וקטורית.

92
00:06:20,754 --> 00:06:24,120
הנה אותן שלוש משוואות כתובות בגופן קצת יותר קטן,

93
00:06:24,120 --> 00:06:28,110
ואתם יכולים לדמיין דרך אחת ליישם את שלוש השורות האלו של קוד על ידי לולאת

94
00:06:28,110 --> 00:06:35,500
for שעוברת על j מקבל ערכים 0, 1 ו-2 ומעדכנת את תטא-j, או משהו דומה לזה.

95
00:06:35,500 --> 00:06:39,570
אבל במקום זה בואו נכתוב יישום וקטורי של זה ונראה

96
00:06:39,570 --> 00:06:43,830
שאנחנו בעצם יכולים בצורה מאוד פשוטה לדחוס את שלוש השורות האלה של קוד,

97
00:06:43,830 --> 00:06:48,540
את לולאת ה-for לקוד קצר ויעיל שעושה את כל קבוצת שלושת הצעדים האלה בצעד אחד.

98
00:06:48,540 --> 00:06:50,070
בואו נראה אם אנחנו מצליחים לקחת את שלושת הצעדים

99
00:06:50,070 --> 00:06:54,220
ולדחוס אותם לתוך שורה אחת של קוד וקטורי.

100
00:06:54,220 --> 00:06:55,500
הנה הרעיון.

101
00:06:55,500 --> 00:06:58,538
מה שאני הולך לעשות הוא

102
00:06:58,538 --> 00:07:03,458
לחשוב על תטא כעל וקטור,

103
00:07:03,458 --> 00:07:08,090
והצעד שלנו יהיה לעדכן את תטא

104
00:07:08,090 --> 00:07:12,723
ולהפחית ממנו אלפא כפול איזשהו וקטור דלתא,

105
00:07:12,723 --> 00:07:18,511
שבו דלתא יהיה 1 חלקי m

106
00:07:18,511 --> 00:07:21,740
כפול הסכום הזה מ-i = 1 עד m

107
00:07:21,740 --> 00:07:28,100
של הביטוי הזה מימין, מובן?

108
00:07:28,100 --> 00:07:29,840
תנו לי להסביר מה קורה כאן.

109
00:07:31,310 --> 00:07:34,920
כאן אנחנו מתייחסים לתטא כאל וקטור,

110
00:07:34,920 --> 00:07:38,170
הוא וקטור בעל ממד n ועוד אחת,

111
00:07:38,170 --> 00:07:43,610
ואני אומר שתטא הוא וקטור ממשי בעל ממד n + 1.

112
00:07:43,610 --> 00:07:50,080
אלפא הזה הוא מספר ממשי, ודלתא כאן היא וקטור.

113
00:07:50,080 --> 00:07:54,920
אז פעולת החיסור הזו היא חיסור של וקטורים, כן?

114
00:07:54,920 --> 00:07:58,380
כי אלפא כפול דלתא הוא וקטור,

115
00:07:58,380 --> 00:08:04,270
ומה שכתוב כאן הוא שאנחנו מציבים בתטא את הוקטור המקורי תטא פחות אלפא כפול דלתא.

116
00:08:04,270 --> 00:08:06,580
ועכשיו, מה הוא הוקטור דלתא?

117
00:08:06,580 --> 00:08:10,959
אז דלתא הוא הוקטור הזה, הוא נראה כך,

118
00:08:10,959 --> 00:08:17,040
ומה שהוא אמור להיות באמת הוא הדבר הזה כאן.

119
00:08:17,040 --> 00:08:22,066
באופן קונקרטי, דלתא הוא וקטור בעל ממד n ועוד אחד,

120
00:08:22,066 --> 00:08:27,570
והאיבר הראשון של הווקטור דלתא הוא הביטוי הזה.

121
00:08:27,570 --> 00:08:32,203
אז אם יש לנו הוקטור דלתא, אם נניח שהאינדקסים שלו מתחילים מ-0,

122
00:08:32,203 --> 00:08:37,288
אז זה דלתא 0, דלתא 1, דלתא 2, אז מה שאני רוצה הוא

123
00:08:37,288 --> 00:08:42,730
שדלתא 0 יהיה שווה למה שכתוב במסגרת הראשונה כאן למעלה בירוק.

124
00:08:42,730 --> 00:08:48,621
וייתכן שתוכל לשכנע את עצמך

125
00:08:48,621 --> 00:08:53,964
שדלתא 0 היא 1 חלקי m של הסכום מ-h של תטא

126
00:08:53,964 --> 00:08:58,360
((x(i) - y(i) כפול (x0(i.

127
00:08:58,360 --> 00:09:01,352
אז בואו רק נוודא שאנחנו מבינים בצורה זהה

128
00:09:01,352 --> 00:09:04,010
איך בעצם מחשבים את דלתא.

129
00:09:04,010 --> 00:09:09,930
דלתא היא 1 חלקי m כפול הסכום הזה כאן, ומהו הסכום הזה?

130
00:09:09,930 --> 00:09:15,782
אז הביטוי הזה כאן הוא מספר ממשי,

131
00:09:15,782 --> 00:09:19,772
והמונח השני כאן, x i,

132
00:09:19,772 --> 00:09:24,427
הוא וקטור, מבינים,

133
00:09:24,427 --> 00:09:29,481
כי (x(i יכול לדוגמא להיות הוקטור

134
00:09:29,481 --> 00:09:34,136
x(i)0, x(i)1, x(i)2,

135
00:09:34,136 --> 00:09:38,150
נכון, ומה זה הסיכום הזה כאן?

136
00:09:38,150 --> 00:09:44,142
ומה שהסכום כאן אומר הוא

137
00:09:44,142 --> 00:09:49,504
שהביטוי הזה, הביטוי הזה כאן,

138
00:09:49,504 --> 00:09:54,707
שווה ל-

139
00:09:54,707 --> 00:10:00,700
(h(x(1))-y(1))*x0(1) + (h(x(2))-y(2))*x0(2)

140
00:10:00,700 --> 00:10:06,080
+ ... וכן הלאה, בסדר?

141
00:10:06,080 --> 00:10:10,041
כי זה סכום על כל ה-i מ-i = 1 עד m,

142
00:10:10,041 --> 00:10:15,100
אז אנחנו מקבלים את כל הביטויים האלה, ומסכמים אותם.

143
00:10:15,100 --> 00:10:19,990
והמשמעות של המונחים האלו, זה מאוד דומה למה שאולי אתם זוכרים

144
00:10:19,990 --> 00:10:23,760
שהיה בבוחן הקודם, כן, כבר ראיתם את המשוואה הזאת.

145
00:10:23,760 --> 00:10:30,680
אמרנו שכדי לעשות את הקוד הזה וקטורי, אז במקום סיכום נכתוב u = 2v + 5W.

146
00:10:30,680 --> 00:10:34,760
או במלים אחרות הוקטור u שווה לשתיים כפול הוקטור v

147
00:10:34,760 --> 00:10:36,470
ועוד חמש כפול הוקטור w.

148
00:10:36,470 --> 00:10:40,530
אז זו דוגמא כיצד לחבר וקטורים,

149
00:10:40,530 --> 00:10:42,940
והסיכום כאן הוא אותו דבר.

150
00:10:42,940 --> 00:10:49,740
התוצאה של הסכום הזה היא פשוט איזה שהוא מספר ממשי, זה ברור?

151
00:10:49,740 --> 00:10:54,370
זה קצת דומה לשתיים או איזה שהוא מספר אחר כפול וקטור, x1.

152
00:10:54,370 --> 00:10:59,213
אז זה קצת כמו 2v או אולי איזה מספר אחר כפול x1,

153
00:10:59,213 --> 00:11:04,244
ובמקום להוסיף 5w אנחנו מוסיפים איזה מספר ממשי

154
00:11:04,244 --> 00:11:09,739
ועוד איזה וקטור, ועוד ועוד וקטורים,

155
00:11:09,739 --> 00:11:14,580
וזו הסיבה בעצם

156
00:11:14,580 --> 00:11:20,670
שכל הדבר הזה כאן, כל הגודל הזה, דלתא, הוא פשוט איזשהו וקטור.

157
00:11:22,240 --> 00:11:27,592
וקונקרטית, שלושת האברים של דלתא מתאימים, אם n = 2,

158
00:11:27,592 --> 00:11:32,800
שלושת האברים של דלתא מתאימים בדיוק לדבר הזה,

159
00:11:32,800 --> 00:11:35,920
לדבר השני, ולדבר השלישי כאן.

160
00:11:35,920 --> 00:11:41,050
ולכן כאשר תעדכן את תטא לתטא פחות אלפא כפול דלתא,

161
00:11:41,050 --> 00:11:44,610
אנחנו בעצם נעשה את כל העדכונים בצורה סימולטנית

162
00:11:44,610 --> 00:11:46,670
בדיוק כמו שהגדרנו בכללי העדכון שלנו.

163
00:11:47,980 --> 00:11:51,940
אני מבין ששקף הזה הוא עמוס מאוד במידע, אבל כמו שכבר אמרתי,

164
00:11:51,940 --> 00:11:57,010
אל תהסס להשהות את הסרטון, ואם אתה לא בטוח

165
00:11:57,010 --> 00:12:02,590
מה בדיוק קורה הייתי ממליץ לך לבצע בעצמך את השלבים בשקופית הזו

166
00:12:02,590 --> 00:12:08,435
כדי לוודא שאתה מבין למה העדכון הזה כאן, עם ההגדרה הזאת של דלתא,

167
00:12:08,435 --> 00:12:12,870
למה הוא זהה לעדכון הזה למעלה.

168
00:12:12,870 --> 00:12:18,430
ואם זה עדיין לא ברור, השתמשו בתובנה שהדבר הזה כאן,

169
00:12:18,430 --> 00:12:21,960
זהו בדיוק הוקטור x,

170
00:12:21,960 --> 00:12:26,560
ואנחנו למעשה לוקחים את כל שלושת החישובים האלה, ודוחסים אותם

171
00:12:26,560 --> 00:12:31,420
לצעד אחד עם הוקטור דלתא הזה, וכך אנחנו מצליחים לבצע

172
00:12:31,420 --> 00:12:36,000
יישום וקטורי של השלב הזה של העדכון.

173
00:12:37,010 --> 00:12:41,630
אז אני מקווה שהצעד הזה נראה לכם הגיוני ובבקשה תסתכלו בוידאו

174
00:12:41,630 --> 00:12:44,030
ותראו אם אתם מצליחים להבין את זה.

175
00:12:44,030 --> 00:12:47,230
אבל גם אם אתם לא ממש מבינים למה שתי הגישות האלה שקולות,

176
00:12:47,230 --> 00:12:50,620
אם תיישמו את זה אז תקבלו את התשובה הנכונה בכל מקרה.

177
00:12:50,620 --> 00:12:53,839
אז גם אם אתם לא ממש מבינים את השקילות,

178
00:12:53,839 --> 00:12:58,610
אם רק תיישמו את זה ככה, תצליחו לגרום לרגרסיה הליניארית לעבוד.

179
00:12:58,610 --> 00:13:03,142
אבל אם אתם כן מסוגלים להבין מדוע שני התהליכים הללו הם שקולים,

180
00:13:03,142 --> 00:13:08,710
אז אני מקווה שזה גם ייתן לכם הבנה טובה יותר של הוקטוריזציה.

181
00:13:08,710 --> 00:13:13,210
ולבסוף, אם אתם צריכים ליישם רגרסיה ליניארית עם הרבה יותר מאחת

182
00:13:13,210 --> 00:13:17,915
או שתי תכונות, לפעמים אנו בונים רגרסיה ליניארית עם 10 או 100

183
00:13:17,915 --> 00:13:19,650
או 1000 תכונות,

184
00:13:19,650 --> 00:13:23,140
אז אם תשתמשו ביישום וקטורי של הרגרסיה הליניארית,

185
00:13:23,140 --> 00:13:27,465
תראו שהוא יפעל הרבה יותר מהר מאשר נניח לו תכתבו

186
00:13:27,465 --> 00:13:31,500
בעצמכם לולאה שמעדכנת את תטא-0, ואחר כך את תטא-1, ואז תטא-2.

187
00:13:31,500 --> 00:13:34,220
אז, באמצעות יישום וקטורי אתם אמורים להיות

188
00:13:34,220 --> 00:13:37,860
מסוגלים לייצר יישום הרבה יותר יעיל של רגרסיה ליניארית.

189
00:13:37,860 --> 00:13:41,820
וכשתעשו וקטוריזציה של אלגוריתמים שנראה יותר מאוחר בקורס הזה,

190
00:13:41,820 --> 00:13:45,110
יש טריק טוב, בין אם תשתמשו באוקטבה או בשפה אחרת כמו ++C או Java,

191
00:13:45,110 --> 00:13:47,700
כדי לגרום לקוד שלכם לפעול באופן יעיל יותר.