このビデオでは、ベクトル化という概念について説明します。 Octave や類似した言語 MATLAB を使っていても、 あるいは Python および NumPy あるいは Java、C、C++ を使っていても、 これら全ての言語は、 既に内蔵されているか、 あるいは、すぐに簡単に入手可能な異なる 数値線型代数ライブラリがあります。 通常、これらは非常によく書かれており、 高度に最適化され、多くの場合、 数値計算の分野で博士号を持つか、 数値計算に本当に特化した人たちによって開発されています。 機械学習アルゴリズムを 実装する時に、こうした 線型代数ライブラリ、こうした 数値線型代数を 活用し、 これらのルーチンを呼び出すことにより、 こうしたライブラリができることを 自分でコードに書く代わりに使えれば、 そうすれば 多くの場合、コードは第一にもっと効率的になります。 ということはもっと実行速度が速くなり、 お手持ちのコンピュータに 搭載されているかもしれない並列処理ハードウェアを をさらに利用できるようになります。 そして二番目に、これは 書かなければならないコードの量が少なくなることも意味します。 つまり、実装が簡素になり、 さらに、そのために、バグも少なくなる可能性があります。 そして、具体的な例として、 行列の乗算をするのに 自分でコードを書く代わりに、 Octave にそれをやらせて a * b と入力すると、 それは非常に効率的な ルーチンを使って二つの行列の乗算を行います。 そして、こうした例は他にもいくつもあり、 適切なベクトル化された実装方法を採用することで コードが簡素になり、さらにもっと効率的なコードになります。 では、いくつか例を見てみましょう。 ここに、通常の線形回帰 の仮説があります。 h(x) を計算したい場合は、 お気づきのように右辺では合計を行うことになります。 一つのやり方は、 j=0 から j=n までの 合計を自分で計算することです。 もう一つの考え方は、 h(x) を theta の転置行列と x との乗算と見なすことです。 ここで出来ることは 二つのベクトルの 内積を計算することだと考えるのです。 ここでは theta は、そうですね 二つの特徴がある場合、ベクトルは theta 0、theta 1、theta 2 となります。 その場合は n = 2 です。 そして x はこのような ベクトルになります x 0、x 1、x 2 そしてこの二つの見方は、 二通りの実装方法につながります。 その意味は次の通りです。 ここに非ベクトル化の h(x) の演算方法の実装があります。 非ベクトル化とは、ベクトル化されていない、という意味です。 最初に prediction を 0.0 に初期化します。 これは、そのうちに prediction は、そのうちに h(x) になります。そして prediction は、そのうちに j = 1 から n+1 とします。 prediction は theta(j) * x(j) でインクリメントされます これは、ちょうどこの式に相当します。 ところで、触れておくべき点として、ここにある 右上のベクトルですが、 ここでは インデックスを 0 から始めています。 ですから、theta 0、theta 1 theta 2、としていました。しかし、MATLAB では インデックスは 1 から始まるので、theta 0 を MATLAB では表現方法を 変えて theta 1 とし、 この二番目の要素は theta 2 になり 三番目の要素は theta 3 となります。 これは単に MATLAB では ベクトルのインデックスは 1 から始まるのに対し、私たちの 本来の theta および x は 0 からインデックスが始まるからです。 これが理由で、ここの for ループでは j は 1 から n+1 に進み、 j が 0 から n へは進まない のです。お分かり頂けましたか。 ということで、これは ここに非ベクトル化の実装方法で、 n 要素の合計を行うのに for ループを使っています。 それとは対照的に、これが ここにベクトル化された実装方法の書き方、 つまり、 x および theta ベクトルとして考え、 prediction に theta の転置行列と x との乗算を代入します。このようにして計算します。 for ループを使ってこうした何行もの コードを書く代わりに たったの一行の コードで済みます。そして この右の一行のコードが 実行するのは、 Octave の高度に最適化された数値 線形代数ルーチンを使って 二つのベクトルtheta および x の 内積を算出します。 単にベクトル化された実装の方が 簡素なだけでなく、より効率的に実行されます。 さて、これは Octave でしたが、 ベクトル化は 他のプログラミング言語でも適用可能です。 では C++ の例をみてみましょう。 ここに非ベクトル化の実装例があります。 ここでも prediction を0.0 に初期化し そしてこの場合は ループが j=0 から n の範囲となります。 prediction += theta[j] * x[j]; ここでも また、この 明示的な for ループを自分で書くことになります。 対照的に、C++ でもよい 数値線型代数ライブラリを 使うと、ここでもこのような 関数を書くことができます。いえ、むしろ 対照的に、C++ でもよい 数値線型代数ライブラリを 使うと、代わりに 次のようなコードを書くことができます。 お使いの数値線型代数 ライブラリにより 詳細は異なりますが オブジェクトとして c++ オブジェクトとして ベクトル theta と c++ オブジェクトとしてベクトル x が定義され、 そして単に theta .transpose() に対して x の乗算を行います。 この乗算演算子は、C++ で オーバーロードされた演算子となり、 C++ でも単に二つのベクトルを乗算することが出来ます。 そしてお使いの数値線型代数 ライブラリの詳細次第では、 多少異なる構文を 使うことになるかもしれませんが ライブラリを利用して この内積を行うことにより コードを非常に簡素化でき、 さらにそれは非常に効率的なものになります。 ではさらに詳細な例を見てみましょう。 念のため、ここに 線形回帰の場合の 最急降下法の更新ルールがあります。 ですから theta j をこの ルールを使って全ての j の値で更新します。 j=0、1、2、という風に。 そして、これを theta 0、 theta 1、 theta 2 を使って式で表すとこうなります。 特徴の数が二つであるという前提です。 ですから n=2 です。 よって、これが私たちが theta 0、 theta 1、theta 2 に実行する更新です。 そして、私が前のビデオで 言ったことを覚えていれば、 これは同時更新でなければなりません。 では、これの ベクトル化された実装が できるか試してみましょう。 ここに、先ほどと同じ三つの式が やや小さめのフォントで表示されています。 想像できることは、この三行のコードを 実装するのに 思いつくやり方の一つは、 for ループを使って、そう ですね、for j = 0; 1 から 2 で theta j を 更新、とかそのようなやり方です。 しかしその代わりに、 ベクトル化された実装を考え出して、もっと簡素化できるか見てみましょう。 つまり、基本的には、これらの三行のコード というか、この三つのステップを実質的に一ステップごとに処理する