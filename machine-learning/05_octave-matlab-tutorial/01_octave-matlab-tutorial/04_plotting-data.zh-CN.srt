1
00:00:00,180 --> 00:00:02,402
当开发学习算法时

2
00:00:02,402 --> 00:00:04,066
往往几个简单的图

3
00:00:04,066 --> 00:00:05,279
可以让你更好地

4
00:00:05,279 --> 00:00:06,593
理解算法的内容

5
00:00:06,593 --> 00:00:08,423
并且可以完整地检查下

6
00:00:08,423 --> 00:00:09,503
算法是否正常运行

7
00:00:09,510 --> 00:00:12,405
是否达到了算法的目的

8
00:00:12,410 --> 00:00:13,924
例如在之前的

9
00:00:13,924 --> 00:00:15,244
视频中  我谈到了

10
00:00:15,244 --> 00:00:16,826
绘制成本函数J(θ)

11
00:00:16,826 --> 00:00:18,433
可以帮助

12
00:00:18,433 --> 00:00:21,383
确认梯度下降算法是否收敛

13
00:00:21,383 --> 00:00:23,084
通常情况下  绘制数据

14
00:00:23,084 --> 00:00:24,795
或学习算法所有输出

15
00:00:24,810 --> 00:00:26,422
也会启发你

16
00:00:26,422 --> 00:00:29,391
如何改进你的学习算法

17
00:00:29,391 --> 00:00:31,312
幸运的是  Octave有非常

18
00:00:31,330 --> 00:00:33,045
简单的工具用来生成大量

19
00:00:33,070 --> 00:00:34,534
不同的图

20
00:00:34,534 --> 00:00:36,518
当我用学习算法时 我发现

21
00:00:36,518 --> 00:00:38,082
绘制数据

22
00:00:38,082 --> 00:00:40,175
绘制学习算法等

23
00:00:40,175 --> 00:00:42,057
往往是

24
00:00:42,060 --> 00:00:43,165
我获得想法

25
00:00:43,165 --> 00:00:45,937
来改进算法的重要部分

26
00:00:45,980 --> 00:00:47,199
在这段视频中

27
00:00:47,199 --> 00:00:48,482
我想告诉你一些

28
00:00:48,482 --> 00:00:52,773
Octave的工具来绘制和可视化你的数据

29
00:00:53,700 --> 00:00:55,301
这是我的 Octave 窗口

30
00:00:55,301 --> 00:00:57,471
我们先来快速生成一些数据

31
00:00:57,471 --> 00:00:58,646
用来绘图

32
00:00:58,646 --> 00:00:59,724
我先设置t

33
00:00:59,740 --> 00:01:02,181
等于这个数列

34
00:01:02,210 --> 00:01:03,828
这是t

35
00:01:03,828 --> 00:01:06,685
是从0到0.98的集合

36
00:01:06,700 --> 00:01:09,048
让我们设置y1等于sin

37
00:01:09,060 --> 00:01:11,340
2*pi*4*t （此处pi表示π）

38
00:01:12,540 --> 00:01:16,102
如果我想绘制正弦函数 这是很容易的

39
00:01:16,102 --> 00:01:17,918
我只需要输入plot(t, y1)

40
00:01:17,918 --> 00:01:20,304
并回车

41
00:01:20,320 --> 00:01:22,233
就出现了这个图

42
00:01:22,233 --> 00:01:24,270
横轴是

43
00:01:24,270 --> 00:01:25,515
t变量 纵轴是y1

44
00:01:25,515 --> 00:01:26,946
也就是我们

45
00:01:26,960 --> 00:01:30,577
刚刚所输出的正弦函数

46
00:01:30,990 --> 00:01:32,281
让我们设置y2

47
00:01:32,281 --> 00:01:34,401
等于cos

48
00:01:34,410 --> 00:01:38,735
2*pi*4*t

49
00:01:38,750 --> 00:01:41,403
而如果我输入plot

50
00:01:41,403 --> 00:01:43,835
t逗号y2

51
00:01:43,835 --> 00:01:45,045
Octave将会

52
00:01:45,060 --> 00:01:46,988
消除之前的正弦图

53
00:01:46,988 --> 00:01:48,681
并且用这个余弦图来代替它

54
00:01:48,690 --> 00:01:51,322
这里纵轴cos(x)从1开始

55
00:01:51,330 --> 00:01:53,006
如果我

56
00:01:53,010 --> 00:01:54,581
要同时表示

57
00:01:54,610 --> 00:01:56,981
正弦和余弦曲线

58
00:01:56,990 --> 00:01:59,702
我要做的就是

59
00:01:59,702 --> 00:02:01,164
输入plot(t, y1)

60
00:02:01,164 --> 00:02:03,332
这是我的正弦函数

61
00:02:03,332 --> 00:02:06,958
我使用函数hold on

62
00:02:06,958 --> 00:02:08,908
hold on函数

63
00:02:08,920 --> 00:02:10,247
的功能是将

64
00:02:10,270 --> 00:02:11,490
新的图像绘制在

65
00:02:11,490 --> 00:02:13,772
旧的之上

66
00:02:13,772 --> 00:02:15,249
我现在绘制t y2

67
00:02:15,249 --> 00:02:19,812
我要以不同的颜色绘制余弦函数

68
00:02:19,850 --> 00:02:22,166
所以我在这里输入

69
00:02:22,180 --> 00:02:24,093
带引号的r

70
00:02:24,093 --> 00:02:25,339
我将绘制余弦函数

71
00:02:25,339 --> 00:02:26,615
在这之上

72
00:02:26,620 --> 00:02:28,499
而不是替换了现有的图

73
00:02:28,499 --> 00:02:32,915
r表示所使用的颜色

74
00:02:32,915 --> 00:02:35,166
再加上命令xlabel('time')

75
00:02:35,166 --> 00:02:39,157
来标记X轴即水平轴

76
00:02:39,160 --> 00:02:41,451
输入ylabel('value')

77
00:02:41,451 --> 00:02:44,688
来标记垂直轴的值

78
00:02:44,688 --> 00:02:47,032
同时我也可以

79
00:02:54,532 --> 00:02:57,616
来标记我的两条函数曲线

80
00:02:57,620 --> 00:03:01,514
用这个命令 legend('sin', 'cos')

81
00:03:01,514 --> 00:03:02,860
将这个

82
00:03:02,890 --> 00:03:04,125
图例放在右上方

83
00:03:04,125 --> 00:03:05,122
表示这两条曲线表示的内容

84
00:03:05,122 --> 00:03:08,285
最后输入title('myplot')

85
00:03:08,290 --> 00:03:12,753
在图像的顶部显示这幅图的标题

86
00:03:12,753 --> 00:03:13,835
如​​果你想保存

87
00:03:13,835 --> 00:03:18,197
这幅图像，你输入print -dpng

88
00:03:18,197 --> 00:03:20,128
'myplot.png'

89
00:03:20,128 --> 00:03:21,505
png是一个图像

90
00:03:21,505 --> 00:03:23,292
文件格式

91
00:03:23,292 --> 00:03:25,170
如果你

92
00:03:25,170 --> 00:03:27,612
这样做了 它可以让你保存为一个文件

93
00:03:27,612 --> 00:03:28,902
如果我这样做

94
00:03:28,920 --> 00:03:31,287
让我先改一下路径

95
00:03:31,320 --> 00:03:35,114
像这样

96
00:03:35,130 --> 00:03:39,180
然后我将它打出来

97
00:03:39,230 --> 00:03:41,692
这需要一点时间

98
00:03:41,700 --> 00:03:43,869
而这取决于你的

99
00:03:43,890 --> 00:03:46,193
Octave的配置设置

100
00:03:46,230 --> 00:03:48,891
可能需要几秒钟  但改变

101
00:03:48,900 --> 00:03:50,730
路径到我的桌面

102
00:03:50,730 --> 00:03:53,943
现在Octave需要几秒钟​​的时间来保存它

103
00:03:54,750 --> 00:03:57,635
如果我现在去到我的桌面  先最小化这些窗口

104
00:03:57,670 --> 00:03:59,358
这就是

105
00:03:59,370 --> 00:04:00,720
Octave所保存的myplot.png

106
00:04:00,740 --> 00:04:03,481
这就是保存为PNG的文件

107
00:04:03,481 --> 00:04:05,530
Octave也可以保存为很多其他的格式

108
00:04:05,530 --> 00:04:07,468
你可以键入help  plot

109
00:04:07,468 --> 00:04:09,497
如果你想试试

110
00:04:09,510 --> 00:04:11,512
其他格式的文件  而不是

111
00:04:11,530 --> 00:04:13,377
PNG 你可以把图片

112
00:04:13,377 --> 00:04:15,149
保存为其他格式

113
00:04:15,149 --> 00:04:16,471
最后如​​果你想

114
00:04:16,471 --> 00:04:18,507
删掉这个图像

115
00:04:18,540 --> 00:04:23,867
命令close会让这个图像关掉

116
00:04:23,867 --> 00:04:24,963
如果我键入

117
00:04:24,963 --> 00:04:26,628
close  这个图像

118
00:04:26,628 --> 00:04:30,153
就从我的桌面消失了

119
00:04:30,640 --> 00:04:33,372
Octave也可以让你为图像标号

120
00:04:33,372 --> 00:04:36,935
你键入figure(1); plot(t, y1);

121
00:04:36,935 --> 00:04:39,582
将显示

122
00:04:39,670 --> 00:04:41,959
第一张图 绘制了变量t y1

123
00:04:41,970 --> 00:04:45,075
如果你想绘制第二个图 你可以指定一个不同的数字编号

124
00:04:45,075 --> 00:04:47,765
键入figure(2); plot(t, y2);

125
00:04:47,780 --> 00:04:49,924
正如这样

126
00:04:49,924 --> 00:04:53,084
现在我的桌面上  其实有2个图

127
00:04:53,084 --> 00:04:54,625
图1和图2

128
00:04:54,625 --> 00:04:55,874
此时一个绘制正弦

129
00:04:55,874 --> 00:04:59,169
函数  另一个绘制了余弦函数

130
00:04:59,170 --> 00:05:00,498
这是另一个我经常使用的命令

131
00:05:00,498 --> 00:05:02,825
subplot命令

132
00:05:02,825 --> 00:05:05,401
我们要使用subplot(1,2,1)

133
00:05:05,401 --> 00:05:07,958
它将图像

134
00:05:07,958 --> 00:05:11,200
分为一个

135
00:05:11,780 --> 00:05:13,760
1*2的格子

136
00:05:13,820 --> 00:05:16,010
也就是前两个参数

137
00:05:16,010 --> 00:05:17,607
然后它使用

138
00:05:17,620 --> 00:05:19,335
第一个格子

139
00:05:19,340 --> 00:05:21,714
也就是最后一个参数1的意思

140
00:05:21,714 --> 00:05:23,568
所以，将我的图像分成

141
00:05:23,568 --> 00:05:24,913
1*2的格子

142
00:05:24,913 --> 00:05:26,585
我现在使用

143
00:05:26,585 --> 00:05:27,948
第一个格子

144
00:05:27,970 --> 00:05:30,435
如果我键入这个

145
00:05:30,435 --> 00:05:32,722
那么这个图像显示在左边

146
00:05:32,760 --> 00:05:35,291
如果键入plot(t, y1)

147
00:05:35,350 --> 00:05:37,682
现在这个图

148
00:05:37,682 --> 00:05:40,462
显示在第一个格子

149
00:05:40,462 --> 00:05:42,565
如果我键入subplot(1,2,2)

150
00:05:42,565 --> 00:05:44,456
那么我就要

151
00:05:44,456 --> 00:05:48,724
使用第二个格子  键入plot(t, y2);

152
00:05:49,270 --> 00:05:51,323
现在y2显示在右边

153
00:05:51,323 --> 00:05:54,875
也就是第二个格子

154
00:05:54,910 --> 00:05:56,114
最后一个命令  你可以

155
00:05:56,114 --> 00:05:58,165
改变轴的刻度

156
00:05:58,165 --> 00:06:00,308
比如改成

157
00:06:00,330 --> 00:06:02,892
[0.5 1 -1 1]

158
00:06:02,892 --> 00:06:05,071
也就是设置了

159
00:06:05,071 --> 00:06:07,448
右边图的x轴

160
00:06:07,448 --> 00:06:09,874
和y轴的范围

161
00:06:09,890 --> 00:06:12,381
具体而言 它将

162
00:06:12,381 --> 00:06:13,668
右图中的横轴

163
00:06:13,670 --> 00:06:14,856
的范围调整至0.5到1

164
00:06:14,856 --> 00:06:16,334
竖轴的范围为

165
00:06:16,340 --> 00:06:19,572
-1到1

166
00:06:19,572 --> 00:06:21,736
而且 你不需要记住所有这些命令

167
00:06:21,736 --> 00:06:23,178
如果你需要

168
00:06:23,178 --> 00:06:24,773
改变坐标轴或者

169
00:06:24,780 --> 00:06:25,703
需要知道axis命令

170
00:06:25,703 --> 00:06:26,628
你可以

171
00:06:26,628 --> 00:06:28,364
用Octave中

172
00:06:28,364 --> 00:06:31,590
help命令了解细节

173
00:06:31,600 --> 00:06:32,861
最后  还有几个命令

174
00:06:32,861 --> 00:06:35,449
clf清除

175
00:06:35,450 --> 00:06:38,362
一幅图像 这里有一个独特的特点

176
00:06:38,362 --> 00:06:39,772
让我们设置A等于

177
00:06:39,772 --> 00:06:42,076
一个5×5

178
00:06:42,076 --> 00:06:43,375
magic方阵

179
00:06:43,380 --> 00:06:45,290
现在A是这个5*5

180
00:06:45,310 --> 00:06:47,581
的矩阵

181
00:06:47,581 --> 00:06:49,341
我有时用一个巧妙的方法

182
00:06:49,350 --> 00:06:51,582
来可视化矩阵

183
00:06:51,582 --> 00:06:54,792
也就是imagesc(A)

184
00:06:54,800 --> 00:06:56,362
它将会

185
00:06:56,370 --> 00:06:58,056
绘制一个5*5的矩阵

186
00:06:58,056 --> 00:07:03,925
一个5*5的彩色格图

187
00:07:03,925 --> 00:07:05,739
不同的颜色对应

188
00:07:05,739 --> 00:07:09,011
A矩阵中的不同值

189
00:07:09,060 --> 00:07:13,262
具体地说 我还可以使用函数colorbar

190
00:07:13,630 --> 00:07:14,903
让我用一个

191
00:07:14,903 --> 00:07:16,715
更复杂的命令 imagesc(A)

192
00:07:16,715 --> 00:07:19,608
colorbar

193
00:07:19,608 --> 00:07:22,454
colormap gray

194
00:07:22,454 --> 00:07:24,757
这实际上是在同一时间运行三个命令

195
00:07:24,760 --> 00:07:26,286
运行imagesc然后运行

196
00:07:26,286 --> 00:07:28,943
colorbar 然后运行colormap gray

197
00:07:28,943 --> 00:07:30,142
它生成了

198
00:07:30,160 --> 00:07:31,355
一个颜色图像

199
00:07:31,355 --> 00:07:32,749
一个灰度分布图 并在

200
00:07:32,749 --> 00:07:35,333
右边也加入一个颜色条

201
00:07:35,360 --> 00:07:37,525
所以这个颜色条

202
00:07:37,550 --> 00:07:40,701
显示不同深浅的颜色所对应的值

203
00:07:40,720 --> 00:07:42,704
具体地  左上

204
00:07:42,704 --> 00:07:44,494
A矩阵的元素

205
00:07:44,494 --> 00:07:46,358
是17  所以对应

206
00:07:46,358 --> 00:07:49,297
的是这样中等的灰度

207
00:07:49,297 --> 00:07:52,012
而与此相反的第二个

208
00:07:52,012 --> 00:07:53,210
元素  也就是

209
00:07:53,280 --> 00:07:55,640
A(1,2)元素

210
00:07:55,640 --> 00:07:57,716
代表的值为24

211
00:07:57,716 --> 00:07:59,683
它对应于

212
00:07:59,690 --> 00:08:01,343
这里的这个方块

213
00:08:01,360 --> 00:08:03,677
是接近白色的灰度

214
00:08:03,677 --> 00:08:05,640
较小的值比如

215
00:08:05,690 --> 00:08:08,657
A多少呢

216
00:08:08,657 --> 00:08:12,260
A(4,5)

217
00:08:12,300 --> 00:08:14,346
为3对应着

218
00:08:14,360 --> 00:08:15,548
你可以看到在我的颜色条

219
00:08:15,548 --> 00:08:16,618
它对应于

220
00:08:16,618 --> 00:08:19,499
一个更暗的灰度

221
00:08:19,499 --> 00:08:21,141
这里是另一个例子

222
00:08:21,141 --> 00:08:23,228
我可以绘制一个较大的

223
00:08:23,230 --> 00:08:24,768
比如magic（15）

224
00:08:24,770 --> 00:08:26,029
给你一个15* 15

225
00:08:26,029 --> 00:08:27,675
magic方阵

226
00:08:27,680 --> 00:08:29,504
这将会是一幅

227
00:08:29,504 --> 00:08:33,675
15*15的magic方阵值的图

228
00:08:33,700 --> 00:08:35,225
最后

229
00:08:35,225 --> 00:08:37,075
总结一下这段视频

230
00:08:37,075 --> 00:08:38,318
你看到我所做的

231
00:08:38,318 --> 00:08:41,917
是使用逗号连接函数调用

232
00:08:41,940 --> 00:08:43,195
这里是你如何真正做到这一点

233
00:08:43,210 --> 00:08:44,638
如果我键入a=1

234
00:08:44,690 --> 00:08:46,613
b=2 c=3

235
00:08:46,613 --> 00:08:48,620
然后按Enter键

236
00:08:48,620 --> 00:08:50,628
其实这是将这

237
00:08:50,628 --> 00:08:52,039
三个命令同时执行

238
00:08:52,040 --> 00:08:53,490
或者是

239
00:08:53,490 --> 00:08:55,849
将三个命令一个接一个执行

240
00:08:55,849 --> 00:08:57,521
它将输出所有这三个结果

241
00:08:57,521 --> 00:08:58,417
这很像

242
00:08:58,417 --> 00:09:00,489
a=1; b=2;

243
00:09:00,489 --> 00:09:01,755
c=3;

244
00:09:01,755 --> 00:09:03,532
如果我用分号来代替逗号

245
00:09:03,540 --> 00:09:05,854
没有输出出任何东西

246
00:09:05,854 --> 00:09:07,195
所以你知道

247
00:09:07,210 --> 00:09:08,865
这里我们称之为

248
00:09:08,870 --> 00:09:12,185
逗号连接的命令或函数调用

249
00:09:12,240 --> 00:09:13,755
只是另一种

250
00:09:13,755 --> 00:09:15,520
Octave中更便捷的方式

251
00:09:15,520 --> 00:09:17,778
将多条命令例如imagesc

252
00:09:17,778 --> 00:09:19,358
colorbar colormap

253
00:09:19,360 --> 00:09:22,919
将这多条命令写在同一行中

254
00:09:22,930 --> 00:09:24,104
就是这样

255
00:09:24,104 --> 00:09:25,281
现在你知道如何绘制

256
00:09:25,281 --> 00:09:27,504
Octave中不同的图像

257
00:09:27,504 --> 00:09:29,270
在下面的视频中

258
00:09:29,280 --> 00:09:30,430
下一个主要内容

259
00:09:30,460 --> 00:09:31,985
我将告诉你怎样在Octave中

260
00:09:31,985 --> 00:09:33,622
写控制语句 比如if

261
00:09:33,630 --> 00:09:35,294
while for语句

262
00:09:35,294 --> 00:09:39,426
并且定义和使用函数 【教育无边界字幕组】翻译: wangqiwhu 校对: 牛仔仔 审核:所罗门捷列夫