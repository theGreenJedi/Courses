1
00:00:00,090 --> 00:00:02,346
你现在已经掌握不少机器学习知识了

2
00:00:02,390 --> 00:00:03,635
在这段视频中

3
00:00:03,635 --> 00:00:05,448
我将教你一种编程语言

4
00:00:05,470 --> 00:00:06,718
Octave语言

5
00:00:06,760 --> 00:00:08,878
你能够用它来非常迅速地

6
00:00:08,890 --> 00:00:10,259
实现这门课中我们已经学过

7
00:00:10,259 --> 00:00:11,770
或者将要学的

8
00:00:11,770 --> 00:00:14,872
机器学习算法

9
00:00:14,900 --> 00:00:16,381
过去我一直尝试用不同的编程语言

10
00:00:16,381 --> 00:00:19,497
来教授机器学习

11
00:00:19,500 --> 00:00:22,046
包括C++、Java、

12
00:00:22,825 --> 00:00:25,379
Python、Numpy

13
00:00:25,379 --> 00:00:27,128
和 Octave

14
00:00:27,160 --> 00:00:28,783
我发现当使用像

15
00:00:28,790 --> 00:00:30,535
Octave这样的

16
00:00:30,570 --> 00:00:32,497
高级语言时

17
00:00:32,497 --> 00:00:33,780
学生能够更快

18
00:00:33,780 --> 00:00:35,569
更好地学习

19
00:00:35,569 --> 00:00:38,262
并掌握这些算法

20
00:00:38,290 --> 00:00:39,798
事实上 在硅谷

21
00:00:39,798 --> 00:00:41,516
我经常看到的情况是

22
00:00:41,520 --> 00:00:43,655
进行大规模的

23
00:00:43,655 --> 00:00:44,714
机器学习项目的人

24
00:00:44,740 --> 00:00:46,548
通常会使用的

25
00:00:46,610 --> 00:00:48,242
程序语言

26
00:00:48,242 --> 00:00:50,637
就是Octave

27
00:00:50,660 --> 00:00:52,200
Octave是一种很好的原始语言(prototyping language)

28
00:00:52,210 --> 00:00:55,264
使用Octave 你能快速地实现你的算法

29
00:00:55,270 --> 00:00:56,629
剩下的事情 你只需要

30
00:00:56,629 --> 00:00:58,459
进行大规模的资源配置

31
00:00:58,480 --> 00:01:00,362
你只用再花时间

32
00:01:00,362 --> 00:01:03,059
用C++或Java这些语言

33
00:01:03,059 --> 00:01:05,150
把算法重新实现就行了

34
00:01:05,160 --> 00:01:06,273
因为我们知道

35
00:01:06,300 --> 00:01:08,679
开发项目的时间

36
00:01:08,710 --> 00:01:09,848
或者说你的时间 是很宝贵的

37
00:01:09,870 --> 00:01:13,309
机器学习的时间也是很宝贵的

38
00:01:13,320 --> 00:01:15,101
所以 如果你能

39
00:01:15,101 --> 00:01:17,898
让你的学习算法在Octave上快速的实现

40
00:01:17,898 --> 00:01:18,932
基本的想法实现以后

41
00:01:18,932 --> 00:01:20,697
再用C++或者Java去改写

42
00:01:20,720 --> 00:01:22,143
这样

43
00:01:22,150 --> 00:01:23,971
你就能节省出

44
00:01:23,971 --> 00:01:28,145
大量的时间

45
00:01:28,160 --> 00:01:30,238
据我所见 人们使用最多的

46
00:01:30,238 --> 00:01:31,538
用于机器学习的原始语言

47
00:01:31,560 --> 00:01:34,058
是Octave、MATLAB

48
00:01:34,070 --> 00:01:37,230
Python、NumPy 和 R

49
00:01:38,150 --> 00:01:40,032
Octave很好 因为它是开源的

50
00:01:40,032 --> 00:01:42,660
当然 MATLAB也很好

51
00:01:42,670 --> 00:01:44,656
但它不是每个人都

52
00:01:44,656 --> 00:01:45,956
买得起的

53
00:01:45,960 --> 00:01:47,972
但是 如果你能够使用MATLAB

54
00:01:47,988 --> 00:01:50,095
你也可以在这门课里面使用

55
00:01:50,110 --> 00:01:52,037
如果你会Python、NumPy

56
00:01:52,037 --> 00:01:54,853
或者R语言 我也见过有人用 R 的

57
00:01:54,870 --> 00:01:56,353
但是 据我所知

58
00:01:56,360 --> 00:01:57,739
这些人不得不中途放弃了

59
00:01:57,760 --> 00:02:00,041
因为这些语言在开发上比较慢

60
00:02:00,050 --> 00:02:02,121
而且 因为这些语言

61
00:02:02,121 --> 00:02:04,048
Python、NumPy的语法

62
00:02:04,048 --> 00:02:08,391
相较于Octave来说 还是更麻烦一点

63
00:02:08,410 --> 00:02:09,704
正因为这样

64
00:02:09,704 --> 00:02:11,372
也因为我们最开始

65
00:02:11,380 --> 00:02:13,039
用Octave来写程序

66
00:02:13,039 --> 00:02:14,363
所以我强烈建议你

67
00:02:14,363 --> 00:02:18,321
不要用NumPy或者R来完整这门课的作业

68
00:02:18,330 --> 00:02:19,805
我建议你

69
00:02:19,805 --> 00:02:21,498
在这门课中

70
00:02:21,520 --> 00:02:24,292
用Octave来写程序

71
00:02:24,330 --> 00:02:25,428
接下来

72
00:02:25,428 --> 00:02:26,708
本视频将快速地介绍

73
00:02:26,708 --> 00:02:28,667
一系列的命令

74
00:02:28,667 --> 00:02:29,879
目标是迅速地展示

75
00:02:29,879 --> 00:02:31,073
通过这一系列Octave的命令

76
00:02:31,080 --> 00:02:34,807
让你知道Octave能用来做什么

77
00:02:34,807 --> 00:02:36,493
我们的网站会提供

78
00:02:36,520 --> 00:02:38,965
所有我在视频中提到的

79
00:02:38,965 --> 00:02:42,095
内容的文本

80
00:02:42,095 --> 00:02:43,185
所以 当你看完这个视频

81
00:02:43,185 --> 00:02:44,905
想查询一些命令时

82
00:02:44,905 --> 00:02:46,635
你可以查看这些资料

83
00:02:46,635 --> 00:02:48,247
这些都放在网上了

84
00:02:48,247 --> 00:02:50,226
总之 我建议你

85
00:02:50,226 --> 00:02:53,225
先看教学视频

86
00:02:53,230 --> 00:02:55,118
之后

87
00:02:55,120 --> 00:02:58,728
把Octave安装到电脑上

88
00:02:58,728 --> 00:02:59,738
最后 去这门课的网站上

89
00:02:59,738 --> 00:03:01,769
下载这门课的

90
00:03:01,770 --> 00:03:02,983
相关文档和视频

91
00:03:02,983 --> 00:03:04,915
然后 你可以试着

92
00:03:04,930 --> 00:03:07,162
在Octave中键入一些

93
00:03:07,200 --> 00:03:09,132
有趣的命令

94
00:03:09,132 --> 00:03:10,602
让程序运行在你的电脑上

95
00:03:10,602 --> 00:03:12,962
这样你可以看到程序是怎么运行的

96
00:03:12,970 --> 00:03:15,535
让我们开始吧

97
00:03:15,920 --> 00:03:19,363
这里是我的Windows桌面 启动Octave

98
00:03:19,370 --> 00:03:20,977
现在打开Octave

99
00:03:20,977 --> 00:03:22,522
这是Octave命令行

100
00:03:22,522 --> 00:03:24,475
现在让我示范

101
00:03:24,475 --> 00:03:27,291
最基本的Octave代码

102
00:03:27,330 --> 00:03:28,505
输入5 + 6

103
00:03:28,505 --> 00:03:30,493
然后得到11

104
00:03:30,493 --> 00:03:31,516
输入3 - 2

105
00:03:31,540 --> 00:03:33,710
5×8、1/2、2 ^ 6

106
00:03:35,733 --> 00:03:37,747
得到64

107
00:03:37,810 --> 00:03:42,361
这些都是基本的数学运算

108
00:03:42,390 --> 00:03:44,495
你也可以做逻辑运算

109
00:03:44,550 --> 00:03:45,929
例如 1==2

110
00:03:45,929 --> 00:03:47,722
计算结果为 false  ( 假 )

111
00:03:47,722 --> 00:03:51,658
这里的百分号命令表示注释

112
00:03:51,658 --> 00:03:53,861
1==2 计算结果为假

113
00:03:53,861 --> 00:03:55,622
这里用0表示

114
00:03:55,650 --> 00:03:58,028
1 ~= 2

115
00:03:58,028 --> 00:03:59,312
这是真的

116
00:03:59,312 --> 00:04:00,718
因此返回1

117
00:04:00,718 --> 00:04:02,146
请注意 不等于符号的写法

118
00:04:02,146 --> 00:04:05,478
是这个波浪线加上等于符号 ( ~= )

119
00:04:05,550 --> 00:04:07,336
而不是等于感叹号加等号 ( != )

120
00:04:07,336 --> 00:04:09,267
这是和其他一些

121
00:04:09,267 --> 00:04:10,878
编程语言中不太一样的地方

122
00:04:10,910 --> 00:04:13,616
让我们看看逻辑运算 1 && 0

123
00:04:13,616 --> 00:04:15,545
使用双＆符号

124
00:04:15,545 --> 00:04:17,340
表示逻辑与

125
00:04:18,120 --> 00:04:20,188
1 && 0判断为假

126
00:04:20,188 --> 00:04:23,886
1和0的或运算 1 || 0

127
00:04:23,900 --> 00:04:25,736
其计算结果为真

128
00:04:25,736 --> 00:04:27,131
还有异或运算 如XOR ( 1, 0 )

129
00:04:27,131 --> 00:04:30,333
其返回值为1

130
00:04:30,333 --> 00:04:32,928
从左向右写着 Octave 324.x版本

131
00:04:32,928 --> 00:04:35,683
其计算结果等于11 这是默认的Octave提示

132
00:04:35,700 --> 00:04:37,513
它显示了当前Octave的版本

133
00:04:37,520 --> 00:04:39,150
以及相关的其它信息

134
00:04:39,150 --> 00:04:40,423
如果你不想看到那个提示

135
00:04:40,450 --> 00:04:43,025
这里有一个隐藏的命令

136
00:04:43,025 --> 00:04:44,670
输入命令

137
00:04:44,670 --> 00:04:46,602
PS('>>  ');

138
00:04:46,602 --> 00:04:48,800
现在你看到的就是等待命令的快捷提示

139
00:04:48,810 --> 00:04:51,272
这句话在中间有一个字符串

140
00:04:51,272 --> 00:04:53,362
('>>  ');

141
00:04:53,400 --> 00:04:55,592
这是我喜欢的命令行样子

142
00:04:55,592 --> 00:04:57,722
这里敲一个回车

143
00:04:57,920 --> 00:04:59,763
抱歉 写错了

144
00:04:59,763 --> 00:05:00,786
这样才对

145
00:05:00,786 --> 00:05:02,622
要写成PS1这样

146
00:05:02,622 --> 00:05:05,420
现在命令提示已经变得简化了

147
00:05:05,500 --> 00:05:09,263
这样看起来很棒

148
00:05:09,710 --> 00:05:12,384
接下来 我们将谈到Octave的变量

149
00:05:12,384 --> 00:05:13,865
现在写一个变量

150
00:05:13,865 --> 00:05:16,165
对变量A赋值为3

151
00:05:16,165 --> 00:05:18,421
并按下回车键

152
00:05:18,440 --> 00:05:20,043
显示变量A等于3

153
00:05:20,070 --> 00:05:22,861
如果你想分配一个变量 但不希望在屏幕上显示结果

154
00:05:22,861 --> 00:05:26,758
你可以在命令后加一个分号

155
00:05:26,920 --> 00:05:30,824
可以抑制打印输出

156
00:05:30,824 --> 00:05:33,160
敲入回车后 不打印任何东西。

157
00:05:33,160 --> 00:05:35,399
A等于3

158
00:05:35,420 --> 00:05:36,719
只是不显示出来

159
00:05:36,719 --> 00:05:39,845
其中这句命令不打印任何东西

160
00:05:39,850 --> 00:05:41,845
现在举一个字符串的例子

161
00:05:41,845 --> 00:05:43,473
变量b等于"hi"

162
00:05:43,520 --> 00:05:45,047
现在

163
00:05:45,047 --> 00:05:46,072
如果我输入b

164
00:05:46,072 --> 00:05:48,338
则会显示字符串变量b的值"hi"

165
00:05:48,370 --> 00:05:51,118
C等于3大于等于1

166
00:05:51,130 --> 00:05:54,538
所以 现在C变量的值是真

167
00:05:55,710 --> 00:05:57,999
如果你想打印出变量

168
00:05:58,030 --> 00:06:00,832
或显示一个变量 你可以像下面这么做

169
00:06:00,832 --> 00:06:03,725
设置A等于圆周率π

170
00:06:03,760 --> 00:06:04,985
如果我要打印该值

171
00:06:04,985 --> 00:06:08,545
那么只需键入A 像这样 就打印出来了

172
00:06:08,545 --> 00:06:10,344
对于更复杂的屏幕输出

173
00:06:10,344 --> 00:06:13,674
也可以用DISP命令显示

174
00:06:13,710 --> 00:06:15,858
Disp( A )就相当于像这样打印出A

175
00:06:15,890 --> 00:06:18,337
你也可以用该命令来显示字符串

176
00:06:18,350 --> 00:06:21,392
输入disp sprintf

177
00:06:21,460 --> 00:06:24,990
小数 0.2%

178
00:06:25,260 --> 00:06:28,273
逗号 A 像这样

179
00:06:28,273 --> 00:06:29,863
通过这条命令将打印出字符串

180
00:06:29,863 --> 00:06:31,722
打印显示为“两位小数：3.14”

181
00:06:31,722 --> 00:06:33,651
这是一种

182
00:06:33,670 --> 00:06:35,993
旧风格的C语言语法

183
00:06:35,993 --> 00:06:37,404
如果

184
00:06:37,420 --> 00:06:39,073
就学过C语言的同学来说

185
00:06:39,073 --> 00:06:41,378
你可以使用这种基本的语法来将结果打印到屏幕

186
00:06:41,380 --> 00:06:44,498
Sprintf命令生成一个字符串

187
00:06:44,510 --> 00:06:46,021
不仅仅是

188
00:06:46,021 --> 00:06:48,274
字符串“2 decimal：3.14”

189
00:06:48,290 --> 00:06:50,644
其中的“0.2％F”表示

190
00:06:50,644 --> 00:06:52,475
代替A放在这里

191
00:06:52,475 --> 00:06:55,926
并显示A值的小数点后两位数字

192
00:06:55,926 --> 00:06:58,104
同时DISP 命令对字符串做出操作

193
00:06:58,130 --> 00:07:00,691
DISP命令输出

194
00:07:00,691 --> 00:07:01,683
Sprintf产生的字符串

195
00:07:01,683 --> 00:07:03,091
Sprintf命令

196
00:07:03,091 --> 00:07:05,835
和DISP命令显示字符串

197
00:07:05,870 --> 00:07:07,020
再说一个细节

198
00:07:07,020 --> 00:07:11,360
例如 sprintf命令的六个小数

199
00:07:11,361 --> 00:07:14,551
0.6％F ,A

200
00:07:14,930 --> 00:07:17,075
这应该打印π

201
00:07:17,090 --> 00:07:21,100
的6位小数形式

202
00:07:22,060 --> 00:07:25,728
最后 看起来像这样

203
00:07:25,740 --> 00:07:28,633
也有一些控制输出长短格式的快捷命令

204
00:07:28,633 --> 00:07:31,759
默认情况下 是字符串

205
00:07:31,760 --> 00:07:33,748
显示出的小数位有点多

206
00:07:33,748 --> 00:07:35,593
短 ( short ) 格式

207
00:07:35,593 --> 00:07:37,095
是默认的输出格式

208
00:07:37,120 --> 00:07:40,113
只是打印小数数位的第一位

209
00:07:40,600 --> 00:07:43,934
相关这方面的内容还需要你继续练习

210
00:07:43,934 --> 00:07:47,047
下面 让我们来看看向量和矩阵

211
00:07:47,070 --> 00:07:49,274
比方说 建立一个矩阵A

212
00:07:49,280 --> 00:07:50,974
输入1  2

213
00:07:50,980 --> 00:07:54,593
; 3 4  ;  5 6

214
00:07:54,600 --> 00:07:56,235
这会产生一个

215
00:07:56,240 --> 00:07:58,572
三行两列的矩阵A

216
00:07:58,580 --> 00:07:59,818
其第一行是1 2

217
00:07:59,820 --> 00:08:02,030
第二行是3 4 第三行是5 6

218
00:08:02,030 --> 00:08:04,385
分号的作用

219
00:08:04,390 --> 00:08:05,818
从本质上来说

220
00:08:05,820 --> 00:08:07,915
就是在矩阵内换行到下一行

221
00:08:07,915 --> 00:08:09,016
此外 还有其他的方法来建立矩阵A

222
00:08:09,016 --> 00:08:11,536
输入A矩阵的值 1 2 分号

223
00:08:11,536 --> 00:08:15,046
3 4 分号 5 6

224
00:08:15,046 --> 00:08:17,038
这是另一种方法

225
00:08:17,038 --> 00:08:18,576
对A矩阵进行赋值

226
00:08:18,576 --> 00:08:22,183
考虑到这是一个三行两列的矩阵

227
00:08:22,200 --> 00:08:23,568
你同样可以用向量

228
00:08:23,568 --> 00:08:25,532
建立向量V并赋值1 2 3

229
00:08:25,560 --> 00:08:27,359
V是一个行向量

230
00:08:27,359 --> 00:08:29,915
或者说是一个3 ( 列 )×1 ( 行 ) 的向量

231
00:08:29,940 --> 00:08:32,016
一个胖胖的Y向量

232
00:08:32,030 --> 00:08:34,375
或者说

233
00:08:34,380 --> 00:08:37,998
一行三列的矩阵

234
00:08:37,998 --> 00:08:39,256
注意不是三行一列

235
00:08:39,256 --> 00:08:41,015
如果我想

236
00:08:41,015 --> 00:08:43,975
分配一个列向量

237
00:08:43,975 --> 00:08:48,778
我可以写“1;2;3”

238
00:08:48,830 --> 00:08:50,030
现在便有了一个

239
00:08:50,100 --> 00:08:51,797
3 行 1 列 的向量

240
00:08:51,797 --> 00:08:55,892
同时这是一个列向量

241
00:08:56,250 --> 00:08:57,968
下面是一些更为有用的符号

242
00:08:57,968 --> 00:09:02,343
V等于1：0.1：2

243
00:09:02,343 --> 00:09:03,598
这个该如何理解呢

244
00:09:03,620 --> 00:09:05,716
这个集合V是一组值

245
00:09:05,716 --> 00:09:08,714
从数值1开始

246
00:09:08,714 --> 00:09:10,392
增量或说是步长为0.1

247
00:09:10,410 --> 00:09:13,657
直到增加到2

248
00:09:13,660 --> 00:09:19,168
按照这样的方法对向量V操作 可以得到一个行向量

249
00:09:19,168 --> 00:09:23,022
这是一个1行11列的矩阵

250
00:09:23,022 --> 00:09:23,739
其矩阵的元素是1  1.1  1.2  1.3

251
00:09:23,739 --> 00:09:26,921
依此类推

252
00:09:27,630 --> 00:09:30,141
直到数值2

253
00:09:31,440 --> 00:09:33,269
现在 我也可以

254
00:09:33,269 --> 00:09:35,049
建立一个集合V并用命令“1:6”进行赋值

255
00:09:35,060 --> 00:09:38,270
这样V就被赋值了

256
00:09:38,270 --> 00:09:41,291
1至6的六个整数

257
00:09:41,620 --> 00:09:44,254
这里还有一些其他的方法来生成矩阵

258
00:09:44,254 --> 00:09:47,426
例如“ones(2, 3)”

259
00:09:47,426 --> 00:09:49,134
也可以用来生成矩阵

260
00:09:49,140 --> 00:09:50,790
其结果为一个两行三列的矩阵

261
00:09:50,790 --> 00:09:52,712
不过矩阵中的所有元素都为1

262
00:09:52,712 --> 00:09:53,991
当我想生成一个

263
00:09:54,000 --> 00:09:56,845
元素都为2

264
00:09:56,845 --> 00:09:59,798
两行三列的矩阵

265
00:09:59,798 --> 00:10:03,061
就可以使用这个命令

266
00:10:03,080 --> 00:10:04,258
你可以把这个方法当成一个

267
00:10:04,258 --> 00:10:05,513
生成矩阵的快速方法

268
00:10:05,550 --> 00:10:06,943
当你想生成一个三维2×2×2的矩阵时

269
00:10:06,943 --> 00:10:10,951
你就可以用这个“ones”命令

270
00:10:11,450 --> 00:10:13,910
比方说

271
00:10:13,920 --> 00:10:15,485
w是一个有三个1的

272
00:10:15,485 --> 00:10:17,937
行向量

273
00:10:17,940 --> 00:10:20,998
或者说一行

274
00:10:20,998 --> 00:10:23,853
由三个同样的1组成的向量

275
00:10:23,853 --> 00:10:25,463
你也可以说

276
00:10:25,463 --> 00:10:27,469
w为一个

277
00:10:27,469 --> 00:10:30,209
一行三列的零矩阵

278
00:10:30,220 --> 00:10:34,732
一行三列的A矩阵里的元素全部是零

279
00:10:34,732 --> 00:10:36,910
还有很多的方式来生成矩阵

280
00:10:36,930 --> 00:10:39,175
如果我对W进行赋值

281
00:10:39,175 --> 00:10:41,512
用Rand命令建立一个一行三列的矩阵

282
00:10:41,520 --> 00:10:43,050
因为使用了Rand命令

283
00:10:43,050 --> 00:10:45,370
则其一行三列的元素均为随机值

284
00:10:45,372 --> 00:10:47,118
如果我使用

285
00:10:47,215 --> 00:10:49,008
“rand(3, 3)”命令

286
00:10:49,050 --> 00:10:50,417
这就生成了一个

287
00:10:50,417 --> 00:10:51,918
3×3的矩阵

288
00:10:51,930 --> 00:10:54,009
并且其所有元素均为随机

289
00:10:54,009 --> 00:10:55,830
数值介于0和1之间

290
00:10:55,830 --> 00:10:56,937
所以

291
00:10:56,937 --> 00:10:58,608
正是因为这一点

292
00:10:58,608 --> 00:11:00,510
我们可以得到

293
00:11:00,540 --> 00:11:02,573
数值均匀介于0和1之间的元素

294
00:11:02,573 --> 00:11:03,718
如果

295
00:11:03,718 --> 00:11:05,375
你知道什么是高斯随机变量

296
00:11:05,410 --> 00:11:06,275
或者

297
00:11:06,275 --> 00:11:07,659
你知道什么是正态分布的随机变量

298
00:11:07,660 --> 00:11:09,112
你可以设置集合W

299
00:11:09,112 --> 00:11:11,956
使其等于一个一行三列的N矩阵

300
00:11:11,990 --> 00:11:13,565
并且

301
00:11:13,570 --> 00:11:15,435
来自三个值

302
00:11:15,435 --> 00:11:17,798
一个平均值为0的高斯分布

303
00:11:17,798 --> 00:11:19,266
方差

304
00:11:19,266 --> 00:11:21,642
或者等于1的标准偏差

305
00:11:21,642 --> 00:11:23,148
还可以设置地更复杂

306
00:11:23,150 --> 00:11:24,698
例如

307
00:11:24,698 --> 00:11:26,194
W减去6 再加上10的平方

308
00:11:26,210 --> 00:11:28,656
两者相乘

309
00:11:28,660 --> 00:11:31,978
Rand命令生成一个1行10000列的矩阵

310
00:11:31,978 --> 00:11:33,106
把分号放到末尾

311
00:11:33,106 --> 00:11:35,623
这样结果就打印不出来

312
00:11:35,623 --> 00:11:37,599
那这样会得到什么呢

313
00:11:37,599 --> 00:11:38,905
这样就可以

314
00:11:38,910 --> 00:11:40,582
得到

315
00:11:40,610 --> 00:11:44,481
一个有10000元素的向量

316
00:11:44,490 --> 00:11:47,596
想知道具体是多少

317
00:11:47,596 --> 00:11:48,373
我们也可把它打印出来

318
00:11:48,373 --> 00:11:51,570
这将产生一个这样的矩阵

319
00:11:51,570 --> 00:11:52,408
对吧?

320
00:11:52,408 --> 00:11:53,978
这就是一个

321
00:11:53,978 --> 00:11:55,835
有着10000个元素的矩阵W

322
00:11:55,835 --> 00:11:57,392
如果我现在

323
00:11:57,392 --> 00:11:59,442
用绘制直方图命令

324
00:11:59,442 --> 00:12:01,818
绘制出一个直方图

325
00:12:01,820 --> 00:12:04,752
使用Octave的

326
00:12:04,752 --> 00:12:06,130
打印直方图命令

327
00:12:06,130 --> 00:12:07,297
你只需要数秒钟就可以将它绘制出来

328
00:12:07,297 --> 00:12:08,965
这是一个对随机变量W

329
00:12:08,970 --> 00:12:10,646
绘制出的直方图

330
00:12:10,650 --> 00:12:12,732
这里是-6+0

331
00:12:12,732 --> 00:12:15,537
乘上十倍的高斯随机变量

332
00:12:15,537 --> 00:12:17,537
这样 可以绘制出一个

333
00:12:17,560 --> 00:12:21,032
有着更多条的 乃至50个条的直方图来

334
00:12:21,032 --> 00:12:22,578
这样 就有一个

335
00:12:22,578 --> 00:12:25,735
均值减去6的高斯直方图

336
00:12:25,735 --> 00:12:27,285
因为这里是

337
00:12:27,285 --> 00:12:29,208
-6加10的平方根并与这项相乘

338
00:12:29,230 --> 00:12:32,952
因此

339
00:12:32,952 --> 00:12:34,961
这个高斯随机变量的方差

340
00:12:34,961 --> 00:12:36,696
是10

341
00:12:36,700 --> 00:12:38,935
且其标准偏差为10的平方根

342
00:12:38,950 --> 00:12:41,063
3.1

343
00:12:41,780 --> 00:12:43,857
最后 说一个生成矩阵的

344
00:12:43,857 --> 00:12:46,208
特殊命令I

345
00:12:46,208 --> 00:12:48,394
其实

346
00:12:48,394 --> 00:12:51,028
I也可说是一个双关语字标识

347
00:12:51,050 --> 00:12:52,650
设置一个4阶单位矩阵

348
00:12:52,720 --> 00:12:56,004
这是一个4×4矩阵

349
00:12:56,004 --> 00:12:57,681
所以I为“eye(4)”

350
00:12:57,681 --> 00:13:00,458
通过上面的命令得到4×4矩阵

351
00:13:00,458 --> 00:13:04,475
I可以等于5阶单位阵 6阶单位阵

352
00:13:04,475 --> 00:13:05,611
那么就有

353
00:13:05,611 --> 00:13:08,089
6阶单位阵

354
00:13:08,120 --> 00:13:09,134
eye( 3 )是一个3阶方阵

355
00:13:09,134 --> 00:13:12,064
在本节视频的最后

356
00:13:12,064 --> 00:13:14,263
还有一个比较有用的命令

357
00:13:14,280 --> 00:13:15,479
那就是帮助命令

358
00:13:15,479 --> 00:13:17,454
例如 你可以键入help i

359
00:13:17,454 --> 00:13:21,181
它就会将矩阵的相关信息显示出来

360
00:13:21,190 --> 00:13:22,803
命令Q可以退出Octave

361
00:13:22,803 --> 00:13:25,375
你也可以键入help rand

362
00:13:25,380 --> 00:13:27,793
将会显示出有关rand函数的相关帮助文档

363
00:13:27,793 --> 00:13:29,734
以及相关的随机数生成函数

364
00:13:29,734 --> 00:13:31,898
甚至可以使用命令help help

365
00:13:31,900 --> 00:13:35,615
将会显示出help命令的使用方法

366
00:13:36,455 --> 00:13:39,022
以上讲解的内容

367
00:13:39,022 --> 00:13:41,612
都是Octave的基本操作

368
00:13:41,612 --> 00:13:42,699
希望你能通过上面的讲解

369
00:13:42,699 --> 00:13:47,131
自己练习一些矩阵、乘、加等操作

370
00:13:47,131 --> 00:13:50,553
将这些操作在Octave中熟练

371
00:13:50,560 --> 00:13:51,893
在接下来的视频中

372
00:13:51,920 --> 00:13:53,818
将会涉及

373
00:13:53,818 --> 00:13:55,700
更多复杂的命令

374
00:13:55,750 --> 00:13:59,180
并使用它们在Octave中对数据进行更多的操作 【教育无边界字幕组】 翻译：Yuens 校对、审核：Naplessss