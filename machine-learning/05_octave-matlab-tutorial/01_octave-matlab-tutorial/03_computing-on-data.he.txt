עכשיו כשאתם כבר יודעים איך לטעון ולשמור נתונים באוקטבה, לשים נתונים בתוך מטריצות וכיוצא בזה, בסרטון הזה, אני רוצה להראות לכם איך לעשות פעולות חישוביות על נתונים. ובהמשך ניישם באמצעות סוגים כאלה של פעולות חישוביות את אלגוריתמי הלמידה שלנו. הבה נתחיל. הנה חלון אוקטבה שלי. חכו רגע כשאני מאתחל במהירות כמה משתנים בהם נשתמש בסרטון. אז אני מאתחל את A להיות מטריצה שלוש על שתיים, ומגדיר מטריצה B שלוש על שתיים, ובואו נגדיר את C להיות מטריצה שתיים על שתיים כך. עכשיו נניח שאני רוצה להכפיל שתיים מהמטריצות שלי. נניח שאני רוצה לחשב את A*C, אני פשוט מקליד A*C, אז זו מטריצה שלוש על שתיים כפול מטריצה שתיים על שתיים, אז התוצאה היא מטריצה שלוש על שתיים. קיימות גם פעולות שעובדות על האיברים ולא על המטריצה, כגון A.*B שלוקח כל איבר של A ומכפיל אותו באיבר המקביל ב-B, זו המשמעות של A.*B. לדוגמא, האיבר הראשון הוא 1 כפול 11, שהם 11. האיבר השני הוא 2 כפול 12 שהם 24, וכן הלאה. אז זהו כפל ברמת האיברים של שתי מטריצות. ובאופן כללי, שימוש בנקודה מציין בדרך כלל פעולות ברמת האיברים באוקטבה. לדוגמא הנה המטריצה A, ואם אני עושה A.^2, נקבל ריבועים של האיברים של A. 1 בריבוע הוא 1, 2 בריבוע הוא 4, וכן הלאה. בואו נקבע את V כווקטור. בואו נאתחל את V לאחת, שתיים, שלוש כווקטור עמודה. אפשר גם לעשות אחת נקודה חלקי V כדי לקבל את ההפוכיים של האברים של v, אז מקבלים אחת חלקי אחת, אחת חלקי שתיים, ואחת חלקי שלוש, וכך הופכים את האיברים, אחת נקודה חלקי מחזירה את ההופכי של כל איבר של A. ושוב, הנקודה כאן נותנת לנו רמז שזו פעולת ברמת האברים. אנחנו גם יכולים לעשות דברים כמו (log(v, שזה לוגריתם ברמת האבר של v. הפונקציה (exp(v נותנת E בחזקת האברים, אז זה E, זה E בריבוע, E בשלישית, כי זה היה V, ואפשר גם לעשות (abs(v כדי לקבל את הערך המוחלט של האברים של v. אז כאן, v היה כולו חיובי, אבל הוקטור מינוס אחת, שתיים, מינוס 3, אז abs שלו ברמת האיבר נותן את הערכים האלה שכולם לא שליליים. ו-v- נותן את הנגדי של איברי v. זה כמו לכתוב 1- כפול v, אבל בדרך כלל כותבים פשוט v- במקום 1-*v. מה עוד אפשר לעשות? הנה עוד טריק. הבה נראה. בואו נגיד שאני רוצה לקחת את v ולהוסיף אחת לכל איבריו. אז דרך אחת לעשות זאת היא על ידי בניית וקטור שלוש על אחת שכולו אחדות, ולחבר אותו ל-v. אז אם נעשה את זה, נגדיל את v מ-1, 2, 3 ל-2, 3, 4. מה שעשיתי כאן היה לקחתי את האורך של v, שהוא (length(v שזה 3, אז (ones(length(v),1 הוא (ones(3,1, אז זה (3,1)ones מימין ומה שעשיתי היה להוסיף ל-v את המטריצה הזו, מה שהוסיף וקטור אחדות ל-v, ולכן הגדיל את v באחת, אבל דרך יותר פשוטה לעשות את זה היא להקליד v ועוד אחת. אז יש לנו v, ו-v פלוס אחת פירושו להוסיף אחת לכל איבר מהאברים של v. עכשיו, בואו נדבר על פעולות נוספות. אז הנה המטריצה ​​שלי A, אם אתה רוצה לשחלף אותה, הדרך לעשות זאת היא לכתוב את התו תג, הסמל של הגרש, זה הגרש השמאלי, אם במקלדת יש לך גרש שמאלי וגרש ימני. זה למעשה סימן הגרש הסטנדרטי. פשוט תקליד 'A, וזה נותן את A משוחלפת. וגם, כמובן, אם אני משחלף אותה שוב, אנחנו אמורים לקבל בחזרה את המטריצה המקורית. עוד כמה פונקציות שימושיות. נניח שa קטנה היא 1 15 2 0.5, זאת אומרת מטריצה של 1 על 4. הבה נציב val שווה מקס a, זה מחזיר את המקסימום בין אברי A, שבמקרה שלנו הוא 15 ואפשר גם להציב זוג ערכים (val, ind] = max(a] וכאן נקבל גם את המקסימום שהוא 15 וגם את מיקומו בתוך a שהוא שתיים. אז זה היה איבר מספר שתיים שערכו הוא 15, ושתיים הוא המצביע לתוך a. שימו לב שאם מריצים (max(A כאשר A היא מטריצה, אז המשמעות של זה היא בעצם למצא את המקסימום של כל עמודה בנפרד. נדבר קצת יותר על זה תיכף. בינתיים אני עדיין משתמש בדוגמא זו של a קטנה. אם אני עושה a<3, גם זה עושה את הפעולה על כל איבר בנפרד. השוואה לפי איבר, ומכיוון שהאיבר הראשון של a אכן קטן משלוש אז התוצאה היא אחת. האיבר השני של a איננו קטן משלוש ולכן הערך כאן הוא אפס כי הוא שקר. האברים השלישי והרביעי של A קטנים משלוש, אז התשובה היא 1 1. אז קיבלנו השוואה לפי איבר של כל ארבעת האברים של המשתנה a < 3. וזה מחזיר אמת או שקר, תלוי אם האיבר קטן משלוש או לא. הפקודה (find(a<3 מחזירה את רשימת האינדקסים של איברים של a הקטנים מ-3, ובמקרה שלנו האברים הראשון, השלישי והרביעי קטנים מ-3. עבור הדוגמא הבאה, הרשו לי להגדיר את A שווה (magic(3 (קסם). הפונקציה מחזירה, בואו נקליד help magic. פונקצית magic מחזירה את המטריצות האלה הנקראות ריבועי קסם. יש להם התכונה המתמטית שכל השורות שלהם, כל העמודות וגם האלכסונים מסתכמים באותו מספר. זה לא באמת שימושי עבור למידה חישובית עד כמה שידוע לי, אני משתמש בזה כעוד דרך נוחה ליצור מטריצה שלוש על שלוש. לריבועי הקסם האלה יש המאפיין שכל שורה, כל עמודה, והאלכסונים כולם מסתכמים באותו סכום, אז זה בעצם מין מבנה מתמטי. אני משתמש בפונקצית magic הזו רק כשאני עושה הדגמות או כשאני מלמד אוקטבה כמו כאן, אני לא ממש משתמש בה לאיזה שהוא יישום של למידה חישובית. אבל בואו נראה, אם אני מקליד (RC = find(A >= 7 זה מוצא את כל האיברים של A שגדולים או שווים שבע, האותיות r, c מייצגות שורה ועמודה. אז האיבר 1,1 גדול שווה 7, האיבר במקום 3,2 גדול שווה 7, והאיבר במקום 2,3 גדול שווה 7. אז בואו נראה. האינדקס 2,3, למשל, דהיינו (A(2, 3, הוא 7, האיבר הזה כאן, והוא אכן גדול שווה שבע. אגב, אני ממש לא טורח לזכור מה עושות כל פונקציות ה-find האלה ומה כל שאר הדברים האלה עושים. בכל פעם שאני משתמש בפונקציה find, לפעמים אני שוכח בדיוק מה היא עושה, ועכשיו אני אקליד help find ואראה את ההסברים. אוקיי, רק עוד שני דברים שאני אראה כאן בזריזות. האחת היא פונקצית sum, אז הנה a, ואני מקליד (sum(a. זה מחבר את כל אברי a, ואם אני רוצה להכפיל אותם, אני מקליד (prod(a, הפונקציה prod מחשבת מכפלה, ומחזירה את מכפלת ארבעת האברים של a (floor(a מעגלת כלפי מטה את אברי a, אז 0.5 מתעגל כלפי מטה ל-0. ו-ceil, או (ceiling(a מעגל את האברים כלפי מעלה למספר השלם הקרוב ביותר, אז 0.5 מתעגל כלפי מעלה ל-1. אפשר גם, בואו נראה. הרשו לי להקליד (rand(3, זה מייצר מטריצה שלוש על שלוש. אם אני מקליד ((max(rand(3), rand(3, מה שזה עושה הוא לוקח את המקסימום ברמת האיבר של שתי מטריצות אקראיות 3 על 3. אז אתם יכולים לראות שהמספרים האלה נוטים להיות יות גדולים מסתם אקראיים, כי כל אחד מהם הוא למעשה המקסימום של שני אברים של שתי מטריצות אקראיות. זהו מספר הקסם שלי. סליחה, זהו ריבוע הקסם שלי, A שלוש על שלוש אז בואו נקליד (max(A ואז [], 1, המשמעות של זה להחזיר את ערכי המקסימום של העמודות. המקסימום של העמודה הראשונה הוא 8, המקסימום של העמודה השנייה הוא 9, המקסימום של העמודה השלישית הוא 7. ה-1 הזה אומר לחשב את המקסימום לפי הממד הראשון של A. לעומת זאת, לו הקלדתי (max(A ואז את הסוגריים האלה פסיק שתיים, אז הייתי מקבל את המקסימום לפי שורות. המקסימום של השורה הראשונה הוא שמונה, המקסימום של השורה השנייה הוא שבע, המקסימום של השורה השלישית הוא תשע, אז זה מאפשר לקבל את המקסימום לפי שורה או לפי עמודה. ברירת המחדל היא לפי עמודה. אז אם אתה רוצה למצוא את האיבר הכי גדול בכל המטריצה A, תוכל להקליד ((max(max(A, ותקבל 9. אפשר גם להפוך את A לוקטור על ידי הביטוי ((:)max(A ואז תקבל את המקסימום של הוקטור שבנוי מהאברים של A שהוא האיבר הכי גדול של הוקטור. ועוד דבר אחרון, בואו נשים ב-A ריבוע קסם של 9 על 9. כזכור לריבוע הקסם יש התכונה שכל טור וכל שורה מסתכמים באותו מספר, וכן גם האלכסונים, אז יצרנו ריבוע קסם תשע על תשע. אז בואו נסכם (sum(A, 1. אז זה עושה סכום לפי טורים, לוקח כל עמודה של A ומסכם אותה ואכן יוצא שעבור ריבוע קסם של תשע על תשע, סכום כל עמודה הוא 369, לכל העמודות אותו סכום. עכשיו בואו נעשה את הסכום לפי שורות. נריץ (sum(A,2, וזה מסכם את כל השורות של A, ואכן גם כל שורה של A מסתכמת ב-369. עכשיו, בואו נסכם את האלכסונים של A כדי לוודא שגם להם אותו סכום. אז מה שנעשה הוא לבנות מטריצת יחידה של ​​תשע על תשע, (eye(9. עכשיו נכפול את ריבוע הקסם במטריצת היחידה לפי איבר, אז הנה המטריצה ​A ואני אחשב (A .* eye(9 מה שזה עושה הוא לכפל את המטריצות האלה איבר איבר, ובגלל האפסים הכל בעצם נעלם חוץ מהערכים באלכסון. ועכשיו נעשה ((sum(sum(a וזה ייתן לנו את הסכום של האברים האלה באלכסון, ואכן אנו רואים שגם הסכום הזה הוא 369. ניתן לסכם גם את האלכסון השני. זה שחישבנו הוא מהפינה השמאלית העליונה לימנית התחתונה, אפשר לסכם גם את האלכסון מהפינה השמאלית התחתונה אל הימנית העליונה. הפקודות כדי לחשב את זה הן קצת פחות מוכרות, ואתם באמת לא צריכים להכיר אותן. אני פשוט מראה את זה למקרה שחלק מכם סקרנים. אבל בואו נראה. Flipud פירושו הֲפוֹךְ מעלה-מטה. אז אם תעשו את זה, אז זה יסכם את האברים ההפוכים. באלכסון השני, וגם כאן זה מסתכם ב-369. הנה, אני אראה לכם. אז (eye(9 היא המטריצה ה​​זו. ((flipud(eye(9 לוקח את מטריצת היחידה והופך אותה בכיוון המאונך, כך שמתקבלת מטריצה עם אחדות על האלכסון הראשי הנגדי. ועכשיו פקודה אחרונה אחת ואז די, ואז סיימנו את הוידאו הזה. בואו נאתחל את A להיות ריבוע קסם שלוש על שלוש. כשרוצים להפוך מטריצה, מקלידים (pinv(a. קוראים לזה בדרך כלל פסאודו-הופכי, אבל זה לא משנה. תחשבו על זה כעל ההופכי של A, זו המטריצה ההופכית של A אז אני יכול להגדיר (temp = pinv(a ולכן A כפול temp היא אכן מטריצת היחידה, שהיא למעשה אחדות על האלכסונים, ואפסים מחוץ לאלכסונים, עד רמת שגיאת העיגול. אז, זה הכל בקשר לאיך לעשות פעולות חישוביות שונות על נתונים ומטריצות. ואחרי הרצת אלגוריתם למידה, בדרך כלל אחד הדברים השימושיים ביותר הוא להיות מסוגל לבחון את התוצאות שלו, דהיינו לשרטט או לצייר את התוצאה. אז בסרטון הבא אני מתכוון להראות לכם בזריזות איך על ידי שורה אחת או שתיים של קוד באוקטבה ניתן בקלות ובמהירות לצייר או לשרטט את הנתונים, ולהשתמש בזה כדי להבין יותר טוב איך עובד אלגוריתם הלימוד.