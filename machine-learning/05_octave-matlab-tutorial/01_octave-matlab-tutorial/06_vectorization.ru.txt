В этом видео я бы хотел рассказывать вам о векторизации. Вне зависимости от того, используете ли вы Octave или похожий на него MATLAB, или языки Python, NymPy, Java или С++. Во всех этих языках есть встроенные или готовые библиотеки для работы с линейной алгеброй. Они обычно очень хорошо написаны и оптимизированы, так как разработаны людьми, защитившими диссертации по численным методам или являющимися специалистами в этой области. В таких случаях при написании обучающихся алгоритмов вы можете воспользоваться преимуществами, которые дают вам готовые библиотеки линейной алгебры, вместо самостоятельного написания функций, которые в этих библиотеках уже реализованы. Если вы так и поступите, то получите код, во-первых, более эффективный. То есть он быстрее исполняется, эффективно использует ресурсы вашего компьютера, и так далее. Во-вторых, вам просто придется писать меньше кода. Тем самым больше вероятность, что в коде не будет багов. Вот конкретный пример. Вместо того, чтобы писать свой код для перемножения матриц, мы просто можете написать A*B в Octave и этим очень быстро узнать результат перемножения. Есть немало случаев, когда оправданно использование векторизации. У Вас получится намного более простой и намного более эффективный код. Давайте рассмотрим примеры. Пусть у нас есть привычная нам гипотеза линейной регрессии, и требуется вычислить h(x). Обратите внимание на сумму справа. Вы можете просто просуммировать элементы для j в пределах от нуля до n. В то же время вы можете получить тот же результат, умножив транспонированное тета на икс. Результат этой операции есть произведение двух векторов, где вектор тета состоит из элементов тета0, тета1, тета2. Таким образом, у вас есть два элемента, или n=2. И есть вектор х, который выглядит так. Эти два метода реализуются по-разному. Вот что я имею в виду. Вот невекторизованная реализация вычисления h(x), то есть без использования векторизации. Изначально присвоим предсказанию величину 0.0. В конечном итоге оно последовательно так как в цикле for, повторяющемся n+1 раз, оно последовательно увеличивается на theta(1) умножить на x(j). Что соответствует вот этому выражению. Кстати, обратите внимание, в этих векторах первым по счету идет нулевой индекс. У меня были элементы theta0, theta1, theta2. Но из-за особенностей индексирования MATLAB theta0 обозначается как theta1, второй элемент обозначается как theta2, и третий элемент обозначается как theta3. Все потому, что индексирование в MATLAB начинается с единицы, в отличие от исходного вектора, где оно начинается с нуля. Поэтому цикл for выполняется от 1 до n+1, а не от 0 до n. Понятно? Но это была невекторизованная реализация, в которой мы в цикле вычисляли сумму из n элементов. В то же время можно использовать векторизацию, то есть представление x и тета в виде векторов и вычисление предсказания как произведения транспонированного тета и х.В соответствии с этим выражением. Вместо написания громоздкого цикла, можно написать одну строчку кода. Эта строчка справа использует возможности Octave в области линейной алгебры для вычисление произведения двух векторов, theta' и x. Этот код не только проще
написать, он также выполняется более эффективно. В примере я использовал Octave, но это справедливо и для других языков программирования. Давайте посмотрим пример на С++. Вот так выглядит невекторизованный вариант. Мы инициализируем переменную prediction, присваиваем ей 0.0, реализуем цикл на интервале от 0 до n. В цикле предсказание увеличивается на величину theta[j]*x[j], и этот цикл вы пишете вручную. В то же время с хорошей библиотекой операций линейной алгебры для С++ вы можете написать функцию, которая... нет, скорее так. В то же время с хорошей библиотекой операций линейной алгебры для С++ ваш код мог бы выглядеть так. В зависимости от выбора библиотеки вам может попасться выражение, обрабатывающее C++-объекты theta и х. Здесь выполняется theta.transpose()*x, звездочка перегружает оператор, и происходит перемножение двух векторов на языке С++. В зависимости от выбранной библиотеки линейной алгебры ваш синтаксис может несколько отличаться, но суть состоит в использовании библиотеки для вычисления произведения. Вы получаете более простой и эффективный код. Теперь обратимся к более сложному примеру. В качестве напоминания: вот наше правило обновления градиентного спуска линейной регрессии. Мы обновляем theta j согласно этому правилу для всех j: 0, 1, 2 и т.д. Теперь я выпишу функции для theta0, theta1, theta2. Исходя из того, что у нас всего два параметра. То есть n=2. Тогда эти формулы есть обновления для theta0, theta1, theta2. Вы наверняка помните, что раньше я говорил, что они должны обновляться одновременно. Посмотрим, сможем ли мы векторизовать этот процесс. Вот те же три уравнения, написанные меньшим шрифтом. Казалось бы, их можно было бы описать с помощью цикла for, выполняющегося для j от 0 и до 2. Вместо этого давайте поищем более простое решение с использованием векторизации. Тем самым мы сожмем три строки кода в один цикл, выполняющий