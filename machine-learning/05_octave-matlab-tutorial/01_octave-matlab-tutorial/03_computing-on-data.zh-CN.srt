1
00:00:00,280 --> 00:00:02,820
现在 你已经学会了在Octave中

2
00:00:02,820 --> 00:00:05,100
如何加载或存储数据

3
00:00:05,100 --> 00:00:10,028
如何把数据存入矩阵 等等

4
00:00:10,028 --> 00:00:14,880
在这段视频中

5
00:00:14,880 --> 00:00:15,870
我将向你介绍

6
00:00:17,130 --> 00:00:17,810
如何对数据进行运算

7
00:00:19,650 --> 00:00:21,040
这是我的 Octave 窗口

8
00:00:21,040 --> 00:00:25,900
运算操作来实现我们的学习算法

9
00:00:25,900 --> 00:00:33,470
现在我们开始吧

10
00:00:33,470 --> 00:00:37,855
这是我的 Octave 窗口

11
00:00:39,195 --> 00:00:42,235
我现在快速地

12
00:00:42,235 --> 00:00:47,195
初始化一些变量

13
00:00:47,195 --> 00:00:52,215
比如设置A

14
00:00:52,215 --> 00:00:57,145
为一个3×2的矩阵

15
00:00:57,145 --> 00:01:02,580
设置B为

16
00:01:02,580 --> 00:01:06,208
一个3 × 2矩阵

17
00:01:06,208 --> 00:01:11,230
设置C为

18
00:01:11,230 --> 00:01:17,140
2 × 2矩阵

19
00:01:17,140 --> 00:01:20,840
现在 我想算两个矩阵的乘积

20
00:01:20,840 --> 00:01:23,200
比如说 A × C

21
00:01:23,200 --> 00:01:27,440
我只需键入A×C

22
00:01:27,440 --> 00:01:31,494
这是一个 3×2 矩阵乘以 2×2 矩阵

23
00:01:31,494 --> 00:01:36,500
得到这样一个3×2矩阵

24
00:01:36,500 --> 00:01:39,440
你也可以对每一个元素

25
00:01:41,100 --> 00:01:42,560
做运算 方法是做点乘运算A .*B

26
00:01:42,560 --> 00:01:46,230
这么做

27
00:01:46,230 --> 00:01:52,010
Octave将矩阵 A 中的每一个元素

28
00:01:52,010 --> 00:01:56,040
与矩阵 B 中的

29
00:01:56,040 --> 00:02:00,610
对应元素相乘

30
00:02:02,760 --> 00:02:08,173
这是A 这是B 这是A .* B

31
00:02:08,173 --> 00:02:15,080
比如说 这里第一个元素

32
00:02:15,080 --> 00:02:20,300
1乘以11得到11

33
00:02:20,300 --> 00:02:25,600
第二个元素是

34
00:02:25,600 --> 00:02:31,040
2乘以12得到24

35
00:02:31,040 --> 00:02:36,660
这就是两个矩阵的

36
00:02:36,660 --> 00:02:42,973
元素位运算

37
00:02:42,973 --> 00:02:45,930
通常来说

38
00:02:45,930 --> 00:02:48,720
在Octave中

39
00:02:48,720 --> 00:02:54,024
点号一般

40
00:02:54,024 --> 00:02:56,050
用来表示元素位运算

41
00:02:56,050 --> 00:02:57,240
这里是一个矩阵A

42
00:02:57,240 --> 00:02:58,360
所以 让我们看看

43
00:02:58,360 --> 00:03:01,700
这将对矩阵A中

44
00:03:01,700 --> 00:03:06,590
每一个元素平方

45
00:03:06,590 --> 00:03:11,430
所以 1的平方是1

46
00:03:11,430 --> 00:03:14,590
2的平方是4 等等

47
00:03:14,590 --> 00:03:21,520
我们设V是一个向量

48
00:03:21,520 --> 00:03:27,260
设V为 [1; 2; 3] 是列向量

49
00:03:27,260 --> 00:03:33,620
你也可以输入

50
00:03:33,620 --> 00:03:38,950
1 ./ V

51
00:03:40,000 --> 00:03:44,190
得到每一个元素的倒数

52
00:03:44,190 --> 00:03:45,450
所以这样一来

53
00:03:45,450 --> 00:03:50,840
就会分别算出 1/1  1/2  1/3

54
00:03:52,470 --> 00:03:55,490
矩阵也可以这样操作

55
00:03:55,490 --> 00:03:59,520
1 ./ A 得到

56
00:03:59,520 --> 00:04:03,720
A中每一个元素的倒数

57
00:04:03,720 --> 00:04:08,350
同样地

58
00:04:08,350 --> 00:04:11,260
这里的点号

59
00:04:11,260 --> 00:04:18,330
还是表示对每一个元素进行操作

60
00:04:18,330 --> 00:04:19,700
我们还可以进行求对数运算

61
00:04:19,700 --> 00:04:22,970
也就是对每个元素

62
00:04:25,160 --> 00:04:27,570
进行求对数运算

63
00:04:27,570 --> 00:04:34,300
还有自然数e的幂次运算

64
00:04:34,300 --> 00:04:38,880
就是以e为底

65
00:04:38,880 --> 00:04:42,970
以这些元素为幂的运算

66
00:04:42,970 --> 00:04:48,430
所以这是e 这是e的平方

67
00:04:48,430 --> 00:04:52,940
这是e的立方

68
00:04:52,940 --> 00:04:58,790
v 矩阵是这样的

69
00:04:58,790 --> 00:05:03,230
我还可以用 abs

70
00:05:03,230 --> 00:05:07,920
来对 v 的每一个元素

71
00:05:07,920 --> 00:05:09,860
求绝对值

72
00:05:11,610 --> 00:05:14,760
当然这里 v 都是正数

73
00:05:14,760 --> 00:05:19,630
我们换成另一个

74
00:05:19,630 --> 00:05:24,030
这样对每个元素求绝对值

75
00:05:24,030 --> 00:05:24,970
得到的结果就是

76
00:05:24,970 --> 00:05:29,970
这些非负的元素

77
00:05:29,970 --> 00:05:36,590
还有 -v

78
00:05:36,590 --> 00:05:42,970
给出V中每个元素的相反数

79
00:05:42,970 --> 00:05:47,440
这等价于 -1 乘以 v

80
00:05:47,440 --> 00:05:53,615
不过一般就直接用 -v 就好了

81
00:05:53,615 --> 00:05:55,235
其实就等于 -1*v

82
00:05:55,235 --> 00:05:59,545
还有什么呢？

83
00:05:59,545 --> 00:06:05,205
还有一个技巧

84
00:06:05,205 --> 00:06:08,985
比如说 我们想对v中的每个元素都加1

85
00:06:08,985 --> 00:06:15,370
那么我们可以这么做

86
00:06:15,370 --> 00:06:20,830
首先构造一个

87
00:06:20,830 --> 00:06:23,690
3行1列的1向量

88
00:06:23,690 --> 00:06:28,830
然后把这个1向量跟原来的向量相加

89
00:06:28,830 --> 00:06:34,450
因此 v 向量从[1 2 3] 增至 [2 3 4]

90
00:06:34,450 --> 00:06:38,788
我用了一个

91
00:06:38,788 --> 00:06:41,751
length(v) 命令

92
00:06:41,751 --> 00:06:44,300
因此这样一来

93
00:06:44,300 --> 00:06:48,820
ones(length(v) ,1) 就相当于

94
00:06:48,820 --> 00:06:53,760
ones(3,1)

95
00:06:53,760 --> 00:06:58,886
所以这是ones(3,1)

96
00:06:58,886 --> 00:07:04,231
对吧 然后我做的是

97
00:07:04,231 --> 00:07:07,740
v + ones(3,1)

98
00:07:07,740 --> 00:07:11,750
也就是将 v 的各元素

99
00:07:11,750 --> 00:07:13,270
都加上这些1

100
00:07:13,270 --> 00:07:14,360
让我们来看一看

101
00:07:14,360 --> 00:07:17,740
增加了1

102
00:07:17,740 --> 00:07:24,270
另一种更简单的方法是

103
00:07:24,270 --> 00:07:28,820
直接用 v+1

104
00:07:28,820 --> 00:07:30,220
所以这是 v

105
00:07:30,220 --> 00:07:34,180
v + 1 也就等于

106
00:07:34,180 --> 00:07:38,020
把 v 中的每一个元素

107
00:07:38,020 --> 00:07:40,130
都加上1

108
00:07:40,130 --> 00:07:44,270
现在 让我们来谈谈更多的操作

109
00:07:44,270 --> 00:07:48,140
这是我的矩阵A 如果你想要求它的转置

110
00:07:48,140 --> 00:07:50,940
那么方法是用A‘

111
00:07:50,940 --> 00:07:54,225
这是单引号符号

112
00:07:54,225 --> 00:08:01,630
并且是左引号

113
00:08:01,630 --> 00:08:06,600
可能你的键盘上

114
00:08:06,600 --> 00:08:10,900
有一个左引号

115
00:08:10,900 --> 00:08:13,330
和一个右引号

116
00:08:13,330 --> 00:08:16,720
这里用的是左引号

117
00:08:16,720 --> 00:08:21,790
也就是标准的引号

118
00:08:21,790 --> 00:08:27,000
因此 A’

119
00:08:27,000 --> 00:08:30,680
将得出 A 的转置矩阵

120
00:08:30,680 --> 00:08:33,150
当然

121
00:08:34,490 --> 00:08:37,515
如果我写 (A‘)’

122
00:08:37,515 --> 00:08:38,280
也就是 A 转置两次

123
00:08:38,280 --> 00:08:43,050
那么我又重新得到矩阵 A

124
00:08:43,050 --> 00:08:48,270
还有一些有用的函数

125
00:08:48,270 --> 00:08:53,580
假如说 小写a

126
00:08:53,580 --> 00:08:58,260
是[1 15 2 0.5]

127
00:08:58,260 --> 00:08:59,960
这是一个1行4列矩阵

128
00:08:59,960 --> 00:09:04,194
假如说 val=max(a)

129
00:09:05,200 --> 00:09:08,780
这将返回

130
00:09:08,780 --> 00:09:12,480
A矩阵中的最大值

131
00:09:12,480 --> 00:09:17,210
在这里是15

132
00:09:17,210 --> 00:09:23,570
我还可以写 [val, ind] = max(a)

133
00:09:24,760 --> 00:09:30,050
这将返回

134
00:09:30,050 --> 00:09:34,880
a矩阵中的最大值

135
00:09:34,880 --> 00:09:39,660
存入val

136
00:09:39,660 --> 00:09:45,130
以及该值对应的索引

137
00:09:45,130 --> 00:09:50,160
因此元素15对应的索引值为2 存入ind

138
00:09:52,130 --> 00:09:56,220
所以 ind 等于2

139
00:09:56,220 --> 00:10:00,700
特别注意一下

140
00:10:00,700 --> 00:10:03,650
如果你用命令 max(A) A是一个矩阵的话

141
00:10:03,650 --> 00:10:06,280
这样做就是对每一列

142
00:10:06,280 --> 00:10:07,470
求最大值

143
00:10:07,470 --> 00:10:12,050
等下再仔细讲讲

144
00:10:12,050 --> 00:10:15,550
我们还是用这个例子

145
00:10:15,550 --> 00:10:20,150
这个 小a 矩阵

146
00:10:20,150 --> 00:10:21,978
如果输入 a<3

147
00:10:21,978 --> 00:10:26,870
这将进行逐元素的运算

148
00:10:26,870 --> 00:10:32,950
所以 第一个元素

149
00:10:32,950 --> 00:10:36,110
是小于3的 因此返回1

150
00:10:36,110 --> 00:10:39,800
a的第二个元素

151
00:10:39,800 --> 00:10:45,558
不小于3 所以

152
00:10:45,558 --> 00:10:52,330
这个值是0 表示"非"

153
00:10:52,330 --> 00:10:56,290
第三个和第四个数字

154
00:10:56,290 --> 00:11:00,970
仍然是小于3

155
00:11:00,970 --> 00:11:05,820
2和0.5都小于3

156
00:11:05,820 --> 00:11:11,130
因此 这返回[1 1 0 1]

157
00:11:11,130 --> 00:11:17,830
也就是说

158
00:11:17,830 --> 00:11:20,260
对a矩阵的每一个元素

159
00:11:20,260 --> 00:11:22,340
与3进行比较

160
00:11:22,340 --> 00:11:27,410
然后根据每一个元素与3的大小关系

161
00:11:27,410 --> 00:11:29,791
返回1和0表示真与假

162
00:11:29,791 --> 00:11:31,600
现在 如果我写 find(a<3)

163
00:11:31,600 --> 00:11:34,790
这将告诉我

164
00:11:34,790 --> 00:11:38,390
a 中的哪些元素

165
00:11:38,390 --> 00:11:40,685
是小于3的

166
00:11:40,685 --> 00:11:45,760
是小于3的

167
00:11:45,760 --> 00:11:50,090
在这里就是第一 第三和第四个元素

168
00:11:50,090 --> 00:11:52,020
是小于3的

169
00:11:52,020 --> 00:11:54,262
下一个例子

170
00:11:54,262 --> 00:11:59,470
设A = magic(3)

171
00:11:59,470 --> 00:12:02,890
magic 函数返回什么呢

172
00:12:02,890 --> 00:12:06,480
让我们查看 magic 函数的帮助文件

173
00:12:08,780 --> 00:12:12,750
magic 函数将返回

174
00:12:12,750 --> 00:12:16,820
一个矩阵 称为魔方阵或幻方 (magic squares)

175
00:12:16,820 --> 00:12:20,340
它们具有以下

176
00:12:20,340 --> 00:12:23,120
这样的数学性质

177
00:12:23,120 --> 00:12:27,830
它们所有的行和列和对角线

178
00:12:27,830 --> 00:12:34,130
加起来都等于相同的值

179
00:12:34,130 --> 00:12:38,110
当然据我所知

180
00:12:38,110 --> 00:12:41,650
这在机器学习里

181
00:12:44,210 --> 00:12:45,596
基本用不上

182
00:12:45,596 --> 00:12:50,630
但我可以用这个方法

183
00:12:50,630 --> 00:12:55,548
很方便地生成一个

184
00:12:55,548 --> 00:12:59,760
3行3列的矩阵

185
00:12:59,760 --> 00:13:04,342
而这个魔方矩阵这神奇的方形屏幕。

186
00:13:04,342 --> 00:13:06,260
每一行 每一列

187
00:13:06,260 --> 00:13:09,255
每一个对角线

188
00:13:09,255 --> 00:13:13,340
三个数字加起来