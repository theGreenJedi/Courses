בהרצאה הזו, אני רוצה להסביר איך כותבים פקודות בקרה באוקטבה, דברים כמו פקודות "for", "while" ו-"if" ובנוסף נלמד גם איך מגדירים פונקציות ואיך משתמשים בהן. הנה חלון אוקטבה שלי. הרשו לי קודם כל להדגים שימוש בלולאת "for". אני הולך להתחיל על ידי הגדרת v להיות וקטור של 10 על 1 של 0. עכשיו, הנה לולאת "for" של i מ-1 עד 10. דהיינו  for i שווה 1:10. בואו נראה, אני אגדיר V במקום ה-i שווה שתיים בחזקת i, ובסוף ובסוף end. הרווחים לא חשובים, אז אני שם כאן רווחים רק כדי לגרום לזה להיראות מסודר יפה, אבל כמות הרווחים לא משנה. אבל התוצאה של הלולאה הזו היא ש-V מתמלא בערכים שהם שתיים בחזקת, שתיים בחזקת אחת, שתיים בחזקת שתיים, וכו'. אז התחביר הזה של i שווה אחת נקודתיים 10 גורם ללולאה של המשתנה i דרך הערכים אחת עד 10. ודרך אגב, אפשר לעשות את זה גם על ידי יצירת וקטור של אינדקסים מאחת עד 10, אינדקסים במערך מאחת עד 10. ואז אפשר לכתוב גם i שווה לאינדקסים. וזה בעצם אותו דבר כמו i שווה לאחת עד 10. אפשר לעשות נניח הצגה של i מתוך וקטור האינדקסים וזה עושה אותו דבר. אז זהו זה בקשר ללולאת "for", אם אתם מכירים את "break" ו-"continue", אז יש משפטי "break" ו-"continue", אפשר להשתמש בהם בלולאות באוקטבה, אבל בואו נראה קודם איך עובדת לולאת while. אז הנה הוקטור שלי V. בואו נכתוב לולאת while. i שווה 1, כל עוד i קטן או שווה ל-5, הבה נגדיר V של i שווה מאה, ונגדיל את i באחת, ושוב משפט end בסוף. מה פירוש הדבר הזה? i בהתחלה שווה לאחת ואז אנחנו שמים בV של i מאה, ומגדילים את i באחת עד ש-i כמו שכתוב כאן עובר מעל חמש. וכתוצאה מזה, בעוד שמקודם הוקטור V הכיל חזקות של שתיים, עכשיו לקחנו את חמשת האברים הראשונים של הווקטור ושינינו את הערך שלהם למאה. אז זה התחביר של לולאת while. בואו נעשה עוד דוגמא i שווה אחת, כל עוד "אמת", וכאן ברצוני להראות איך משתמשים בפקודה break. בואו נכתב V של i שווה 999 ו-i שווה i + 1, ואם i שווה 6, break ובסוף end. זו גם הפעם הראשונה שאנו משתמשים במשפט if, אז אני מקווה שזה נראה לכם הגיוני. מאחר ש-i מתחיל כשווה אחת, ואנחנו מגדילים אותו בלולאה. לולאת ה-while חוזרת שוב ושוב על סדרת הפעולות של לשים ב-V של i את הערך 999 ולקדם את i. כאשר i מגיע ל-6, הפקודה break גורמת ליציאה מהלולאה. ומה שזה עושה הוא לקחת את חמשה האברים הראשונים של הוקטור V ולשים בהם ערך 999. אז לקחנו את V והחלפנו את הערך של חמישה האברים הראשונים שלו ל-999. זה התחביר של פקודת "if" ופקודת while, ושימו לב שבסוף כאן ישנה הפקודה end פעמיים. ה-end הראשון מסיים את פקודת ה"if" והשני מסיים את פקודת ה-while. עכשיו הרשו לי להראות לכם תחביר כללי יותר של פקודת if שבו יש if-else. אז, בואו נראה, כרגע V של 1 שווה 999, בואו נכניס ל-(V)1 את הערך 2 בשביל הדוגמא הזו. עכשיו נכניס את הפקודות if V(1) == 1 הדפס "הערך הוא אחת". הנה איך כותבים את פקודת ה-else, או ליתר דיוק else if v(1) == 2. זה, שבמקרה הוא נכון בדוגמא שלנו, ידפיס "הערך הוא 2". אחרת, הדפס "הערך אינו לא אחת ולא שתיים". אוקיי, אז כך נראה משפט if-else if-else וכמובן, בסוף end. וכמובן, מכיוון שהצבנו כאן ב-(V(1 את הערך 2, אז כצפוי התוצאה תהיה "הערך הוא 2". ועוד משהו, אני לא חושב שהזכרתי את זה עדיין, אבל אם אי פעם צריך לצאת מאוקטבה, תוכל להקליד את פקודת exit ולהקיש Enter ואוקטבה תסיים את פעולתה, וניתן להשתמש גם בפקודה 'q'-. ועכשיו בואו נדבר על פונקציות, כיצד להגדיר אותם ואיך להשתמש בהם. הנה שולחן העבודה שלי, ואני הכנתי מראש קובץ ששמרתי על שולחן העבודה שלי בשם "squarethisnumber.m". הנה איך מגדירים פונקציות באוקטבה. אתה יוצר קובץ בשם הפונקציה שלך עם הסיומת "m.", וכאשר אוקטבה מוצאת את הקובץ הזה, היא יודעת ששם היא צריכה לחפש את ההגדרה של הפונקציה "squarethisnumber". בואו נפתח את הקובץ הזה. שימו לב שאני משתמש בתוכנית wordpad של מיקרוסופט כדי לפתוח את הקובץ הזה. אני רוצה להמליץ לכם שאם אתם משתמשים ב-Microsoft Windows, תשתמשו ב-wordpad ולא ב-Notepad כדי לפתוח את הקבצים הללו, אם יש לכם עורך טקסטים אחר, גם הם בסדר, אבל notepad לפעמים מקלקל את הרווחים. אם יש לך רק Notepad, גם זה צריך לעבוד, גם זה יכול לעבוד, אבל אם יש לך גם wordpad, אני מעדיף להשתמש בו או בעורך טקסטים אחר, אם יש לך מעבד טקסטים שונה לעריכת הפונקציות שלך. אז הנה איך מגדירים פונקציה באוקטבה. אני רק אגדיל את זה קצת. בקובץ הזה יש בסך הכל שלוש שורות. השורה הראשונה אומרת (function Y = squareThisNumber(X, זה מגדיר לאוקטבה שהערך המוחזר מהפונקציה הוא Y, יוחזר ערך בודד שערכו יהיה במשתנה Y וזה גם מגדיר לאוקטבה שלפונקציה הזו יש ארגומנט אחד, שהוא X, ואת הגדרת הפונקציה שהיא Y מקבל את squareThisNumber של X. אז בואו ננסה לקרוא לפונקציה הזו "square", עם המספר 5, וזה בעצם לא יעבוד, ואוקטבה טוען שהביטוי הזה הוא לא מוגדר. הסיבה לכך היא שאוקטבה לא יודעת איפה למצוא את הקובץ הזה. אז כרגיל, בואו נשתמש ב-PWD לראות איפה אנחנו, אה, אנחנו לא בספרייה שלי, אז בואו נעבור לשם: c:\users\ang\desktop. שם נמצא שולחן העבודה שלי. אופס, טעות הקלדה קטנה. Users ANG Desktop ואם עכשיו אני מקליד (sqaureThisNumber(5, אני מקבל את התשובה 25. כמין תכונה מתקדמת, רק עבור אלה מכם שמכירים את המונח נתיב חיפוש. אבל אם אתה רוצה לשנות את נתיב החיפוש של אוקטבה אז זה אפשרי, אבל תחשבו על הדבר הבא כחומר מתקדם או אופציונלי. רק למי שמכירים את המושגים של תיקיות חיפוש בסביבות עבודה של שפות, אתם יכולים להשתמש בפקודה addpath, עם התיקייה שאתם רוצים להוסיף כדי להוסיף את התיקייה הזו לרשימת תיקיות החיפוש של אוקטבה כך שגם אם אתם עוברים לאיזו ספרייה אחרת אוקטבה עדיין תדע לחפש פונקציות בספריית שולחן העבודה של המשתמש ANG, כך שלמרות שעברנו לספרייה שונה, היא עדיין תדע איפה למצוא את פונקצית ריבוע המספר הזו. בסדר? אבל אם אתם לא מכירים את המושג של תיקיות לחיפוש, אין לכם מה לדאוג בקשר לזה. פשוט תוודאו בכניסה לאוקטבה להריץ cd וללכת לספרייה שבה מוגדרות הפונקציות שלכם לפני שתפעילו אותן וזה יעבוד בסדר גמור. תכונה אחת שיש לאוקטבה שלא קיימת בהרבה שפות תכנות אחרות היא שאפשר גם להגדיר פונקציות המחזירות ערכים מרובים או ארגומנטים מרובים. אז הנה דוגמה לכך. הגדרתי פונקציה שנקראת SquareAndCubeThisNumber של המספר X והפונקציה הזו מחזירה 2 ערכים, y1 ו-y2. כאשר y1 הוא X בריבוע, ו-y2 הוא X בשלישית. והמשמעות של זה היא שהפונקציה אכן מחזירה 2 מספרים. חלק מכם, תלוי באילו שפות תכנות אתם משתמשים, אם נניח אתה מכיר ויודע, לדוגמא, את C או ++C. אז בדרך כלל אנו חושבים על פונקציה כדבר שמחזיר רק ערך אחד. אבל התחביר באוקטבה נבנה כך שיוכל להחזיר ערכים מרובים. עכשיו אנחנו בחזרה בחלון אוקטבה. אני מקליד a, b = SquareCubeThisNumber של המספר 5, אז עכשיו a שווה 25 ו-b שווה 5 בשלישית שזה 125. אז זה די נוח אם אנחנו צריכים פונקציה שמחזירה ערכים מרובים. לסיום אני עומד להראות לכם איזו דוגמא יותר מתוחכמת של פונקציה. נניח שיש לי סדרת נתונים שנראית ככה, עם נתונים בנקודות 1, 1, 2, 2, 3, 3. ומה שאני רוצה לעשות הוא להגדיר פונקציה באוקטבה כדי לחשב את פונקצית העלות J של תטא עבור ערכים שונים של תטא. קודם כל בואו נכניס את הנתונים לאוקטבה. אז נבנה מטריצה עם ערכים 1,1,1,2,1,3. זוהי מטריצת העיצוב x שבה X0, העמודה הראשונה היא המקדם של תטא-0 שהוא 1 והעמודה השנייה הם ערכי ה-x של שלוש דוגמאות האימון שלי. וכן נגדיר y להיות 1-2-3, שהם ערכי ציר y. אז בואו נניח שהמקדמים, הוקטור תטא הם 0 נקודה-פסיק 1. כאן על שולחן העבודה שלי, הגדרתי מראש את פונקצית העלות j ואם נציג אותה על המסך היא נראית כך. אז הפונקציה j שווה CostFunctionJ של X, y ותטא, קצת הערות שמתארות את הקלט ואז מספר קטן של פעולות, m מחושב כגודל סדרת האימון, דהיינו מספר השורות ב-x. חישוב ההשערה, ההשערה שווה x כפול תטא, עכשיו עוד הערה שגלשה לשורה הבאה, והיא כנראה חלק מההערה הקודמת. חישוב סכום ריבועי השגיאות, אתם רואים, אנחנו לוקחים את ההפרש בין התחזית ובין ערכי y בפועל ומעלים בריבוע, ובסוף חישוב של פונקצית העלות J. ואוקטבה יודעת ש-J הוא הערך שאני רוצה להחזיר כי J מופיע כאן בהגדרת הפונקציה. דרך אגב, תרגישו חופשיים להשהות את הוידאו אם תרצו להסתכל על הגדרת הפונקציה יותר לעומק כדי לוודא שאתם מבינים את הצעדים השונים. כשמריצים את זה באוקטבה, מריצים (j = CostFunctionJ(x, y, theta וזה מחשב, אופס, טעות הקלדה, הייתי צריך לכתוב X גדולה. התשובה היא J שווה 0 כי סדרת נתוני האימון היא כזכור 1 2 3, 1 2 3 ואז כשמגדירים תטא-0 שווה 0 ותטא-1 שווה 1, אנחנו מקבלים בדיוק קו של 45 מעלות שמתאים לסדרת הנתונים בצורה מושלמת. בניגוד לכך, אם נגדיר תטא שווה נניח 0, 0, אז פונקצית ההשערה מנבאת או חוזה שכל ערכי התוצאה הם 0, תטא-0 שווה 0, תטא-1 שווה 0, עכשיו נחשב את פונקציית העלות J, עכשיו נקבל 2.333 שזה בעצם 1 בריבוע שהיא ריבוע השגיאה בדוגמה הראשונה, ועוד 2 בריבוע, ועוד 3 בריבוע והכל חלקי 2m, דהיינו 2 כפול מספר דוגמאות האימון, וזה אכן יוצא 2.33, פשוט וידאתי שהפונקציה הזו כאן באמת מחשבת את פונקצית העלות כמו שצריך, ואלה היו פשוט שתי דוגמאות שבדקנו על סדרת האימון הפשוטה שלנו. אז בדקנו בצורה שטחית שפונקצית העלות J, כפי שהיא מוגדרת כאן באוקטבה, אכן מחשבת את פונקציית העלות האמיתית, לפחות על סדרת האימון הפשוטה שלנו כאן עם ה-X וה-Y שהם הדוגמה הפשוטה הזו שפתרנו. אז עכשיו אתם יודעים איך לכתוב משפטי בקרה כמו לולאות "for" ו-"while" ומשפטי "if" באוקטבה, כמו גם איך להגדיר פונקציות ואיך להשתמש בהן. בסרטון הבא, אני ארפרף על הלוגיסטיקה של איך עובדים על תרגילים ואיך מגישים אותם בקורס הזה, ואת אופן השימוש במערכת הגשת התרגילים שלנו. ולאחר מכן, בסרטון האחרון של לימוד אוקטבה, אני מתכוון לספר לכם על וקטוריזציה, שהוא הרעיון של איך לגרום לתוכניות אוקטבה לרוץ הרבה יותר מהר.