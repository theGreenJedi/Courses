1/2、 ここまでで機械学習について様々な知識が得られました。 このビデオでは、 プログラミング言語 Octave を使って、 既に見た 学習アルゴリズムおよび、 今後の授業で学ぶ学習アルゴリズムを 手早く実装する方法を学びます。 過去に、機械学習を教えるにあたって、 様々な種類のプログラミング言語を使ってきました。 たとえば C++、 Java、 Python、NumPy、R、そして Octave などです。その経験から 学んだことは、学生たちが 一番効率よく、 手早く学ぶことができ、 そして アルゴリズムの試作を 迅速に行えるのは、 Octave のような高級言語であるということです。 実際に、私がよく シリコンバレーで見かけるのは、 たとえ構築する必要があるのが 構築したいものが 大規模な学習 アルゴリズムであっても、多くの場合、 まず試作を行い、その言語は Octave であることです。 これは 試作用の言語として優れています。 ですから、学習アルゴリズムを手早く動作させることが出来、 本当に、必要な時のみ、 それを大規模に展開する段階になって、 その時にのみ、時間をかけて アルゴリズムを C++ や Java などの言語で再実装します。 なぜなら、これまで学んだ教訓として、 プログラミングの時間、開発の時間、 つまりあなたの時間は、 機械学習に使う時間は、非常に貴重だ、ということです。 このため、もし Octave を使って 学習アルゴリズムを手早く稼動させることができれば 結果的に、開発時間 の大幅な節約につながるのは 最初にアルゴリズムの開発を Octave で行い、次に、アイディアが有効で あることを確認した後で C++ や Java などで実装することです。 私が見た中で、人々が一番一般的に 機械学習で使う試作用の言語は、 Octave、 MATLAB、 Python、NumPy、そして R です。 Octave はオープンソースなのでナイスですが、 MATLAB も有効です。 しかし多くの人にとって、 価格が高すぎます。 もしMATLAB のコピーにアクセス可能であれば、 このクラスで MATLAB を使うこともできます。 もし Python、NumPy を知っているか R を知っているなら、それを使う人も中にはいます。 しかし、私が見る限り、 結果的にこうした人たちは、 こうした言語では、開発により時間がかかる 傾向があります。 というのは、Python、NumPy の構文は、 Octave の構文に比べてやや取り扱いにくいからです。 ということで、また スターターコードを Octave で リリースすることもあわせ、 私として、強くお勧めするのは、 NumPy や R で このクラスの演習問題を試みないこと、 しかし、お勧めしたいのは、 代わりにこのクラスのプログラミング演習を Octave で行うことです。 このビデオで私が お見せしたいのは、 コマンドをざっと通して 紹介し、そのゴールとして Octave で利用可能なコマンドの 範囲やどのようなことが出きるか手早く紹介することです。 コースウェブサイトでは 私がお見せすることは 全て講義録として掲載しますので、 このビデオを見終わったら、 コースウェブサイトに掲載された 講義録を参考にして コマンドを見つけたい時に利用してください。 具体的に、私がお勧めするのは、 まずこのチュートリアルビデオを見て、 最後まで見終わったら、 Octave をコンピュータにインストールし、 最後に、コースウェブサイトへ 行き、講義録をダウンロードして このセッションで見たことを 参考に、 興味のあるコマンドを 自分の Octave で試してみることです。 自分のコンピュータで実行することで 自分の目で確認してください。 では、始めましょう。 これは、私の Windows デスクトップで、今から Octave を起動します。 今、Octave を開きました。 これが Octave のプロンプトです。 最初に初歩的な Octave の 操作をお見せします。 まず 5 + 6 と入力すると 11 が答えとして戻ります。 3 - 2、 5 x 8、 2^6 は 64 これらが初歩的な算術演算です。 また論理演算も可能です。 よって、 1 == 2 は 偽 を返します。 % コマンドは、ここではコメントを意味します。 よって、 1 == 2 は偽を返し、 これは ゼロで表されます。 1 が 2 と同等ではない、とすると、これは真です。 これは真です。 これは、1 を戻します。 ご注意頂きたいのは、同等ではないという演算子は この ~= という記号だということです。 つまり != ではない、ということです。 これは、いくつか プログラミング言語では使われます。 さて、論理演算 1 AND 0 これは && という記号を使って 論理積を表します。 そしてこれは偽となります。 1 または 0 は 論理和演算で、 それは 真となります。 また xor(1, 0)、とすることも出来、これは 1 を返します。 この左側にあるもの、この octave-3.2.4.exe:11 これはデフォルトの Octave プロンプトです。 これが表示するのは、 Octave のバージョンなどです。 このプロンプトが不要な場合、 少し暗号的なコマンド PS 引用符、>> などなど を使って、プロンプトを変えることができます。 そして、この引用符に囲まれた真ん中の文字列、 この '>> ' これが私の好みの Octave のプロンプトです。 ですから、Enterを押すと、 おっと、失礼、 このように、 PS1 とすると、 このように Octave のプロンプトが >> という記号に変わり、 前より見やすくなりました。 次に、Octave の変数についてお話します。 変数 A を指定してそれに 3 を代入し Enterを押します。 これで A = 3 となりました。 変数に代入したいけれども、結果を出力したくない場合は、 セミコロンをつけると、セミコロンが 結果のプリント出力を抑制します。 そうすると、Enter を押しても、何も出力されません。 一方、 A = 3 とすると、出力され、 A = 3; だと、出力されません。 文字列の代入もできます。 B = 'Hi' ここで単に Enter Bとすると変数が出力されます。 よって、 B は文字列 'Hi' です。 C = (3 >= 1) とすると、C は真となります。 プリント出力、 つまり変数を画面に表示するには、このようにします。 まずは A = Pi とします。 これをプリント出力したい場合は、 このように A とだけ入力します。すると出力されます。 より複雑な出力方法としては、 disp コマンドがあり、これは display の略です。 display A とすると、A をこのように出力します。 文字列を表示することもできます。 例えば、 disp、sprintf、2 decimals、%0.2、 F、カンマ、A、とこのように入力します。 するとこれは文字列として '2 decimals: 3.14' を出力します。 これはちょっと 一様分布から抽出されます。 みなさんの中で 以前C でプログラミングされた方は、これと 基本的に同じ構文が画面出力で使われます。 ですから、sprintf は 文字列を出力し、 それはこの '2 deciamals: 3.14' という文字列です この %0.2f の意味は これを A と差し替えなさいということ、 また小数点から二桁まで表示、ということです。 そして disp はこの文字列を sprintf コマンドから出力されたものを sprintf sprintf コマンド そして disp が実際にその文字列を表示します。 では、別の 例として sprintf、6 decimals %0.6f、カンマ、A すると、これは、円周率 Pi を 小数点六桁まで出力します。 最後に、前に見たように A はこのように出力されます。 便利なショートカットがあり、format long と入力すると、 文字列がデフォルトで より多くの小数点以下の桁数で表示されます。 そして format short は これをデフォルトに戻すコマンドです。 出力される桁数が減ります。 OK、これが変数の取り扱い方です。 では、ベクトルと行列について見てみましょう。 例えば、A に行列を代入したいとします。 では例をお見せします。1、2、 セミコロン、3、4、セミコロン、5、6 これは 3 x 2 の 行列を作成し、その最初の 行は 1、2、二番目の行 3、4、三番目の行は 5、6 セミコロンが意味するのは 本質的に、行列の 次の行に行きなさいということです。 これを入力する方法は他にもあります。 A 1、2、セミコロン 3、4、セミコロン、5、6、とこのように するのも、別の同等のやり方で A に この 3 x 2 の行列の値を代入します。 同様に、ベクトルも代入できます。 ですから V = 1、2、3 これは実は行ベクトルです。 3 x 1 ベクトルとも言います。 これは 太い Y ベクトル... 失礼、違います、これは 1 x 3 行列でした。 3 x 1 ではありません。 もしこれに 列ベクトルを代入したい場合は、 代わりに行うのは、V = 1、セミコロン、2、セミコロン、3 これで 3 x 1 のベクトルができます 1 x 3 ベクトルの代わりに。 ですからこれは列ベクトルです。 さらにいくつか便利な表記方法をお見せします。 V = 1、コロン、0.1、コロン、2。 これが意味するのは、 V にいくつか の要素を1 から始めて代入し ステップの増分を 0.1単位で増やし、2 に至るまで続ける、ということです。 ですから、これを実行すると、V はこのような行ベクトルになります。 これは、そうですね、1 x 11 行列ですね。 これが 1、1.1、 1.2、1.3 と 続き最後は2 まで行きます。 さらに、 V = 1、コロン、6 と指定すると V にこれらの数字が代入されます。 1 から 6、OKです。 さらに、行列を作成するにはいくつか他の方法もあります。 ones(2,3) はコマンドで それは行列を作成し 2 x 3 行列ですね これは 全て 1 の行列です。 ですから、もし C = 2 掛ける ones(2, 3) とするとこれは 2 x 3 行列で全てが 2 となります。 これは、 これをより簡潔に書く方法として見なすことができます C = 2、2、2 セミコロン、 2、2、2、これも同じ結果を戻します。 仮に W = ones(1, 3) ということはこれは 行ベクトルになります 三つの要素からなる行 で全てが 1、そして 同様に W = zeros(1, 3) そしてこれが作成する行列は 1 x 3 の全てゼロの行列です。 さらに二つほど行列の作成方法を紹介します。 もし W = rand(1, 3) とすると これで返されるのは、1 x 3 の乱数の行列です。 もし rand (3, 3) とすると これは、3 x 3 の行列で、全て 0 から 1 の間の 一様分布からの 乱数となります。 このため、これを実行するたびに 異なる組み合わせの 乱数が 0 から 1 の間の 一様分布から抽出されます。 皆さんの中で ガウス確率変数をご存知の方は、 あるいは正規確率変数を ご存知なら W を = randn(1, 3) と指定することも出来ます。 すると、これらは、 ガウス分布から抽出された 三つの値で、平均値が 0 で 分散あるいは 標準偏差が 1 となる分布から抽出されます。 さらにもっと複雑なことも可能で、 例えば、 W = マイナス 6 足す 10の平方根 掛ける、例えば、 randn (1, 10000) 一番最後にセミコロンをつけます。 というのもこれを出力したくないからです。 これを出力すると、なんというか、 まあ、出てくるのは 10万、失礼、1万要素 のベクトルです。 ですから、えっと、まあいいか、 出力してみましょう。 といいことでこのような行列が作成されます。 この通り 1万の要素があります。 これが W の中身です。 ですから、ここで W のヒストグラムをプロットすると hist コマンドを使います Octave の hist コマンドは、数秒かかりますが、 これが出力されます。 これは、W に含まれる 確率変数のヒストグラムです。 これはマイナス 6 足す 10の平方根 掛ける このガウス確率変数でした。 そして、ヒストグラムをプロットするのに もっとビンの数を増やして、例えば 50 ビンとしてみます するとこれが 平均が -6 のガウス分布のヒストグラムです。 なぜなら、ここに -6があって、 それ足す 10 の平方根掛けるこれです。 ですから、この ガウス確率変数の分散は 10で、その標準偏差は、 10 の平方根、それはなんだっけ、 3.1 です。 最後に、行列を作成する特別なコマンド が一つあります。これは、eye コマンドです。 eye は、おそらくダジャレでしょうが identity matrix (単位行列) という言葉の略で 例えば eye(4) とすると、 これは 4 x 4 の単位行列です。 ということで I = eye(4) とすると 4 x 4 の単位行列が得られます。 さらに I = eye(5)、じゃなくて eye(6) は 6 x 6 の 単位行列、eye(3) は 3 x 3 の単位行列です。 最後に、 このビデオのまとめとして、もう一つ便利なコマンドがあります。 これば help コマンドです。 help eye と入力すると、 単位行列についてのヘルプ機能が表示されます。 Q を押すと終了します。 また、help rand と入力すると rand 、つまり乱数作成関数についての ドキュメンテーションが表示されます。 あるいは help help とすると、 help 機能についてのヘルプが表示されます。 ということで、これらが Octave の基本操作となります。 そしてこれによって、 行列をいくつか作成し、掛け算や足し算を行ったり Octave の基本操作を利用することができます。 次のビデオで お話していきたいのは、 より高度なコマンドと、