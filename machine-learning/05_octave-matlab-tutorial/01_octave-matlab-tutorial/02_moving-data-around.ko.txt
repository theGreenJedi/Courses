이 두 번째 튜토리얼 비디오에 데이터를 Octave에 옮기는 방법에 대해 이야기해 보겠습니다 기계 학습에 쓸 데이터가 있다면 그 데이터를 어떻게 Octave에 불러올 수 있을까요? 어떻게 행렬에 집어넣을까요? 어떻게 이 행렬들을 조작할까요? 어떻게 결과를 저장할까요? 어떻게 데이터를 옮기고 다룰까요? 이전처럼 여기에 제 Octave 창이 있고 지난번 비디오에서 끝난 부분부터 시작하겠습니다 A를 입력하면 이것은 행렬이고, = 1 2; 3 4; 5 6 명령어로 만들 수 있습니다 이것은 3 x 2 행렬입니다 size 명령어는 행렬의 크기를 말해줍니다 그래서 size A는 3 2를 반환합니다 Clustering 과
unsupervised learning은 이 size 명령 자체는 실제로 1 x 2 행렬을 반환합니다 그래서 SZ를 A의 크기로 설정할 수 있고 SZ는 첫 번째 요소가 3이고 두 번째 요소가 2인 1 x 2 행렬입니다 그래서 size SZ를 입력하면 SZ는 두 개의 요소가 행렬 A의 차원을 나타내는 1 x 2 행렬입니다 또한 size A 1 을 입력해 A의 첫 번째 차원을 알 수 있고 첫 번째 차원의 크기 그래서 이것이 행의 갯수이고 size A 2로 2를 반환하는데 이 숫자는 행렬A의 열의 갯수입니다 벡터 V가 있다면 V에 1 2 3 4 를 대입하고 length(V)를 입력합니다 이것은 가장 긴 차원의 길이를 반환합니다 length(A)도 입력할 수 있고 왜냐 하면 A는 3 x 2 행렬이기 때문에 더 긴 차원의 길이가 3 입니다 그래서 3를 출력해야 합니다 그러나 보통 벡터의 길이를 찾기 위해 length를 씁니다 length 1 2 3 4 5 행렬에는 length를 잘 사용하지 않습니다 왜냐하면 헷갈리기 때문입니다 이제, 데이터를 불러오고 파일에서 데이터를 찾는 방법을 알아보겠습니다 Octave를 시작했을 때 우리는 보통, 자주 Octave가 위치한 경로에 있습니다 PWD 명령어는 현재 디렉토리 또는 Octave가 위치한 현재 경로를 보여줍니다 지금은 데이터 위치에서 조금 먼 디렉토리에 있습니다 CD명령어는 디렉토리 변경을 나타냅니다 C:/Users/Ang/Desktop에 이동할 수 있고 이제 제 Desktop에 왔습니다 ls 입력하면 ls는 유닉스 또는 리눅스 명령어에서 유래합니다 ls는 desktop에 있는 디렉토리를 나열합니다 제 Desktop에 있는 파일들이 있네요 제 desktop에 두 개의 파일이 있는데 기계 학습 문제를 풀기위한 featureX 와 priceY 입니다 여기가 제 desktop이고 이게 featuresX featuresX 는 이 창입니다 죄송합니다, featuresX는 데이터 두개 열이 있는 파일입니다 실제로 제 집값 데이터입니다 제 생각엔 데이터 셋은 47 행이고 첫 번째 집은 2104 제곱피트 크기고 3개의 침실이 있습니다 두 번째 집은 1600 제곱피트이고 3개의 침실이 있습니다, 등등 priceY는 이 파일입니다 학습 셋에 있는 가격 데이터입니다 featuresX와 priceY는 데이터를 가진 단순 텍스트 파일입니다 어떻게 이 데이터를 Octave에 불러올까요? 그럼, load featuresX.dat 명령어를 입력하고 이것으로 featuresX를 불러옵니다 load priceY.dat 도 할 수 있습니다 그건 그렇고, 데이터를 불러오는 여러가지 방법이 있습니다 이 명령어는 featuresX.dat을 문자열로 여기에 입력하면 이렇게 불러옵니다 오타가 났네요 이것은 동일한 명령입니다 그래서 이 방법으로 그냥 파일 이름의 문자열을 넣고 초기화 할 때 문자열으로 Octave는 작은 따옴표를 문자열을 나타내기위해 사용합니다 그래서 이것은 문자열이고 주어진 문자열로 시작하는 파일을 불러올 수 있습니다 이제 WHO 명령어는 제 Octave 워크스페이스에 어떤 변수들이 있는지 보여줍니다 그래서 WHO는 Octave의 변수들이 메모리에 존재하는지 보여줍니다 FeaturesX와 priceY가 이 사이에 있네요 또한 앞서 만들었던 변수들도 있네요 featuresx를 입력해서 featuresX를 출력할 수 있습니다 제 데이터입니다 size featuresx를 입력할 수 있습니다 이게 저의 47 x 2 행렬입니다 priceY를 입력해서 이것은 47 x 1 행렬을 반환합니다 47원 벡터입니다 이것은 모두 제 학습 세트에 있는 price Y를 가진 공통 벡터입니다 who 함수는 현재 워크스페이스에 있는 변수를 보여줍니다 whos 함수도 있는데 변수에 대한 상세한 보기를 제공합니다 s를 붙이면 또한 변수들을 나열하는데 이제는 크기도 나옵니다 A 는 3 x 2 행렬이고 featuresX는 47 x2 행렬 priceY는 47 x 1 행렬입니다 이것이 벡터라는 것을 의미합니다 그리고 메모리를 얼마나 차지하는지 보여줍니다 행렬이 어떤 데이터 유형인지도 보여줍니다 double은 double position형 부동소수점을 뜻합니다 즉 실수, 부동소수점 수를 뜻합니다 변수를 없애고 싶다면 clear 명령어를 사용할 수 있습니다 clear featuresX를 하고 whos를 다시 입력하세요 featuresX 변수가 이제 사라진것을 볼 수 있습니다 그러면 어떻게 데이터를 저장할까요? 한번 봅시다. 변수 V를 priceY 1; 10으로 합니다 이것은 V를 벡터 Y의 앞에서 10개의 원소로 설정합니다. who 또는 whos를 입력해봅시다 priceY는 47 x 1 벡터이고 V는 10 x 1입니다 V 를 priceY 1; 10 으로 하면 V를 Y의 앞에서부터 10개의 요소로 설정합니다 이것을 디스크에 저장하고 싶다고 해봅시다 save 명령어와 hello.mat v 는 변수 v를 hello.mat이라고 하는 파일에 저장합니다 한번 해보죠 이제 이 파일이 제 바탕 화면에 나타났습니다 이름은 hello.mat 입니다 저는 MATLAB이 설치되어 있습니다 그래서 이 아이콘이 나타납니다 왜냐하면 윈도우가 MATLAB 파일을 인식하기 때문입니다 하지만 이 파일의 아이콘이 다르게 생겼어도 걱정하지 마세요 변수들을 모두 지운다고 해 봅시다 아무것도 없이 clear를 입력하면 워크스페이스에 있는 모든 변수를 제거합니다 이제 워크스페이스에 아무것도 없습니다 load hello.mat를 하면 제 변수 v를 다시 불러올 수 있습니다 v는 전에 hallo.mat 파일에 저장했던 데이터입니다 방금 전에 hello.mat을 저장하기 위해 hello.mat을 했습니다 이것은 데이터를 이진 형식으로 저장합니다 약간 더 압축 된 이진 형식입니다 그래서 v 가 많은 데이터를 가지고 있으면, 더 많이 압축될것이고 적은 공간을 차지합니다 데이터를 사람이 읽을 수 있는 형식으로 저장하려면 save hello.text v를 입력하고 다음에 -ascii를 입력하세요 이 명령어는 데이터를 텍스트파일 또는 ASCII형식의 텍스트로 저장합니다 이제, 이것을 하고 나면 이 파일이 있습니다 hello.text가 제 바탕화면에 나타났습니다 이것을 열면 데이터가 저장된 텍스트 파일임을 볼 수 있습니다 이것이 데이터를 불러오고 저장하는 방법입니다 이제 데이터를 조작하는 방법에 대해 조금 이야기 해 보겠습니다 A를 또다시 행렬로 설정하고 이것은 3 x 2 행렬입니다 원소를 찾는 것 입니다 A 3,2를 입력하면 A의 3,2 원소를 찾습니다 이것은 알다시피 보통 이렇게 적습니다 A_ {3, 2} 또는 A_ 3,2 이것이 3번째 행 2번째 열에 있는 원소 6입니다 또한 A 2 ,:을 입력해서 두 번째 행을 전부 가져올 수 있습니다 : 는 행 또는 열에 있는 모든 원소를 의미합니다 A의 2,: 은 A의 두 번째 행입니다 비슷하게, : , 2를 하면 이것은 A의 두 번째 열 전체를 의미합니다. 그래서 이것은 2 4 6을 반환합니다 이것은 A의 전체, 두번째 열 을 의미합니다 그래서 이게 A의 2, 4, 6 요소가 있는 두 번째 열입니다 이제 연산에서 가장 복잡한 인덱싱을 사용할 수 있습니다 예제를 하나씩 해 보겠습니다 아마도 자주 쓰지는 않겠지만 A 1 3 , : 을 하면 이것은 첫 번째 인덱스가 1 또는 3인 모든 원소를 가져옴을 뜻합니다 A의 첫 번째와 세 번째 행 모든 원소를 모든 열에서 가져옴을 뜻합니다 이것이 행렬 A고 A [1 3], : 은 첫 번째 행과 두 번째 행 세 번째 행 전부를 가져온다는 뜻이고 : 은 첫 번째와 두 번째 열 전부를 뜻합니다 그래서 이것은 1 2 5 6 를 반환합니다 이러한 고급 첨자 인덱스의 사용 빈도는 다소 낮을지도 모릅니다 이 외에도 할 수 있는 것을 보여드리겠습니다 여기 A 행렬이 있고 A : , 2 로 두 번째 열을 가져옵니다 이것을 대입에 사용할 수 있습니다 A의 두 번째 열을 가져와서 그것에 10 11 12를 할당합니다 이렇게 하면 이제는 A의 두 번째 열을 가져와서 열벡터 10 11 12를 대입했습니다 이제 A 행렬은 1 3 5 두 번째 열은 10 11 12로 바뀌었습니다 그리고 다른 연산이 있습니다 A를 A, [100 101 102]로 해 봅시다 이것은 다른 열 벡터를 오른쪽에 붙입니다 이제는 제가 좀 실수한 것 같네요 세미콜론을 부였어야 했는데 이제 A는 이것과 같습니다 알겠죠? 잘 이해하셨기를 바랍니다 100 101 102 이것은 열 벡터이고 우리가 한 것은 A를 가져와서 원래 정의대로 설정하고 뒤에 열 벡터를 넣었습니다 그래서 행렬 A를 가져왔고 왼쪽에 있는 여섯개의 원소입니다 행렬 A를 가져와서 다른 열벡터를 오른쪽에 붙입니다 이게 A가 보시는 대로 3 x 3 행렬인 이유입니다 마지막으로 이 요령을 가끔 사용합니다 A(:)를 이렇게 하면 특별한 경우의 문법입니다 A에 있는 모든 원소를 하나의 열 벡터에 넣으라는 뜻입니다 9 x 1 벡터를 반환합니다 단순히 다른 원소들을 하나로 합칩니다 몇 가지 예제를 더하자면 A를 1 2 3 4 5 6 로 설정해 봅시다 그리고 B를 11 12 13 14 15 16로 설정합니다 A B로 새로운 행렬을 만들 수 있습니다 이것이 뜻하는 것은 행렬 A 행렬 B가 있고 C를 A, B로 설정합니다 제가 하는 것은 이 두개의 행렬을 가져와서 서로를 연결합니다 왼쪽에는, 행렬 A가 왼쪽이고 행렬 B가 오른쪽에 있습니다 이렇게 두개를 합쳐 행렬 C를 만들었습니다 또한 마찬가지로 C를 A; B로 하고 이 세미콜론 표기는 다음 행렬을 아래에 넣겠다는 의미입니다 그래서 A; B를 합니다 행렬 A 와 B를 합치는데 상하로 연결됩니다 따라서 A가 위, B가 아래이고 C는 이제 6 x 2 행렬입니다 세미콜론은 보통 다음 행으로 가는것을 의미합니다 그래서 C는 A와 그 아래로 가서 아래에 배치된 B로 구성됩니다 [A B]는 [A, B]와 동일합니다 둘 다 같은 결과를 줍니다 이것으로 바라건데 어떻게 행렬을 구성하는지 알고 빠르게 행렬을 만들고 그 행렬을 이용해 합쳐서 더 큰 행렬을 만드는데 사용하는 명령어들을 소개했습니다 단 몇 줄의 코드로요 Octave는 빠르게 복잡한 행렬을 만들고 데이터를 조작한다는 점에서 편리합니다 그래서, 이것이 데이터를 조작하는 방법입니다 다음 비디오에서는 여기서 실제로 우리의 데이터를 가지고 어떻게 복잡한 연산을 하는지에 대해 이야기해 보겠습니다 단 몇 개의 명령어로 어떻게 Octave 에서 빠르게 데이터를 조작하는지 감각을 알게 되었기를 바랍니다 벡터와 행렬을 불러오고 저장하고 데이터도 불러오고 저장합니다 더 큰 행렬을 생성하기 위해 행렬을 만듭니다 행렬에서 특정 원소를 색인하거나 선택합니다 매우 많은 명령어를 다뤘다는 것을 알고 있습니다 제일 좋은 것은 이후에 제가 입력한 스크립트를 보는 것 입니다 여기를 보십시오 이 수업의 사이트를 보고 세션의 스크립트를 다운로드 하세요 스크립트를 살펴보고 Octave에 스스로 명령어들을 입력해 보세요 이 명령어를 가지고 놀고 작동시켜 보세요 분명히, 이 모든 명령어를 외우려는 시도는 의미가 없습니다 당신이 해야 하는 것은 그냥 이 비디오에서 여러분이 할 수 있는 것에 대한 감을 잡았길 바랍니다 그래서 이후에 직접 학습 알고리즘을 짜려고 할 때 Octave에서 가능하다고 생각한 특정 명령어를 찾으려고 노력한다면 왜냐하면 아마도 여기에서 그 명령어를 봤다고 생각하기 때문에 이 세션의 스크립트를 참조해서 사용하길 원하는 명령어를 찾기 위해 훑어보세요 이것이 행렬과 벡터의 곱셈입니다. 데이터를 조작하는 것과 다음 비디오에서는 데이터를 가지고 실제로 어떻게 복잡한 연산을 하는지 그리고 어떻게 데이터를 연산하고 실제로 학습 알고리즘을 실행하는지에 대해 말해보겠습니다