1
00:00:00,280 --> 00:00:02,820
अब जब आप जानते है कैसे लोड और सेव करते हैं डेटा को ओकटेव में,

2
00:00:02,820 --> 00:00:05,100
रख सकते हैं आपका डेटा मेट्रिसीज़ में और इसी प्रकार आगे.

3
00:00:05,100 --> 00:00:10,028
इस वीडियो में में आपको दिखाना चाहूँगा कैसे करते हैं कॉम्प्यूटेशनल ऑपरेशन्स डेटा पर.

4
00:00:10,028 --> 00:00:14,880
और बाद में हम इस्तेमाल करेंगे ये सोर्स कॉम्प्यूटेशनल ऑपरेशन्स का इम्प्लमेंट करने के लिए

5
00:00:14,880 --> 00:00:15,870
हमारे लर्निंग अल्गोरिद्म्स.

6
00:00:17,130 --> 00:00:17,810
तो चलिए, शुरू करते हैं.

7
00:00:19,650 --> 00:00:21,040
यह है मेरी ओकटेव विंडो.

8
00:00:21,040 --> 00:00:25,900
मैं जल्दी से ईनिशीयलाइज करता हूँ कुछ वेरीयबल्स इस्तेमाल करने के लिए हमारे उदाहरण में.

9
00:00:25,900 --> 00:00:33,470
तो सेट करें A को एक तीन बाई दो मेट्रिक्स, और सेट करें B को एक तीन बाई दो मेट्रिक्स,

10
00:00:33,470 --> 00:00:37,855
और सेट करते हैं C को एक दो बाई दो मेट्रिक्स इस तरह.

11
00:00:39,195 --> 00:00:42,235
अब मान लो मैं करना चाहता हूँ गुणा दो मेरी मेट्रिसीज़ को.

12
00:00:42,235 --> 00:00:47,195
तो मान लो मैं कम्प्यूट करना चाहता हूँ A*C, मैं सिर्फ़ टाइप करता हूँ A*C तो यह है एक तीन बाई दो मेट्रिक्स

13
00:00:47,195 --> 00:00:52,215
गुणा एक दो बाई दो मेट्रिक्स, यह देता है मुझे यह तीन बाई दो मेट्रिक्स.

14
00:00:52,215 --> 00:00:57,145
आप कर सकते हैं एलिमेंट-वाइज़ ऑपरेशन्स भी और करें A.*B और यह क्या करेगा कि

15
00:00:57,145 --> 00:01:02,580
यह लेगा प्रत्येक एलिमेंट A का और गुणा करेगा इसे उन्हीं एलिमेंट्स से B के,

16
00:01:02,580 --> 00:01:06,208
तो वह है A, वह है B, वह है A.*B.

17
00:01:06,208 --> 00:01:11,230
तो उदाहरण के लिए, पहला एलिमेंट देता है 1 गुणा 11 जो देता है 11.

18
00:01:11,230 --> 00:01:17,140
दूसरा एलिमेंट देता हैं 2 गुणा 12 जो देता हैं 24, और इसी प्रकार आगे.

19
00:01:17,140 --> 00:01:20,840
तो यह है एलिमेंट-वाइज़ गुणन दो मेट्रिसीज़ का.

20
00:01:20,840 --> 00:01:23,200
और सामान्य तौर पर, बिंदु प्रतीत होता है,

21
00:01:23,200 --> 00:01:27,440
अक्सर इस्तेमाल किया जाता है डिनोट करने के लिए एलिमेंट-वाइज़ ऑपरेशन्स ओकटेव में.

22
00:01:27,440 --> 00:01:31,494
तो यहाँ है एक मेट्रिक्स A, और यदि मैं करता हूँ A.^2,

23
00:01:31,494 --> 00:01:36,500
यह देता है मुझे एलिमेंट-वाइज़ वर्ग A का.

24
00:01:36,500 --> 00:01:39,440
तो 1 का वर्ग है 1, 2 का वर्ग है 4, और इसी प्रकार आगे.

25
00:01:41,100 --> 00:01:42,560
चलो सेट करते हैं v को एक वेक्टर की तरह.

26
00:01:42,560 --> 00:01:46,230
चलो सेट करते हैं v को एक, दो, तीन एक कॉलम वेक्टर जैसे.

27
00:01:46,230 --> 00:01:52,010
आप कर सकते हैं एक डॉट ओवर v करने के लिए एलिमेंट-वाइज़ रेसिप्रोकल v का,

28
00:01:52,010 --> 00:01:56,040
तो यह देता है मुझे एक बटा एक, एक बटा दो और एक बटा तीन, और यह है जहाँ

29
00:01:56,040 --> 00:02:00,610
मैं मेट्रिसीज़ करता हूँ, तो एक डॉट ओवर A देता है मुझे एलिमेंट-वाइज़ इन्वर्स A का.

30
00:02:02,760 --> 00:02:08,173
और एक बार फिर, बिंदु यहाँ देता है हमें संकेत कि यह है एक एलिमेंट-वाइज़ ऑपरेशन.

31
00:02:08,173 --> 00:02:15,080
हम कर सकते हैं चीज़ें जैसे log(v), यह है एलिमेंट-वाइज़ लॉगरिधम v का.

32
00:02:15,080 --> 00:02:20,300
e की पॉवर v है बेस एक्सपोनेंशिएशन इन एलिमेंट्स का,

33
00:02:20,300 --> 00:02:25,600
तो यह है e, यह है e स्क्वेर्ड eq, क्योंकि वह था v, और

34
00:02:25,600 --> 00:02:31,040
मैं कर सकता हूँ abs v लेने के लिए एलिमेंट-वाइज़ ऐब्सलूट वैल्यू v की.

35
00:02:31,040 --> 00:02:36,660
तो यहाँ v था पॉज़िटिव, abs माइनस एक, दो, माइनस 3,

36
00:02:36,660 --> 00:02:42,973
एलिमेंट-वाइज़ ऐब्सलूट वेलयु देता है मुझे वापिस ये नॉन-नेगेटिव वैल्यूज़.

37
00:02:42,973 --> 00:02:45,930
और नेगेटिव v देता है मुझे माइनस v का.

38
00:02:45,930 --> 00:02:48,720
यह है समान नेगेटिव एक गुणा v, लेकिन

39
00:02:48,720 --> 00:02:54,024
आम तौर पर आप सिर्फ लिखते हैं सिर्फ़ नेगेटिव v बजाय -1*v के.

40
00:02:54,024 --> 00:02:56,050
आप और क्या कर सकते हैं?

41
00:02:56,050 --> 00:02:57,240
यहाँ है एक और तरकीब.

42
00:02:57,240 --> 00:02:58,360
तो चलो देखते हैं.

43
00:02:58,360 --> 00:03:01,700
मान लो मैं चाहता हूँ वृद्धि करना v के प्रत्येक एलिमेंट की एक से.

44
00:03:01,700 --> 00:03:06,590
वैसे एक तरीक़ा इसे करने का है

45
00:03:06,590 --> 00:03:11,430
बना कर एक तीन बाई एक का वेक्टर जो है सारे एक और जोड़ दें उसे v में.

46
00:03:11,430 --> 00:03:14,590
तो यदि मैं वह करता हूँ, यह बढ़ाता है v को 1, 2, 3 से 2, 3, 4 तक.

47
00:03:14,590 --> 00:03:21,520
जिस तरह मैंने वह किया था, length(v) है 3,

48
00:03:21,520 --> 00:03:27,260
तो ones(length(v),1), यह है एक की 3 बाई 1, तो

49
00:03:27,260 --> 00:03:33,620
वह है ones(3,1) दाईं तरफ़ और मैंने क्या किया कि v प्लस ones v by one,

50
00:03:33,620 --> 00:03:38,950
वह है जोड़ना हमारे एक के वेक्टर को v में, तो यह वृद्धि करता है v की एक से,

51
00:03:40,000 --> 00:03:44,190
और एक अन्य आसान ढंग उसे करने का है कि टाइप करें v प्लस एक.

52
00:03:44,190 --> 00:03:45,450
तो वह था v, और

53
00:03:45,450 --> 00:03:50,840
v जमा एक का भी मतलब है जोड़े एक एलिमेंट-वाइज़ प्रत्येक एलिमेंट में v के.

54
00:03:52,470 --> 00:03:55,490
अब चलो बात करते हैं और ऑपरेशन्स की.

55
00:03:55,490 --> 00:03:59,520
तो यहाँ है मेरी मेट्रिक्स A, यदि आप चाहते हैं करना A ट्रान्स्पोज़, ढंग करने के उसे है

56
00:03:59,520 --> 00:04:03,720
कि लिखें A प्राइम, वह है अपॉस्ट्रॉफ़ी चिन्ह, यह है लेफ़्ट क्वोट,

57
00:04:03,720 --> 00:04:08,350
तो यह आपके कीबोर्ड पर है, आपके पास है एक लेफ़्ट क्वोट और एक राइट क्वोट.

58
00:04:08,350 --> 00:04:11,260
तो यह वास्तव में स्टैंडर्ड क्वोटेशन चिन्ह.

59
00:04:11,260 --> 00:04:18,330
सिर्फ़ टाइप करें A ट्रान्स्पोज़, यह देता है मुझे ट्रान्स्पोज़ मेरी मेट्रिक्स A का.

60
00:04:18,330 --> 00:04:19,700
और, निश्चय ही, A ट्रान्स्पोज़,

61
00:04:19,700 --> 00:04:22,970
यदि मैं ट्रान्स्पोज़ करता हूँ उसे वापिस, तब मुझे मिलनी चाहिए वापिस मेरी

62
00:04:25,160 --> 00:04:27,570
कुछ और अधिक उपयोगी फ़ंक्शन्स.

63
00:04:27,570 --> 00:04:34,300
मान लो लोअर केस a है 1 15 2 0.5, तो यह है एक 1 बाई 4 मेट्रिक्स.

64
00:04:34,300 --> 00:04:38,880
मान लो val बराबर है max(a), देता है अधिकतम वैल्यू

65
00:04:38,880 --> 00:04:42,970
a की जो इस केस में है 15 और मैं कर सकता हूँ val

66
00:04:42,970 --> 00:04:48,430
ind max(a) और यह देता है val और ind

67
00:04:48,430 --> 00:04:52,940
जो होंगे अधिकतम वैल्यू a की जो है 15, तथा इंडेक्स भी.

68
00:04:52,940 --> 00:04:58,790
तो वह था एलिमेंट संख्या दो जो था 15 तो ind है मेरा इंडेक्स इसमें.

69
00:04:58,790 --> 00:05:03,230
बस एक चेतावनी के रूप में, यदि आप करते हैं max(a), जहां a एक मैट्रिक्स है,

70
00:05:03,230 --> 00:05:07,920
यह क्या करता है यह वास्तव में करता है कॉलम-वाइज़ अधिकतम वैल्यू.

71
00:05:07,920 --> 00:05:09,860
लेकिन बताता हूँ थोड़ा और इस बारे में कुछ ही देर में.

72
00:05:11,610 --> 00:05:14,760
अभी भी इस्तेमाल कर रहा हूँ यह उदाहरण लोअर केस a वाला.

73
00:05:14,760 --> 00:05:19,630
यदि मैं करता हूँ a < 3, यह करता है एलिमेंट-वाइज़ ऑपरेशन.

74
00:05:19,630 --> 00:05:24,030
एलिमेंट-वाइज़ तुलना, तो पहला एलिमेंट A का है कम तीन से तो

75
00:05:24,030 --> 00:05:24,970
यह एक.

76
00:05:24,970 --> 00:05:29,970
दूसरा एलिमेंट A का नहीं है कम तीन से तो यह वैल्यू है ज़ीरो क्योकि यह फाल्स है.

77
00:05:29,970 --> 00:05:36,590
तीसरा और चौथा एलिमेंट A का है कम तीन से, तो वह है सिर्फ़ 1 1.

78
00:05:36,590 --> 00:05:42,970
तो वह है एलिमेंट-वाइज़ तुलना हमारे चार एलिमेंट्स की वेरीयबल a < 3 की.

79
00:05:42,970 --> 00:05:47,440
यह देता है ट्रू या फाल्स निर्भर करते हुए हैं या नहीं वहाँ कम तीन से.

80
00:05:47,440 --> 00:05:53,615
अब, यदि मैं करता हूँ find(a < 3) यह बताएगा मुझे कौन से हैं एलिमेंट्स a के,

81
00:05:53,615 --> 00:05:55,235
वेरीयबल a के, जो हैं कम 3 से,

82
00:05:55,235 --> 00:05:59,545
और इस केस में, पहला, तीसरा और चौथा एलिमेंट है कम 3 से.

83
00:05:59,545 --> 00:06:05,205
हमारे अगले उदाहरण के लिए, मैं सेट करता हूँ a को बराबर magic(3).

84
00:06:05,205 --> 00:06:08,985
magic फ़ंक्शन देता है, चलो टाइप करते हैं help magic.

85
00:06:08,985 --> 00:06:15,370
magic फ़ंक्शन देता है ये मेट्रिसीज़ जिन्हें कहते हैं मैजिक स्क्वेर्ज़.

86
00:06:15,370 --> 00:06:20,830
उनमें है यह, आप जानते हैं, गणितीय गुण कि सारी उनकी रोज़ और

87
00:06:20,830 --> 00:06:23,690
कॉलम और विकर्ण जोड़ आकर समान नम्बर बनाते हैं.

88
00:06:23,690 --> 00:06:28,830
तो, आप जानते हैं, यह वास्तव में नहीं है उपयोगी मशीन लर्निंग के लिए जहाँ तक मैं जानता हूँ, लेकिन

89
00:06:28,830 --> 00:06:34,450
मैं सिर्फ़ इस्तेमाल कर रहा हूँ इसे एक सुविधाजनक ढंग के रूप में जेनरेट करने के लिए एक तीन बाई तीन का मेट्रिक्स.

90
00:06:34,450 --> 00:06:38,788
और ये मैजिक स्क्वेर्ज़ का गुण है प्रत्येक रो, प्रत्येक कॉलम,

91
00:06:38,788 --> 00:06:41,751
और विकर्ण सारे जोड़ने पर एक समान नम्बर बनाते हैं, इसलिए

92
00:06:41,751 --> 00:06:44,300
यह है एक प्रकार से गणितीय कन्स्ट्रक्ट.

93
00:06:44,300 --> 00:06:48,820
मैं इस्तेमाल करता हूँ मैजिक फ़ंक्शन जब मैं कर रहा हूँ डेमो या जब मैं पढ़ा रहा हूँ ओकटेव

94
00:06:48,820 --> 00:06:53,760
जैसे वे, मैं वास्तव नहीं करता हूँ इसका इस्तेमाल किसी उपयोगी मशीन लर्निंग ऐप्लिकेशन के लिए.

95
00:06:53,760 --> 00:06:58,886
लेकिन चलो देखते हैं, अगर मैं टाइप करता हूँ RC=find(A>7) यह ढूँढता है

96
00:06:58,886 --> 00:07:04,231
A के सारे एलिमेंट्स जो बड़े हैं या बराबर है सात के,

97
00:07:04,231 --> 00:07:07,740
और इसलिए r, c का मतलब है रो तथा कॉलम.

98
00:07:07,740 --> 00:07:11,750
तो एलिमेंट 1,1 है बड़ा 7 से, 3,2 एलिमेंट है बड़ा 7 से, और

99
00:07:11,750 --> 00:07:13,270
2, 3 एलिमेंट है बड़ा 7 से.

100
00:07:13,270 --> 00:07:14,360
तो चलो देखते हैं.

101
00:07:14,360 --> 00:07:17,740
2, 3 एलिमेंट, उदाहरण के लिए, है A(2,3),

102
00:07:17,740 --> 00:07:24,270
है 7 है यह एलिमेंट यहाँ पर, और वाक़ई में बड़ा है बराबर सात.

103
00:07:24,270 --> 00:07:28,820
वैसे तो, मैं वास्तव में याद भी नहीं करता ख़ुद के ये find फ़ंक्शन्स करते हैं और

104
00:07:28,820 --> 00:07:30,220
क्या ये सब चीज़ें करती हैं ख़ुद भी.

105
00:07:30,220 --> 00:07:34,180
और जब भी मैं इस्तेमाल करता हूँ find फ़ंक्शन, कभो-कभी मैं ख़ुद भूल जाता हूँ कि क्या

106
00:07:34,180 --> 00:07:38,020
करता है, और अब मैं टाइप करूँगा help find देखने के लिए डॉक्युमेंट.

107
00:07:38,020 --> 00:07:40,130
ठीक है, सिर्फ दो चीजें और हैं जो मैं जल्दी से आपको दिखाता हूँ.

108
00:07:40,130 --> 00:07:44,270
एक है sum फ़ंक्शन, तो यहाँ है मेरा a, और फिर मैं टाइप करता हूँ sum(a).

109
00:07:44,270 --> 00:07:48,140
यह जोड़ता है सारे एलिमेंट्स को a के, और यदि मैं चाहता हूँ गुणा करना उन्हें एक साथ,

110
00:07:48,140 --> 00:07:50,940
मैं टाइप करता हूँ prod(a) prod डेटा है गुणन, और

111
00:07:50,940 --> 00:07:54,225
यह देता है गुणन इस चार एलिमेंट्स का A के.

112
00:07:54,225 --> 00:08:01,630
floor(a) राउंड डाउन करता हैं A के इन एलिमेंट्स को, तो 0.5 हो जाता है 0.

113
00:08:01,630 --> 00:08:06,600
और ceil, या ceiling(A) करता है राउंड अप नज़दीकी पूर्णाँक पर,

114
00:08:06,600 --> 00:08:10,900
तो 0.5 हो जाता है 1.

115
00:08:10,900 --> 00:08:13,330
आप कर सकते हैं, चलो देखते हैं.

116
00:08:13,330 --> 00:08:16,720
मैं टाइप करता हूँ rand(3), यह बनाएगा एक तीन बाई तीन मेट्रिक्स.

117
00:08:16,720 --> 00:08:21,790
यदि मैं टाइप करता हूँ max(rand(3)), यह क्या करता है यह लेता है

118
00:08:21,790 --> 00:08:27,000
एलिमेंट-वाइज़ अधिकतम 3 रैंडम 3 बाई 3 मेट्रिसीज़ का.

119
00:08:27,000 --> 00:08:30,680
तो आप ध्यान दें ये सारे प्रतीत होते हैं थोड़े बड़े क्योंकि

120
00:08:30,680 --> 00:08:33,150
प्रत्येक इन में से है वास्तव में अधिकतम एक एलिमेंट

121
00:08:34,490 --> 00:08:37,515
वाइज़ अधिकतम दो रैंडम ढंग से बनाई गई मेट्रिसीज़ का.

122
00:08:37,515 --> 00:08:38,280
यह है मेरा मैजिक नम्बर.

123
00:08:38,280 --> 00:08:43,050
यह है मेरा मैजिक स्क्वेर तीन बाई तीन A.

124
00:08:43,050 --> 00:08:48,270
मान लो मैं टाइप करता हूँ max A, और तब यह होगा एक [],

125
00:08:48,270 --> 00:08:53,580
1, यह क्या करता है यह टेस्ट करता है कॉलम-वाइज़ अधिकतम वैल्यू.

126
00:08:53,580 --> 00:08:58,260
तो अधिकतम वैल्यू पहले कॉलम की है 8, अधिकतम दूसरे कॉलम की है 9,

127
00:08:58,260 --> 00:08:59,960
और अधिकतम तीसरे कॉलम का है 7.

128
00:08:59,960 --> 00:09:04,194
इस 1 का मतलब है लें अधिकतम पहली डिमेन्शन से A की.

129
00:09:05,200 --> 00:09:08,780
इसके विपरीत, यदि मुझे टाइप करना होता max A, यह हास्यास्पद नोटेशन,

130
00:09:08,780 --> 00:09:12,480
दो, तब यह लेता है हर रो का अधिकतम.

131
00:09:12,480 --> 00:09:17,210
तो अधिकतम वैल्यू पहली रो की है आठ, अधिकतम दूसरी रो की है सात, अधिकतम तीसरी

132
00:09:17,210 --> 00:09:23,570
रो की है नौ, और इसलिए यह आपको लेने देता हैं अधिकतम प्रत्येक रो का या प्रत्येक कॉलम का.

133
00:09:24,760 --> 00:09:30,050
और याद रखे, डिफ़ॉल्ट है कॉलम-वाइज़ एलिमेंट.

134
00:09:30,050 --> 00:09:34,880
तो यदि आप ढूँढना चाहते हैं अधिकतम एलिमेंट पूरी मेट्रिक्स A का,

135
00:09:34,880 --> 00:09:39,660
आप टाइप कर सकते हैं max(max(A)) इस तरह, जो है 9.

136
00:09:39,660 --> 00:09:45,130
और बदल सकते हैं A एक वेक्टर में और टाइप कर सकते हैं max(A(:)) इस तरह और

137
00:09:45,130 --> 00:09:50,160
यह सोचता है इसे एक वेक्टर और लेता है अधिकतम एलिमेंट उस वेक्टर का.

138
00:09:52,130 --> 00:09:56,220
अंत में, चलो सेट करते हैं A को 9 बाई 9 का मैजिक स्क्वेर.

139
00:09:56,220 --> 00:10:00,700
तो ध्यान रखें मैजिक स्क्वेर का यह गुण हैं कि प्रत्येक कॉलम और

140
00:10:00,700 --> 00:10:03,650
रो का योग है समान, और विकर्णो का भी, इसलिए

141
00:10:03,650 --> 00:10:06,280
सिर्फ़ एक नौ बाई नौ मेट्रिक्स स्क्वेर.

142
00:10:06,280 --> 00:10:07,470
तो मैं सिर्फ़ करता हूँ sum(A,1).

143
00:10:07,470 --> 00:10:12,050
तो यह करता है प्रत्येक कॉलम का योग, तो हम लेते हैं प्रत्येक कॉलम A का और

144
00:10:12,050 --> 00:10:15,550
जोड़ देते हैं उन्हें और यह सत्यापित हो गया कि वास्तव में

145
00:10:15,550 --> 00:10:20,150
एक नौ बाई नौ मेट्रिक्स स्क्वेर के लिए, प्रत्येक कॉलम का योग होता है 369, योग होता है समान.

146
00:10:20,150 --> 00:10:21,978
अब चलो करते हैं रो वाइज़ जोड़.

147
00:10:21,978 --> 00:10:26,870
तो sum(A,2), और

148
00:10:26,870 --> 00:10:32,950
यह जमा करता है प्रत्येक रो को A की, और वाक़ई A की प्रत्येक रो का योग भी होता है 369.

149
00:10:32,950 --> 00:10:36,110
अब, चलो जोड़ करते हैं A के विकर्ण के एलिमेंट्स का और

150
00:10:36,110 --> 00:10:39,800
सुनिश्चित करते हैं कि वह जोड़ भी समान होता है.

151
00:10:39,800 --> 00:10:45,558
तो मैं क्या करूँगा कि बनाऊँगा एक नौ बाई नौ आयडेंटिटी मेट्रिक्स, वह है eye नौ.

152
00:10:45,558 --> 00:10:52,330
और मैं लेता हूँ A और बनाता हूँ, गुणा करता हूँ A को एलिमेंट-वाइज़, तो यहाँ है मेरी मेट्रिक्स A.

153
00:10:52,330 --> 00:10:56,290
मैं करूँगा A.*eye(9).

154
00:10:56,290 --> 00:11:00,970
यह क्या करेगा कि लेगा एलिमेंट-वाइज़ गुणन इन मेट्रिसीज़ का, और इसलिए

155
00:11:00,970 --> 00:11:05,820
इसे हटा देने चाहिए सबकुछ A का, सिवाय विकर्ण एलिमेंट्स के.

156
00:11:05,820 --> 00:11:11,130
और अब मैं करूँगा sum(sum(A)) उसका और

157
00:11:11,130 --> 00:11:17,830
यह देता है मुझे जोड़ इन विकर्ण के एलिमेंट्स का, और वास्तव में वह है 369.

158
00:11:17,830 --> 00:11:20,260
आप जोड़ सकते हैं बाक़ी के विकर्ण भी.

159
00:11:20,260 --> 00:11:22,340
तो यह उपर बाईं तरफ़ से नीचे बाईं तरफ़,

160
00:11:22,340 --> 00:11:27,410
आप जोड़ सकते हैं विपरीत विकर्ण नीचे बाईं तरफ़ से ऊपर दाईं तरफ़.

161
00:11:27,410 --> 00:11:29,791
कमांड उसके लिए कुछ और क्रिप्टिक / घुमावदार है,

162
00:11:29,791 --> 00:11:31,600
आपको वास्तव में उसे जानने की जरूरत नहीं है.

163
00:11:31,600 --> 00:11:34,790
मैं सिर्फ़ आपको दिखा रहा हूँ यह यदि आप में से कोई उत्सुक हैं.

164
00:11:34,790 --> 00:11:38,390
लेकिन चलो देखते हैं.

165
00:11:38,390 --> 00:11:40,685
flipud का मतलब है फ़्लिप अप डाउन.

166
00:11:40,685 --> 00:11:45,760
लेकिन याद आप वह करते हैं, यह जोड़ देता है एलिमेंट्स विपरीत दिशा के.

167
00:11:45,760 --> 00:11:50,090
तो दूसरा विकर्ण, उसका भी जोड़ होता है 369.

168
00:11:50,090 --> 00:11:52,020
यहाँ, मैं दिखाता हूँ आपको.

169
00:11:52,020 --> 00:11:54,262
जबकि eye(9) है यह मेट्रिक्स.

170
00:11:54,262 --> 00:11:59,470
flipup(eye(9)), लेता है आयडेंटिटी मेट्रिक्स,

171
00:11:59,470 --> 00:12:02,890
और फ़्लिप करता है इसे ऊपर की दिशा में, तो आपको मिलता है, माफ़ कीजिए,

172
00:12:02,890 --> 00:12:06,480
flip UD, करता है एक को इस विपरीत दिशा के विकर्ण पर भी.

173
00:12:08,780 --> 00:12:12,750
सिर्फ़ एक अंतिम कमांड, और फिर बस, और तब इतना ही इस वीडियो में.

174
00:12:12,750 --> 00:12:16,820
चलो सेट करते हैं A को तीन बाई तीन मैजिक स्क्वेर मेट्रिक्स.

175
00:12:16,820 --> 00:12:20,340
यदि आप इन्वर्ट करना चाहते हैं एक मेट्रिक्स को, आप टाइप करते हैं pinv(A).

176
00:12:20,340 --> 00:12:23,120
इसे आमतौर पास कहते हैं स्यूडो-इन्वर्स, लेकिन इससे अंतर नहीं पड़ता.

177
00:12:23,120 --> 00:12:27,830
सिर्फ़ सोचें इसे मूलरूप में A के इन्वर्स की तरह, और वह है इन्वर्स A का.

178
00:12:27,830 --> 00:12:34,130
और इसलिए मैं सेट कर सकता हूँ temp=pinv(A) और temp गुणा A,

179
00:12:34,130 --> 00:12:38,110
यह है वास्तव में आयडेंटिटी मेट्रिक्स, जहाँ अनिवार्यत: एक हैं विकर्णो पर

180
00:12:38,110 --> 00:12:41,650
और ज़ीरो है विकर्ण के अलावा स्थानों पर, एक नूमेरिकल राउंड ऑफ़ तक.

181
00:12:44,210 --> 00:12:45,596
तो, इतना ही 

182
00:12:45,596 --> 00:12:50,630
कैसे करने हैं विभिन्न कॉम्प्यूटेशनल ऑपरेशन्स डेटा तथा मेट्रिसीज़ पर.

183
00:12:50,630 --> 00:12:55,548
और रन करने के बाद एक लर्निंग अल्गोरिद्म को, अक्सर एक बहुत उपयोगी काम है

184
00:12:55,548 --> 00:12:59,760
कि देख पाना अपने परिणामों पर, कि प्लॉट कर पाएँ या विज़ूअलाइज कर पाएँ अपने परिणाम.

185
00:12:59,760 --> 00:13:04,342
और अगले वीडियो में, मैं बहुत फुर्ती से दिखाऊँगा आपको कि कैसे फिर से एक

186
00:13:04,342 --> 00:13:06,260
या दो लाइन्स से कोड की ओकटेव का इस्तेमाल करते हुए.

187
00:13:06,260 --> 00:13:09,255
आप जल्दी से विज़ूअलाइज कर सकते हैं आपका डेटा या प्लॉट कर सकते हैं आपका डेटा और

188
00:13:09,255 --> 00:13:13,340
उपयोग कर सकते हैं उसका बेहतर समझने के लिए कि आपके लर्निंग अल्गोरिद्म्स क्या कर रहे हैं.