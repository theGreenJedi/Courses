この二番目のOctaveチュートリアルビデオでは、 Octave でのデータの 取り扱いについて説明していきます。 機械学習問題用のデータがある場合、 それをどのように Octave に読み込むか。 どうすれば行列に取り込めるか。 こうした行列をどのように取り扱うか。 結果をどのように保存するか。 どのようにデータを出し入れし演算を行うか。 ここに、Octave ウィンドウが 前回のビデオで使ったままであります。ここから続けます。 A と入力すると、それは 前に作成した行列ですよね。 このコマンドで、= 1、2、 3、4、 5、 6、すると これは 3 x 2 の行列です。 Octave の size コマンドを使うと その行列のサイズが表示されます。 よってsize(A) は 3、2 を 返します。 実は、 この size コマンドそのものが 1 x 2 の行列を返すのです。 このため、SZ = size(A) を実行すると、SZ は 1 x 2 の行列となり、 最初の要素が 3、二番目の要素が 2 となります。 そこで size(SZ) と入力すると、 SZ は 1 x 2 の行列で、その二つの要素には 行列 A の次元情報が含まれています。 また size(A, 1)と入力すると 返されるのは 最初の A の次元のサイズ、 Aの最初の次元のサイズです。 これは行の数です。 size(A, 2) の場合は 2 が返されます。これは 行列 A の列の数です。 もし ベクトル V の場合は、 例えば V = 1、 2、 3、4、そして length(V) と入力します。 この場合は、 一番長い次元のサイズを返します。 よって、 length(A) と入力すると、 A は 3 x 2 の行列なので、 長い方の次元のサイズは 3、よって 3 が出力されるはずです。 でも、通常は length はベクトルだけに使用します。 なので、length 1、2、 3、4、と使いますが、 length を行列には使いません。 混乱を来たす余地があるからです。 では、ここで、どのように データを読み込み、データをファイル システム上で見つけるかを説明します。 Octave を起動すると 通常、多くの場合、 パスは Octave のある場所となります。 そこで pwd コマンドを使うと カレントディレクトリ、つまり Octave の現在のパスが表示されます。よって 今いるのは知らないディレクトリかもしれません。 cd コマンドは change directory の略で、ここで C:/Users/Ang/Desktop と入力すると 今いる場所がデスクトップになります。 ls と入力すると、ちなみに ls は、Unix あるいは Linux コマンドに由来します が、ls はリストとして デスクトップ上のディレクトリを戻し 表示するので、これらが 今、私のデスクトップにあるファイルです。 実際、私のデスクトップには 二つのファイルがあります。Features X と Price Y です。これは 私が解きたい機械学習問題のデータです。 これが私のデスクトップです。 ここに Features X があり、 Features X はこのウィンドウで、 失礼、このファイルで、二列のデータがあります。 これが実際の住宅の価格のデータです。 たしか、知っている限り このデータセットは47行あると思います。 この最初の住宅の面積は 2104平方フィート、 寝室が三つあります。二番目の 住宅は 1600平方フィート、 寝室は三つ、というように続きます。 そして Price Y はこの ファイルで、 訓練セットの価格のデータです。 つまり、Features X と Price Y はデータを含む単なるテキストファイルです。 このデータを Octave にどのように読み込むか。 単に、コマンドで load Features X.dat と入力して 実行すると Features X が読み込まれ 同様に Price Y.dat も読み込めます。 ちなみに、これには複数のやり方があり、 このコマンドで、 Features X.dat を文字列として入力 しても同様に読み込めます。 打ち間違いがありました。 これが同等のコマンドです。 このように、 ファイル名の文字列として ファイル名を 文字列として使います。 Octave ではシングル引用符を使って 文字列を表します。こんな風に。 ですからこれは文字列です。 そしてファイルを読み込むには その名前を文字列として与えます。 さて who コマンド は現在 どのような変数が Octave ワークスペースにあるか表示します。 つまり、Who は 変数が 現在 Octave のメモリに存在するかを示します。 Features X と Price Y も そこに含まれていて、さらに、 変数には、 このセッションで前に作成したものもあります。 なので、 Features X と入力すると Features X が表示されます。 そしてこれがそのデータです。 size(Features X) と入力することもでき、 これは 47 x 2 の行列です。 そして同様に size(Price Y) と打つと 47 x 1 ベクトルを返します。 これは 47次元ベクトルです。 この列ベクトルに含まれるのは 訓練セットに含まれる全ての価格 Y です。 さて、 Who 関数は どの変数が現在ワークスペースにあるか示します。 また、Who S 変数 とすると 詳細が表示されます。 そしてこの場合も、 最後に S がつきます、 変数の一覧を表示しますが、違いは サイズも表示する点です。 ですから A は 3 x 2 の 行列で、Features X は 47 x 2 の行列、 Price Y は　47 x 1 の行列で、 つまりこれは単なるベクトルです。 さらに、何バイトのメモリを消費しているか、 またデータの型は何か、も表示します。 Double は倍精度浮動 小数点数、つまりこれは 実数で、浮動小数点数であるということです。 さて、もし 変数を削除したい場合には、clear コマンドを使います。 よって clear Features X として whos を再実行すると お気づきのように Features X という変数は消えています。 ではデータを保存するにはどうするか。 見てみましょう。 変数 V を例に使い、 仮にそれが Price Y (1:10) とします。 こうすると、 V には 最初の10要素 がベクトル Y から 読み込まれます。who あるいは whos と入力すろと、 Y は 47 x 1 のベクトルだった のに対し、V が 10 x 1 です。 V = Price Y (1 :10 とすると、 これは単に Y の最初の 10 要素です。 これをデータとしてディスクに保存したいとします。 コマンドは save hello.mat V。こうすると 変数 V が保存されるのは hello.mat というファイルになります。 ではやってみましょう。 そして、今ファイルが デスクトップに現れました。その 名前は、Hello.mat です。 たまたま MATLAB がインストールされているので この Windowでは、 このアイコンが このようになっているのは Windows が それを MATLAB ファイルと認識しているからで、 心配しないでください。もしこのファイルが 違った アイコンでお使いのマシンで表示されても。 さて、全ての変数をクリアしたとします。 つまり、clear だけと入力して何も指定しなければ、 これはワークペース内の全ての変数を削除します。 whos を実行してもワークスペースには何も残っていません。 そこで hello.mat を読み込むと 再度 読み込まれる 変数 V に 含まれるデータは、 hello.mat ファイルに先ほど保存したものです。 では、 hello.mat つまり今実行した save hello.mat V、これで保存されるのは バイナリ形式のデータ、 多少圧縮されたバイナリ形式です。 ですから V が大きな データの場合、これは多少圧縮され、 消費するスペースが多少は減ります。 もし、保存する形式として データを人間が読める 形式にしたい場合は、save hello.txt 変数 V、そして -ascii。 すると、これは テキストとして ASCII 形式テキストとして保存されます。 すると、これを実行したので このファイルができました。 Hello.txt が今 デスクトップに表示され、 それを開くと、 ご覧の通りこれがテキスト ファイルで、データが保存されています。 これが、データの読み込みと保存です。 では、少しデータの操作についてお話します。 A = をその A の行列として指定すると、3 x 2 の行列になります。 インデックスするには、 A(3, 2) と入力します。 これでインデックスされるのは 3、2 の要素が 行列 A から読み出されます。 これは ご存知の通り、 通常、表記上は 添え字で A_{3、2} あるいは A 添え字 3、2 そしてこれがその要素で、 3 番目の行と 2 番目の列が A から読み出され、その要素は 6 です。 また、A、2、 カンマ、コロン、とすると、 二番目の行の全ての要素を取得できます。 ですから、コロンの意味は その行あるいは列の全ての要素、ということです。 よって A( 2, : ) は A の二番目の行です。確かに。 そして同様に コロン、カンマ、2 だと、その意味は、全要素を A の二番目の列から参照する、つまり 2 4 6 が戻され、 確かに、この意味は A、全要素、二列目、ということです。 ですから、これが Aの二列目、2 4 6。 さらに、もっと 高度なインデックス方法を演算で使うこともできます。 では、ざっと例をご覧に入れます。 使用頻度は低いでしょうが、 ここで A([1 3], :) を試してみましょう。 この意味は、 Aの要素で最初のインデックスが 1 あるいは 3 のもの全て、 つまり、この意味は、 最初と三番目の行の 全ての 列の要素を参照、 ですから、 行列 A で A( [1 3], : ) の意味は、 一番目の行から全て と二番目の行 いえ、三行目から全てを取得し、 コロンは、ご承知の通り、 最初と二番目両方 の列、よって、これは 1 2 5 6 を返します。 このような 高度な添え字インデックス 操作の使用頻度は、多少低いかもしれません。 これ以外にできることをご覧に入れます。 ここに 行列 A があり、これは A(:, 2) で、二番目の列を返します。 これを代入にも使えます。 そこで、二番目の列を A から指定して、そこに 10、11、12、と代入し、 実行すると、これは 二番目の列を A で指定し、そこにこの列ベクトル 10、11、12 を代入します。 ですから、この行列は、これが1、3、5 で その二列目が 10、11、12 に置き換わっています。 さらに別の操作があります。 A を = A カンマ、100、101、 102 とこのように指定すると、 この処理により、 別の列ベクトルが 右に追加されます。 ですから、ここで、おっと、 少し間違えがあったようです。 ここにセミコロンを入れるべきでした すると、A はこれにイコールとなります。 分かりましたか。 この意味が分かるとよいのですが。 ですから、これが 100、101、102 で これが列ベクトル そこで実行したのは、 A = とし、 そこに A の元の定義を代入し、 さらに、その列 ベクトルを右に追加したのです。 これにより、 行列 A は、もともと 左にある 6 つの要素でしたが、 その行列 A を指定して、別の 列ベクトルをその右に追加したわけです。 このため、A は今は 3 x 3 の行列となり、このように表示されています。 そして最後に、ひとつちょっとした コツを私は時々使います。 このように単に A(:) とします。 これは少し特別な構文です。 これの意味は、A の全ての要素を 単一の列ベクトルに入れるということで 9 x 1 のベクトルが返されます。 これは単に全ての要素が連結されているだけです。 あと例をもうひとつかふたつ。さて、 例えば、Aを = 1、2、3、4、5、6 とします、いいですか。 さらに、 B を B = 11、12、13、14、15、16。 すると、新たな 行列 C を A B から作成できます。 これの意味は単に 行列 A、ここに行列 B、そして C を = [A B] と指定します。 何をしているかというと、 二つの行列を使って、これをお互いに連結させているだけです。 左側には、行列 A が左に そして、行列 B が右にあります。 このようにして 二つを連結して行列 C を作成しました。 また、 C = [A; B]。 セミコロン表記の意味は、 次の行列を下につけるということです。 ですから、ここで C = [A; B] を実行します。これも 行列 A と B を連結しますが、この場合は 上下に連結されます。 ですから、A が上に、そして B が下に、そして C は 6 x 2 の行列になっています。 このように、セミコロンは 通常、次の行に行くという意味ですので C は、A と その下に B が配置される というわけです。ところで、 この [A B] は [A, B] と同じ意味ですので、 いずれの場合も同じ結果が得られます。 さて、ここまでで、おそらく どのように行列を作成するかを 理解でき、また いくつか、便利な コマンドも紹介したので、 手早く行列を作成して そうした行列を利用して、 組み合わせることにより、 より大きな行列を作成する のが、ほんの数行のコードでできる ので Octave が非常に便利 で いかに手早く 複雑な行列を作成し、データを操作できるかお分かり頂けたと思います。 データの操作方法については以上です。 次のビデオでは、 実際にどのようにして 複雑な演算処理をデータに対して行うかについて説明します。 ですから、これで 感覚的に、いかに いつくかのコマンドだけで、 Octave でいかに簡単のデータを取り扱えるか、 ベクトルや行列の読み込みと保存、 データの読み込みと保存、 行列の組み合わせによる新規の 行列の作成、行列内の特定の要素の 参照方法、などがご理解いただけたと思います。 かなり色々なコマンドを 紹介しましたので、 一番いいのは、 この後で、 私の入力内容の講義録を見て つまり、それを見るには、 コースワークのウェブサイトを見て、 このセッションの講義録を そこからダウンロードして、 講義録を見ながら、こうした コマンドを Octave に自分で打ち込み、 うまく機能するように色々と試してみることです。 言うまでもなく、こうしたコマンドを暗記する必要は一切なく その代わりに すべきなことは、 このビデオを通して、 どのようなことができるかの概要を把握し 後で、実際に プログラミングで、学習 アルゴリズムを自分で作成している時に、 何か特定の コマンドを探す際に、どのようなことが Octave で可能か思い返してみると、 ここで見たことが役に立つかもしまれせん。 その時に、講義録で このセッションを見返すと 使いたいコマンドが見つかるかと思います。 機械学習においては、実際には データの操作については終了し、 次のビデオで 紹介していきたいのは、 実際にどのように 複雑な演算処理を データを使って行うか、 データをどのように処理するか、 そして実際に学習アルゴリズムの実装についてお話します。