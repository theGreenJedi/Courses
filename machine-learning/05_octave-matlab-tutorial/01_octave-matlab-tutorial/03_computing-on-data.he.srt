1
00:00:00,280 --> 00:00:02,820
עכשיו כשאתם כבר יודעים איך לטעון ולשמור נתונים באוקטבה,

2
00:00:02,820 --> 00:00:05,100
לשים נתונים בתוך מטריצות וכיוצא בזה,

3
00:00:05,100 --> 00:00:10,028
בסרטון הזה, אני רוצה להראות לכם איך לעשות פעולות חישוביות על נתונים.

4
00:00:10,028 --> 00:00:14,880
ובהמשך ניישם באמצעות סוגים כאלה של פעולות חישוביות

5
00:00:14,880 --> 00:00:15,870
את אלגוריתמי הלמידה שלנו.

6
00:00:17,130 --> 00:00:17,810
הבה נתחיל.

7
00:00:19,650 --> 00:00:21,040
הנה חלון אוקטבה שלי.

8
00:00:21,040 --> 00:00:25,900
חכו רגע כשאני מאתחל במהירות כמה משתנים בהם נשתמש בסרטון.

9
00:00:25,900 --> 00:00:33,470
אז אני מאתחל את A להיות מטריצה שלוש על שתיים, ומגדיר מטריצה B שלוש על שתיים,

10
00:00:33,470 --> 00:00:37,855
ובואו נגדיר את C להיות מטריצה שתיים על שתיים כך.

11
00:00:39,195 --> 00:00:42,235
עכשיו נניח שאני רוצה להכפיל שתיים מהמטריצות שלי.

12
00:00:42,235 --> 00:00:47,195
נניח שאני רוצה לחשב את A*C, אני פשוט מקליד A*C, אז זו מטריצה שלוש על שתיים

13
00:00:47,195 --> 00:00:52,215
כפול מטריצה שתיים על שתיים, אז התוצאה היא מטריצה שלוש על שתיים.

14
00:00:52,215 --> 00:00:57,145
קיימות גם פעולות שעובדות על האיברים ולא על המטריצה, כגון A.*B

15
00:00:57,145 --> 00:01:02,580
שלוקח כל איבר של A ומכפיל אותו באיבר המקביל ב-B,

16
00:01:02,580 --> 00:01:06,208
זו המשמעות של A.*B.

17
00:01:06,208 --> 00:01:11,230
לדוגמא, האיבר הראשון הוא 1 כפול 11, שהם 11.

18
00:01:11,230 --> 00:01:17,140
האיבר השני הוא 2 כפול 12 שהם 24, וכן הלאה.

19
00:01:17,140 --> 00:01:20,840
אז זהו כפל ברמת האיברים של שתי מטריצות.

20
00:01:20,840 --> 00:01:23,200
ובאופן כללי, שימוש בנקודה מציין

21
00:01:23,200 --> 00:01:27,440
בדרך כלל פעולות ברמת האיברים באוקטבה.

22
00:01:27,440 --> 00:01:31,494
לדוגמא הנה המטריצה A, ואם אני עושה A.^2,

23
00:01:31,494 --> 00:01:36,500
נקבל ריבועים של האיברים של A.

24
00:01:36,500 --> 00:01:39,440
1 בריבוע הוא 1, 2 בריבוע הוא 4, וכן הלאה.

25
00:01:41,100 --> 00:01:42,560
בואו נקבע את V כווקטור.

26
00:01:42,560 --> 00:01:46,230
בואו נאתחל את V לאחת, שתיים, שלוש כווקטור עמודה.

27
00:01:46,230 --> 00:01:52,010
אפשר גם לעשות אחת נקודה חלקי V כדי לקבל את ההפוכיים של האברים של v,

28
00:01:52,010 --> 00:01:56,040
אז מקבלים אחת חלקי אחת, אחת חלקי שתיים, ואחת חלקי שלוש, וכך

29
00:01:56,040 --> 00:02:00,610
הופכים את האיברים, אחת נקודה חלקי מחזירה את ההופכי של כל איבר של A.

30
00:02:02,760 --> 00:02:08,173
ושוב, הנקודה כאן נותנת לנו רמז שזו פעולת ברמת האברים.

31
00:02:08,173 --> 00:02:15,080
אנחנו גם יכולים לעשות דברים כמו (log(v, שזה לוגריתם ברמת האבר של v.

32
00:02:15,080 --> 00:02:20,300
הפונקציה (exp(v נותנת E בחזקת האברים,

33
00:02:20,300 --> 00:02:25,600
אז זה E, זה E בריבוע, E בשלישית, כי זה היה V,

34
00:02:25,600 --> 00:02:31,040
ואפשר גם לעשות (abs(v כדי לקבל את הערך המוחלט של האברים של v.

35
00:02:31,040 --> 00:02:36,660
אז כאן, v היה כולו חיובי, אבל הוקטור מינוס אחת, שתיים, מינוס 3,

36
00:02:36,660 --> 00:02:42,973
אז abs שלו ברמת האיבר נותן את הערכים האלה שכולם לא שליליים.

37
00:02:42,973 --> 00:02:45,930
ו-v- נותן את הנגדי של איברי v.

38
00:02:45,930 --> 00:02:48,720
זה כמו לכתוב 1- כפול v, אבל

39
00:02:48,720 --> 00:02:54,024
בדרך כלל כותבים פשוט v- במקום 1-*v.

40
00:02:54,024 --> 00:02:56,050
מה עוד אפשר לעשות?

41
00:02:56,050 --> 00:02:57,240
הנה עוד טריק.

42
00:02:57,240 --> 00:02:58,360
הבה נראה.

43
00:02:58,360 --> 00:03:01,700
בואו נגיד שאני רוצה לקחת את v ולהוסיף אחת לכל איבריו.

44
00:03:01,700 --> 00:03:06,590
אז דרך אחת לעשות זאת היא על ידי בניית וקטור שלוש

45
00:03:06,590 --> 00:03:11,430
על אחת שכולו אחדות, ולחבר אותו ל-v.

46
00:03:11,430 --> 00:03:14,590
אז אם נעשה את זה, נגדיל את v מ-1, 2, 3 ל-2, 3, 4.

47
00:03:14,590 --> 00:03:21,520
מה שעשיתי כאן היה לקחתי את האורך של v, שהוא (length(v שזה 3,

48
00:03:21,520 --> 00:03:27,260
אז (ones(length(v),1 הוא (ones(3,1,

49
00:03:27,260 --> 00:03:33,620
אז זה (3,1)ones מימין ומה שעשיתי היה להוסיף ל-v את המטריצה הזו,

50
00:03:33,620 --> 00:03:38,950
מה שהוסיף וקטור אחדות ל-v, ולכן הגדיל את v באחת,

51
00:03:40,000 --> 00:03:44,190
אבל דרך יותר פשוטה לעשות את זה היא להקליד v ועוד אחת.

52
00:03:44,190 --> 00:03:45,450
אז יש לנו v,

53
00:03:45,450 --> 00:03:50,840
ו-v פלוס אחת פירושו להוסיף אחת לכל איבר מהאברים של v.

54
00:03:52,470 --> 00:03:55,490
עכשיו, בואו נדבר על פעולות נוספות.

55
00:03:55,490 --> 00:03:59,520
אז הנה המטריצה ​​שלי A, אם אתה רוצה לשחלף אותה, הדרך לעשות זאת

56
00:03:59,520 --> 00:04:03,720
היא לכתוב את התו תג, הסמל של הגרש, זה הגרש השמאלי,

57
00:04:03,720 --> 00:04:08,350
אם במקלדת יש לך גרש שמאלי וגרש ימני.

58
00:04:08,350 --> 00:04:11,260
זה למעשה סימן הגרש הסטנדרטי.

59
00:04:11,260 --> 00:04:18,330
פשוט תקליד 'A, וזה נותן את A משוחלפת.

60
00:04:18,330 --> 00:04:19,700
וגם, כמובן, אם

61
00:04:19,700 --> 00:04:22,970
אני משחלף אותה שוב, אנחנו אמורים לקבל בחזרה את המטריצה המקורית.

62
00:04:25,160 --> 00:04:27,570
עוד כמה פונקציות שימושיות.

63
00:04:27,570 --> 00:04:34,300
נניח שa קטנה היא 1 15 2 0.5, זאת אומרת מטריצה של 1 על 4.

64
00:04:34,300 --> 00:04:38,880
הבה נציב val שווה מקס a, זה מחזיר את המקסימום בין

65
00:04:38,880 --> 00:04:42,970
אברי A, שבמקרה שלנו הוא 15 ואפשר גם להציב

66
00:04:42,970 --> 00:04:48,430
זוג ערכים (val, ind] = max(a] וכאן נקבל גם

67
00:04:48,430 --> 00:04:52,940
את המקסימום שהוא 15 וגם את מיקומו בתוך a שהוא שתיים.

68
00:04:52,940 --> 00:04:58,790
אז זה היה איבר מספר שתיים שערכו הוא 15, ושתיים הוא המצביע לתוך a.

69
00:04:58,790 --> 00:05:03,230
שימו לב שאם מריצים (max(A כאשר A היא מטריצה,

70
00:05:03,230 --> 00:05:07,920
אז המשמעות של זה היא בעצם למצא את המקסימום של כל עמודה בנפרד.

71
00:05:07,920 --> 00:05:09,860
נדבר קצת יותר על זה תיכף.

72
00:05:11,610 --> 00:05:14,760
בינתיים אני עדיין משתמש בדוגמא זו של a קטנה.

73
00:05:14,760 --> 00:05:19,630
אם אני עושה a<3, גם זה עושה את הפעולה על כל איבר בנפרד.

74
00:05:19,630 --> 00:05:24,030
השוואה לפי איבר, ומכיוון שהאיבר הראשון של a אכן קטן משלוש

75
00:05:24,030 --> 00:05:24,970
אז התוצאה היא אחת.

76
00:05:24,970 --> 00:05:29,970
האיבר השני של a איננו קטן משלוש ולכן הערך כאן הוא אפס כי הוא שקר.

77
00:05:29,970 --> 00:05:36,590
האברים השלישי והרביעי של A קטנים משלוש, אז התשובה היא 1 1.

78
00:05:36,590 --> 00:05:42,970
אז קיבלנו השוואה לפי איבר של כל ארבעת האברים של המשתנה a < 3.

79
00:05:42,970 --> 00:05:47,440
וזה מחזיר אמת או שקר, תלוי אם האיבר קטן משלוש או לא.

80
00:05:47,440 --> 00:05:53,615
הפקודה (find(a<3 מחזירה את רשימת האינדקסים של איברים של a

81
00:05:53,615 --> 00:05:55,235
הקטנים מ-3,

82
00:05:55,235 --> 00:05:59,545
ובמקרה שלנו האברים הראשון, השלישי והרביעי קטנים מ-3.

83
00:05:59,545 --> 00:06:05,205
עבור הדוגמא הבאה, הרשו לי להגדיר את A שווה (magic(3 (קסם).

84
00:06:05,205 --> 00:06:08,985
הפונקציה מחזירה, בואו נקליד help magic.

85
00:06:08,985 --> 00:06:15,370
פונקצית magic מחזירה את המטריצות האלה הנקראות ריבועי קסם.

86
00:06:15,370 --> 00:06:20,830
יש להם התכונה המתמטית שכל השורות שלהם,

87
00:06:20,830 --> 00:06:23,690
כל העמודות וגם האלכסונים מסתכמים באותו מספר.

88
00:06:23,690 --> 00:06:28,830
זה לא באמת שימושי עבור למידה חישובית עד כמה שידוע לי,

89
00:06:28,830 --> 00:06:34,450
אני משתמש בזה כעוד דרך נוחה ליצור מטריצה שלוש על שלוש.

90
00:06:34,450 --> 00:06:38,788
לריבועי הקסם האלה יש המאפיין שכל שורה, כל עמודה,

91
00:06:38,788 --> 00:06:41,751
והאלכסונים כולם מסתכמים באותו סכום,

92
00:06:41,751 --> 00:06:44,300
אז זה בעצם מין מבנה מתמטי.

93
00:06:44,300 --> 00:06:48,820
אני משתמש בפונקצית magic הזו רק כשאני עושה הדגמות או כשאני מלמד אוקטבה

94
00:06:48,820 --> 00:06:53,760
כמו כאן, אני לא ממש משתמש בה לאיזה שהוא יישום של למידה חישובית.

95
00:06:53,760 --> 00:06:58,886
אבל בואו נראה, אם אני מקליד (RC = find(A >= 7 זה מוצא

96
00:06:58,886 --> 00:07:04,231
את כל האיברים של A שגדולים או שווים שבע,

97
00:07:04,231 --> 00:07:07,740
האותיות r, c מייצגות שורה ועמודה.

98
00:07:07,740 --> 00:07:11,750
אז האיבר 1,1 גדול שווה 7, האיבר במקום 3,2 גדול שווה 7,

99
00:07:11,750 --> 00:07:13,270
והאיבר במקום 2,3 גדול שווה 7.

100
00:07:13,270 --> 00:07:14,360
אז בואו נראה.

101
00:07:14,360 --> 00:07:17,740
האינדקס 2,3, למשל, דהיינו (A(2, 3,

102
00:07:17,740 --> 00:07:24,270
הוא 7, האיבר הזה כאן, והוא אכן גדול שווה שבע.

103
00:07:24,270 --> 00:07:28,820
אגב, אני ממש לא טורח לזכור מה עושות כל פונקציות ה-find האלה

104
00:07:28,820 --> 00:07:30,220
ומה כל שאר הדברים האלה עושים.

105
00:07:30,220 --> 00:07:34,180
בכל פעם שאני משתמש בפונקציה find, לפעמים אני שוכח בדיוק מה

106
00:07:34,180 --> 00:07:38,020
היא עושה, ועכשיו אני אקליד help find ואראה את ההסברים.

107
00:07:38,020 --> 00:07:40,130
אוקיי, רק עוד שני דברים שאני אראה כאן בזריזות.

108
00:07:40,130 --> 00:07:44,270
האחת היא פונקצית sum, אז הנה a, ואני מקליד (sum(a.

109
00:07:44,270 --> 00:07:48,140
זה מחבר את כל אברי a, ואם אני רוצה להכפיל אותם,

110
00:07:48,140 --> 00:07:50,940
אני מקליד (prod(a, הפונקציה prod מחשבת מכפלה,

111
00:07:50,940 --> 00:07:54,225
ומחזירה את מכפלת ארבעת האברים של a

112
00:07:54,225 --> 00:08:01,630
(floor(a מעגלת כלפי מטה את אברי a, אז 0.5 מתעגל כלפי מטה ל-0.

113
00:08:01,630 --> 00:08:06,600
ו-ceil, או (ceiling(a מעגל את האברים כלפי מעלה למספר השלם הקרוב ביותר,

114
00:08:06,600 --> 00:08:10,900
אז 0.5 מתעגל כלפי מעלה ל-1.

115
00:08:10,900 --> 00:08:13,330
אפשר גם, בואו נראה.

116
00:08:13,330 --> 00:08:16,720
הרשו לי להקליד (rand(3, זה מייצר מטריצה שלוש על שלוש.

117
00:08:16,720 --> 00:08:21,790
אם אני מקליד ((max(rand(3), rand(3, מה שזה עושה הוא לוקח

118
00:08:21,790 --> 00:08:27,000
את המקסימום ברמת האיבר של שתי מטריצות אקראיות 3 על 3.

119
00:08:27,000 --> 00:08:30,680
אז אתם יכולים לראות שהמספרים האלה נוטים להיות יות גדולים מסתם אקראיים,

120
00:08:30,680 --> 00:08:33,150
כי כל אחד מהם הוא למעשה המקסימום של שני אברים

121
00:08:34,490 --> 00:08:37,515
של שתי מטריצות אקראיות.

122
00:08:37,515 --> 00:08:38,280
זהו מספר הקסם שלי.

123
00:08:38,280 --> 00:08:43,050
סליחה, זהו ריבוע הקסם שלי, A שלוש על שלוש

124
00:08:43,050 --> 00:08:48,270
אז בואו נקליד (max(A ואז [],

125
00:08:48,270 --> 00:08:53,580
1, המשמעות של זה להחזיר את ערכי המקסימום של העמודות.

126
00:08:53,580 --> 00:08:58,260
המקסימום של העמודה הראשונה הוא 8, המקסימום של העמודה השנייה הוא 9,

127
00:08:58,260 --> 00:08:59,960
המקסימום של העמודה השלישית הוא 7.

128
00:08:59,960 --> 00:09:04,194
ה-1 הזה אומר לחשב את המקסימום לפי הממד הראשון של A.

129
00:09:05,200 --> 00:09:08,780
לעומת זאת, לו הקלדתי (max(A ואז את הסוגריים האלה

130
00:09:08,780 --> 00:09:12,480
פסיק שתיים, אז הייתי מקבל את המקסימום לפי שורות.

131
00:09:12,480 --> 00:09:17,210
המקסימום של השורה הראשונה הוא שמונה, המקסימום של השורה השנייה הוא שבע, המקסימום של השורה

132
00:09:17,210 --> 00:09:23,570
השלישית הוא תשע, אז זה מאפשר לקבל את המקסימום לפי שורה או לפי עמודה.

133
00:09:24,760 --> 00:09:30,050
ברירת המחדל היא לפי עמודה.

134
00:09:30,050 --> 00:09:34,880
אז אם אתה רוצה למצוא את האיבר הכי גדול בכל המטריצה A,

135
00:09:34,880 --> 00:09:39,660
תוכל להקליד ((max(max(A, ותקבל 9.

136
00:09:39,660 --> 00:09:45,130
אפשר גם להפוך את A לוקטור על ידי הביטוי ((:)max(A

137
00:09:45,130 --> 00:09:50,160
ואז תקבל את המקסימום של הוקטור שבנוי מהאברים של A שהוא האיבר הכי גדול של הוקטור.

138
00:09:52,130 --> 00:09:56,220
ועוד דבר אחרון, בואו נשים ב-A ריבוע קסם של 9 על 9.

139
00:09:56,220 --> 00:10:00,700
כזכור לריבוע הקסם יש התכונה שכל טור

140
00:10:00,700 --> 00:10:03,650
וכל שורה מסתכמים באותו מספר, וכן גם האלכסונים, אז

141
00:10:03,650 --> 00:10:06,280
יצרנו ריבוע קסם תשע על תשע.

142
00:10:06,280 --> 00:10:07,470
אז בואו נסכם (sum(A, 1.

143
00:10:07,470 --> 00:10:12,050
אז זה עושה סכום לפי טורים, לוקח כל עמודה של A

144
00:10:12,050 --> 00:10:15,550
ומסכם אותה ואכן יוצא

145
00:10:15,550 --> 00:10:20,150
שעבור ריבוע קסם של תשע על תשע, סכום כל עמודה הוא 369, לכל העמודות אותו סכום.

146
00:10:20,150 --> 00:10:21,978
עכשיו בואו נעשה את הסכום לפי שורות.

147
00:10:21,978 --> 00:10:26,870
נריץ (sum(A,2,

148
00:10:26,870 --> 00:10:32,950
וזה מסכם את כל השורות של A, ואכן גם כל שורה של A מסתכמת ב-369.

149
00:10:32,950 --> 00:10:36,110
עכשיו, בואו נסכם את האלכסונים של A

150
00:10:36,110 --> 00:10:39,800
כדי לוודא שגם להם אותו סכום.

151
00:10:39,800 --> 00:10:45,558
אז מה שנעשה הוא לבנות מטריצת יחידה של ​​תשע על תשע, (eye(9.

152
00:10:45,558 --> 00:10:52,330
עכשיו נכפול את ריבוע הקסם במטריצת היחידה לפי איבר, אז הנה המטריצה ​A

153
00:10:52,330 --> 00:10:56,290
ואני אחשב (A .* eye(9

154
00:10:56,290 --> 00:11:00,970
מה שזה עושה הוא לכפל את המטריצות האלה איבר איבר,

155
00:11:00,970 --> 00:11:05,820
ובגלל האפסים הכל בעצם נעלם חוץ מהערכים באלכסון.

156
00:11:05,820 --> 00:11:11,130
ועכשיו נעשה ((sum(sum(a וזה

157
00:11:11,130 --> 00:11:17,830
ייתן לנו את הסכום של האברים האלה באלכסון, ואכן אנו רואים שגם הסכום הזה הוא 369.

158
00:11:17,830 --> 00:11:20,260
ניתן לסכם גם את האלכסון השני.

159
00:11:20,260 --> 00:11:22,340
זה שחישבנו הוא מהפינה השמאלית העליונה לימנית התחתונה,

160
00:11:22,340 --> 00:11:27,410
אפשר לסכם גם את האלכסון מהפינה השמאלית התחתונה אל הימנית העליונה.

161
00:11:27,410 --> 00:11:29,791
הפקודות כדי לחשב את זה הן קצת פחות מוכרות,

162
00:11:29,791 --> 00:11:31,600
ואתם באמת לא צריכים להכיר אותן.

163
00:11:31,600 --> 00:11:34,790
אני פשוט מראה את זה למקרה שחלק מכם סקרנים.

164
00:11:34,790 --> 00:11:38,390
אבל בואו נראה.

165
00:11:38,390 --> 00:11:40,685
Flipud פירושו הֲפוֹךְ מעלה-מטה.

166
00:11:40,685 --> 00:11:45,760
אז אם תעשו את זה, אז זה יסכם את האברים ההפוכים.

167
00:11:45,760 --> 00:11:50,090
באלכסון השני, וגם כאן זה מסתכם ב-369.

168
00:11:50,090 --> 00:11:52,020
הנה, אני אראה לכם.

169
00:11:52,020 --> 00:11:54,262
אז (eye(9 היא המטריצה ה​​זו.

170
00:11:54,262 --> 00:11:59,470
((flipud(eye(9 לוקח את מטריצת היחידה

171
00:11:59,470 --> 00:12:02,890
והופך אותה בכיוון המאונך,

172
00:12:02,890 --> 00:12:06,480
כך שמתקבלת מטריצה עם אחדות על האלכסון הראשי הנגדי.

173
00:12:08,780 --> 00:12:12,750
ועכשיו פקודה אחרונה אחת ואז די, ואז סיימנו את הוידאו הזה.

174
00:12:12,750 --> 00:12:16,820
בואו נאתחל את A להיות ריבוע קסם שלוש על שלוש.

175
00:12:16,820 --> 00:12:20,340
כשרוצים להפוך מטריצה, מקלידים (pinv(a.

176
00:12:20,340 --> 00:12:23,120
קוראים לזה בדרך כלל פסאודו-הופכי, אבל זה לא משנה.

177
00:12:23,120 --> 00:12:27,830
תחשבו על זה כעל ההופכי של A, זו המטריצה ההופכית של A

178
00:12:27,830 --> 00:12:34,130
אז אני יכול להגדיר (temp = pinv(a ולכן A כפול temp

179
00:12:34,130 --> 00:12:38,110
היא אכן מטריצת היחידה, שהיא למעשה אחדות על האלכסונים,

180
00:12:38,110 --> 00:12:41,650
ואפסים מחוץ לאלכסונים, עד רמת שגיאת העיגול.

181
00:12:44,210 --> 00:12:45,596
אז, זה הכל בקשר

182
00:12:45,596 --> 00:12:50,630
לאיך לעשות פעולות חישוביות שונות על נתונים ומטריצות.

183
00:12:50,630 --> 00:12:55,548
ואחרי הרצת אלגוריתם למידה, בדרך כלל אחד הדברים השימושיים ביותר הוא

184
00:12:55,548 --> 00:12:59,760
להיות מסוגל לבחון את התוצאות שלו, דהיינו לשרטט או לצייר את התוצאה.

185
00:12:59,760 --> 00:13:04,342
אז בסרטון הבא אני מתכוון להראות לכם בזריזות איך על ידי שורה אחת

186
00:13:04,342 --> 00:13:06,260
או שתיים של קוד באוקטבה

187
00:13:06,260 --> 00:13:09,255
ניתן בקלות ובמהירות לצייר או לשרטט את הנתונים,

188
00:13:09,255 --> 00:13:13,340
ולהשתמש בזה כדי להבין יותר טוב איך עובד אלגוריתם הלימוד.