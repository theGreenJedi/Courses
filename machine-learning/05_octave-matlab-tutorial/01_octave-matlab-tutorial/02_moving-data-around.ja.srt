1
00:00:00,111 --> 00:00:02,628
この二番目のOctaveチュートリアルビデオでは、

2
00:00:02,630 --> 00:00:03,904
Octave でのデータの

3
00:00:03,930 --> 00:00:07,322
取り扱いについて説明していきます。

4
00:00:07,340 --> 00:00:08,783
機械学習問題用のデータがある場合、

5
00:00:08,783 --> 00:00:12,125
それをどのように Octave に読み込むか。

6
00:00:12,125 --> 00:00:13,693
どうすれば行列に取り込めるか。

7
00:00:13,693 --> 00:00:15,284
こうした行列をどのように取り扱うか。

8
00:00:15,290 --> 00:00:16,982
結果をどのように保存するか。

9
00:00:17,000 --> 00:00:22,185
どのようにデータを出し入れし演算を行うか。

10
00:00:22,900 --> 00:00:25,044
ここに、Octave ウィンドウが

11
00:00:25,044 --> 00:00:29,256
前回のビデオで使ったままであります。ここから続けます。

12
00:00:29,290 --> 00:00:31,132
A と入力すると、それは

13
00:00:31,140 --> 00:00:32,258
前に作成した行列ですよね。

14
00:00:32,258 --> 00:00:35,197
このコマンドで、= 1、2、

15
00:00:35,197 --> 00:00:38,152
3、4、 5、 6、すると

16
00:00:38,190 --> 00:00:40,696
これは 3 x 2 の行列です。

17
00:00:40,710 --> 00:00:42,415
Octave の size コマンドを使うと

18
00:00:42,430 --> 00:00:46,361
その行列のサイズが表示されます。

19
00:00:46,361 --> 00:00:48,207
よってsize(A) は 3、2 を 返します。

20
00:00:48,207 --> 00:00:50,160
実は、

21
00:00:50,180 --> 00:00:52,155
この size コマンドそのものが

22
00:00:52,155 --> 00:00:54,591
1 x 2 の行列を返すのです。

23
00:00:54,591 --> 00:00:56,598
このため、SZ =

24
00:00:56,598 --> 00:00:58,370
size(A) を実行すると、SZ は

25
00:00:58,380 --> 00:00:59,597
1 x 2 の行列となり、

26
00:00:59,597 --> 00:01:01,627
最初の要素が

27
00:01:01,640 --> 00:01:04,689
3、二番目の要素が 2 となります。

28
00:01:04,700 --> 00:01:07,494
そこで size(SZ) と入力すると、

29
00:01:07,494 --> 00:01:08,898
SZ は 1 x 2

30
00:01:08,898 --> 00:01:10,862
の行列で、その二つの要素には

31
00:01:10,862 --> 00:01:13,721
行列 A の次元情報が含まれています。

32
00:01:13,721 --> 00:01:15,279
また

33
00:01:15,279 --> 00:01:17,787
size(A, 1)と入力すると

34
00:01:17,787 --> 00:01:19,505
返されるのは 最初の

35
00:01:19,510 --> 00:01:21,542
A の次元のサイズ、

36
00:01:21,542 --> 00:01:22,662
Aの最初の次元のサイズです。

37
00:01:22,680 --> 00:01:24,108
これは行の数です。

38
00:01:24,110 --> 00:01:26,307
size(A, 2) の場合は

39
00:01:26,320 --> 00:01:28,361
2 が返されます。これは

40
00:01:28,361 --> 00:01:29,598
行列 A の列の数です。

41
00:01:29,598 --> 00:01:31,942
もし

42
00:01:31,950 --> 00:01:34,034
ベクトル V の場合は、

43
00:01:34,034 --> 00:01:36,016
例えば V = 1、 2、

44
00:01:36,030 --> 00:01:38,089
3、4、そして

45
00:01:38,089 --> 00:01:40,830
length(V) と入力します。

46
00:01:40,830 --> 00:01:42,097
この場合は、

47
00:01:42,097 --> 00:01:44,123
一番長い次元のサイズを返します。

48
00:01:44,170 --> 00:01:45,609
よって、

49
00:01:45,609 --> 00:01:48,487
length(A) と入力すると、

50
00:01:48,500 --> 00:01:49,856
A は 3 x 2

51
00:01:49,860 --> 00:01:52,305
の行列なので、

52
00:01:52,330 --> 00:01:53,825
長い方の次元のサイズは

53
00:01:53,825 --> 00:01:56,145
3、よって 3 が出力されるはずです。

54
00:01:56,145 --> 00:01:58,805
でも、通常は length はベクトルだけに使用します。

55
00:01:58,810 --> 00:02:00,194
なので、length 1、2、

56
00:02:00,200 --> 00:02:02,222
3、4、と使いますが、

57
00:02:02,230 --> 00:02:04,010
length を行列には使いません。

58
00:02:04,010 --> 00:02:07,205
混乱を来たす余地があるからです。

59
00:02:07,620 --> 00:02:10,122
では、ここで、どのように

60
00:02:10,122 --> 00:02:11,843
データを読み込み、データをファイル

61
00:02:11,860 --> 00:02:13,732
システム上で見つけるかを説明します。

62
00:02:13,732 --> 00:02:15,254
Octave を起動すると

63
00:02:15,254 --> 00:02:16,882
通常、多くの場合、

64
00:02:16,920 --> 00:02:19,098
パスは

65
00:02:19,098 --> 00:02:21,738
Octave のある場所となります。

66
00:02:21,750 --> 00:02:24,042
そこで pwd コマンドを使うと

67
00:02:24,060 --> 00:02:25,619
カレントディレクトリ、つまり

68
00:02:25,640 --> 00:02:28,738
Octave の現在のパスが表示されます。よって

69
00:02:28,738 --> 00:02:31,932
今いるのは知らないディレクトリかもしれません。

70
00:02:31,932 --> 00:02:33,999
cd コマンドは

71
00:02:34,000 --> 00:02:35,322
change directory の略で、ここで

72
00:02:35,330 --> 00:02:40,681
C:/Users/Ang/Desktop と入力すると

73
00:02:40,681 --> 00:02:43,657
今いる場所がデスクトップになります。

74
00:02:43,657 --> 00:02:45,925
ls と入力すると、ちなみに

75
00:02:45,925 --> 00:02:49,447
ls は、Unix あるいは Linux コマンドに由来します

76
00:02:49,447 --> 00:02:50,648
が、ls はリストとして

77
00:02:50,648 --> 00:02:52,435
デスクトップ上のディレクトリを戻し

78
00:02:52,435 --> 00:02:54,137
表示するので、これらが

79
00:02:54,140 --> 00:02:58,184
今、私のデスクトップにあるファイルです。

80
00:03:15,850 --> 00:03:17,838
実際、私のデスクトップには

81
00:03:17,838 --> 00:03:19,920
二つのファイルがあります。Features X と

82
00:03:19,920 --> 00:03:21,689
Price Y です。これは

83
00:03:21,689 --> 00:03:23,596
私が解きたい機械学習問題のデータです。

84
00:03:23,620 --> 00:03:25,830
これが私のデスクトップです。

85
00:03:25,830 --> 00:03:29,144
ここに Features X があり、

86
00:03:29,144 --> 00:03:31,598
Features X はこのウィンドウで、

87
00:03:31,630 --> 00:03:34,492
失礼、このファイルで、二列のデータがあります。

88
00:03:34,492 --> 00:03:36,702
これが実際の住宅の価格のデータです。

89
00:03:36,750 --> 00:03:38,374
たしか、知っている限り

90
00:03:38,374 --> 00:03:40,652
このデータセットは47行あると思います。

91
00:03:40,652 --> 00:03:42,344
この最初の住宅の面積は

92
00:03:42,350 --> 00:03:43,966
2104平方フィート、

93
00:03:43,970 --> 00:03:46,172
寝室が三つあります。二番目の

94
00:03:46,190 --> 00:03:47,367
住宅は 1600平方フィート、

95
00:03:47,367 --> 00:03:49,862
寝室は三つ、というように続きます。

96
00:03:49,880 --> 00:03:52,302
そして Price Y はこの

97
00:03:52,302 --> 00:03:55,020
ファイルで、

98
00:03:55,040 --> 00:03:57,575
訓練セットの価格のデータです。

99
00:03:57,575 --> 00:03:59,735
つまり、Features X と

100
00:03:59,735 --> 00:04:03,061
Price Y はデータを含む単なるテキストファイルです。

101
00:04:03,061 --> 00:04:04,770
このデータを Octave にどのように読み込むか。

102
00:04:04,770 --> 00:04:06,050
単に、コマンドで

103
00:04:06,090 --> 00:04:08,163
load Features X.dat と入力して

104
00:04:08,163 --> 00:04:10,069
実行すると

105
00:04:10,069 --> 00:04:11,991
Features X が読み込まれ

106
00:04:11,991 --> 00:04:15,772
同様に Price Y.dat も読み込めます。

107
00:04:15,772 --> 00:04:17,323
ちなみに、これには複数のやり方があり、

108
00:04:17,323 --> 00:04:19,245
このコマンドで、

109
00:04:19,245 --> 00:04:20,916
Features X.dat を文字列として入力

110
00:04:20,916 --> 00:04:22,533
しても同様に読み込めます。

111
00:04:22,550 --> 00:04:25,477
打ち間違いがありました。

112
00:04:25,490 --> 00:04:27,317
これが同等のコマンドです。

113
00:04:27,317 --> 00:04:29,334
このように、

114
00:04:29,360 --> 00:04:31,985
ファイル名の文字列として

115
00:04:32,000 --> 00:04:34,148
ファイル名を

116
00:04:34,148 --> 00:04:35,716
文字列として使います。

117
00:04:35,716 --> 00:04:38,902
Octave ではシングル引用符を使って

118
00:04:38,930 --> 00:04:41,876
文字列を表します。こんな風に。

119
00:04:41,910 --> 00:04:42,837
ですからこれは文字列です。

120
00:04:42,860 --> 00:04:45,517
そしてファイルを読み込むには

121
00:04:45,517 --> 00:04:48,324
その名前を文字列として与えます。

122
00:04:48,324 --> 00:04:50,919
さて who コマンド は現在

123
00:04:50,960 --> 00:04:52,538
どのような変数が

124
00:04:52,538 --> 00:04:54,605
Octave ワークスペースにあるか表示します。

125
00:04:54,605 --> 00:04:56,310
つまり、Who は 変数が

126
00:04:56,330 --> 00:04:59,952
現在 Octave のメモリに存在するかを示します。

127
00:04:59,952 --> 00:05:01,367
Features X と Price Y も

128
00:05:01,370 --> 00:05:02,991
そこに含まれていて、さらに、

129
00:05:02,991 --> 00:05:04,120
変数には、

130
00:05:04,170 --> 00:05:06,311
このセッションで前に作成したものもあります。

131
00:05:06,311 --> 00:05:09,198
なので、 Features X と入力すると

132
00:05:09,198 --> 00:05:11,062
Features X が表示されます。

133
00:05:11,062 --> 00:05:14,164
そしてこれがそのデータです。

134
00:05:14,200 --> 00:05:16,419
size(Features X) と入力することもでき、

135
00:05:16,419 --> 00:05:18,022
これは

136
00:05:18,022 --> 00:05:20,519
47 x 2 の行列です。

137
00:05:20,519 --> 00:05:22,307
そして同様に size(Price

138
00:05:22,320 --> 00:05:23,729
Y) と打つと

139
00:05:23,729 --> 00:05:26,753
47 x 1 ベクトルを返します。

140
00:05:26,753 --> 00:05:30,125
これは 47次元ベクトルです。

141
00:05:30,125 --> 00:05:32,080
この列ベクトルに含まれるのは

142
00:05:32,080 --> 00:05:35,231
訓練セットに含まれる全ての価格 Y です。

143
00:05:35,240 --> 00:05:37,584
さて、 Who 関数は

144
00:05:37,600 --> 00:05:40,086
どの変数が現在ワークスペースにあるか示します。

145
00:05:40,086 --> 00:05:42,195
また、Who S 変数 とすると

146
00:05:42,195 --> 00:05:45,369
詳細が表示されます。

147
00:05:45,369 --> 00:05:47,252
そしてこの場合も、

148
00:05:47,270 --> 00:05:48,574
最後に S がつきます、

149
00:05:48,574 --> 00:05:49,979
変数の一覧を表示しますが、違いは

150
00:05:49,979 --> 00:05:51,782
サイズも表示する点です。

151
00:05:51,790 --> 00:05:52,759
ですから A は 3 x 2 の

152
00:05:52,759 --> 00:05:54,764
行列で、Features X は

153
00:05:54,764 --> 00:05:56,545
47 x 2 の行列、

154
00:05:56,545 --> 00:05:59,327
Price Y は　47 x 1 の行列で、

155
00:05:59,327 --> 00:06:01,098
つまりこれは単なるベクトルです。

156
00:06:01,130 --> 00:06:03,438
さらに、何バイトのメモリを消費しているか、

157
00:06:03,438 --> 00:06:06,020
またデータの型は何か、も表示します。

158
00:06:06,020 --> 00:06:07,765
Double は倍精度浮動

159
00:06:07,765 --> 00:06:08,915
小数点数、つまりこれは

160
00:06:08,915 --> 00:06:13,148
実数で、浮動小数点数であるということです。

161
00:06:13,148 --> 00:06:14,190
さて、もし

162
00:06:14,190 --> 00:06:17,316
変数を削除したい場合には、clear コマンドを使います。

163
00:06:17,340 --> 00:06:21,124
よって clear Features X として whos を再実行すると

164
00:06:21,130 --> 00:06:23,448
お気づきのように Features X

165
00:06:23,448 --> 00:06:26,465
という変数は消えています。

166
00:06:27,270 --> 00:06:28,567
ではデータを保存するにはどうするか。

167
00:06:28,567 --> 00:06:29,221
見てみましょう。

168
00:06:29,221 --> 00:06:30,411
変数 V を例に使い、

169
00:06:30,411 --> 00:06:33,075
仮にそれが Price Y (1:10) とします。

170
00:06:33,075 --> 00:06:34,826
こうすると、 V には

171
00:06:34,826 --> 00:06:38,574
最初の10要素

172
00:06:38,860 --> 00:06:43,215
がベクトル Y から 読み込まれます。who あるいは whos

173
00:06:43,220 --> 00:06:46,612
と入力すろと、 Y は 47 x 1 のベクトルだった

174
00:06:46,612 --> 00:06:48,474
のに対し、V が 10 x 1 です。

175
00:06:48,474 --> 00:06:50,809
V = Price Y (1

176
00:06:50,809 --> 00:06:52,451
:10 とすると、

177
00:06:52,451 --> 00:06:53,520
これは単に Y の最初の 10

178
00:06:53,520 --> 00:06:55,705
要素です。

179
00:06:55,705 --> 00:06:57,398
これをデータとしてディスクに保存したいとします。

180
00:06:57,398 --> 00:07:00,129
コマンドは save hello.mat

181
00:07:00,129 --> 00:07:02,302
V。こうすると

182
00:07:02,310 --> 00:07:04,357
変数 V が保存されるのは

183
00:07:04,370 --> 00:07:05,690
hello.mat というファイルになります。

184
00:07:05,720 --> 00:07:08,490
ではやってみましょう。

185
00:07:08,640 --> 00:07:10,965
そして、今ファイルが

186
00:07:11,030 --> 00:07:13,181
デスクトップに現れました。その

187
00:07:13,181 --> 00:07:15,066
名前は、Hello.mat です。

188
00:07:15,066 --> 00:07:16,509
たまたま MATLAB がインストールされているので

189
00:07:16,530 --> 00:07:17,962
この Windowでは、

190
00:07:17,962 --> 00:07:19,711
このアイコンが

191
00:07:19,711 --> 00:07:21,621
このようになっているのは Windows が

192
00:07:21,621 --> 00:07:23,559
それを MATLAB ファイルと認識しているからで、

193
00:07:23,559 --> 00:07:24,882
心配しないでください。もしこのファイルが

194
00:07:24,890 --> 00:07:26,051
違った

195
00:07:26,051 --> 00:07:28,778
アイコンでお使いのマシンで表示されても。

196
00:07:28,778 --> 00:07:31,017
さて、全ての変数をクリアしたとします。

197
00:07:31,020 --> 00:07:32,602
つまり、clear だけと入力して何も指定しなければ、

198
00:07:32,602 --> 00:07:36,061
これはワークペース内の全ての変数を削除します。

199
00:07:36,080 --> 00:07:39,078
whos を実行してもワークスペースには何も残っていません。

200
00:07:39,078 --> 00:07:41,856
そこで hello.mat を読み込むと

201
00:07:41,856 --> 00:07:44,388
再度 読み込まれる

202
00:07:44,388 --> 00:07:46,054
変数 V に

203
00:07:46,054 --> 00:07:47,830
含まれるデータは、

204
00:07:47,830 --> 00:07:51,035
hello.mat ファイルに先ほど保存したものです。

205
00:07:51,035 --> 00:07:54,636
では、 hello.mat つまり今実行した save hello.mat

206
00:07:54,636 --> 00:07:55,877
V、これで保存されるのは

207
00:07:55,877 --> 00:07:57,811
バイナリ形式のデータ、

208
00:07:57,850 --> 00:07:59,702
多少圧縮されたバイナリ形式です。

209
00:07:59,702 --> 00:08:01,077
ですから V が大きな

210
00:08:01,077 --> 00:08:03,899
データの場合、これは多少圧縮され、

211
00:08:03,899 --> 00:08:05,645
消費するスペースが多少は減ります。

212
00:08:05,650 --> 00:08:06,784
もし、保存する形式として

213
00:08:06,784 --> 00:08:08,959
データを人間が読める

214
00:08:08,959 --> 00:08:11,870
形式にしたい場合は、save hello.txt

215
00:08:11,870 --> 00:08:14,055
変数 V、そして -ascii。

216
00:08:14,110 --> 00:08:16,083
すると、これは

217
00:08:16,083 --> 00:08:18,787
テキストとして

218
00:08:18,840 --> 00:08:21,352
ASCII 形式テキストとして保存されます。

219
00:08:21,352 --> 00:08:22,802
すると、これを実行したので

220
00:08:22,802 --> 00:08:24,973
このファイルができました。

221
00:08:24,973 --> 00:08:26,115
Hello.txt が今

222
00:08:26,130 --> 00:08:28,463
デスクトップに表示され、

223
00:08:28,463 --> 00:08:29,951
それを開くと、

224
00:08:29,951 --> 00:08:31,016
ご覧の通りこれがテキスト

225
00:08:31,016 --> 00:08:33,958
ファイルで、データが保存されています。

226
00:08:33,958 --> 00:08:36,698
これが、データの読み込みと保存です。

227
00:08:36,698 --> 00:08:38,832
では、少しデータの操作についてお話します。

228
00:08:38,832 --> 00:08:40,526
A = をその

229
00:08:40,526 --> 00:08:44,910
A の行列として指定すると、3 x 2 の行列になります。

230
00:08:45,710 --> 00:08:46,778
インデックスするには、

231
00:08:46,778 --> 00:08:48,493
A(3, 2) と入力します。

232
00:08:48,493 --> 00:08:51,219
これでインデックスされるのは

233
00:08:51,219 --> 00:08:52,917
3、2 の要素が

234
00:08:52,917 --> 00:08:54,308
行列 A から読み出されます。

235
00:08:54,370 --> 00:08:56,320
これは ご存知の通り、

236
00:08:56,400 --> 00:08:57,488
通常、表記上は

237
00:08:57,510 --> 00:09:00,421
添え字で A_{3、2}

238
00:09:00,430 --> 00:09:02,280
あるいは A 添え字

239
00:09:03,570 --> 00:09:05,320
3、2

240
00:09:05,380 --> 00:09:07,028
そしてこれがその要素で、

241
00:09:07,028 --> 00:09:08,664
3 番目の行と 2 番目の列が

242
00:09:08,664 --> 00:09:11,539
A から読み出され、その要素は 6 です。

243
00:09:11,590 --> 00:09:13,820
また、A、2、

244
00:09:14,550 --> 00:09:16,770
カンマ、コロン、とすると、

245
00:09:16,770 --> 00:09:18,851
二番目の行の全ての要素を取得できます。

246
00:09:18,851 --> 00:09:22,806
ですから、コロンの意味は

247
00:09:22,810 --> 00:09:27,381
その行あるいは列の全ての要素、ということです。

248
00:09:27,420 --> 00:09:29,274
よって A( 2, : )

249
00:09:29,274 --> 00:09:32,425
は A の二番目の行です。確かに。

250
00:09:32,470 --> 00:09:35,662
そして同様に コロン、カンマ、2

251
00:09:35,680 --> 00:09:38,262
だと、その意味は、全要素を

252
00:09:38,262 --> 00:09:41,328
A の二番目の列から参照する、つまり 2 4 6 が戻され、

253
00:09:41,328 --> 00:09:42,921
確かに、この意味は

254
00:09:42,930 --> 00:09:45,467
A、全要素、二列目、ということです。

255
00:09:45,500 --> 00:09:46,967
ですから、これが

256
00:09:46,970 --> 00:09:49,636
Aの二列目、2 4 6。

257
00:09:49,650 --> 00:09:51,267
さらに、もっと

258
00:09:51,280 --> 00:09:54,148
高度なインデックス方法を演算で使うこともできます。

259
00:09:54,148 --> 00:09:56,575
では、ざっと例をご覧に入れます。

260
00:09:56,575 --> 00:09:58,537
使用頻度は低いでしょうが、

261
00:09:58,550 --> 00:10:02,231
ここで A([1 3], :) を試してみましょう。

262
00:10:02,231 --> 00:10:03,471
この意味は、

263
00:10:03,500 --> 00:10:07,444
Aの要素で最初のインデックスが 1 あるいは 3 のもの全て、

264
00:10:07,450 --> 00:10:08,765
つまり、この意味は、

265
00:10:08,765 --> 00:10:10,588
最初と三番目の行の

266
00:10:10,603 --> 00:10:12,780
全ての

267
00:10:13,240 --> 00:10:13,240
列の要素を参照、

268
00:10:14,163 --> 00:10:16,430
ですから、

269
00:10:16,800 --> 00:10:18,260
行列 A で A(

270
00:10:18,440 --> 00:10:21,872
[1 3], : ) の意味は、

271
00:10:21,900 --> 00:10:23,222
一番目の行から全て

272
00:10:23,250 --> 00:10:25,023
と二番目の行

273
00:10:25,023 --> 00:10:27,172
いえ、三行目から全てを取得し、

274
00:10:27,172 --> 00:10:28,313
コロンは、ご承知の通り、

275
00:10:28,313 --> 00:10:29,585
最初と二番目両方

276
00:10:29,585 --> 00:10:31,045
の列、よって、これは

277
00:10:31,045 --> 00:10:32,842
1 2 5 6 を返します。

278
00:10:32,842 --> 00:10:34,353
このような

279
00:10:34,353 --> 00:10:37,182
高度な添え字インデックス

280
00:10:37,182 --> 00:10:39,819
操作の使用頻度は、多少低いかもしれません。

281
00:10:40,210 --> 00:10:41,453
これ以外にできることをご覧に入れます。

282
00:10:41,453 --> 00:10:43,617
ここに 行列 A があり、これは

283
00:10:43,617 --> 00:10:47,276
A(:, 2) で、二番目の列を返します。

284
00:10:47,276 --> 00:10:49,773
これを代入にも使えます。

285
00:10:49,773 --> 00:10:51,178
そこで、二番目の列を

286
00:10:51,190 --> 00:10:52,949
A から指定して、そこに

287
00:10:52,950 --> 00:10:55,605
10、11、12、と代入し、

288
00:10:55,670 --> 00:10:58,084
実行すると、これは

289
00:10:58,120 --> 00:10:59,220
二番目の列を

290
00:10:59,290 --> 00:11:02,768
A で指定し、そこにこの列ベクトル 10、11、12 を代入します。

291
00:11:02,768 --> 00:11:05,440
ですから、この行列は、これが1、3、5 で

292
00:11:05,480 --> 00:11:08,760
その二列目が 10、11、12 に置き換わっています。

293
00:11:08,760 --> 00:11:14,513
さらに別の操作があります。

294
00:11:14,680 --> 00:11:15,917
A を =

295
00:11:15,917 --> 00:11:17,738
A カンマ、100、101、

296
00:11:17,750 --> 00:11:21,605
102 とこのように指定すると、

297
00:11:21,605 --> 00:11:24,109
この処理により、

298
00:11:24,120 --> 00:11:28,025
別の列ベクトルが

299
00:11:28,047 --> 00:11:29,855
右に追加されます。

300
00:11:29,890 --> 00:11:33,230
ですから、ここで、おっと、

301
00:11:33,260 --> 00:11:36,798
少し間違えがあったようです。

302
00:11:36,800 --> 00:11:41,065
ここにセミコロンを入れるべきでした

303
00:11:41,700 --> 00:11:43,910
すると、A はこれにイコールとなります。

304
00:11:43,910 --> 00:11:44,564
分かりましたか。

305
00:11:44,564 --> 00:11:45,479
この意味が分かるとよいのですが。

306
00:11:45,479 --> 00:11:46,480
ですから、これが 100、101、102 で

307
00:11:46,480 --> 00:11:48,804
これが列ベクトル

308
00:11:48,820 --> 00:11:51,668
そこで実行したのは、

309
00:11:51,668 --> 00:11:53,386
A = とし、

310
00:11:53,386 --> 00:11:56,156
そこに A の元の定義を代入し、

311
00:11:56,156 --> 00:11:57,368
さらに、その列

312
00:11:57,380 --> 00:11:59,192
ベクトルを右に追加したのです。

313
00:11:59,192 --> 00:12:00,217
これにより、

314
00:12:00,217 --> 00:12:04,288
行列 A は、もともと

315
00:12:04,288 --> 00:12:05,405
左にある 6 つの要素でしたが、

316
00:12:05,405 --> 00:12:06,785
その行列

317
00:12:06,810 --> 00:12:08,564
A を指定して、別の

318
00:12:08,564 --> 00:12:09,793
列ベクトルをその右に追加したわけです。

319
00:12:09,793 --> 00:12:11,814
このため、A は今は

320
00:12:11,814 --> 00:12:16,083
3 x 3 の行列となり、このように表示されています。

321
00:12:16,200 --> 00:12:18,005
そして最後に、ひとつちょっとした

322
00:12:18,010 --> 00:12:19,802
コツを私は時々使います。

323
00:12:19,810 --> 00:12:22,022
このように単に A(:) とします。

324
00:12:22,022 --> 00:12:25,585
これは少し特別な構文です。

325
00:12:25,590 --> 00:12:28,695
これの意味は、A の全ての要素を

326
00:12:28,695 --> 00:12:30,751
単一の列ベクトルに入れるということで

327
00:12:30,850 --> 00:12:34,513
9 x 1 のベクトルが返されます。

328
00:12:34,513 --> 00:12:38,584
これは単に全ての要素が連結されているだけです。

329
00:12:39,700 --> 00:12:45,258
あと例をもうひとつかふたつ。さて、

330
00:12:45,300 --> 00:12:52,073
例えば、Aを = 1、2、3、4、5、6 とします、いいですか。

331
00:12:52,181 --> 00:12:54,035
さらに、

332
00:12:54,060 --> 00:12:55,674
B を B

333
00:12:55,680 --> 00:12:58,984
= 11、12、13、14、15、16。

334
00:12:58,984 --> 00:13:00,346
すると、新たな

335
00:13:00,346 --> 00:13:03,161
行列 C を A B から作成できます。

336
00:13:03,200 --> 00:13:05,010
これの意味は単に

337
00:13:05,080 --> 00:13:06,666
行列 A、ここに行列

338
00:13:06,666 --> 00:13:08,426
B、そして C を

339
00:13:08,426 --> 00:13:11,053
= [A B] と指定します。

340
00:13:11,070 --> 00:13:12,225
何をしているかというと、

341
00:13:12,225 --> 00:13:15,438
二つの行列を使って、これをお互いに連結させているだけです。

342
00:13:15,438 --> 00:13:18,408
左側には、行列 A が左に

343
00:13:18,420 --> 00:13:20,786
そして、行列 B が右にあります。

344
00:13:20,800 --> 00:13:23,738
このようにして

345
00:13:23,830 --> 00:13:27,145
二つを連結して行列 C を作成しました。

346
00:13:27,145 --> 00:13:28,927
また、 C =

347
00:13:28,927 --> 00:13:31,975
[A; B]。

348
00:13:32,000 --> 00:13:35,552
セミコロン表記の意味は、

349
00:13:35,552 --> 00:13:38,881
次の行列を下につけるということです。

350
00:13:38,881 --> 00:13:39,880
ですから、ここで C

351
00:13:39,910 --> 00:13:41,169
= [A; B] を実行します。これも

352
00:13:41,170 --> 00:13:42,408
行列 A と

353
00:13:42,460 --> 00:13:44,048
B を連結しますが、この場合は

354
00:13:44,048 --> 00:13:46,408
上下に連結されます。

355
00:13:46,408 --> 00:13:49,675
ですから、A が上に、そして B が下に、そして C は

356
00:13:49,675 --> 00:13:52,038
6 x 2 の行列になっています。

357
00:13:52,038 --> 00:13:54,263
このように、セミコロンは

358
00:13:54,270 --> 00:13:56,705
通常、次の行に行くという意味ですので

359
00:13:56,705 --> 00:13:58,463
C は、A と

360
00:13:58,463 --> 00:13:59,598
その下に

361
00:13:59,598 --> 00:14:00,610
B が配置される

362
00:14:00,690 --> 00:14:02,320
というわけです。ところで、

363
00:14:02,390 --> 00:14:04,225
この [A B] は

364
00:14:04,225 --> 00:14:05,734
[A, B] と同じ意味ですので、

365
00:14:05,750 --> 00:14:09,106
いずれの場合も同じ結果が得られます。

366
00:14:10,310 --> 00:14:11,916
さて、ここまでで、おそらく

367
00:14:11,916 --> 00:14:14,256
どのように行列を作成するかを

368
00:14:14,260 --> 00:14:17,207
理解でき、また

369
00:14:17,207 --> 00:14:18,223
いくつか、便利な

370
00:14:18,223 --> 00:14:19,822
コマンドも紹介したので、

371
00:14:19,850 --> 00:14:21,913
手早く行列を作成して

372
00:14:21,940 --> 00:14:23,390
そうした行列を利用して、

373
00:14:23,390 --> 00:14:24,984
組み合わせることにより、

374
00:14:25,000 --> 00:14:27,009
より大きな行列を作成する

375
00:14:27,009 --> 00:14:28,962
のが、ほんの数行のコードでできる

376
00:14:28,962 --> 00:14:30,770
ので Octave が非常に便利

377
00:14:30,770 --> 00:14:32,683
で いかに手早く

378
00:14:32,683 --> 00:14:36,033
複雑な行列を作成し、データを操作できるかお分かり頂けたと思います。

379
00:14:36,050 --> 00:14:38,027
データの操作方法については以上です。

380
00:14:38,027 --> 00:14:39,347
次のビデオでは、

381
00:14:39,347 --> 00:14:40,783
実際にどのようにして

382
00:14:40,860 --> 00:14:46,232
複雑な演算処理をデータに対して行うかについて説明します。

383
00:14:46,830 --> 00:14:48,256
ですから、これで

384
00:14:48,256 --> 00:14:49,961
感覚的に、いかに

385
00:14:49,961 --> 00:14:51,049
いつくかのコマンドだけで、

386
00:14:51,049 --> 00:14:54,573
Octave でいかに簡単のデータを取り扱えるか、

387
00:14:54,590 --> 00:14:56,164
ベクトルや行列の読み込みと保存、

388
00:14:56,180 --> 00:14:58,059
データの読み込みと保存、

389
00:14:58,090 --> 00:15:00,201
行列の組み合わせによる新規の

390
00:15:00,201 --> 00:15:02,990
行列の作成、行列内の特定の要素の

391
00:15:02,990 --> 00:15:05,021
参照方法、などがご理解いただけたと思います。

392
00:15:05,021 --> 00:15:06,015
かなり色々なコマンドを

393
00:15:06,015 --> 00:15:06,944
紹介しましたので、

394
00:15:06,980 --> 00:15:08,244
一番いいのは、

395
00:15:08,244 --> 00:15:09,741
この後で、

396
00:15:09,741 --> 00:15:12,248
私の入力内容の講義録を見て

397
00:15:12,248 --> 00:15:13,286
つまり、それを見るには、

398
00:15:13,286 --> 00:15:14,661
コースワークのウェブサイトを見て、

399
00:15:14,661 --> 00:15:15,927
このセッションの講義録を

400
00:15:15,950 --> 00:15:17,479
そこからダウンロードして、

401
00:15:17,479 --> 00:15:18,820
講義録を見ながら、こうした

402
00:15:18,820 --> 00:15:21,942
コマンドを Octave に自分で打ち込み、

403
00:15:21,942 --> 00:15:24,752
うまく機能するように色々と試してみることです。

404
00:15:24,752 --> 00:15:28,113
言うまでもなく、こうしたコマンドを暗記する必要は一切なく

405
00:15:28,113 --> 00:15:30,030
その代わりに

406
00:15:30,030 --> 00:15:31,852
すべきなことは、

407
00:15:31,852 --> 00:15:32,910
このビデオを通して、

408
00:15:32,910 --> 00:15:35,065
どのようなことができるかの概要を把握し

409
00:15:35,100 --> 00:15:36,519
後で、実際に

410
00:15:36,520 --> 00:15:37,902
プログラミングで、学習

411
00:15:37,902 --> 00:15:39,630
アルゴリズムを自分で作成している時に、

412
00:15:39,630 --> 00:15:40,921
何か特定の

413
00:15:40,930 --> 00:15:42,455
コマンドを探す際に、どのようなことが

414
00:15:42,455 --> 00:15:43,878
Octave で可能か思い返してみると、

415
00:15:43,878 --> 00:15:45,325
ここで見たことが役に立つかもしまれせん。

416
00:15:45,325 --> 00:15:47,300
その時に、講義録で

417
00:15:47,300 --> 00:15:48,545
このセッションを見返すと

418
00:15:48,560 --> 00:15:51,693
使いたいコマンドが見つかるかと思います。

419
00:15:51,693 --> 00:15:53,069
機械学習においては、実際には

420
00:15:53,069 --> 00:15:54,841
データの操作については終了し、

421
00:15:54,841 --> 00:15:56,060
次のビデオで

422
00:15:56,120 --> 00:15:57,699
紹介していきたいのは、

423
00:15:57,740 --> 00:15:59,257
実際にどのように

424
00:15:59,257 --> 00:16:01,404
複雑な演算処理を

425
00:16:01,410 --> 00:16:03,548
データを使って行うか、

426
00:16:03,550 --> 00:16:04,866
データをどのように処理するか、

427
00:16:04,866 --> 00:16:06,560
そして実際に学習アルゴリズムの実装についてお話します。