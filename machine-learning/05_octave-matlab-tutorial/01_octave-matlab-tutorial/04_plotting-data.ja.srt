1
00:00:00,180 --> 00:00:02,402
学習アルゴリズムを開発する時に、

2
00:00:02,402 --> 00:00:04,066
非常に多くの場合、いくつかのプロットを

3
00:00:04,066 --> 00:00:05,279
出力することにより

4
00:00:05,279 --> 00:00:06,593
アルゴリズムがどのように

5
00:00:06,593 --> 00:00:08,423
動作しているかを把握し、要所確認できます。

6
00:00:08,423 --> 00:00:09,503
全てが問題なく進行しているか

7
00:00:09,510 --> 00:00:12,405
アルゴリズムが意図したことを実行しているかなどです。

8
00:00:12,410 --> 00:00:13,924
例えば、以前の

9
00:00:13,924 --> 00:00:15,244
ビデオで、目的関数

10
00:00:15,244 --> 00:00:16,826
J(theta) をプロット

11
00:00:16,826 --> 00:00:18,433
することで最急降下法が

12
00:00:18,433 --> 00:00:21,383
収束していることを確認できるとお話しました。

13
00:00:21,383 --> 00:00:23,084
多くの場合、データのプロット

14
00:00:23,084 --> 00:00:24,795
あるいは学習アルゴリズムの全出力のプロットから

15
00:00:24,810 --> 00:00:26,422
学習アルゴリズムをどのように改善すべきか

16
00:00:26,422 --> 00:00:29,391
アイディアを得ることができます。

17
00:00:29,391 --> 00:00:31,312
幸い、 Octave では非常に

18
00:00:31,330 --> 00:00:33,045
簡単なツールで多くの

19
00:00:33,070 --> 00:00:34,534
異なるプロットを作成することが出来ますので、

20
00:00:34,534 --> 00:00:36,518
私が学習アルゴリズムを使う時は

21
00:00:36,518 --> 00:00:38,082
データをプロットし、

22
00:00:38,082 --> 00:00:40,175
学習アルゴリズムなどをプロットすることが

23
00:00:40,175 --> 00:00:42,057
しばしば重要な

24
00:00:42,060 --> 00:00:43,165
プロセスの一過程として

25
00:00:43,165 --> 00:00:45,937
アルゴリズムの改善案を得るのに

26
00:00:45,980 --> 00:00:47,199
役立っています。このビデオでは

27
00:00:47,199 --> 00:00:48,482
こうした Octave のプロット作成

28
00:00:48,482 --> 00:00:52,773
およびデータの可視化のツールをお見せしたいと思います。

29
00:00:53,700 --> 00:00:55,301
これが私の Octave ウィンドウです。

30
00:00:55,301 --> 00:00:57,471
では、さっそく、プロットに使うデータを

31
00:00:57,471 --> 00:00:58,646
いくつか作成します。

32
00:00:58,646 --> 00:00:59,724
そこで、t に

33
00:00:59,740 --> 00:01:02,181
この数字の配列を代入します。

34
00:01:02,210 --> 00:01:03,828
これが t

35
00:01:03,828 --> 00:01:06,685
0 から .98 に続く数字の集まりです。

36
00:01:06,700 --> 00:01:09,048
さらに y1 = sin

37
00:01:09,060 --> 00:01:11,340
(2<i>pi<i>4<i>t) として</i></i></i>

38
00:01:12,540 --> 00:01:16,102
この正弦関数をプロットするのは非常に簡単です。

39
00:01:16,102 --> 00:01:17,918
plot(t, y1) と入力し

40
00:01:17,918 --> 00:01:20,304
Enter を押すだけです。

41
00:01:20,320 --> 00:01:22,233
するとこのプロットが表示され

42
00:01:22,233 --> 00:01:24,270
横軸が

43
00:01:24,270 --> 00:01:25,515
t 変数で、縦軸が

44
00:01:25,515 --> 00:01:26,946
y1 となり、

45
00:01:26,960 --> 00:01:30,577
それがさきほど計算した正弦の波形関数です。

46
00:01:30,990 --> 00:01:32,281
では y2 を

47
00:01:32,281 --> 00:01:34,401
= cos

48
00:01:34,410 --> 00:01:38,735
(2<i>pi<i>4<i>t)</i></i></i>

49
00:01:38,750 --> 00:01:41,403
そしてこれをプロットすると

50
00:01:41,403 --> 00:01:43,835
plot(t,y2)、Octave が

51
00:01:43,835 --> 00:01:45,045
実行するのは、

52
00:01:45,060 --> 00:01:46,988
この正弦波形のプロットを

53
00:01:46,988 --> 00:01:48,681
この余弦関数と

54
00:01:48,690 --> 00:01:51,322
置き換え、余弦なので開始が 1 からになっています。

55
00:01:51,330 --> 00:01:53,006
では、もし

56
00:01:53,010 --> 00:01:54,581
両方のプロット

57
00:01:54,610 --> 00:01:56,981
正弦と余弦を重ねたい場合はどうすればいいでしょう。

58
00:01:56,990 --> 00:01:59,702
その場合にするのは、

59
00:01:59,702 --> 00:02:01,164
まず plot(t, y1) と入力し、

60
00:02:01,164 --> 00:02:03,332
そしてこれがその正弦関数です。そして次に

61
00:02:03,332 --> 00:02:06,958
関数 hold on を使います。

62
00:02:06,958 --> 00:02:08,908
hold on が行うのは、

63
00:02:08,920 --> 00:02:10,247
Octave が新しいグラフを

64
00:02:10,270 --> 00:02:11,490
前のグラフの上に

65
00:02:11,490 --> 00:02:13,772
重ねてプロットします。

66
00:02:13,772 --> 00:02:15,249
ここで plot(t, y2) とすると

67
00:02:15,249 --> 00:02:19,812
余弦関数は違う色でプロットしたいと思います。

68
00:02:19,850 --> 00:02:22,166
なので、これをここに

69
00:02:22,180 --> 00:02:24,093
r を引用符で囲んで入れます。

70
00:02:24,093 --> 00:02:25,339
すると、現在のグラフを置き換える

71
00:02:25,339 --> 00:02:26,615
代わりに、余弦関数がその上に

72
00:02:26,620 --> 00:02:28,499
プロットされ、さらに、

73
00:02:28,499 --> 00:02:32,915
r が示すのは、赤が色として指定されていることです。

74
00:02:32,915 --> 00:02:35,166
ここで追加のコマンドを - xlabel

75
00:02:35,166 --> 00:02:39,157
('times') を使って X軸、横軸のラベルを指定します。

76
00:02:39,160 --> 00:02:41,451
そして ylabel('values') として

77
00:02:41,451 --> 00:02:44,688
縦軸のラベルを 'value' とします。

78
00:02:44,688 --> 00:02:47,032
そしてさらに

79
00:02:54,532 --> 00:02:57,616
二つの線に凡例をつけることができます。

80
00:02:57,620 --> 00:03:01,514
これがそのコマンドです: legend('sin','cos')

81
00:03:01,514 --> 00:03:02,860
すると、この

82
00:03:02,890 --> 00:03:04,125
凡例が右上に

83
00:03:04,125 --> 00:03:05,122
表示され、二つの

84
00:03:05,122 --> 00:03:08,285
線が何かを示します。さらに

85
00:03:08,290 --> 00:03:12,753
title('my plot') とするとグラフの上に題名が表示されます。

86
00:03:12,753 --> 00:03:13,835
最後に、このグラフを保存するには

87
00:03:13,835 --> 00:03:18,197
print

88
00:03:18,197 --> 00:03:20,128
-dpng

89
00:03:20,128 --> 00:03:21,505
'myplot.png' と入力します。

90
00:03:21,505 --> 00:03:23,292
PNG は画像

91
00:03:23,292 --> 00:03:25,170
ファイル形式で、これを

92
00:03:25,170 --> 00:03:27,612
実行すると、この形式でファイルに保存されます。

93
00:03:27,612 --> 00:03:28,902
実行すると

94
00:03:28,920 --> 00:03:31,287
ディレクトリを変更させてください

95
00:03:31,320 --> 00:03:35,114
そうですね、こんな風に

96
00:03:35,130 --> 00:03:39,180
そして、それをプリント出力します。

97
00:03:39,230 --> 00:03:41,692
これには少し

98
00:03:41,700 --> 00:03:43,869
時間がかかります。

99
00:03:43,890 --> 00:03:46,193
Octave の構成がどう設定されているかによって

100
00:03:46,230 --> 00:03:48,891
数秒かかることがあります。ディレクトリを

101
00:03:48,900 --> 00:03:50,730
デスクトップに変更し、Octave が

102
00:03:50,730 --> 00:03:53,943
これを保存するのに数秒かかっています。

103
00:03:54,750 --> 00:03:57,635
デスクトップに行って、ウィンドウを隠すと

104
00:03:57,670 --> 00:03:59,358
ここに myplot.png があります。

105
00:03:59,370 --> 00:04:00,720
これが Octave が保存したファイルです。

106
00:04:00,740 --> 00:04:03,481
このPNGファイルに先ほどのグラフが保存されています。

107
00:04:03,481 --> 00:04:05,530
Octave はファイルを他の形式で保存することもできます。

108
00:04:05,530 --> 00:04:07,468
そこで help plot と入力すると

109
00:04:07,468 --> 00:04:09,497
PNG 以外でグラフを

110
00:04:09,510 --> 00:04:11,512
保存できる他のファイル形式

111
00:04:11,530 --> 00:04:13,377
が何かを見ることが

112
00:04:13,377 --> 00:04:15,149
できます。

113
00:04:15,149 --> 00:04:16,471
そして最後に、もし

114
00:04:16,471 --> 00:04:18,507
プロットを閉じたい場合は、

115
00:04:18,540 --> 00:04:23,867
close コマンドで グラフが閉じます。

116
00:04:23,867 --> 00:04:24,963
そこで

117
00:04:24,963 --> 00:04:26,628
close と入力するとグラフが

118
00:04:26,628 --> 00:04:30,153
デスクトップから消えました。

119
00:04:30,640 --> 00:04:33,372
Octave ではグラフに番号を指定することもできます。

120
00:04:33,372 --> 00:04:36,935
figure(1); plot(t, y1); とすると

121
00:04:36,935 --> 00:04:39,582
最初のグラフが開き

122
00:04:39,670 --> 00:04:41,959
そして、(t, y1) がプロットされます。

123
00:04:41,970 --> 00:04:45,075
次に二つ目のグラフを出力するには、異なる番号を指定します。

124
00:04:45,075 --> 00:04:47,765
ですから、 figure(2); plot(t, y2);

125
00:04:47,780 --> 00:04:49,924
とすると、

126
00:04:49,924 --> 00:04:53,084
これでデスクトップ上に二つのグラフが表示されます。

127
00:04:53,084 --> 00:04:54,625
figure 1 および figure 2

128
00:04:54,625 --> 00:04:55,874
一つが正弦

129
00:04:55,874 --> 00:04:59,169
関数、もう一つが余弦関数です。

130
00:04:59,170 --> 00:05:00,498
ここに、もう一つ便利なコマンドがあります。

131
00:05:00,498 --> 00:05:02,825
私が良く使うこのコマンドは、subplot です。

132
00:05:02,825 --> 00:05:05,401
では subplot(1, 2, 1) としましょう。

133
00:05:05,401 --> 00:05:07,958
これが実行するのは、

134
00:05:07,958 --> 00:05:11,200
プロットを1 x 2 のグリッドに

135
00:05:11,780 --> 00:05:13,760
二分割し、それが

136
00:05:13,820 --> 00:05:16,010
最初の二つの引数の意味です、

137
00:05:16,010 --> 00:05:17,607
そしてその最初の

138
00:05:17,620 --> 00:05:19,335
グリッドにアクセスします。それが

139
00:05:19,340 --> 00:05:21,714
最後の引数 1 の意味です。

140
00:05:21,714 --> 00:05:23,568
ですから、グラフを

141
00:05:23,568 --> 00:05:24,913
1 x 2 のグリッドに分割し、

142
00:05:24,913 --> 00:05:26,585
その最初のグリッドにアクセスする

143
00:05:26,585 --> 00:05:27,948
という意味です。

144
00:05:27,970 --> 00:05:30,435
そして、それを入力すると、

145
00:05:30,435 --> 00:05:32,722
この出力、このグラフは、左側に表示されます。

146
00:05:32,760 --> 00:05:35,291
そして、plot(t, y1) とすると、

147
00:05:35,350 --> 00:05:37,682
これはその

148
00:05:37,682 --> 00:05:40,462
最初のグリッドに表示されます。

149
00:05:40,462 --> 00:05:42,565
さらに、subplot(1, 2, 2) とすると、

150
00:05:42,565 --> 00:05:44,456
二番目のグリッドに

151
00:05:44,456 --> 00:05:48,724
アクセスを開始し、そして plot(t, y2) とすると、

152
00:05:49,270 --> 00:05:51,323
y2 が

153
00:05:51,323 --> 00:05:54,875
右側、つまり二番目のグリッドに表示されます。

154
00:05:54,910 --> 00:05:56,114
そして最後のコマンドで、

155
00:05:56,114 --> 00:05:58,165
軸の目盛りも変更します。

156
00:05:58,165 --> 00:06:00,308
軸を axis([0.5 1

157
00:06:00,330 --> 00:06:02,892
-1 1]) として変更すると、

158
00:06:02,892 --> 00:06:05,071
X軸の範囲と

159
00:06:05,071 --> 00:06:07,448
Y軸の範囲が

160
00:06:07,448 --> 00:06:09,874
右側のグラフに対して指定されます。

161
00:06:09,890 --> 00:06:12,381
具体的には、これは右側の

162
00:06:12,381 --> 00:06:13,668
グラフの主要な目盛りを

163
00:06:13,670 --> 00:06:14,856
指定し、念のため 0.5

164
00:06:14,856 --> 00:06:16,334
から 1 になっていますね、そして

165
00:06:16,340 --> 00:06:19,572
縦軸の値の範囲が -1 から 1 となります。

166
00:06:19,572 --> 00:06:21,736
ちなみに、こうしたコマンドを全て暗記する必要はありません。

167
00:06:21,736 --> 00:06:23,178
軸を変更する必要が

168
00:06:23,178 --> 00:06:24,773
生じた場合、

169
00:06:24,780 --> 00:06:25,703
知っていなければならないのは、軸を変更する

170
00:06:25,703 --> 00:06:26,628
コマンドがあるということだけで、

171
00:06:26,628 --> 00:06:28,364
そしてその詳細は

172
00:06:28,364 --> 00:06:31,590
お馴染みの Octave の help コマンドから得ることができます。

173
00:06:31,600 --> 00:06:32,861
最後に、いくつか最後のコマンドを。

174
00:06:32,861 --> 00:06:35,449
clf はグラフをクリアし

175
00:06:35,450 --> 00:06:38,362
そして、もう一つ便利なコツがあります。

176
00:06:38,362 --> 00:06:39,772
例えば、A =

177
00:06:39,772 --> 00:06:42,076
5 x 5 の

178
00:06:42,076 --> 00:06:43,375
魔方陣 とします。すると、A は

179
00:06:43,380 --> 00:06:45,290
これで 5 x 5

180
00:06:45,310 --> 00:06:47,581
の行列です。ここで

181
00:06:47,581 --> 00:06:49,341
私が行列を可視化するために

182
00:06:49,350 --> 00:06:51,582
時々使う便利なコツがあります。

183
00:06:51,582 --> 00:06:54,792
それは imagesc(A) を使うと

184
00:06:54,800 --> 00:06:56,362
これが実行するのは

185
00:06:56,370 --> 00:06:58,056
5 x 5 の行列を

186
00:06:58,056 --> 00:07:03,925
プロットして、5 x 5 の色のグリッドを表示します。

187
00:07:03,925 --> 00:07:05,739
異なる色は、A の行列の中の

188
00:07:05,739 --> 00:07:09,011
異なる値に対応しています。

189
00:07:09,060 --> 00:07:13,262
また、具体的には、colorbar とすることもできます。

190
00:07:13,630 --> 00:07:14,903
いや、もっと

191
00:07:14,903 --> 00:07:16,715
高度なコマンドを使います imagesc(A)

192
00:07:16,715 --> 00:07:19,608
colorbar,

193
00:07:19,608 --> 00:07:22,454
colormap gray 。

194
00:07:22,454 --> 00:07:24,757
これは実際には三つのコマンドを続けて実行しています。

195
00:07:24,760 --> 00:07:26,286
まず imagesc を実行し、次に

196
00:07:26,286 --> 00:07:28,943
colorbar、そしてcolormap gray を実行しています。

197
00:07:28,943 --> 00:07:30,142
これが実行するのは、

198
00:07:30,160 --> 00:07:31,355
カラーマップを指定しますので、

199
00:07:31,355 --> 00:07:32,749
ここでは白黒階調のカラーマップになり、

200
00:07:32,749 --> 00:07:35,333
その右に、さらにカラーバーが表示されます。

201
00:07:35,360 --> 00:07:37,525
このカラーバーが

202
00:07:37,550 --> 00:07:40,701
どの色の階調が何に対応するかを示します。

203
00:07:40,720 --> 00:07:42,704
具体的には、行列 A の

204
00:07:42,704 --> 00:07:44,494
左上の要素は

205
00:07:44,494 --> 00:07:46,358
17、ですからそれに対応する

206
00:07:46,358 --> 00:07:49,297
のは、このへんの階調の灰色です。

207
00:07:49,297 --> 00:07:52,012
これに比べて、A の

208
00:07:52,012 --> 00:07:53,210
二番目の要素、ですから

209
00:07:53,280 --> 00:07:55,640
A(1, 2) は 24 です。

210
00:07:55,640 --> 00:07:57,716
この通り、A(1, 2) は 24 です。

211
00:07:57,716 --> 00:07:59,683
これが対応するのは

212
00:07:59,690 --> 00:08:01,343
ここにあるこの四角で、

213
00:08:01,360 --> 00:08:03,677
それはほぼ白に近い灰色です。

214
00:08:03,677 --> 00:08:05,640
そして小さな値、

215
00:08:05,690 --> 00:08:08,657
A、どれかな？

216
00:08:08,657 --> 00:08:12,260
A(4, 5) の値は

217
00:08:12,300 --> 00:08:14,346
ここにある 3 で、それに対応する

218
00:08:14,360 --> 00:08:15,548
のは、カラーバーで見て分かるように

219
00:08:15,548 --> 00:08:16,618
それが対応するのは、

220
00:08:16,618 --> 00:08:19,499
この画像のかなり暗目の階調です。

221
00:08:19,499 --> 00:08:21,141
ここにもう一つの例があります。

222
00:08:21,141 --> 00:08:23,228
もっと大きなプロット、

223
00:08:23,230 --> 00:08:24,768
このように magic(15) とすると

224
00:08:24,770 --> 00:08:26,029
15 x 15 の

225
00:08:26,029 --> 00:08:27,675
魔方陣が得られます。

226
00:08:27,680 --> 00:08:29,504
それをプロットすると、

227
00:08:29,504 --> 00:08:33,675
この 15 x 15 の魔方陣の値が可視化できます。

228
00:08:33,700 --> 00:08:35,225
そして最後のビデオの

229
00:08:35,225 --> 00:08:37,075
まとめとして、皆さんが

230
00:08:37,075 --> 00:08:38,318
ここでご覧になったのは、

231
00:08:38,318 --> 00:08:41,917
関数呼び出しのカンマ連鎖の使い方です。

232
00:08:41,940 --> 00:08:43,195
このようにして実際に利用します。

233
00:08:43,210 --> 00:08:44,638
もし、a =

234
00:08:44,690 --> 00:08:46,613
1, b = 2, c =

235
00:08:46,613 --> 00:08:48,620
3、そして Enter を押すと、

236
00:08:48,620 --> 00:08:50,628
これは実際には

237
00:08:50,628 --> 00:08:52,039
三つのコマンドを同時に実行することになります。

238
00:08:52,040 --> 00:08:53,490
というか、実際には三つのコマンドを

239
00:08:53,490 --> 00:08:55,849
連続して実行します。

240
00:08:55,849 --> 00:08:57,521
そして三つの全ての結果を出力します。

241
00:08:57,521 --> 00:08:58,417
これは、このようにするのと似ています

242
00:08:58,417 --> 00:09:00,489
a = 1; b =

243
00:09:00,489 --> 00:09:01,755
2; c = 3、違いは

244
00:09:01,755 --> 00:09:03,532
ここではカンマの代わりに

245
00:09:03,540 --> 00:09:05,854
セミコロンを使っているので何も出力されません。

246
00:09:05,854 --> 00:09:07,195
ということで、

247
00:09:07,210 --> 00:09:08,865
これがいわゆるコマンドの

248
00:09:08,870 --> 00:09:12,185
カンマ連鎖、関数呼び出しのカンマ連鎖です。

249
00:09:12,240 --> 00:09:13,755
そして、これは Octave が提供する

250
00:09:13,755 --> 00:09:15,520
複数のコマンド、例えば

251
00:09:15,520 --> 00:09:17,778
imagesc、colorbar、colormap

252
00:09:17,778 --> 00:09:19,358
のように、複数のコマンドを

253
00:09:19,360 --> 00:09:22,919
同一ライン上で実行できる便利な機能の一つです。

254
00:09:22,930 --> 00:09:24,104
これで以上です。

255
00:09:24,104 --> 00:09:25,281
ここまでで、どのように

256
00:09:25,281 --> 00:09:27,504
Octave で異なるグラフをプロットするかお分かり頂けたと思います。

257
00:09:27,504 --> 00:09:29,270
次のビデオでは、

258
00:09:29,280 --> 00:09:30,430
私がお話したい次の主要なポイントは、

259
00:09:30,460 --> 00:09:31,985
Octave における

260
00:09:31,985 --> 00:09:33,622
if、while、for などの制御文の

261
00:09:33,630 --> 00:09:35,294
書き方と、

262
00:09:35,294 --> 00:09:39,426
関数の定義の仕方と使い方です。