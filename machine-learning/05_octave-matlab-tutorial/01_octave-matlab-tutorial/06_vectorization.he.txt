בסרטון הזה אני רוצה לספר לכם על הרעיון של וקטוריזציה. אז אם אתה משתמש אוקטבה או שפה דומה כמו MATLAB או אם אתה משתמש בפייתון, ++NumPy, R, Java, C, או כל אחת מהשפות הללו, קיימות בתוכם או שהוספו על גביהן ספריות נגישות של אלגברה לינארית נומרית. בדרך כלל הן כתובות היטב, יעילות במיוחד, לעתים קרובות הן פותחו על ידי אנשים שיש להם תואר דוקטור במחשוב נומרי או שהם ממש מומחים במחשוב נומרי. וכאשר אנחנו מיישמים אלגוריתמים של למידה חישובית, אם אנחנו יכולים לנצל את הספריות האלה של אלגברה ליניארית או אלגברה לינארית נומרית, ולקרוא לפונקציות בתוכן במקום לקודד בעצמנו את אותם דברים שהספריה אולי עושה, אם אנחנו עושים את זה, אז בדרך כלל נקבל קוד שהוא, ראשית, יעיל יותר, פשוט רץ מהר יותר, ומנצל יותר טוב כל חומרה מקבילית שייתכן שקיימת במחשב. ושנית, זה גם אומר שבסופו של דבר יש לך פחות קוד שאתה בעצמך צריך לכתוב, אז היישום יוצא יותר פשוט ולכן יש לו גם סיכוי יותר גבוה להיות נקי משגיאות. וכדוגמה קונקרטית, במקום לכתוב בעצמך קוד להכפלת מטריצות, אם תיתן לאוקטבה לעשות זאת על ידי הקלדת A כפול B, היא תשתמש בפונקציה מאוד יעילה כדי לכפול את המטריצות. ויש קבוצה של דוגמאות כאלה, שבהן אם תשתמש ביישומי וקטוריזציה מתאימים תקבל קוד הרבה יותר פשוט והרבה יותר יעיל. בואו נראה מספר דוגמאות. הנה פונקצית ההשערה הרגילה שלנו לרגרסיה ליניארית, ואם אתה רוצה לחשב את (h(x, שימו לב שיש כאן סכום מימין. אז אחת האפשרויות שלך היא לחשב את הסכום מ-j = 0 ועד j = n בעצמך. דרך נוספת לחשוב על זה היא לחשוב על (h(x כתטא משוחלפת כפול x, ואז מה שאפשר לעשות הוא לחשוב על זה כעל מכפלה פנימית בין שני וקטורים, שבה תטא הוא הוקטור, נניח, תטא-0, תטא-1, תטא-2 אם יש שתי תכונות, אם n שווה שתיים, ואם אתה חושב על x כעל וקטור x0, x1, x2. ושתי הגישות האלה יכולות להניב שני מימושים שונים. אסביר את כוונתי. הנה יישום של החישוב שהוא לא וקטורי וכשאני אומר לא וקטורי, אני מתכוון שאין בו וקטוריזציה. הנה דוגמא של יישום, אנו נאתחל משתנה בשם "תחזית" ל-0.0. בסוף התהליך "תחזית" תהיה (h(x, ועכשו נריץ לולאה עבור j = 1 עד n + 1, נוסיף ל"תחזית" את תטא-j כפול (x(j זה הביטוי הזה כאן. אגב, אני צריך להזכיר שהוקטורים האלה שכתבתי כאן הם וקטורים עם אינדקסים שמתחילים מ-0. ולכן כאן יש לנו תטא-0, תטא-1 ותטא-2. אבל מאחר וב-MATLAB האברים בוקטור מתחילים מאחת, תטא-0 ב-MATLAB נקרא תטא-1 והאיבר הבא נקרא תטא-2 והשלישי תטא-3, אבל רק בגלל שהווקטורים שלנו ב-MATLAB מבוססי אינדקס 1. לכן, למרות שקראתי כאן לוקטורים תטא ו-x, שהם מתחילים מ-0, בלולאת for שלנו j הולך מ 1 עד n + 1 ולא מ-0 עד n, ברור? אבל בכל אופן, זה יישום לא-וקטורי כי יש לנו כאן לולאת for שמסכמת את n האלמנטים שמרכיבים את הסכום. לעומת זאת, הנה דוגמה של כתיבה וקטורית, שבה אנחנו חושבים על x ותטא כעל וקטורים. כאן פשוט נכתוב "תחזית" = תטא * x. מחשבים את זה פשוט כך. אז במקום לכתוב את כל שורות הקוד האלה עם לולאת for, צריך רק שורת קוד אחת. ומה ששורת הקוד מימין תעשה הוא פשוט להשתמש בשגרות המאוד אופטימליות של אלגברה לינארית נומרית באוקטבה כדי לחשב את המכפלה הפנימית הזו בין שני הוקטורים, תטא ו-X, ובנוסף לכך שהיישום הוקטורי הוא פשוט בהרבה, הוא גם הרבה יותר יעיל. זה היה באוקטבה, אבל הנושא של וקטוריזציה קיים גם בשפות תכנות אחרות. בואו נסתכל על דוגמה ב++C. זו דוגמא של יישום שאיננו וקטורי. אנחנו שוב מאתחלים את "תחזית" ל-0.0 ואז מבצעים לולאת for עבור j = 0 עד n. "תחזית" + = תטא-j כפול  [x[j, וכאן שוב יש לולאת for מפורשת שאנחנו כותבים בעצמנו. לעומת זאת, בשימוש בספריה בסיסית טובה של אלגברה לינארית נומרית ב-++C, אפשר לכתוב פונקציה כזו, או ליתר דיוק, לעומת זאת, בשימוש בספריה בסיסית טובה של אלגברה לינארית נומרית ב-++C, אפשר במקום זאת לכתוב קוד שנראה משהו כמו זה. תלוי בפרטים המדויקים של איזו ספרייה יש לכם לפעולות אלגברה לינארית נומרית, ייתכן שאפשר ליצור אובייקט, אובייקט של ++ C, שהוא הוקטור תטא, ועוד אובייקט ++C שהוא הוקטור x, וצריך פשוט לכתוב  theta.transpose * x, בו הכפל הוא מה שנקרא ב++C בשם Operator Overload שמאפשר להגדיר כפל על אובייקטים מסוג וקטורים, ולכן אפשר פשוט להכפיל את שני הוקטורים האלה ב ++C. ובתלות בפרטים של הספריית הזו של אלגברה לינארית נומרית, ייתכן שתצטרך תחביר קצת שונה, אבל בכל אופן על ידי כך שהספרייה בעצם תבצע את המכפלה הפנימית הזו בין הוקטורים, נקבל פיסת קוד הרבה יותר פשוטה וגם הרבה יותר יעילה. עכשיו בואו נראה דוגמא יותר מתוחכמת. רק להזכיר לכם, הנה כלל העדכון שלנו של ירידה בשיפוע ברגרסיה ליניארית. באמצעות הכלל הזה אנחנו מעדכנים את תטא-j עבור כל הערכים של j = 0, 1, 2, וכו'. אז נכתוב את המשוואות הללו עבור תטא-0, תטא-1 ותטא-2, בהנחה שיש לנו שתי תכונות, זאת אומרת ש-n = 2. אלה הם העדכונים שאנו עושים לתטא-0, תטא-1 ותטא-2, ואולי אתם זוכרים שאמרתי בסרטון קודם שהעדכונים צריכים להיות סימולטניים. בואו נראה אם ​​אנחנו יכולים לכתוב את זה בצורה וקטורית. הנה אותן שלוש משוואות כתובות בגופן קצת יותר קטן, ואתם יכולים לדמיין דרך אחת ליישם את שלוש השורות האלו של קוד על ידי לולאת for שעוברת על j מקבל ערכים 0, 1 ו-2 ומעדכנת את תטא-j, או משהו דומה לזה. אבל במקום זה בואו נכתוב יישום וקטורי של זה ונראה שאנחנו בעצם יכולים בצורה מאוד פשוטה לדחוס את שלוש השורות האלה של קוד, את לולאת ה-for לקוד קצר ויעיל שעושה את כל קבוצת שלושת הצעדים האלה בצעד אחד. בואו נראה אם אנחנו מצליחים לקחת את שלושת הצעדים ולדחוס אותם לתוך שורה אחת של קוד וקטורי. הנה הרעיון. מה שאני הולך לעשות הוא לחשוב על תטא כעל וקטור, והצעד שלנו יהיה לעדכן את תטא ולהפחית ממנו אלפא כפול איזשהו וקטור דלתא, שבו דלתא יהיה 1 חלקי m כפול הסכום הזה מ-i = 1 עד m של הביטוי הזה מימין, מובן? תנו לי להסביר מה קורה כאן. כאן אנחנו מתייחסים לתטא כאל וקטור, הוא וקטור בעל ממד n ועוד אחת, ואני אומר שתטא הוא וקטור ממשי בעל ממד n + 1. אלפא הזה הוא מספר ממשי, ודלתא כאן היא וקטור. אז פעולת החיסור הזו היא חיסור של וקטורים, כן? כי אלפא כפול דלתא הוא וקטור, ומה שכתוב כאן הוא שאנחנו מציבים בתטא את הוקטור המקורי תטא פחות אלפא כפול דלתא. ועכשיו, מה הוא הוקטור דלתא? אז דלתא הוא הוקטור הזה, הוא נראה כך, ומה שהוא אמור להיות באמת הוא הדבר הזה כאן. באופן קונקרטי, דלתא הוא וקטור בעל ממד n ועוד אחד, והאיבר הראשון של הווקטור דלתא הוא הביטוי הזה. אז אם יש לנו הוקטור דלתא, אם נניח שהאינדקסים שלו מתחילים מ-0, אז זה דלתא 0, דלתא 1, דלתא 2, אז מה שאני רוצה הוא שדלתא 0 יהיה שווה למה שכתוב במסגרת הראשונה כאן למעלה בירוק. וייתכן שתוכל לשכנע את עצמך שדלתא 0 היא 1 חלקי m של הסכום מ-h של תטא ((x(i) - y(i) כפול (x0(i. אז בואו רק נוודא שאנחנו מבינים בצורה זהה איך בעצם מחשבים את דלתא. דלתא היא 1 חלקי m כפול הסכום הזה כאן, ומהו הסכום הזה? אז הביטוי הזה כאן הוא מספר ממשי, והמונח השני כאן, x i, הוא וקטור, מבינים, כי (x(i יכול לדוגמא להיות הוקטור x(i)0, x(i)1, x(i)2, נכון, ומה זה הסיכום הזה כאן? ומה שהסכום כאן אומר הוא שהביטוי הזה, הביטוי הזה כאן, שווה ל- (h(x(1))-y(1))*x0(1) + (h(x(2))-y(2))*x0(2) + ... וכן הלאה, בסדר? כי זה סכום על כל ה-i מ-i = 1 עד m, אז אנחנו מקבלים את כל הביטויים האלה, ומסכמים אותם. והמשמעות של המונחים האלו, זה מאוד דומה למה שאולי אתם זוכרים שהיה בבוחן הקודם, כן, כבר ראיתם את המשוואה הזאת. אמרנו שכדי לעשות את הקוד הזה וקטורי, אז במקום סיכום נכתוב u = 2v + 5W. או במלים אחרות הוקטור u שווה לשתיים כפול הוקטור v ועוד חמש כפול הוקטור w. אז זו דוגמא כיצד לחבר וקטורים, והסיכום כאן הוא אותו דבר. התוצאה של הסכום הזה היא פשוט איזה שהוא מספר ממשי, זה ברור? זה קצת דומה לשתיים או איזה שהוא מספר אחר כפול וקטור, x1. אז זה קצת כמו 2v או אולי איזה מספר אחר כפול x1, ובמקום להוסיף 5w אנחנו מוסיפים איזה מספר ממשי ועוד איזה וקטור, ועוד ועוד וקטורים, וזו הסיבה בעצם שכל הדבר הזה כאן, כל הגודל הזה, דלתא, הוא פשוט איזשהו וקטור. וקונקרטית, שלושת האברים של דלתא מתאימים, אם n = 2, שלושת האברים של דלתא מתאימים בדיוק לדבר הזה, לדבר השני, ולדבר השלישי כאן. ולכן כאשר תעדכן את תטא לתטא פחות אלפא כפול דלתא, אנחנו בעצם נעשה את כל העדכונים בצורה סימולטנית בדיוק כמו שהגדרנו בכללי העדכון שלנו. אני מבין ששקף הזה הוא עמוס מאוד במידע, אבל כמו שכבר אמרתי, אל תהסס להשהות את הסרטון, ואם אתה לא בטוח מה בדיוק קורה הייתי ממליץ לך לבצע בעצמך את השלבים בשקופית הזו כדי לוודא שאתה מבין למה העדכון הזה כאן, עם ההגדרה הזאת של דלתא, למה הוא זהה לעדכון הזה למעלה. ואם זה עדיין לא ברור, השתמשו בתובנה שהדבר הזה כאן, זהו בדיוק הוקטור x, ואנחנו למעשה לוקחים את כל שלושת החישובים האלה, ודוחסים אותם לצעד אחד עם הוקטור דלתא הזה, וכך אנחנו מצליחים לבצע יישום וקטורי של השלב הזה של העדכון. אז אני מקווה שהצעד הזה נראה לכם הגיוני ובבקשה תסתכלו בוידאו ותראו אם אתם מצליחים להבין את זה. אבל גם אם אתם לא ממש מבינים למה שתי הגישות האלה שקולות, אם תיישמו את זה אז תקבלו את התשובה הנכונה בכל מקרה. אז גם אם אתם לא ממש מבינים את השקילות, אם רק תיישמו את זה ככה, תצליחו לגרום לרגרסיה הליניארית לעבוד. אבל אם אתם כן מסוגלים להבין מדוע שני התהליכים הללו הם שקולים, אז אני מקווה שזה גם ייתן לכם הבנה טובה יותר של הוקטוריזציה. ולבסוף, אם אתם צריכים ליישם רגרסיה ליניארית עם הרבה יותר מאחת או שתי תכונות, לפעמים אנו בונים רגרסיה ליניארית עם 10 או 100 או 1000 תכונות, אז אם תשתמשו ביישום וקטורי של הרגרסיה הליניארית, תראו שהוא יפעל הרבה יותר מהר מאשר נניח לו תכתבו בעצמכם לולאה שמעדכנת את תטא-0, ואחר כך את תטא-1, ואז תטא-2. אז, באמצעות יישום וקטורי אתם אמורים להיות מסוגלים לייצר יישום הרבה יותר יעיל של רגרסיה ליניארית. וכשתעשו וקטוריזציה של אלגוריתמים שנראה יותר מאוחר בקורס הזה, יש טריק טוב, בין אם תשתמשו באוקטבה או בשפה אחרת כמו ++C או Java, כדי לגרום לקוד שלכם לפעול באופן יעיל יותר.