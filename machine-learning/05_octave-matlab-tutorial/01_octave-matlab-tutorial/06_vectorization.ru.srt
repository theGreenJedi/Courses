1
00:00:00,320 --> 00:00:03,682
В этом видео я бы хотел рассказывать вам о векторизации.

2
00:00:03,682 --> 00:00:08,380
Вне зависимости от того,

3
00:00:08,380 --> 00:00:12,540
используете ли вы Octave или

4
00:00:12,540 --> 00:00:17,470
похожий на него MATLAB, или

5
00:00:17,470 --> 00:00:21,840
языки Python, NymPy, Java или С++.

6
00:00:21,840 --> 00:00:24,400
Во всех этих языках есть

7
00:00:24,400 --> 00:00:29,250
встроенные

8
00:00:29,250 --> 00:00:32,070
или готовые библиотеки для работы с

9
00:00:32,070 --> 00:00:35,590
линейной алгеброй.

10
00:00:35,590 --> 00:00:39,880
Они обычно очень хорошо написаны и оптимизированы,

11
00:00:39,880 --> 00:00:44,510
так как разработаны людьми, защитившими

12
00:00:44,510 --> 00:00:48,470
диссертации по численным методам или

13
00:00:48,470 --> 00:00:51,970
являющимися специалистами в этой области.

14
00:00:51,970 --> 00:00:53,170
В таких случаях при написании обучающихся алгоритмов вы

15
00:00:53,170 --> 00:00:58,120
можете воспользоваться преимуществами, которые дают вам

16
00:00:58,120 --> 00:01:03,080
готовые библиотеки линейной

17
00:01:03,080 --> 00:01:07,330
алгебры, вместо самостоятельного

18
00:01:07,330 --> 00:01:08,540
написания

19
00:01:08,540 --> 00:01:13,450
функций,

20
00:01:13,450 --> 00:01:18,170
которые в этих

21
00:01:18,170 --> 00:01:22,220
библиотеках уже реализованы.

22
00:01:22,220 --> 00:01:26,090
Если вы так и поступите, то получите код, во-первых, более

23
00:01:26,090 --> 00:01:30,310
эффективный.

24
00:01:30,310 --> 00:01:31,470
То есть он быстрее

25
00:01:33,090 --> 00:01:36,110
исполняется, эффективно

26
00:01:36,110 --> 00:01:40,010
использует ресурсы вашего

27
00:01:40,010 --> 00:01:46,660
компьютера, и так далее.

28
00:01:46,660 --> 00:01:51,920
Во-вторых, вам просто

29
00:01:51,920 --> 00:01:56,330
придется писать меньше кода.

30
00:01:56,330 --> 00:02:03,220
Тем самым больше вероятность,

31
00:02:03,220 --> 00:02:07,221
что в коде не будет багов.

32
00:02:07,221 --> 00:02:11,632
Вот конкретный пример.

33
00:02:11,632 --> 00:02:17,590
Вместо того, чтобы писать

34
00:02:17,590 --> 00:02:18,820
свой код для перемножения матриц,

35
00:02:18,820 --> 00:02:23,623
мы просто можете

36
00:02:23,623 --> 00:02:25,360
написать A*B в Octave и

37
00:02:25,360 --> 00:02:30,160
этим очень быстро

38
00:02:30,160 --> 00:02:36,057
узнать результат перемножения.

39
00:02:36,057 --> 00:02:42,320
Есть немало случаев, когда оправданно

40
00:02:42,320 --> 00:02:44,740
использование векторизации.

41
00:02:44,740 --> 00:02:45,736
У Вас получится намного более простой и намного более эффективный код.

42
00:02:45,736 --> 00:02:51,100
Давайте рассмотрим примеры.

43
00:02:51,100 --> 00:02:53,270
Пусть у нас есть привычная

44
00:02:53,270 --> 00:02:58,543
нам гипотеза линейной регрессии, и требуется

45
00:02:58,543 --> 00:03:03,557
вычислить h(x).

46
00:03:03,557 --> 00:03:08,570
Обратите внимание на сумму справа.

47
00:03:08,570 --> 00:03:13,411
Вы можете просто

48
00:03:13,411 --> 00:03:18,620
просуммировать элементы для j в

49
00:03:18,620 --> 00:03:25,480
пределах от нуля до n.

50
00:03:25,480 --> 00:03:30,286
В то же время вы можете

51
00:03:30,286 --> 00:03:33,940
получить тот же результат,

52
00:03:33,940 --> 00:03:39,251
умножив транспонированное

53
00:03:39,251 --> 00:03:43,290
тета на икс. Результат

54
00:03:43,290 --> 00:03:46,620
этой операции есть произведение

55
00:03:46,620 --> 00:03:48,150
двух векторов, где вектор

56
00:03:48,150 --> 00:03:52,077
тета состоит из

57
00:03:52,077 --> 00:03:54,620
элементов тета0, тета1, тета2.

58
00:03:54,620 --> 00:03:57,764
Таким образом, у вас есть два элемента,

59
00:03:57,764 --> 00:04:02,604
или n=2. И есть вектор х,

60
00:04:02,604 --> 00:04:07,823
который выглядит

61
00:04:07,823 --> 00:04:13,250
так. Эти два

62
00:04:15,850 --> 00:04:17,590
метода реализуются

63
00:04:17,590 --> 00:04:22,080
по-разному.

64
00:04:22,080 --> 00:04:24,740
Вот что я имею в виду.

65
00:04:24,740 --> 00:04:27,820
Вот невекторизованная реализация вычисления h(x),

66
00:04:27,820 --> 00:04:31,468
то есть без использования

67
00:04:31,468 --> 00:04:35,650
векторизации.

68
00:04:35,650 --> 00:04:40,598
Изначально присвоим предсказанию величину 0.0.

69
00:04:40,598 --> 00:04:42,620
В конечном итоге

70
00:04:42,620 --> 00:04:47,720
оно последовательно

71
00:04:47,720 --> 00:04:50,950
так как в цикле for, повторяющемся n+1 раз,

72
00:04:54,410 --> 00:04:59,000
оно последовательно

73
00:04:59,000 --> 00:05:02,500
увеличивается

74
00:05:02,500 --> 00:05:06,540
на theta(1) умножить

75
00:05:06,540 --> 00:05:11,230
на x(j).

76
00:05:11,230 --> 00:05:17,540
Что соответствует вот этому выражению.

77
00:05:17,540 --> 00:05:22,270
Кстати, обратите внимание, в

78
00:05:22,270 --> 00:05:26,380
этих векторах первым по счету идет

79
00:05:26,380 --> 00:05:30,390
нулевой индекс.

80
00:05:30,390 --> 00:05:32,880
У меня были элементы theta0,

81
00:05:32,880 --> 00:05:35,800
theta1, theta2. Но из-за

82
00:05:35,800 --> 00:05:39,290
особенностей индексирования MATLAB

83
00:05:40,660 --> 00:05:43,590
theta0 обозначается

84
00:05:43,590 --> 00:05:45,840
как theta1, второй элемент

85
00:05:45,840 --> 00:05:48,260
обозначается как theta2, и третий

86
00:05:48,260 --> 00:05:55,070
элемент обозначается

87
00:05:55,070 --> 00:05:59,575
как theta3. Все

88
00:05:59,575 --> 00:06:03,410
потому, что индексирование

89
00:06:03,410 --> 00:06:08,377
в MATLAB

90
00:06:08,377 --> 00:06:13,230
начинается

91
00:06:14,850 --> 00:06:19,580
с единицы, в

92
00:06:20,754 --> 00:06:24,120
отличие от исходного

93
00:06:24,120 --> 00:06:28,110
вектора, где оно

94
00:06:28,110 --> 00:06:35,500
начинается

95
00:06:35,500 --> 00:06:39,570
с нуля. Поэтому

96
00:06:39,570 --> 00:06:43,830
цикл for выполняется

97
00:06:43,830 --> 00:06:48,540
от 1 до n+1, а не от 0 до n. Понятно?

98
00:06:48,540 --> 00:06:50,070
Но это была

99
00:06:50,070 --> 00:06:54,220
невекторизованная реализация, в

100
00:06:54,220 --> 00:06:55,500
которой мы в

101
00:06:55,500 --> 00:06:58,538
цикле вычисляли сумму из n элементов.

102
00:06:58,538 --> 00:07:03,458
В то же время можно

103
00:07:03,458 --> 00:07:08,090
использовать векторизацию, то

104
00:07:08,090 --> 00:07:12,723
есть представление x и тета в виде

105
00:07:12,723 --> 00:07:18,511
векторов и

106
00:07:18,511 --> 00:07:21,740
вычисление

107
00:07:21,740 --> 00:07:28,100
предсказания как произведения

108
00:07:28,100 --> 00:07:29,840
транспонированного тета и х.В соответствии с этим выражением.

109
00:07:31,310 --> 00:07:34,920
Вместо написания громоздкого

110
00:07:34,920 --> 00:07:38,170
цикла,

111
00:07:38,170 --> 00:07:43,610
можно написать одну

112
00:07:43,610 --> 00:07:50,080
строчку кода. Эта

113
00:07:50,080 --> 00:07:54,920
строчка справа использует возможности

114
00:07:54,920 --> 00:07:58,380
Octave в области линейной

115
00:07:58,380 --> 00:08:04,270
алгебры для

116
00:08:04,270 --> 00:08:06,580
вычисление произведения

117
00:08:06,580 --> 00:08:10,959
двух векторов, theta' и x. Этот

118
00:08:10,959 --> 00:08:17,040
код не только проще
написать, он также

119
00:08:17,040 --> 00:08:22,066
выполняется

120
00:08:22,066 --> 00:08:27,570
более эффективно.

121
00:08:27,570 --> 00:08:32,203
В примере я использовал Octave,

122
00:08:32,203 --> 00:08:37,288
но это справедливо и для других

123
00:08:37,288 --> 00:08:42,730
языков программирования.

124
00:08:42,730 --> 00:08:48,621
Давайте посмотрим пример на С++.

125
00:08:48,621 --> 00:08:53,964
Вот так выглядит невекторизованный вариант.

126
00:08:53,964 --> 00:08:58,360
Мы инициализируем

127
00:08:58,360 --> 00:09:01,352
переменную prediction,

128
00:09:01,352 --> 00:09:04,010
присваиваем ей 0.0, реализуем цикл

129
00:09:04,010 --> 00:09:09,930
на интервале от 0 до n.

130
00:09:09,930 --> 00:09:15,782
В цикле предсказание

131
00:09:15,782 --> 00:09:19,772
увеличивается на величину theta[j]*x[j], и этот цикл вы пишете вручную.

132
00:09:19,772 --> 00:09:24,427
В то же время с хорошей

133
00:09:24,427 --> 00:09:29,481
библиотекой операций

134
00:09:29,481 --> 00:09:34,136
линейной алгебры для С++ вы

135
00:09:34,136 --> 00:09:38,150
можете написать функцию, которая... нет, скорее так.

136
00:09:38,150 --> 00:09:44,142
В то же время с хорошей

137
00:09:44,142 --> 00:09:49,504
библиотекой операций

138
00:09:49,504 --> 00:09:54,707
линейной алгебры для С++ ваш

139
00:09:54,707 --> 00:10:00,700
код мог бы выглядеть так.

140
00:10:00,700 --> 00:10:06,080
В зависимости от выбора

141
00:10:06,080 --> 00:10:10,041
библиотеки вам

142
00:10:10,041 --> 00:10:15,100
может попасться выражение,

143
00:10:15,100 --> 00:10:19,990
обрабатывающее C++-объекты

144
00:10:19,990 --> 00:10:23,760
theta и х. Здесь

145
00:10:23,760 --> 00:10:30,680
выполняется

146
00:10:30,680 --> 00:10:34,760
theta.transpose()*x, звездочка

147
00:10:34,760 --> 00:10:36,470
перегружает оператор,

148
00:10:36,470 --> 00:10:40,530
и происходит

149
00:10:40,530 --> 00:10:42,940
перемножение

150
00:10:42,940 --> 00:10:49,740
двух векторов на

151
00:10:49,740 --> 00:10:54,370
языке С++.

152
00:10:54,370 --> 00:10:59,213
В зависимости от

153
00:10:59,213 --> 00:11:04,244
выбранной библиотеки линейной

154
00:11:04,244 --> 00:11:09,739
алгебры ваш синтаксис

155
00:11:09,739 --> 00:11:14,580
может несколько отличаться,

156
00:11:14,580 --> 00:11:20,670
но суть состоит в использовании

157
00:11:22,240 --> 00:11:27,592
библиотеки для вычисления произведения.

158
00:11:27,592 --> 00:11:32,800
Вы получаете более простой

159
00:11:32,800 --> 00:11:35,920
и эффективный код.

160
00:11:35,920 --> 00:11:41,050
Теперь обратимся к более сложному примеру.

161
00:11:41,050 --> 00:11:44,610
В качестве напоминания: вот

162
00:11:44,610 --> 00:11:46,670
наше правило обновления

163
00:11:47,980 --> 00:11:51,940
градиентного спуска линейной

164
00:11:51,940 --> 00:11:57,010
регрессии. Мы обновляем

165
00:11:57,010 --> 00:12:02,590
theta j согласно этому правилу для всех j: 0, 1, 2 и т.д.

166
00:12:02,590 --> 00:12:08,435
Теперь я выпишу функции

167
00:12:08,435 --> 00:12:12,870
для theta0, theta1,

168
00:12:12,870 --> 00:12:18,430
theta2.

169
00:12:18,430 --> 00:12:21,960
Исходя из того, что у нас всего два параметра.

170
00:12:21,960 --> 00:12:26,560
То есть n=2.

171
00:12:26,560 --> 00:12:31,420
Тогда эти формулы есть

172
00:12:31,420 --> 00:12:36,000
обновления для theta0, theta1, theta2.

173
00:12:37,010 --> 00:12:41,630
Вы наверняка помните, что

174
00:12:41,630 --> 00:12:44,030
раньше я говорил, что они должны

175
00:12:44,030 --> 00:12:47,230
обновляться одновременно.

176
00:12:47,230 --> 00:12:50,620
Посмотрим, сможем

177
00:12:50,620 --> 00:12:53,839
ли мы векторизовать этот

178
00:12:53,839 --> 00:12:58,610
процесс.

179
00:12:58,610 --> 00:13:03,142
Вот те же три

180
00:13:03,142 --> 00:13:08,710
уравнения,

181
00:13:08,710 --> 00:13:13,210
написанные

182
00:13:13,210 --> 00:13:17,915
меньшим шрифтом. Казалось бы,

183
00:13:17,915 --> 00:13:19,650
их можно было

184
00:13:19,650 --> 00:13:23,140
бы описать с

185
00:13:23,140 --> 00:13:27,465
помощью

186
00:13:27,465 --> 00:13:31,500
цикла for, выполняющегося

187
00:13:31,500 --> 00:13:34,220
для j от 0 и до 2.

188
00:13:34,220 --> 00:13:37,860
Вместо этого давайте поищем более простое решение с

189
00:13:37,860 --> 00:13:41,820
использованием векторизации.

190
00:13:41,820 --> 00:13:45,110
Тем самым мы сожмем три

191
00:13:45,110 --> 00:13:47,700
строки кода в один цикл, выполняющий