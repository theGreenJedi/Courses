1
00:00:00,180 --> 00:00:01,178
このビデオでは、

2
00:00:01,178 --> 00:00:02,587
制御文を

3
00:00:02,600 --> 00:00:03,842
Octave プログラムで

4
00:00:03,842 --> 00:00:05,672
どのように書くか

5
00:00:05,700 --> 00:00:07,280
例えば、for、while そして if 文など、

6
00:00:07,350 --> 00:00:12,176
そしてどのように関数を定義して使うかをお話します。

7
00:00:12,480 --> 00:00:13,980
これが私の Octave ウィンドウです。

8
00:00:13,980 --> 00:00:16,502
では最初に for ループの使い方からお見せします。

9
00:00:16,502 --> 00:00:17,888
まず、v を

10
00:00:17,888 --> 00:00:18,852
10 x

11
00:00:18,870 --> 00:00:20,808
1 の 0 のベクトルにします。

12
00:00:20,830 --> 00:00:22,209
ここで私の

13
00:00:22,240 --> 00:00:25,071
for ループの書き方は、for i = 1 から 10

14
00:00:25,090 --> 00:00:27,608
つまり、for i = 1:10

15
00:00:27,608 --> 00:00:29,905
そして、そうですね、

16
00:00:29,905 --> 00:00:31,466
v(i) を

17
00:00:31,466 --> 00:00:33,214
2 の

18
00:00:33,220 --> 00:00:36,848
i 乗にします、そして最後に

19
00:00:36,848 --> 00:00:37,671
end。

20
00:00:37,671 --> 00:00:39,082
スペースは無視されます。

21
00:00:39,090 --> 00:00:40,538
ですから見やすくするために

22
00:00:40,538 --> 00:00:41,960
スペースを使って字下げしています。

23
00:00:41,990 --> 00:00:44,385
しかし、スペースは関係ありません。

24
00:00:44,420 --> 00:00:46,163
しかし、これを実行すると、

25
00:00:46,163 --> 00:00:48,626
結果は v が

26
00:00:48,626 --> 00:00:49,420
2 の1 乗、2 乗、というように

27
00:00:49,500 --> 00:00:51,478
設定されます。

28
00:00:51,490 --> 00:00:52,665
ですからこれが構文です。i =

29
00:00:52,665 --> 00:00:55,410
1:10 これは

30
00:00:55,410 --> 00:00:57,429
i の値を 1 から 10 まで

31
00:00:57,440 --> 00:00:59,662
ループさせます。

32
00:00:59,662 --> 00:01:00,830
ちなみに、これには

33
00:01:00,830 --> 00:01:02,481
別のやり方もあり、

34
00:01:02,481 --> 00:01:04,795
indices = 1:10

35
00:01:04,800 --> 00:01:07,260
として、

36
00:01:07,270 --> 00:01:09,305
indices を 1 からの 10 までの配列とし、

37
00:01:09,305 --> 00:01:13,249
そして、i=indices と書くこともできます。

38
00:01:15,040 --> 00:01:17,805
そして、これは、実際には、for i = 1:10 と同じことです。

39
00:01:17,820 --> 00:01:19,459
そして disp(i)

40
00:01:19,480 --> 00:01:23,498
とすると、同じ結果になります。

41
00:01:23,498 --> 00:01:24,698
ということでこれが for ループです。

42
00:01:24,698 --> 00:01:27,201
もし break と continue が

43
00:01:27,230 --> 00:01:29,375
お馴染みであれば、break および

44
00:01:29,375 --> 00:01:30,809
continue 文もありますので、

45
00:01:30,809 --> 00:01:32,061
Octave のループ内でこれらを

46
00:01:32,061 --> 00:01:33,902
使用することもできます。でも最初に

47
00:01:33,902 --> 00:01:36,550
while ループがどのように動作するかをご覧に入れます。

48
00:01:36,570 --> 00:01:39,088
ここにベクトル

49
00:01:39,120 --> 00:01:40,912
V があります。では while ループ を書きましょう。

50
00:01:40,920 --> 00:01:44,037
i = 1;

51
00:01:44,037 --> 00:01:45,259
while i <= 5

52
00:01:45,259 --> 00:01:47,662
ここで

53
00:01:47,662 --> 00:01:51,082
v(i) = 100 と設定し

54
00:01:51,530 --> 00:01:54,449
i を 1 インクリメントし

55
00:01:54,449 --> 00:01:56,644
end とします。

56
00:01:56,700 --> 00:01:58,090
これが意味するのは、

57
00:01:58,090 --> 00:01:59,932
i が = 1 で始まり、

58
00:01:59,970 --> 00:02:01,359
そして

59
00:02:01,380 --> 00:02:02,629
v(i) = 100 に設定され、

60
00:02:02,629 --> 00:02:04,249
それから i が 1 インクリメント

61
00:02:04,260 --> 00:02:07,666
されて、i が 5 以上になるまで続きます。

62
00:02:07,690 --> 00:02:09,377
そしてその結果として

63
00:02:09,377 --> 00:02:13,022
以前には、V は 2 の累乗のベクトルでしたが

64
00:02:13,022 --> 00:02:14,573
そのベクトルの

65
00:02:14,580 --> 00:02:17,225
最初の5 つの要素を取って

66
00:02:17,260 --> 00:02:19,618
100 という値で置き換えたのです。

67
00:02:19,618 --> 00:02:22,797
これが、while ループの構文です。

68
00:02:23,140 --> 00:02:24,503
ではもう一つ例をご覧頂きます。

69
00:02:24,503 --> 00:02:26,600
i = 1;

70
00:02:26,600 --> 00:02:28,491
while true ここでは

71
00:02:28,500 --> 00:02:31,892
break 文の使い方をお見せしたいと思います。

72
00:02:31,892 --> 00:02:34,040
たとえば v(i) = 999;

73
00:02:34,070 --> 00:02:37,331
そして i = i+1;

74
00:02:38,110 --> 00:02:45,900
if i == 6, break; end

75
00:02:47,910 --> 00:02:47,910
end。

76
00:02:48,410 --> 00:02:49,425
そして これはここでの最初の

77
00:02:49,425 --> 00:02:51,945
if 文の使用例でもあります。

78
00:02:51,945 --> 00:02:53,308
この例のロジックの意味がお分かりいただけると思います。

79
00:02:53,308 --> 00:02:57,297
i == 1 と初期化し、無限ループの中で

80
00:02:57,340 --> 00:02:59,900
while で繰り返し v(i) = 1 設定し

81
00:02:59,900 --> 00:03:01,527
i を 1 インクリメントします。

82
00:03:01,527 --> 00:03:02,901
そして、 i が

83
00:03:02,920 --> 00:03:04,451
6 になったら、

84
00:03:04,451 --> 00:03:05,757
break して while のループから

85
00:03:05,757 --> 00:03:07,284
離脱し、

86
00:03:07,284 --> 00:03:08,596
その結果として

87
00:03:08,596 --> 00:03:09,929
ベクトル v の最初の 5 の要素を

88
00:03:09,929 --> 00:03:11,748
取り出してそれらを 999 にします。

89
00:03:11,748 --> 00:03:14,832
そして確かに、v の値のうち

90
00:03:14,832 --> 00:03:18,345
最初の 5 つの要素の値が 999 で上書きされています。

91
00:03:18,345 --> 00:03:20,172
以上が

92
00:03:20,172 --> 00:03:21,974
if 文と

93
00:03:21,974 --> 00:03:25,058
while 文の構文の説明です。end に注意してください。

94
00:03:25,070 --> 00:03:27,159
ここに二つ end があります。

95
00:03:27,170 --> 00:03:29,719
ここの end は if 文を締めくくり、

96
00:03:29,730 --> 00:03:33,228
この二番目の end は while 文を締めくくります。

97
00:03:33,250 --> 00:03:35,265
では、if 文の使いかたについて

98
00:03:35,265 --> 00:03:37,763
もっと一般的な構文をご紹介します。

99
00:03:37,763 --> 00:03:40,274
さて、ここで v(1)

100
00:03:40,274 --> 00:03:42,776
= 999、いや

101
00:03:42,860 --> 00:03:46,996
この例では v(1) = 2 とします。

102
00:03:47,020 --> 00:03:48,758
そこで 入力するのは

103
00:03:48,758 --> 00:03:55,050
if v(1) == 1; disp('the value is one') ; です。

104
00:03:56,855 --> 00:03:58,588
else 文の書き方は

105
00:03:58,588 --> 00:04:00,040
こうします:

106
00:04:00,040 --> 00:04:03,853
else if v(1) == 2

107
00:04:03,853 --> 00:04:07,815
これは、この例の場合は真となります

108
00:04:07,815 --> 00:04:12,268
disp('the value is two'); else

109
00:04:13,650 --> 00:04:17,960
disp('the value is not one or two');

110
00:04:17,990 --> 00:04:21,699
お分かり頂けたでしょうか、これが if-else-

111
00:04:21,700 --> 00:04:23,889
if-else 文で、end で締めくくります。

112
00:04:23,889 --> 00:04:25,271
そしてもちろん、ここで

113
00:04:25,271 --> 00:04:27,589
v(1) = 2 としましたので、うまくいけば、

114
00:04:27,610 --> 00:04:30,729
うん、確かに値が 2 であると表示しました。

115
00:04:30,780 --> 00:04:32,844
そして、最後に、そう言えば

116
00:04:32,880 --> 00:04:34,143
これについてお話していなかったと思います

117
00:04:34,143 --> 00:04:35,622
Octave を終了する必要がある場合、

118
00:04:35,622 --> 00:04:36,947
exit コマンドを入力し

119
00:04:36,947 --> 00:04:38,373
Enter を押すと、Octave が終了します。

120
00:04:38,400 --> 00:04:39,981
また q、quit

121
00:04:39,981 --> 00:04:42,428
コマンドでも同様です。

122
00:04:42,450 --> 00:04:43,857
最後に、関数と

123
00:04:43,857 --> 00:04:45,292
その定義の仕方、使いかたに

124
00:04:45,310 --> 00:04:48,592
ついてお話します。

125
00:04:48,620 --> 00:04:49,680
ここに私のデスクトップがあります。

126
00:04:49,720 --> 00:04:52,078
そして定義済みのファイル

127
00:04:52,078 --> 00:04:56,818
というか、予めデスクトップに保存しておいたファイル squarethisnumber.m があります。

128
00:04:56,830 --> 00:04:59,471
Octave で関数を定義する方法は以下の通りです。

129
00:04:59,480 --> 00:05:01,681
ファイルを作成し、その名前を

130
00:05:01,681 --> 00:05:03,958
関数の名前とし、最後に.mを付けます。

131
00:05:03,960 --> 00:05:05,694
Octave がそのファイルを

132
00:05:05,730 --> 00:05:07,643
見つけると、その関数の

133
00:05:07,680 --> 00:05:12,322
定義は、squarethisnumber.m で探す必要があることがわかります。

134
00:05:12,340 --> 00:05:14,076
ではこのファイルを開きましょう。

135
00:05:14,076 --> 00:05:15,717
お気づきのように、私が

136
00:05:15,717 --> 00:05:19,352
このファイルを開いているのは Microsoft の Wordpadです。

137
00:05:19,352 --> 00:05:20,250
私がお勧めしたいのは、もし

138
00:05:20,250 --> 00:05:23,379
Microsoft Windows を使う場合は、

139
00:05:23,379 --> 00:05:25,075
こうしたファイルを開くときに、Wordpad を

140
00:05:25,110 --> 00:05:27,477
使い、Notepad は使わないことです。

141
00:05:27,490 --> 00:05:28,557
もし異なる

142
00:05:28,557 --> 00:05:29,938
テキストエディタをお使いの場合はそれでも構いません。

143
00:05:29,938 --> 00:05:33,325
Notepad は時々スペースが無茶苦茶になることがあるからです。

144
00:05:33,350 --> 00:05:34,775
もし Notepad しか手元にない場合

145
00:05:34,800 --> 00:05:36,312
それも使えますが、

146
00:05:36,312 --> 00:05:37,779
でも、もし

147
00:05:37,779 --> 00:05:39,354
WordPad もあるなら、

148
00:05:39,354 --> 00:05:40,609
それを使うか、その他の

149
00:05:40,610 --> 00:05:45,053
テキストエディタを使って、関数を編集します。

150
00:05:45,060 --> 00:05:47,155
では、Octave での関数の定義の仕方は次の通りです。

151
00:05:47,155 --> 00:05:49,816
ちょっと拡大します。

152
00:05:49,816 --> 00:05:52,516
このファイルには、三行のテキストしかありません。

153
00:05:52,516 --> 00:05:54,440
一行目は、function y = square this

154
00:05:54,440 --> 00:05:56,448
number (x)、そしてこれは

155
00:05:56,448 --> 00:05:57,705
Octave に対し、この関数が

156
00:05:57,705 --> 00:06:00,025
y の値を戻すこと、その値は

157
00:06:00,025 --> 00:06:01,315
一つであること、そして

158
00:06:01,315 --> 00:06:02,375
その値は

159
00:06:02,375 --> 00:06:04,443
変数 y に保存されることを知らせます。

160
00:06:04,443 --> 00:06:06,003
さらに、Octave は

161
00:06:06,003 --> 00:06:08,068
この関数の引数は一つだけであること

162
00:06:08,070 --> 00:06:10,408
そしてそれが 引数 x であることも理解します。

163
00:06:10,420 --> 00:06:11,846
そして関数の本体は、

164
00:06:11,846 --> 00:06:15,156
y = x^2; と定義されています。

165
00:06:15,180 --> 00:06:16,553
では、この関数を

166
00:06:16,553 --> 00:06:19,071
呼び出して、square this number

167
00:06:19,071 --> 00:06:21,854
(5) すると、これは実際には

168
00:06:21,854 --> 00:06:23,115
動作せず、

169
00:06:23,115 --> 00:06:25,693
Octave は square this number は定義されていないと言います。

170
00:06:25,693 --> 00:06:28,902
なぜなら、 Octave はそのファイルがどこにあるか知らないからです。

171
00:06:28,902 --> 00:06:30,682
そこで、いつもながら、pwd を使いましょう。

172
00:06:30,690 --> 00:06:32,592
これは正しいディレクトリではないので

173
00:06:32,592 --> 00:06:36,151
では cd C:\users\ang\Desktop としましょう。

174
00:06:36,151 --> 00:06:39,888
これが私のデスクトップです。

175
00:06:39,888 --> 00:06:41,276
おっと、打ち間違いがありました。

176
00:06:41,276 --> 00:06:42,848
users\ang\Desktop

177
00:06:42,848 --> 00:06:44,157
そしてここで square

178
00:06:44,157 --> 00:06:46,728
this number (5) とすると、

179
00:06:46,728 --> 00:06:48,505
25 が答えとして返ります。

180
00:06:48,505 --> 00:06:50,347
すこし高度な機能ですので、これは

181
00:06:50,347 --> 00:06:51,972
検索パスという用語の

182
00:06:51,972 --> 00:06:54,596
意味が分かる方のみで結構ですが、

183
00:06:54,596 --> 00:06:55,945
もし

184
00:06:55,945 --> 00:06:57,497
Octave の検索パスを

185
00:06:57,497 --> 00:06:58,863
変更したい場合は、

186
00:06:58,863 --> 00:06:59,866
次の部分は、上級の

187
00:06:59,866 --> 00:07:01,827
自主選択の教材だと

188
00:07:01,827 --> 00:07:03,292
考えていただいて結構です。

189
00:07:03,292 --> 00:07:04,214
プログラミング言語における

190
00:07:04,214 --> 00:07:05,484
検索パスという概念をご存知の方

191
00:07:05,484 --> 00:07:07,642
のみで結構ですが、

192
00:07:07,650 --> 00:07:08,962
次のようなコマンドを使うことができます。

193
00:07:08,962 --> 00:07:11,875
addpath('C:

194
00:07:11,880 --> 00:07:16,241
\users\ang\Desktop

195
00:07:16,241 --> 00:07:17,972
すると、このディレクトリが

196
00:07:17,972 --> 00:07:19,744
Octave の検索パスに追加され、

197
00:07:19,744 --> 00:07:21,065
たとえ、他のディレクトリに

198
00:07:21,065 --> 00:07:22,611
行っても、

199
00:07:22,611 --> 00:07:24,510
Octave は関数を探すのに

200
00:07:24,510 --> 00:07:26,005
users\ang\

201
00:07:26,005 --> 00:07:29,214
Deskotp ディレクトリを見ることを覚えます。

202
00:07:29,214 --> 00:07:30,521
このため、今は

203
00:07:30,521 --> 00:07:31,868
別のディレクトリにいるにも関わらず、

204
00:07:31,868 --> 00:07:35,297
Octave は square this number 関数がどこにあるか見つけることができます。

205
00:07:35,297 --> 00:07:35,935
分かりましたか。

206
00:07:35,935 --> 00:07:37,407
もし、検索パスの概念に

207
00:07:37,407 --> 00:07:39,184
馴染みがない場合は、心配する必要は

208
00:07:39,184 --> 00:07:40,068
ありません。

209
00:07:40,068 --> 00:07:40,889
関数を実行する前に単に cd コマンドを使って

210
00:07:40,889 --> 00:07:42,053
関数があるディレクトリに

211
00:07:42,053 --> 00:07:43,926
行くのを覚えていれば。

212
00:07:43,940 --> 00:07:47,441
これで実際には支障はないはずです。

213
00:07:47,441 --> 00:07:49,587
Octave にあって、

214
00:07:49,600 --> 00:07:51,058
他の多くのプログラミング

215
00:07:51,058 --> 00:07:52,969
言語にはない概念に

216
00:07:52,969 --> 00:07:54,909
複数の戻り値や

217
00:07:54,909 --> 00:07:58,873
複数の引数を定義できるという点があります。

218
00:07:58,873 --> 00:08:00,889
ここにその例があります。

219
00:08:00,889 --> 00:08:02,931
この関数を定義します square

220
00:08:02,931 --> 00:08:04,964
and cube this number(x)

221
00:08:04,964 --> 00:08:06,644
これが何かというと、この

222
00:08:06,660 --> 00:08:08,547
関数は y1 および y2 の二つの関数を戻します。

223
00:08:08,547 --> 00:08:09,955
その定義は以下の通りです。

224
00:08:09,960 --> 00:08:13,603
y1 は 二乗、y2 は三乗です。

225
00:08:13,603 --> 00:08:16,972
これを実行すると、実際に二つの数が戻ります。

226
00:08:16,980 --> 00:08:18,855
皆さんの中には、

227
00:08:18,855 --> 00:08:20,195
お使いのプログラミング言語によって、

228
00:08:20,195 --> 00:08:22,931
C++ やその他に馴染んでいる場合、

229
00:08:22,940 --> 00:08:26,051
しばしば、関数は一つの値を戻すものと思いがちです。

230
00:08:26,051 --> 00:08:27,847
しかし、Octave の文法では、

231
00:08:27,847 --> 00:08:31,679
複数の値を戻すことができます。

232
00:08:32,430 --> 00:08:34,087
Octave ウィンドウに戻ります。

233
00:08:34,087 --> 00:08:37,914
そうですね、[a, b] =

234
00:08:37,914 --> 00:08:41,263
square and cube this

235
00:08:41,263 --> 00:08:44,599
number(5) とすると、

236
00:08:44,610 --> 00:08:46,338
a は = 25 で

237
00:08:46,338 --> 00:08:47,778
b =

238
00:08:47,778 --> 00:08:49,729
5の三乗、よって = 125 となります。

239
00:08:49,729 --> 00:08:51,645
ですから、これは

240
00:08:51,670 --> 00:08:53,010
複数の値を戻す関数を

241
00:08:53,010 --> 00:08:56,447
定義するのに多くの場合とても便利です。

242
00:08:56,447 --> 00:08:57,480
最後にお見せしたいのは、

243
00:08:57,480 --> 00:09:01,123
さらに詳細な関数の例です。

244
00:09:01,130 --> 00:09:02,361
例えば、次のようなデータセットがあるとします。

245
00:09:02,370 --> 00:09:04,400
1、1、2、2、3、3 でのデータポイントがこうなっています。

246
00:09:04,430 --> 00:09:07,636
そして、私が行いたいのは、

247
00:09:07,636 --> 00:09:09,113
異なる値の theta に対する

248
00:09:09,113 --> 00:09:10,798
目的関数 J(theta) を算出する

249
00:09:10,830 --> 00:09:14,341
Octave 関数を定義することです。

250
00:09:14,360 --> 00:09:16,157
まず、データを Octave で作成します。

251
00:09:16,160 --> 00:09:17,694
計画行列を

252
00:09:17,700 --> 00:09:20,998
1、1、2、2、3、3 とします。

253
00:09:21,010 --> 00:09:24,043
これが、私の計画

254
00:09:24,050 --> 00:09:26,073
行列 x で、x 0、

255
00:09:26,073 --> 00:09:27,428
最初の列が切片

256
00:09:27,428 --> 00:09:28,746
項で二列目が

257
00:09:28,770 --> 00:09:32,375
訓練データの三つの x 値です。

258
00:09:32,375 --> 00:09:33,594
そして、

259
00:09:33,594 --> 00:09:35,488
y = [1; 2; 3] とし、

260
00:09:35,488 --> 00:09:38,793
これは y 軸の値となります。

261
00:09:38,810 --> 00:09:40,431
そして、仮に theta

262
00:09:40,431 --> 00:09:43,714
= [0; 1] とします。

263
00:09:43,730 --> 00:09:45,652
私のデスクトップ上に

264
00:09:45,660 --> 00:09:47,483
目的関数Jを予め定義しておきました。

265
00:09:47,490 --> 00:09:49,008
そして

266
00:09:49,010 --> 00:09:52,019
この関数の定義を開くと、以下のようになっています。

267
00:09:52,019 --> 00:09:53,579
function J = costFunction

268
00:09:53,580 --> 00:09:55,192
J 引数 x, y,

269
00:09:55,192 --> 00:09:57,151
theta、 コメントで入力の

270
00:09:57,151 --> 00:09:59,546
定義をし、そして

271
00:09:59,560 --> 00:10:01,383
その次に幾つかのステップを定義します。m を

272
00:10:01,383 --> 00:10:02,995
訓練データサンプル数とします。

273
00:10:03,020 --> 00:10:05,495
つまり x の行数ですね。

274
00:10:05,510 --> 00:10:07,596
predictions を計算します。predictions =

275
00:10:07,596 --> 00:10:10,137
x * theta;

276
00:10:10,170 --> 00:10:11,670
これは自動改行されたコメントの

277
00:10:11,710 --> 00:10:14,693
続きです。ということは、これがその前の行のコメントですね。

278
00:10:14,720 --> 00:10:16,823
二乗誤差を計算します。これは、

279
00:10:16,823 --> 00:10:18,637
predictions と y の

280
00:10:18,640 --> 00:10:20,265
値の差をとって

281
00:10:20,265 --> 00:10:22,126
それを要素単位で二乗します。

282
00:10:22,140 --> 00:10:24,376
最後に、目的関数

283
00:10:24,376 --> 00:10:26,128
J を計算します。Octave は

284
00:10:26,128 --> 00:10:27,439
J が私の

285
00:10:27,439 --> 00:10:31,383
戻したい値であるのを知っています。なぜなら、J はここ関数定義に出ているからです。

286
00:10:31,420 --> 00:10:34,127
ところで、いつでも遠慮なく

287
00:10:34,170 --> 00:10:35,292
このビデオを停止して

288
00:10:35,292 --> 00:10:36,712
この関数定義を

289
00:10:36,712 --> 00:10:38,820
じっくり見て、

290
00:10:38,820 --> 00:10:44,031
それぞれのステップをちゃんと理解してください。

291
00:10:44,031 --> 00:10:45,184
これを Octave 内で

292
00:10:45,184 --> 00:10:46,630
実行するには、J =

293
00:10:46,630 --> 00:10:51,197
cost function J(x, y, theta) を実行します。

294
00:10:51,197 --> 00:10:55,142
すると、演算が実行され、おっと、ここが打ち間違いです

295
00:10:55,142 --> 00:10:57,018
大文字の X でした。すると

296
00:10:57,018 --> 00:11:00,472
計算が実行され、J = 0 となります。

297
00:11:00,510 --> 00:11:03,367
なぜなら、データセットが

298
00:11:03,367 --> 00:11:06,963
1、2、3、1、2、3 なので、theta 0 は

299
00:11:06,980 --> 00:11:08,741
= 0、theta 1 =

300
00:11:08,770 --> 00:11:11,259
1 とすると、これは丁度

301
00:11:11,259 --> 00:11:15,559
このデータセットに完全に一致する45度の線になります。

302
00:11:15,600 --> 00:11:16,887
一方、対照的に、もし

303
00:11:16,887 --> 00:11:19,828
theta を仮に =[0, 0] とした場合、

304
00:11:19,830 --> 00:11:22,524
この仮説は

305
00:11:22,540 --> 00:11:24,050
全てに対して同じく 0 と予測します。

306
00:11:24,050 --> 00:11:25,803
theta 0 = 0、

307
00:11:25,810 --> 00:11:27,139
theta1 = 0 そして

308
00:11:27,139 --> 00:11:29,345
目的関数を計算すると

309
00:11:29,370 --> 00:11:31,830
答えは 2.333となり、それは

310
00:11:31,830 --> 00:11:35,495
実は = 1^2

311
00:11:35,520 --> 00:11:36,745
これは最初のサンプルの

312
00:11:36,745 --> 00:11:39,789
二乗誤差、+ 2^2

313
00:11:39,800 --> 00:11:42,377
+ 3^2 そして次に

314
00:11:42,440 --> 00:11:45,288
/(2*m) これは

315
00:11:45,288 --> 00:11:47,091
訓練データのサンプル数の二倍です。

316
00:11:47,091 --> 00:11:50,643
そしてその結果は確かに 2.33 になります。

317
00:11:50,643 --> 00:11:53,289
この要所確認により、

318
00:11:53,330 --> 00:11:54,909
この関数は、

319
00:11:54,909 --> 00:11:56,302
正しい目的関数を計算しているということが

320
00:11:56,302 --> 00:11:58,212
分かります。そしてここまでで

321
00:11:58,250 --> 00:12:00,222
シンプルな訓練サンプルを使っていくつか例を

322
00:12:00,222 --> 00:12:03,433
試してみたわけです。

323
00:12:03,490 --> 00:12:04,914
この要所確認は

324
00:12:04,960 --> 00:12:08,689
目的関数 J が

325
00:12:08,720 --> 00:12:10,202
ここに定義されているように

326
00:12:10,230 --> 00:12:12,992
確かに正しい

327
00:12:12,992 --> 00:12:14,908
目的関数を演算しているかどうかを確認します。

328
00:12:14,920 --> 00:12:17,424
そしてこれが先ほど使った

329
00:12:17,430 --> 00:12:18,835
簡単な訓練セット X

330
00:12:18,835 --> 00:12:20,823
と Y で、これが

331
00:12:20,823 --> 00:12:25,189
いま見た簡単な訓練データの例です。

332
00:12:25,230 --> 00:12:26,285
ここまでのところで、

333
00:12:26,285 --> 00:12:28,171
Octave において、for ループ、

334
00:12:28,171 --> 00:12:29,838
while ループ、if 文などの制御文の書き方、

335
00:12:29,838 --> 00:12:33,197
および関数の定義の仕方と使いかたがご理解いただけたと思います。

336
00:12:33,197 --> 00:12:34,530
次のビデオでは、

337
00:12:34,530 --> 00:12:36,123
非常に手短に、

338
00:12:36,123 --> 00:12:38,144
このクラスで課題に

339
00:12:38,144 --> 00:12:39,873
取り組んで提出する

340
00:12:39,873 --> 00:12:41,664
手順を順番に紹介し、

341
00:12:41,664 --> 00:12:45,212
提出用システムをどのように使うか説明します。

342
00:12:45,230 --> 00:12:46,794
そして最後に、その後で、

343
00:12:46,794 --> 00:12:48,856
最後の Octave チュートリアル ビデオでは

344
00:12:48,856 --> 00:12:51,400
ベクトル化についてお話します。

345
00:12:51,400 --> 00:12:52,938
これは Octave プログラムの実行速度を

346
00:12:52,938 --> 00:12:56,126
高速化する手法です。