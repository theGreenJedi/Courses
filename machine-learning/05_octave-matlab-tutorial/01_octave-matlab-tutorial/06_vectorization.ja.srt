1
00:00:00,320 --> 00:00:03,682
このビデオでは、ベクトル化という概念について説明します。

2
00:00:03,682 --> 00:00:08,380
Octave や類似した言語

3
00:00:08,380 --> 00:00:12,540
MATLAB を使っていても、

4
00:00:12,540 --> 00:00:17,470
あるいは Python および NumPy

5
00:00:17,470 --> 00:00:21,840
あるいは Java、C、C++ を使っていても、

6
00:00:21,840 --> 00:00:24,400
これら全ての言語は、

7
00:00:24,400 --> 00:00:29,250
既に内蔵されているか、

8
00:00:29,250 --> 00:00:32,070
あるいは、すぐに簡単に入手可能な異なる

9
00:00:32,070 --> 00:00:35,590
数値線型代数ライブラリがあります。

10
00:00:35,590 --> 00:00:39,880
通常、これらは非常によく書かれており、

11
00:00:39,880 --> 00:00:44,510
高度に最適化され、多くの場合、

12
00:00:44,510 --> 00:00:48,470
数値計算の分野で博士号を持つか、

13
00:00:48,470 --> 00:00:51,970
数値計算に本当に特化した人たちによって開発されています。

14
00:00:51,970 --> 00:00:53,170
機械学習アルゴリズムを

15
00:00:53,170 --> 00:00:58,120
実装する時に、こうした

16
00:00:58,120 --> 00:01:03,080
線型代数ライブラリ、こうした

17
00:01:03,080 --> 00:01:07,330
数値線型代数を

18
00:01:07,330 --> 00:01:08,540
活用し、

19
00:01:08,540 --> 00:01:13,450
これらのルーチンを呼び出すことにより、

20
00:01:13,450 --> 00:01:18,170
こうしたライブラリができることを

21
00:01:18,170 --> 00:01:22,220
自分でコードに書く代わりに使えれば、

22
00:01:22,220 --> 00:01:26,090
そうすれば

23
00:01:26,090 --> 00:01:30,310
多くの場合、コードは第一にもっと効率的になります。

24
00:01:30,310 --> 00:01:31,470
ということはもっと実行速度が速くなり、

25
00:01:33,090 --> 00:01:36,110
お手持ちのコンピュータに

26
00:01:36,110 --> 00:01:40,010
搭載されているかもしれない並列処理ハードウェアを

27
00:01:40,010 --> 00:01:46,660
をさらに利用できるようになります。

28
00:01:46,660 --> 00:01:51,920
そして二番目に、これは

29
00:01:51,920 --> 00:01:56,330
書かなければならないコードの量が少なくなることも意味します。

30
00:01:56,330 --> 00:02:03,220
つまり、実装が簡素になり、

31
00:02:03,220 --> 00:02:07,221
さらに、そのために、バグも少なくなる可能性があります。

32
00:02:07,221 --> 00:02:11,632
そして、具体的な例として、

33
00:02:11,632 --> 00:02:17,590
行列の乗算をするのに

34
00:02:17,590 --> 00:02:18,820
自分でコードを書く代わりに、

35
00:02:18,820 --> 00:02:23,623
Octave にそれをやらせて

36
00:02:23,623 --> 00:02:25,360
a * b と入力すると、

37
00:02:25,360 --> 00:02:30,160
それは非常に効率的な

38
00:02:30,160 --> 00:02:36,057
ルーチンを使って二つの行列の乗算を行います。

39
00:02:36,057 --> 00:02:42,320
そして、こうした例は他にもいくつもあり、

40
00:02:42,320 --> 00:02:44,740
適切なベクトル化された実装方法を採用することで

41
00:02:44,740 --> 00:02:45,736
コードが簡素になり、さらにもっと効率的なコードになります。

42
00:02:45,736 --> 00:02:51,100
では、いくつか例を見てみましょう。

43
00:02:51,100 --> 00:02:53,270
ここに、通常の線形回帰

44
00:02:53,270 --> 00:02:58,543
の仮説があります。

45
00:02:58,543 --> 00:03:03,557
h(x) を計算したい場合は、

46
00:03:03,557 --> 00:03:08,570
お気づきのように右辺では合計を行うことになります。

47
00:03:08,570 --> 00:03:13,411
一つのやり方は、

48
00:03:13,411 --> 00:03:18,620
j=0 から j=n までの

49
00:03:18,620 --> 00:03:25,480
合計を自分で計算することです。

50
00:03:25,480 --> 00:03:30,286
もう一つの考え方は、

51
00:03:30,286 --> 00:03:33,940
h(x) を

52
00:03:33,940 --> 00:03:39,251
theta の転置行列と x との乗算と見なすことです。

53
00:03:39,251 --> 00:03:43,290
ここで出来ることは

54
00:03:43,290 --> 00:03:46,620
二つのベクトルの

55
00:03:46,620 --> 00:03:48,150
内積を計算することだと考えるのです。

56
00:03:48,150 --> 00:03:52,077
ここでは theta は、そうですね

57
00:03:52,077 --> 00:03:54,620
二つの特徴がある場合、ベクトルは

58
00:03:54,620 --> 00:03:57,764
theta 0、theta 1、theta 2 となります。

59
00:03:57,764 --> 00:04:02,604
その場合は n = 2 です。

60
00:04:02,604 --> 00:04:07,823
そして x はこのような

61
00:04:07,823 --> 00:04:13,250
ベクトルになります x 0、x 1、x 2

62
00:04:15,850 --> 00:04:17,590
そしてこの二つの見方は、

63
00:04:17,590 --> 00:04:22,080
二通りの実装方法につながります。

64
00:04:22,080 --> 00:04:24,740
その意味は次の通りです。

65
00:04:24,740 --> 00:04:27,820
ここに非ベクトル化の

66
00:04:27,820 --> 00:04:31,468
h(x) の演算方法の実装があります。

67
00:04:31,468 --> 00:04:35,650
非ベクトル化とは、ベクトル化されていない、という意味です。

68
00:04:35,650 --> 00:04:40,598
最初に prediction を 0.0 に初期化します。

69
00:04:40,598 --> 00:04:42,620
これは、そのうちに

70
00:04:42,620 --> 00:04:47,720
prediction は、そのうちに

71
00:04:47,720 --> 00:04:50,950
h(x) になります。そして

72
00:04:54,410 --> 00:04:59,000
prediction は、そのうちに

73
00:04:59,000 --> 00:05:02,500
j = 1 から n+1 とします。

74
00:05:02,500 --> 00:05:06,540
prediction は

75
00:05:06,540 --> 00:05:11,230
theta(j) * x(j) でインクリメントされます

76
00:05:11,230 --> 00:05:17,540
これは、ちょうどこの式に相当します。

77
00:05:17,540 --> 00:05:22,270
ところで、触れておくべき点として、ここにある

78
00:05:22,270 --> 00:05:26,380
右上のベクトルですが、

79
00:05:26,380 --> 00:05:30,390
ここでは インデックスを 0 から始めています。

80
00:05:30,390 --> 00:05:32,880
ですから、theta 0、theta 1

81
00:05:32,880 --> 00:05:35,800
theta 2、としていました。しかし、MATLAB では

82
00:05:35,800 --> 00:05:39,290
インデックスは 1 から始まるので、theta 0 を

83
00:05:40,660 --> 00:05:43,590
MATLAB では表現方法を

84
00:05:43,590 --> 00:05:45,840
変えて theta 1 とし、

85
00:05:45,840 --> 00:05:48,260
この二番目の要素は

86
00:05:48,260 --> 00:05:55,070
theta 2 になり

87
00:05:55,070 --> 00:05:59,575
三番目の要素は

88
00:05:59,575 --> 00:06:03,410
theta 3 となります。

89
00:06:03,410 --> 00:06:08,377
これは単に MATLAB では

90
00:06:08,377 --> 00:06:13,230
ベクトルのインデックスは

91
00:06:14,850 --> 00:06:19,580
1 から始まるのに対し、私たちの

92
00:06:20,754 --> 00:06:24,120
本来の theta および x は

93
00:06:24,120 --> 00:06:28,110
0 からインデックスが始まるからです。

94
00:06:28,110 --> 00:06:35,500
これが理由で、ここの for ループでは

95
00:06:35,500 --> 00:06:39,570
j は 1 から n+1 に進み、

96
00:06:39,570 --> 00:06:43,830
j が 0 から n へは進まない

97
00:06:43,830 --> 00:06:48,540
のです。お分かり頂けましたか。

98
00:06:48,540 --> 00:06:50,070
ということで、これは

99
00:06:50,070 --> 00:06:54,220
ここに非ベクトル化の実装方法で、

100
00:06:54,220 --> 00:06:55,500
n 要素の合計を行うのに

101
00:06:55,500 --> 00:06:58,538
for ループを使っています。

102
00:06:58,538 --> 00:07:03,458
それとは対照的に、これが

103
00:07:03,458 --> 00:07:08,090
ここにベクトル化された実装方法の書き方、

104
00:07:08,090 --> 00:07:12,723
つまり、

105
00:07:12,723 --> 00:07:18,511
x および theta

106
00:07:18,511 --> 00:07:21,740
ベクトルとして考え、

107
00:07:21,740 --> 00:07:28,100
prediction に theta の転置行列と

108
00:07:28,100 --> 00:07:29,840
x との乗算を代入します。このようにして計算します。

109
00:07:31,310 --> 00:07:34,920
for ループを使ってこうした何行もの

110
00:07:34,920 --> 00:07:38,170
コードを書く代わりに

111
00:07:38,170 --> 00:07:43,610
たったの一行の

112
00:07:43,610 --> 00:07:50,080
コードで済みます。そして

113
00:07:50,080 --> 00:07:54,920
この右の一行のコードが

114
00:07:54,920 --> 00:07:58,380
実行するのは、

115
00:07:58,380 --> 00:08:04,270
Octave の高度に最適化された数値

116
00:08:04,270 --> 00:08:06,580
線形代数ルーチンを使って

117
00:08:06,580 --> 00:08:10,959
二つのベクトルtheta および x の

118
00:08:10,959 --> 00:08:17,040
内積を算出します。

119
00:08:17,040 --> 00:08:22,066
単にベクトル化された実装の方が

120
00:08:22,066 --> 00:08:27,570
簡素なだけでなく、より効率的に実行されます。

121
00:08:27,570 --> 00:08:32,203
さて、これは Octave でしたが、

122
00:08:32,203 --> 00:08:37,288
ベクトル化は

123
00:08:37,288 --> 00:08:42,730
他のプログラミング言語でも適用可能です。

124
00:08:42,730 --> 00:08:48,621
では C++ の例をみてみましょう。

125
00:08:48,621 --> 00:08:53,964
ここに非ベクトル化の実装例があります。

126
00:08:53,964 --> 00:08:58,360
ここでも prediction を0.0 に初期化し

127
00:08:58,360 --> 00:09:01,352
そしてこの場合は

128
00:09:01,352 --> 00:09:04,010
ループが j=0 から n の範囲となります。

129
00:09:04,010 --> 00:09:09,930
prediction +=

130
00:09:09,930 --> 00:09:15,782
theta[j] * x[j]; ここでも

131
00:09:15,782 --> 00:09:19,772
また、この 明示的な for ループを自分で書くことになります。

132
00:09:19,772 --> 00:09:24,427
対照的に、C++ でもよい

133
00:09:24,427 --> 00:09:29,481
数値線型代数ライブラリを

134
00:09:29,481 --> 00:09:34,136
使うと、ここでもこのような

135
00:09:34,136 --> 00:09:38,150
関数を書くことができます。いえ、むしろ

136
00:09:38,150 --> 00:09:44,142
対照的に、C++ でもよい

137
00:09:44,142 --> 00:09:49,504
数値線型代数ライブラリを

138
00:09:49,504 --> 00:09:54,707
使うと、代わりに

139
00:09:54,707 --> 00:10:00,700
次のようなコードを書くことができます。

140
00:10:00,700 --> 00:10:06,080
お使いの数値線型代数

141
00:10:06,080 --> 00:10:10,041
ライブラリにより

142
00:10:10,041 --> 00:10:15,100
詳細は異なりますが

143
00:10:15,100 --> 00:10:19,990
オブジェクトとして

144
00:10:19,990 --> 00:10:23,760
c++ オブジェクトとして

145
00:10:23,760 --> 00:10:30,680
ベクトル theta と c++

146
00:10:30,680 --> 00:10:34,760
オブジェクトとしてベクトル x が定義され、

147
00:10:34,760 --> 00:10:36,470
そして単に theta

148
00:10:36,470 --> 00:10:40,530
.transpose() に対して x の乗算を行います。

149
00:10:40,530 --> 00:10:42,940
この乗算演算子は、C++ で

150
00:10:42,940 --> 00:10:49,740
オーバーロードされた演算子となり、

151
00:10:49,740 --> 00:10:54,370
C++ でも単に二つのベクトルを乗算することが出来ます。

152
00:10:54,370 --> 00:10:59,213
そしてお使いの数値線型代数

153
00:10:59,213 --> 00:11:04,244
ライブラリの詳細次第では、

154
00:11:04,244 --> 00:11:09,739
多少異なる構文を

155
00:11:09,739 --> 00:11:14,580
使うことになるかもしれませんが

156
00:11:14,580 --> 00:11:20,670
ライブラリを利用して

157
00:11:22,240 --> 00:11:27,592
この内積を行うことにより

158
00:11:27,592 --> 00:11:32,800
コードを非常に簡素化でき、

159
00:11:32,800 --> 00:11:35,920
さらにそれは非常に効率的なものになります。

160
00:11:35,920 --> 00:11:41,050
ではさらに詳細な例を見てみましょう。

161
00:11:41,050 --> 00:11:44,610
念のため、ここに

162
00:11:44,610 --> 00:11:46,670
線形回帰の場合の

163
00:11:47,980 --> 00:11:51,940
最急降下法の更新ルールがあります。

164
00:11:51,940 --> 00:11:57,010
ですから theta j をこの

165
00:11:57,010 --> 00:12:02,590
ルールを使って全ての j の値で更新します。 j=0、1、2、という風に。

166
00:12:02,590 --> 00:12:08,435
そして、これを

167
00:12:08,435 --> 00:12:12,870
theta 0、 theta 1、 theta 2

168
00:12:12,870 --> 00:12:18,430
を使って式で表すとこうなります。

169
00:12:18,430 --> 00:12:21,960
特徴の数が二つであるという前提です。

170
00:12:21,960 --> 00:12:26,560
ですから n=2 です。

171
00:12:26,560 --> 00:12:31,420
よって、これが私たちが theta 0、

172
00:12:31,420 --> 00:12:36,000
theta 1、theta 2 に実行する更新です。

173
00:12:37,010 --> 00:12:41,630
そして、私が前のビデオで

174
00:12:41,630 --> 00:12:44,030
言ったことを覚えていれば、

175
00:12:44,030 --> 00:12:47,230
これは同時更新でなければなりません。

176
00:12:47,230 --> 00:12:50,620
では、これの

177
00:12:50,620 --> 00:12:53,839
ベクトル化された実装が

178
00:12:53,839 --> 00:12:58,610
できるか試してみましょう。

179
00:12:58,610 --> 00:13:03,142
ここに、先ほどと同じ三つの式が

180
00:13:03,142 --> 00:13:08,710
やや小さめのフォントで表示されています。

181
00:13:08,710 --> 00:13:13,210
想像できることは、この三行のコードを

182
00:13:13,210 --> 00:13:17,915
実装するのに

183
00:13:17,915 --> 00:13:19,650
思いつくやり方の一つは、

184
00:13:19,650 --> 00:13:23,140
for ループを使って、そう

185
00:13:23,140 --> 00:13:27,465
ですね、for j = 0;

186
00:13:27,465 --> 00:13:31,500
1 から 2 で theta j を

187
00:13:31,500 --> 00:13:34,220
更新、とかそのようなやり方です。

188
00:13:34,220 --> 00:13:37,860
しかしその代わりに、

189
00:13:37,860 --> 00:13:41,820
ベクトル化された実装を考え出して、もっと簡素化できるか見てみましょう。

190
00:13:41,820 --> 00:13:45,110
つまり、基本的には、これらの三行のコード

191
00:13:45,110 --> 00:13:47,700
というか、この三つのステップを実質的に一ステップごとに処理する