1
00:00:00,090 --> 00:00:02,346
이제 여러분은 기계 학습에 대해 많은 것을 알고있습니다.

2
00:00:02,390 --> 00:00:03,635
저는 이 비디오에서

3
00:00:03,635 --> 00:00:05,448
여러분에게 프로그래밍 언어

4
00:00:05,470 --> 00:00:06,718
Octave를 가르치려고 합니다.

5
00:00:06,760 --> 00:00:08,878
여러분은 Octave로

6
00:00:08,890 --> 00:00:10,259
이미 본 학습 알고리즘과

7
00:00:10,259 --> 00:00:11,770
앞으로 이 수업에서 볼 학습 알고리즘을

8
00:00:11,770 --> 00:00:14,872
매우 빠르게 구현할 수 있습니다.

9
00:00:14,900 --> 00:00:16,381
이전에, 다른 많은 많은 프로그래밍 언어들을 사용해

10
00:00:16,381 --> 00:00:19,497
기계 학습을 가르치려고 노력했었습니다

11
00:00:19,500 --> 00:00:22,046
C++ 자바를 포함해

12
00:00:22,825 --> 00:00:25,379
파이썬, Numpy

13
00:00:25,379 --> 00:00:27,128
Octave 또한 있었습니다.

14
00:00:27,160 --> 00:00:28,783
학생들이 Octave 같이 상대적으로 고수준의 언어를 사용해

15
00:00:28,790 --> 00:00:30,535
가장 생산적으로 배우고

16
00:00:30,570 --> 00:00:32,497
가장 빠르게 배우고

17
00:00:32,497 --> 00:00:33,780
알고리즘의 프로토타입을

18
00:00:33,780 --> 00:00:35,569
가장 빠르게 만들 수 있다는 것을

19
00:00:35,569 --> 00:00:38,262
발견했습니다.

20
00:00:38,290 --> 00:00:39,798
사실, 제가 자주

21
00:00:39,798 --> 00:00:41,516
실리콘 벨리에서 봤던 것은

22
00:00:41,520 --> 00:00:43,655
알고리즘을 구축해야 하는 경우에도

23
00:00:43,655 --> 00:00:44,714
만약 큰 규모의 학습 알고리즘을

24
00:00:44,740 --> 00:00:46,548
구축하려고 한다면

25
00:00:46,610 --> 00:00:48,242
사람들은 흔히 프로토 타입을 만듭니다

26
00:00:48,242 --> 00:00:50,637
그리고 언어는 Octave를 사용합니다.

27
00:00:50,660 --> 00:00:52,200
Octave는 프로토타입 하기에 훌륭한 언어입니다.

28
00:00:52,210 --> 00:00:55,264
그래서 학습 알고리즘을 빠르게 구현할 수 있습니다.

29
00:00:55,270 --> 00:00:56,629
매우 큰 규모의 학습 알고리즘이

30
00:00:56,629 --> 00:00:58,459
필요한 경우에만

31
00:00:58,480 --> 00:01:00,362
C++, 자바 또는 이와 같은 언어로

32
00:01:00,362 --> 00:01:03,059
알고리즘을 재구현 하는데

33
00:01:03,059 --> 00:01:05,150
시간을 쓰세요.

34
00:01:05,160 --> 00:01:06,273
왜냐하면 지금까지 배운 교훈은

35
00:01:06,300 --> 00:01:08,679
프로그래밍 시간 또는 개발 시간

36
00:01:08,710 --> 00:01:09,848
즉 당신의 시간은

37
00:01:09,870 --> 00:01:13,309
기계 학습에서 시간은 매우 소중합니다

38
00:01:13,320 --> 00:01:15,101
만약에 Octave로

39
00:01:15,101 --> 00:01:17,898
학습 알고리즘을 더 빠르게 작동시킬 수 있다면.

40
00:01:17,898 --> 00:01:18,932
알고리즘의 첫 개발을

41
00:01:18,932 --> 00:01:20,697
Octave에서 함으로

42
00:01:20,720 --> 00:01:22,143
전체적으로 많은 시간을 아끼게 됩니다

43
00:01:22,150 --> 00:01:23,971
그리고 그 알고리즘 아이디어가 작동한 다음에

44
00:01:23,971 --> 00:01:28,145
C++ 자바 로 구현합니다.

45
00:01:28,160 --> 00:01:30,238
제가 본 기계학습에서 쓰이는

46
00:01:30,238 --> 00:01:31,538
가장 일반적인 프로토타입 언어는

47
00:01:31,560 --> 00:01:34,058
Octave, MATLAB,

48
00:01:34,070 --> 00:01:37,230
파이썬, NumPy, R 입니다.

49
00:01:38,150 --> 00:01:40,032
Octave는 오픈소스기 때문에 좋습니다.

50
00:01:40,032 --> 00:01:42,660
MATLAB도 잘 되긴 하지만

51
00:01:42,670 --> 00:01:44,656
많은 사람들에게

52
00:01:44,656 --> 00:01:45,956
비쌉니다.

53
00:01:45,960 --> 00:01:47,972
MATLAB를 사용할 수 있으시다면

54
00:01:47,988 --> 00:01:50,095
강의에서 MATLAB도 사용할 수 있습니다.

55
00:01:50,110 --> 00:01:52,037
파이썬이나 NumPy 또는 R을 알고있다면

56
00:01:52,037 --> 00:01:54,853
몇몇 사람들이 그걸 쓰는걸 봤습니다만

57
00:01:54,870 --> 00:01:56,353
이 사람들은 결국엔 보통

58
00:01:56,360 --> 00:01:57,739
더 느리게 개발합니다

59
00:01:57,760 --> 00:02:00,041
왜냐하면

60
00:02:00,050 --> 00:02:02,121
이 언어들,

61
00:02:02,121 --> 00:02:04,048
파이썬, NumPy 문법이

62
00:02:04,048 --> 00:02:08,391
Octave 문법 보다 투박하기 때문입니다.

63
00:02:08,410 --> 00:02:09,704
그리고 이것 때문에

64
00:02:09,704 --> 00:02:11,372
처음에 코드를 쓰는데

65
00:02:11,380 --> 00:02:13,039
Octave를 사용합니다.

66
00:02:13,039 --> 00:02:14,363
이 수업에 따르는 연습을

67
00:02:14,363 --> 00:02:18,321
Numpy와 R에서 하려고 노력하지 않기를 강력히 추천합니다.

68
00:02:18,330 --> 00:02:19,805
하지만 대신에 이 수업에 있는

69
00:02:19,805 --> 00:02:21,498
프로그래밍 연습을 Octave에서 하기를

70
00:02:21,520 --> 00:02:24,292
추천합니다.

71
00:02:24,330 --> 00:02:25,428
이번 비디오에서

72
00:02:25,428 --> 00:02:26,708
명령어들을 매우 빠르게

73
00:02:26,708 --> 00:02:28,667
훑어 보려고 합니다

74
00:02:28,667 --> 00:02:29,879
명령어의 범위와

75
00:02:29,879 --> 00:02:31,073
Octave에서 할 수 있는 것들을

76
00:02:31,080 --> 00:02:34,807
빠르게 보여주는 것이 목표입니다.

77
00:02:34,807 --> 00:02:36,493
강의 사이트에는

78
00:02:36,520 --> 00:02:38,965
제가 하는 모든 것의

79
00:02:38,965 --> 00:02:42,095
스크립트가 있습니다.

80
00:02:42,095 --> 00:02:43,185
그리고 비디오를 다 본 뒤에

81
00:02:43,185 --> 00:02:44,905
명령어를 찾고 싶으면

82
00:02:44,905 --> 00:02:46,635
스크립트를 참고할 수 있습니다

83
00:02:46,635 --> 00:02:48,247
스크립트를 참고할 수 있습니다

84
00:02:48,247 --> 00:02:50,226
구체적으로, 처음에 비디오를 보는 것을

85
00:02:50,226 --> 00:02:53,225
추천합니다.

86
00:02:53,230 --> 00:02:55,118
끝까지 보고 나서

87
00:02:55,120 --> 00:02:58,728
Octave를 컴퓨터에 설치하세요.

88
00:02:58,728 --> 00:02:59,738
끝으로, 강의 사이트에 들어가서

89
00:02:59,738 --> 00:03:01,769
세션에서 본 스크립트를 다운받고

90
00:03:01,770 --> 00:03:02,983
흥미로워보이는 명령어들을

91
00:03:02,983 --> 00:03:04,915
어떤 것이든

92
00:03:04,930 --> 00:03:07,162
컴퓨터에서 실행되도록

93
00:03:07,200 --> 00:03:09,132
쳐보세요

94
00:03:09,132 --> 00:03:10,602
그러면

95
00:03:10,602 --> 00:03:12,962
실행되는 것을 볼 수 있습니다.

96
00:03:12,970 --> 00:03:15,535
그럼 시작해보겠습니다.

97
00:03:15,920 --> 00:03:19,363
여기 제 윈도우 데스크탑이 있고 Octave를 실행하겠습니다.

98
00:03:19,370 --> 00:03:20,977
Octave 창에 있습니다.

99
00:03:20,977 --> 00:03:22,522
이것이 저의 Octave 프롬포트 창입니다.

100
00:03:22,522 --> 00:03:24,475
처음에 기초적인 것들을 보여드리겠습니다.

101
00:03:24,475 --> 00:03:27,291
Octave에서 기초 연산을 할 수 있습니다

102
00:03:27,330 --> 00:03:28,505
5 + 6 을 타이핑하면

103
00:03:28,505 --> 00:03:30,493
답인 11을 보여줍니다.

104
00:03:30,493 --> 00:03:31,516
3-2.

105
00:03:31,540 --> 00:03:33,710
5 × 8, 1/2, 2 ^ 6

106
00:03:35,733 --> 00:03:37,747
는 64 입니다.

107
00:03:37,810 --> 00:03:42,361
이것은 기초적인 수학 연산입니다.

108
00:03:42,390 --> 00:03:44,495
논리 연산도 할 수 있습니다.

109
00:03:44,550 --> 00:03:45,929
1은 2와 같다.

110
00:03:45,929 --> 00:03:47,722
이것은 거짓입니다.

111
00:03:47,722 --> 00:03:51,658
퍼센트 명령어는 여기서 주석을 의미합니다.

112
00:03:51,658 --> 00:03:53,861
1은 2와 같다 는 거짓이고

113
00:03:53,861 --> 00:03:55,622
0으로 나타냅니다.

114
00:03:55,650 --> 00:03:58,028
1은 2와 같지 않다.

115
00:03:58,028 --> 00:03:59,312
이것은 참입니다.

116
00:03:59,312 --> 00:04:00,718
그래서 1을 반환합니다.

117
00:04:00,718 --> 00:04:02,146
여기서 같지 않다는 부호는

118
00:04:02,146 --> 00:04:05,478
물결 등호로 표시합니다

119
00:04:05,550 --> 00:04:07,336
다른 프로그래밍 언어에서

120
00:04:07,336 --> 00:04:09,267
같지 않다로 사용하는 느낌표 등호는

121
00:04:09,267 --> 00:04:10,878
같지 않다가 아닙니다

122
00:04:10,910 --> 00:04:13,616
1과 0이 있는 논리 연산을 살펴보겠습니다

123
00:04:13,616 --> 00:04:15,545
논리연산 AND에

124
00:04:15,545 --> 00:04:17,340
두 개의 &기호를 사용합니다.

125
00:04:18,120 --> 00:04:20,188
거짓으로 평가합니다.

126
00:04:20,188 --> 00:04:23,886
1 또는 0은 OR 연산입니다.

127
00:04:23,900 --> 00:04:25,736
참으로 평가합니다.

128
00:04:25,736 --> 00:04:27,131
0과 1을 XOR 연산 할 수 있습니다.

129
00:04:27,131 --> 00:04:30,333
1로 평가합니다

130
00:04:30,333 --> 00:04:32,928
왼쪽에 있는 Octave 324 exe 는 11과 같습니다

131
00:04:32,928 --> 00:04:35,683
이것은 Octave 기본 프롬포트입니다.

132
00:04:35,700 --> 00:04:37,513
Octave 버전과 기타 정보를

133
00:04:37,520 --> 00:04:39,150
보여줍니다.

134
00:04:39,150 --> 00:04:40,423
이 프롬포트가 마음에 들지 않으면

135
00:04:40,450 --> 00:04:43,025
PS, 따옴표, 부등호, 부등호,

136
00:04:43,025 --> 00:04:44,670
따옴표로 된

137
00:04:44,670 --> 00:04:46,602
숨겨진 명령어가 있습니다.

138
00:04:46,602 --> 00:04:48,800
이것으로 프롬포트를 바꿀 수 있습니다.

139
00:04:48,810 --> 00:04:51,272
제가 알기론 이 명령어는 중간에 있는 문자열을 가져옵니다.

140
00:04:51,272 --> 00:04:53,362
따옴표, 부등호, 부등호, 공백

141
00:04:53,400 --> 00:04:55,592
저는 이런 Octave 프롬포트를 더 좋아합니다.

142
00:04:55,592 --> 00:04:57,722
자 엔터를 누르면

143
00:04:57,920 --> 00:04:59,763
죄송합니다.

144
00:04:59,763 --> 00:05:00,786
이렇게.

145
00:05:00,786 --> 00:05:02,622
PS1 으로

146
00:05:02,622 --> 00:05:05,420
이제 제 Octave 프롬포트가 부등호 부등호 기호로 바뀌었습니다.

147
00:05:05,500 --> 00:05:09,263
조금 더 나아 보입니다.

148
00:05:09,710 --> 00:05:12,384
다음으로, Octave 변수에 대해 이야기 해 봅시다.

149
00:05:12,384 --> 00:05:13,865
변수 A를 가져와서

150
00:05:13,865 --> 00:05:16,165
3을 할당하고

151
00:05:16,165 --> 00:05:18,421
엔터를 누릅니다.

152
00:05:18,440 --> 00:05:20,043
이제 A는 3과 같습니다.

153
00:05:20,070 --> 00:05:22,861
변수를 할당하고 싶지만 결과를 출력하고 싶지는 않습니다.

154
00:05:22,861 --> 00:05:26,758
세미콜론을 넣으면

155
00:05:26,920 --> 00:05:30,824
세미콜론은 결과를 출력하는 것을 막습니다.

156
00:05:30,824 --> 00:05:33,160
그래서 이렇게 하고 엔터를 누르면 아무것도 출력하지 않습니다.

157
00:05:33,160 --> 00:05:35,399
A = 3을 하면

158
00:05:35,420 --> 00:05:36,719
출력합니다.

159
00:05:36,719 --> 00:05:39,845
A = 3; 은 아무것도 출력하지 않습니다.

160
00:05:39,850 --> 00:05:41,845
문자열도 할당할 수 있습니다.

161
00:05:41,845 --> 00:05:43,473
B 는 hi와 같고

162
00:05:43,520 --> 00:05:45,047
이제 제가 그냥 엔터를 누르면

163
00:05:45,047 --> 00:05:46,072
변수 B를 출력합니다

164
00:05:46,072 --> 00:05:48,338
B는 문자열 hi 입니다

165
00:05:48,370 --> 00:05:51,118
C는 3>=1 입니다

166
00:05:51,130 --> 00:05:54,538
이제 C를 참으로 평가합니다.

167
00:05:55,710 --> 00:05:57,999
변수를 출력하거나 보이고 싶다면

168
00:05:58,030 --> 00:06:00,832
이렇게 하면 됩니다

169
00:06:00,832 --> 00:06:03,725
A를 Pi로 하고

170
00:06:03,760 --> 00:06:04,985
A를 출력하고 싶다면

171
00:06:04,985 --> 00:06:08,545
이렇게 그냥 A를 치면 출력합니다.

172
00:06:08,545 --> 00:06:10,344
더 복잡한 출력을 하기 위해서

173
00:06:10,344 --> 00:06:13,674
출력 표준 명령어인 DISP 또한 존재합니다.

174
00:06:13,710 --> 00:06:15,858
disp A 는 이렇게 A를 그냥 출력합니다

175
00:06:15,890 --> 00:06:18,337
문자열로 출력할 수 있습니다.

176
00:06:18,350 --> 00:06:21,392
자, disp, sprintf

177
00:06:21,460 --> 00:06:24,990
2 decimals, percent 0.2

178
00:06:25,260 --> 00:06:28,273
F , A

179
00:06:28,273 --> 00:06:29,863
이것은 문자열을 출력합니다.

180
00:06:29,863 --> 00:06:31,722
2 decimals, 콜론, 3.14

181
00:06:31,722 --> 00:06:33,651
이건 오래된 C 언어 스타일의

182
00:06:33,670 --> 00:06:35,993
문법입니다

183
00:06:35,993 --> 00:06:37,404
이전에 C 프로그래밍을 해본 적이 있다면

184
00:06:37,420 --> 00:06:39,073
이것은 출력을 하기 위해

185
00:06:39,073 --> 00:06:41,378
필수적인 문법입니다.

186
00:06:41,380 --> 00:06:44,498
Sprintf는

187
00:06:44,510 --> 00:06:46,021
소숫점 두 번째 자리까지 나타낸 3.14

188
00:06:46,021 --> 00:06:48,274
문자열을 생성합니다

189
00:06:48,290 --> 00:06:50,644
%0.2f는

190
00:06:50,644 --> 00:06:52,475
A로 이 부분을 대체하고

191
00:06:52,475 --> 00:06:55,926
소숫점 뒤 두 자리까지 나타냄을 뜻합니다.

192
00:06:55,926 --> 00:06:58,104
그리고 DISP는 Sprintf 명령어에 의해 생성된

193
00:06:58,130 --> 00:07:00,691
문자열을 받습니다.

194
00:07:00,691 --> 00:07:01,683
Sprintf

195
00:07:01,683 --> 00:07:03,091
Sprintf 명령어와 DISP는

196
00:07:03,091 --> 00:07:05,835
실제로 문자열을 출력합니다.

197
00:07:05,870 --> 00:07:07,020
다른 예제를 보여드리겠습니다

198
00:07:07,020 --> 00:07:11,360
Sprintf six decimals

199
00:07:11,361 --> 00:07:14,551
percent 0.6 F , A.

200
00:07:14,930 --> 00:07:17,075
이것은 Pi를

201
00:07:17,090 --> 00:07:21,100
소숫점 아래 6번째 자리까지 출력합니다.

202
00:07:22,060 --> 00:07:25,728
마지막으로, A를 이렇게 출력했었습니다.

203
00:07:25,740 --> 00:07:28,633
format long을 입력하는 유용한 방법이 있습니다.

204
00:07:28,633 --> 00:07:31,759
이것은 문자열을 기본으로 합니다.

205
00:07:31,760 --> 00:07:33,748
더 많은 자릿수가 표시됩니다.

206
00:07:33,748 --> 00:07:35,593
그리고 format short는

207
00:07:35,593 --> 00:07:37,095
작은 수를 출력하는 기본으로

208
00:07:37,120 --> 00:07:40,113
돌아가는 명령어입니다.

209
00:07:40,600 --> 00:07:43,934
좋습니다, 이것이 변수를 다루는 방법입니다.

210
00:07:43,934 --> 00:07:47,047
이제 백터와 행렬을 보겠습니다.

211
00:07:47,070 --> 00:07:49,274
MAT A 에 행렬을 할당하려고 합니다.

212
00:07:49,280 --> 00:07:50,974
예제를 보겠습니다

213
00:07:50,980 --> 00:07:54,593
1 2; 3 4; 5 6;

214
00:07:54,600 --> 00:07:56,235
이것은 3 x 2 행렬 A를 생성합니다

215
00:07:56,240 --> 00:07:58,572
첫 번째 행은 1, 2

216
00:07:58,580 --> 00:07:59,818
두 번째 행은 3 4

217
00:07:59,820 --> 00:08:02,030
세 번째 행은 5 6

218
00:08:02,030 --> 00:08:04,385
세미콜론이 하는 것은 필수적인데

219
00:08:04,390 --> 00:08:05,818
행렬의

220
00:08:05,820 --> 00:08:07,915
다음 행으로 가라는 뜻입니다

221
00:08:07,915 --> 00:08:09,016
이것을 입력하는 다른 방법도 있습니다.

222
00:08:09,016 --> 00:08:11,536
A 1, 2 세미콜론

223
00:08:11,536 --> 00:08:15,046
3, 4 세미콜론 5, 6 계속해서 입력합니다.

224
00:08:15,046 --> 00:08:17,038
이 3 x 2 행렬을

225
00:08:17,038 --> 00:08:18,576
A에 할당하는

226
00:08:18,576 --> 00:08:22,183
다른 방법입니다

227
00:08:22,200 --> 00:08:23,568
마찬가지로 벡터를 할당 할 수 있습니다.

228
00:08:23,568 --> 00:08:25,532
V는 1, 2, 3이 됩니다.

229
00:08:25,560 --> 00:08:27,359
이것은 실제로 행 벡터입니다

230
00:08:27,359 --> 00:08:29,915
또는 3 x 1 벡터입니다.

231
00:08:29,940 --> 00:08:32,016
이건 y 축으로 긴 벡터입니다

232
00:08:32,030 --> 00:08:34,375
죄송합니다.

233
00:08:34,380 --> 00:08:37,998
a는 1 x 3 행렬입니다

234
00:08:37,998 --> 00:08:39,256
3 x 1 아니라

235
00:08:39,256 --> 00:08:41,015
이것을 열 벡터로

236
00:08:41,015 --> 00:08:43,975
만들고 싶다면

237
00:08:43,975 --> 00:08:48,778
대신 v = 1; 2; 3; 를 하면 됩니다.

238
00:08:48,830 --> 00:08:50,030
그러면 3 x 1 행렬을 반환합니다

239
00:08:50,100 --> 00:08:51,797
1 x 3 행렬이 있습니다

240
00:08:51,797 --> 00:08:55,892
이것은 열 벡터입니다.

241
00:08:56,250 --> 00:08:57,968
좀 더 유용한 표기법이 있습니다.

242
00:08:57,968 --> 00:09:02,343
v = 1: 0.1: 2

243
00:09:02,343 --> 00:09:03,598
이것은 v 를

244
00:09:03,620 --> 00:09:05,716
1부터 시작해

245
00:09:05,716 --> 00:09:08,714
2 까지

246
00:09:08,714 --> 00:09:10,392
0.1씩 증가하는 요소들로

247
00:09:10,410 --> 00:09:13,657
설정합니다

248
00:09:13,660 --> 00:09:19,168
그래서 그렇게 하고 나면, V는 이처럼 행 벡터가 됩니다.

249
00:09:19,168 --> 00:09:23,022
이것은 1 x 11 행렬입니다.

250
00:09:23,022 --> 00:09:23,739
1, 1.1, 1.2, 1.3 이고

251
00:09:23,739 --> 00:09:26,921
2가 될 때 까지

252
00:09:27,630 --> 00:09:30,141
계속됩니다.

253
00:09:31,440 --> 00:09:33,269
이제, v를 1;6 로

254
00:09:33,269 --> 00:09:35,049
설정할 수 있습니다.

255
00:09:35,060 --> 00:09:38,270
그러면 v를 1 부터 6 까지 숫자로

256
00:09:38,270 --> 00:09:41,291
설정합니다, 좋습니다.

257
00:09:41,620 --> 00:09:44,254
이제 행렬을 만드는 다른 방법이 있습니다.

258
00:09:44,254 --> 00:09:47,426
ones 2.3은

259
00:09:47,426 --> 00:09:49,134
모든 요소가 1인

260
00:09:49,140 --> 00:09:50,790
2 x 3 행렬을 생성하는

261
00:09:50,790 --> 00:09:52,712
명령어입니다.

262
00:09:52,712 --> 00:09:53,991
c 를 ones 2.3

263
00:09:54,000 --> 00:09:56,845
곱하기 2로 설정하면

264
00:09:56,845 --> 00:09:59,798
모든 요소가 2인

265
00:09:59,798 --> 00:10:03,061
2 x 3 행렬을 생성합니다.

266
00:10:03,080 --> 00:10:04,258
이것을

267
00:10:04,258 --> 00:10:05,513
c = 2, 2, 2; 2, 2, 2를

268
00:10:05,550 --> 00:10:06,943
선언하는 간략한 방법이라고 생각할 수 있습니다.

269
00:10:06,943 --> 00:10:10,951
이것은 같은 결과를 반환합니다.

270
00:10:11,450 --> 00:10:13,910
w를

271
00:10:13,920 --> 00:10:15,485
ones 1. 3로 하면

272
00:10:15,485 --> 00:10:17,937
행 백터 또는

273
00:10:17,940 --> 00:10:20,998
세개의 1로 이루어진

274
00:10:20,998 --> 00:10:23,853
한 개의 행입니다

275
00:10:23,853 --> 00:10:25,463
또한 마찬가지로 w를

276
00:10:25,463 --> 00:10:27,469
zeroes 1. 3로 하면

277
00:10:27,469 --> 00:10:30,209
행렬을 만듭니다.

278
00:10:30,220 --> 00:10:34,732
모든 요소가 0인 1 x 3 행렬입니다.

279
00:10:34,732 --> 00:10:36,910
행렬을 생성하는 몇 가지 방법이 더 있습니다.

280
00:10:36,930 --> 00:10:39,175
w를 rand 0.3로

281
00:10:39,175 --> 00:10:41,512
할당하면

282
00:10:41,520 --> 00:10:43,050
모든 요소가 무작위 숫자인

283
00:10:43,050 --> 00:10:45,370
0 x 3 행렬을 반환합니다.

284
00:10:45,372 --> 00:10:47,118
rand 3.3를 하면

285
00:10:47,215 --> 00:10:49,008
모든 요소들이

286
00:10:49,050 --> 00:10:50,417
0과 1 사이의 균등분포에서 가져온

287
00:10:50,417 --> 00:10:51,918
무작위 숫자로 구성된

288
00:10:51,930 --> 00:10:54,009
3 x 3 행렬을

289
00:10:54,009 --> 00:10:55,830
반환합니다.

290
00:10:55,830 --> 00:10:56,937
그래서 이 것을 할 때 마다

291
00:10:56,937 --> 00:10:58,608
0과 1 사이의 균등분포에서 가져온

292
00:10:58,608 --> 00:11:00,510
다른 무작위 숫자를

293
00:11:00,540 --> 00:11:02,573
가지게 됩니다.

294
00:11:02,573 --> 00:11:03,718
이전에 C 프로그래밍을 해본 적이 있다면

295
00:11:03,718 --> 00:11:05,375
여러분 중 가우스 확률 변수 또는

296
00:11:05,410 --> 00:11:06,275
정규 확률 변수를

297
00:11:06,275 --> 00:11:07,659
아는 사람은

298
00:11:07,660 --> 00:11:09,112
w를 randn 1.3로

299
00:11:09,112 --> 00:11:11,956
설정할 수 있습니다.

300
00:11:11,990 --> 00:11:13,565
그러면 이것은

301
00:11:13,570 --> 00:11:15,435
평균이 0이고

302
00:11:15,435 --> 00:11:17,798
분산 또는 표준 편차가 1인

303
00:11:17,798 --> 00:11:19,266
가우스 분포로부터 가져온

304
00:11:19,266 --> 00:11:21,642
세가지 값이 됩니다.

305
00:11:21,642 --> 00:11:23,148
더 복잡한 것들을

306
00:11:23,150 --> 00:11:24,698
설정할 수 있습니다

307
00:11:24,698 --> 00:11:26,194
w = -6

308
00:11:26,210 --> 00:11:28,656
+ sqrt(10)

309
00:11:28,660 --> 00:11:31,978
* randn(1. 10000)

310
00:11:31,978 --> 00:11:33,106
마지막에 세미콜론을 추가하겠습니다.

311
00:11:33,106 --> 00:11:35,623
왜냐 하면 출력하고 싶지 않기 때문입니다.

312
00:11:35,623 --> 00:11:37,599
어떻게 될까요?

313
00:11:37,599 --> 00:11:38,905
이것은

314
00:11:38,910 --> 00:11:40,582
백터가 되는데

315
00:11:40,610 --> 00:11:44,481
십만개로 이루어진, 죄송합니다, 만개의 요소를 가집니다

316
00:11:44,490 --> 00:11:47,596
그래서

317
00:11:47,596 --> 00:11:48,373
출력해 봅시다.

318
00:11:48,373 --> 00:11:51,570
이와 같은 행렬을 생성합니다.

319
00:11:51,570 --> 00:11:52,408
그렇지 않습니까?

320
00:11:52,408 --> 00:11:53,978
10,000개의 요소를 가진.

321
00:11:53,978 --> 00:11:55,835
이게 w 입니다.

322
00:11:55,835 --> 00:11:57,392
지금

323
00:11:57,392 --> 00:11:59,442
hist 명령어로

324
00:11:59,442 --> 00:12:01,818
w의 막대그래프를 그리면

325
00:12:01,820 --> 00:12:04,752
Octave가 hist 명령어를 출력합니다

326
00:12:04,752 --> 00:12:06,130
이것를 불러오려면

327
00:12:06,130 --> 00:12:07,297
몇 초 정도 걸립니다.

328
00:12:07,297 --> 00:12:08,965
이것이 w 확률 변수의

329
00:12:08,970 --> 00:12:10,646
막대그래프 입니다.

330
00:12:10,650 --> 00:12:12,732
-6 + sqrt(10)

331
00:12:12,732 --> 00:12:15,537
곱하기 가우스 확률 변수가 있고

332
00:12:15,537 --> 00:12:17,537
막대그래프를 더 많은 막대로

333
00:12:17,560 --> 00:12:21,032
50개로 그릴 수 있습니다.

334
00:12:21,032 --> 00:12:22,578
그리고 이것이

335
00:12:22,578 --> 00:12:25,735
평균이 -6인 가우스 변수의 막대그래프입니다.

336
00:12:25,735 --> 00:12:27,285
왜냐 하면 -6을 했고

337
00:12:27,285 --> 00:12:29,208
루트 10을 곱했기 때문입니다.

338
00:12:29,230 --> 00:12:32,952
그래서 가우스 확률 변수의

339
00:12:32,952 --> 00:12:34,961
분산은 10이고

340
00:12:34,961 --> 00:12:36,696
표준 편차는 루트 10입니다.

341
00:12:36,700 --> 00:12:38,935
루트 10은 무슨 값일까요?

342
00:12:38,950 --> 00:12:41,063
3.1 입니다.

343
00:12:41,780 --> 00:12:43,857
마지막으로 행렬을 생성하기 위한

344
00:12:43,857 --> 00:12:46,208
특별한 명령어 하나는 eye 입니다.

345
00:12:46,208 --> 00:12:48,394
이것이

346
00:12:48,394 --> 00:12:51,028
단어 정체성에 대한 말장난이라고 생각합니다

347
00:12:51,050 --> 00:12:52,650
eye에 4를 넘겨주면

348
00:12:52,720 --> 00:12:56,004
4 x 4 단위 행렬이 됩니다.

349
00:12:56,004 --> 00:12:57,681
i 를 eye 4로 하면

350
00:12:57,681 --> 00:13:00,458
4 x 4 단위 행렬을 반환합니다.

351
00:13:00,458 --> 00:13:04,475
그리고 i 를 eye 5, eye 6으로 하면

352
00:13:04,475 --> 00:13:05,611
6 x 6 행렬을

353
00:13:05,611 --> 00:13:08,089
반환합니다.

354
00:13:08,120 --> 00:13:09,134
eye 3 는 3 x 3 단위행렬입니다.

355
00:13:09,134 --> 00:13:12,064
마지막으로

356
00:13:12,064 --> 00:13:14,263
비디오를 마무리하며, 유용한 명령어가 하나 더 있습니다.

357
00:13:14,280 --> 00:13:15,479
help 명령어입니다.

358
00:13:15,479 --> 00:13:17,454
help eye를 입력하면

359
00:13:17,454 --> 00:13:21,181
단위 행렬에 대한 도움말 기능을 제공합니다.

360
00:13:21,190 --> 00:13:22,803
종료하기 위해 q 를 누르세요

361
00:13:22,803 --> 00:13:25,375
또한 help rand라고 입력할 수 있습니다.

362
00:13:25,380 --> 00:13:27,793
rand에 대한 문서나

363
00:13:27,793 --> 00:13:29,734
무작위 숫자 생성 기능에 대해 불러옵니다.

364
00:13:29,734 --> 00:13:31,898
또는 심지어 help help도

365
00:13:31,900 --> 00:13:35,615
도움말 기능의 help 를 보여줍니다

366
00:13:36,455 --> 00:13:39,022
이것들은

367
00:13:39,022 --> 00:13:41,612
Octave에 있는 기본 연산입니다.

368
00:13:41,612 --> 00:13:42,699
이것들을 가지고

369
00:13:42,699 --> 00:13:47,131
행렬을 만들고 곱하고 더할 수 있습니다.

370
00:13:47,131 --> 00:13:50,553
Octave에서 기본 연산들을 사용해 보세요.

371
00:13:50,560 --> 00:13:51,893
다음 비디오에서는

372
00:13:51,920 --> 00:13:53,818
더 복잡한 명령어와

373
00:13:53,818 --> 00:13:55,700
어떻게 데이터를 사용하는지 이야기하고

374
00:13:55,750 --> 00:13:59,180
Octave에서 데이터를 처리를 시작해 보고자 합니다.