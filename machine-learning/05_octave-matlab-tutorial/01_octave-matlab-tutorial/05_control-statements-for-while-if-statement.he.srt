1
00:00:00,180 --> 00:00:01,178
בהרצאה הזו, אני רוצה

2
00:00:01,178 --> 00:00:02,587
להסביר איך כותבים

3
00:00:02,600 --> 00:00:03,842
פקודות בקרה

4
00:00:03,842 --> 00:00:05,672
באוקטבה, דברים

5
00:00:05,700 --> 00:00:07,280
כמו פקודות "for", "while" ו-"if"

6
00:00:07,350 --> 00:00:12,176
ובנוסף נלמד גם איך מגדירים פונקציות ואיך משתמשים בהן.

7
00:00:12,480 --> 00:00:13,980
הנה חלון אוקטבה שלי.

8
00:00:13,980 --> 00:00:16,502
הרשו לי קודם כל להדגים שימוש בלולאת "for".

9
00:00:16,502 --> 00:00:17,888
אני הולך להתחיל על ידי הגדרת v

10
00:00:17,888 --> 00:00:18,852
להיות וקטור של 10 על

11
00:00:18,870 --> 00:00:20,808
1 של 0.

12
00:00:20,830 --> 00:00:22,209
עכשיו, הנה

13
00:00:22,240 --> 00:00:25,071
לולאת "for" של i מ-1 עד 10.

14
00:00:25,090 --> 00:00:27,608
דהיינו  for i שווה 1:10.

15
00:00:27,608 --> 00:00:29,905
בואו נראה, אני

16
00:00:29,905 --> 00:00:31,466
אגדיר V במקום ה-i

17
00:00:31,466 --> 00:00:33,214
שווה שתיים בחזקת

18
00:00:33,220 --> 00:00:36,848
i, ובסוף

19
00:00:36,848 --> 00:00:37,671
ובסוף end.

20
00:00:37,671 --> 00:00:39,082
הרווחים לא חשובים,

21
00:00:39,090 --> 00:00:40,538
אז אני שם כאן רווחים

22
00:00:40,538 --> 00:00:41,960
רק כדי לגרום לזה להיראות מסודר יפה,

23
00:00:41,990 --> 00:00:44,385
אבל כמות הרווחים לא משנה.

24
00:00:44,420 --> 00:00:46,163
אבל התוצאה של הלולאה הזו

25
00:00:46,163 --> 00:00:48,626
היא ש-V מתמלא

26
00:00:48,626 --> 00:00:49,420
בערכים שהם שתיים

27
00:00:49,500 --> 00:00:51,478
בחזקת, שתיים בחזקת אחת, שתיים בחזקת שתיים, וכו'.

28
00:00:51,490 --> 00:00:52,665
אז התחביר הזה של i

29
00:00:52,665 --> 00:00:55,410
שווה אחת נקודתיים 10

30
00:00:55,410 --> 00:00:57,429
גורם ללולאה של המשתנה i

31
00:00:57,440 --> 00:00:59,662
דרך הערכים אחת עד 10.

32
00:00:59,662 --> 00:01:00,830
ודרך אגב, אפשר לעשות את זה גם

33
00:01:00,830 --> 00:01:02,481
על ידי יצירת וקטור של

34
00:01:02,481 --> 00:01:04,795
אינדקסים מאחת עד

35
00:01:04,800 --> 00:01:07,260
10, אינדקסים

36
00:01:07,270 --> 00:01:09,305
במערך מאחת עד 10.

37
00:01:09,305 --> 00:01:13,249
ואז אפשר לכתוב גם i שווה לאינדקסים.

38
00:01:15,040 --> 00:01:17,805
וזה בעצם אותו דבר כמו i שווה לאחת עד 10.

39
00:01:17,820 --> 00:01:19,459
אפשר לעשות נניח הצגה

40
00:01:19,480 --> 00:01:23,498
של i מתוך וקטור האינדקסים וזה עושה אותו דבר.

41
00:01:23,498 --> 00:01:24,698
אז זהו זה בקשר ללולאת "for",

42
00:01:24,698 --> 00:01:27,201
אם אתם מכירים את "break"

43
00:01:27,230 --> 00:01:29,375
ו-"continue", אז יש משפטי "break"

44
00:01:29,375 --> 00:01:30,809
ו-"continue", אפשר

45
00:01:30,809 --> 00:01:32,061
להשתמש בהם בלולאות

46
00:01:32,061 --> 00:01:33,902
באוקטבה, אבל בואו

47
00:01:33,902 --> 00:01:36,550
נראה קודם איך עובדת לולאת while.

48
00:01:36,570 --> 00:01:39,088
אז הנה הוקטור שלי

49
00:01:39,120 --> 00:01:40,912
V. בואו נכתוב לולאת while.

50
00:01:40,920 --> 00:01:44,037
i שווה 1, כל עוד i

51
00:01:44,037 --> 00:01:45,259
קטן או שווה

52
00:01:45,259 --> 00:01:47,662
ל-5, הבה נגדיר

53
00:01:47,662 --> 00:01:51,082
V של i שווה מאה,

54
00:01:51,530 --> 00:01:54,449
ונגדיל את i

55
00:01:54,449 --> 00:01:56,644
באחת, ושוב משפט end בסוף.

56
00:01:56,700 --> 00:01:58,090
מה פירוש הדבר הזה?

57
00:01:58,090 --> 00:01:59,932
i בהתחלה שווה

58
00:01:59,970 --> 00:02:01,359
לאחת ואז אנחנו

59
00:02:01,380 --> 00:02:02,629
שמים בV של i

60
00:02:02,629 --> 00:02:04,249
מאה, ומגדילים את i

61
00:02:04,260 --> 00:02:07,666
באחת עד ש-i כמו שכתוב כאן עובר מעל חמש.

62
00:02:07,690 --> 00:02:09,377
וכתוצאה מזה,

63
00:02:09,377 --> 00:02:13,022
בעוד שמקודם הוקטור V הכיל חזקות של שתיים,

64
00:02:13,022 --> 00:02:14,573
עכשיו לקחנו את חמשת

65
00:02:14,580 --> 00:02:17,225
האברים הראשונים של הווקטור

66
00:02:17,260 --> 00:02:19,618
ושינינו את הערך שלהם למאה.

67
00:02:19,618 --> 00:02:22,797
אז זה התחביר של לולאת while.

68
00:02:23,140 --> 00:02:24,503
בואו נעשה עוד דוגמא

69
00:02:24,503 --> 00:02:26,600
i שווה אחת, כל עוד

70
00:02:26,600 --> 00:02:28,491
"אמת", וכאן

71
00:02:28,500 --> 00:02:31,892
ברצוני להראות איך משתמשים בפקודה break.

72
00:02:31,892 --> 00:02:34,040
בואו נכתב V של i שווה 999

73
00:02:34,070 --> 00:02:37,331
ו-i שווה i + 1,

74
00:02:38,110 --> 00:02:45,900
ואם i שווה 6, break

75
00:02:47,910 --> 00:02:47,910
ובסוף end.

76
00:02:48,410 --> 00:02:49,425
זו גם הפעם

77
00:02:49,425 --> 00:02:51,945
הראשונה שאנו משתמשים במשפט if, אז

78
00:02:51,945 --> 00:02:53,308
אני מקווה שזה נראה לכם הגיוני.

79
00:02:53,308 --> 00:02:57,297
מאחר ש-i מתחיל כשווה אחת, ואנחנו מגדילים אותו בלולאה.

80
00:02:57,340 --> 00:02:59,900
לולאת ה-while חוזרת שוב ושוב על סדרת הפעולות

81
00:02:59,900 --> 00:03:01,527
של לשים ב-V של i את הערך 999 ולקדם את i.

82
00:03:01,527 --> 00:03:02,901
כאשר i מגיע

83
00:03:02,920 --> 00:03:04,451
ל-6, הפקודה

84
00:03:04,451 --> 00:03:05,757
break גורמת ליציאה מהלולאה.

85
00:03:05,757 --> 00:03:07,284
ומה שזה עושה

86
00:03:07,284 --> 00:03:08,596
הוא לקחת את

87
00:03:08,596 --> 00:03:09,929
חמשה האברים הראשונים של הוקטור

88
00:03:09,929 --> 00:03:11,748
V ולשים בהם ערך 999.

89
00:03:11,748 --> 00:03:14,832
אז לקחנו את

90
00:03:14,832 --> 00:03:18,345
V והחלפנו את הערך של חמישה האברים הראשונים שלו ל-999.

91
00:03:18,345 --> 00:03:20,172
זה התחביר

92
00:03:20,172 --> 00:03:21,974
של פקודת "if"

93
00:03:21,974 --> 00:03:25,058
ופקודת while, ושימו לב שבסוף כאן

94
00:03:25,070 --> 00:03:27,159
ישנה הפקודה end פעמיים.

95
00:03:27,170 --> 00:03:29,719
ה-end הראשון מסיים את פקודת ה"if"

96
00:03:29,730 --> 00:03:33,228
והשני מסיים את פקודת ה-while.

97
00:03:33,250 --> 00:03:35,265
עכשיו הרשו לי להראות לכם תחביר כללי יותר של

98
00:03:35,265 --> 00:03:37,763
פקודת if שבו יש if-else.

99
00:03:37,763 --> 00:03:40,274
אז, בואו נראה, כרגע V של 1

100
00:03:40,274 --> 00:03:42,776
שווה 999, בואו

101
00:03:42,860 --> 00:03:46,996
נכניס ל-(V)1 את הערך 2 בשביל הדוגמא הזו.

102
00:03:47,020 --> 00:03:48,758
עכשיו נכניס

103
00:03:48,758 --> 00:03:55,050
את הפקודות if V(1) == 1 הדפס "הערך הוא אחת".

104
00:03:56,855 --> 00:03:58,588
הנה איך כותבים את פקודת ה-else,

105
00:03:58,588 --> 00:04:00,040
או ליתר דיוק

106
00:04:00,040 --> 00:04:03,853
else if v(1) ==

107
00:04:03,853 --> 00:04:07,815
2. זה, שבמקרה הוא נכון בדוגמא שלנו, ידפיס

108
00:04:07,815 --> 00:04:12,268
"הערך הוא 2". אחרת,

109
00:04:13,650 --> 00:04:17,960
הדפס "הערך אינו לא אחת ולא שתיים".

110
00:04:17,990 --> 00:04:21,699
אוקיי, אז כך נראה משפט if-else

111
00:04:21,700 --> 00:04:23,889
if-else וכמובן, בסוף end.

112
00:04:23,889 --> 00:04:25,271
וכמובן, מכיוון שהצבנו

113
00:04:25,271 --> 00:04:27,589
כאן ב-(V(1 את הערך 2, אז כצפוי

114
00:04:27,610 --> 00:04:30,729
התוצאה תהיה "הערך הוא 2".

115
00:04:30,780 --> 00:04:32,844
ועוד משהו, אני לא

116
00:04:32,880 --> 00:04:34,143
חושב שהזכרתי את זה עדיין, אבל

117
00:04:34,143 --> 00:04:35,622
אם אי פעם צריך לצאת מאוקטבה,

118
00:04:35,622 --> 00:04:36,947
תוכל להקליד את פקודת exit

119
00:04:36,947 --> 00:04:38,373
ולהקיש Enter ואוקטבה

120
00:04:38,400 --> 00:04:39,981
תסיים את פעולתה, וניתן להשתמש

121
00:04:39,981 --> 00:04:42,428
גם בפקודה 'q'-.

122
00:04:42,450 --> 00:04:43,857
ועכשיו בואו נדבר על

123
00:04:43,857 --> 00:04:45,292
פונקציות, כיצד להגדיר

124
00:04:45,310 --> 00:04:48,592
אותם ואיך להשתמש בהם.

125
00:04:48,620 --> 00:04:49,680
הנה שולחן העבודה שלי, ואני

126
00:04:49,720 --> 00:04:52,078
הכנתי מראש קובץ

127
00:04:52,078 --> 00:04:56,818
ששמרתי על שולחן העבודה שלי בשם "squarethisnumber.m".

128
00:04:56,830 --> 00:04:59,471
הנה איך מגדירים פונקציות באוקטבה.

129
00:04:59,480 --> 00:05:01,681
אתה יוצר קובץ

130
00:05:01,681 --> 00:05:03,958
בשם הפונקציה שלך עם הסיומת "m.",

131
00:05:03,960 --> 00:05:05,694
וכאשר אוקטבה מוצאת

132
00:05:05,730 --> 00:05:07,643
את הקובץ הזה, היא יודעת ששם

133
00:05:07,680 --> 00:05:12,322
היא צריכה לחפש את ההגדרה של הפונקציה "squarethisnumber".

134
00:05:12,340 --> 00:05:14,076
בואו נפתח את הקובץ הזה.

135
00:05:14,076 --> 00:05:15,717
שימו לב שאני משתמש

136
00:05:15,717 --> 00:05:19,352
בתוכנית wordpad של מיקרוסופט כדי לפתוח את הקובץ הזה.

137
00:05:19,352 --> 00:05:20,250
אני רוצה להמליץ לכם

138
00:05:20,250 --> 00:05:23,379
שאם אתם משתמשים ב-Microsoft Windows,

139
00:05:23,379 --> 00:05:25,075
תשתמשו ב-wordpad ולא

140
00:05:25,110 --> 00:05:27,477
ב-Notepad כדי לפתוח

141
00:05:27,490 --> 00:05:28,557
את הקבצים הללו, אם יש לכם

142
00:05:28,557 --> 00:05:29,938
עורך טקסטים אחר, גם הם

143
00:05:29,938 --> 00:05:33,325
בסדר, אבל notepad לפעמים מקלקל את הרווחים.

144
00:05:33,350 --> 00:05:34,775
אם יש לך רק Notepad, גם זה

145
00:05:34,800 --> 00:05:36,312
צריך לעבוד, גם זה יכול לעבוד,

146
00:05:36,312 --> 00:05:37,779
אבל אם יש

147
00:05:37,779 --> 00:05:39,354
לך גם wordpad, אני

148
00:05:39,354 --> 00:05:40,609
מעדיף להשתמש בו או

149
00:05:40,610 --> 00:05:45,053
בעורך טקסטים אחר, אם יש לך מעבד טקסטים שונה לעריכת הפונקציות שלך.

150
00:05:45,060 --> 00:05:47,155
אז הנה איך מגדירים פונקציה באוקטבה.

151
00:05:47,155 --> 00:05:49,816
אני רק אגדיל את זה קצת.

152
00:05:49,816 --> 00:05:52,516
בקובץ הזה יש בסך הכל שלוש שורות.

153
00:05:52,516 --> 00:05:54,440
השורה הראשונה אומרת (function Y = squareThisNumber(X,

154
00:05:54,440 --> 00:05:56,448
זה מגדיר

155
00:05:56,448 --> 00:05:57,705
לאוקטבה שהערך המוחזר

156
00:05:57,705 --> 00:06:00,025
מהפונקציה הוא Y,

157
00:06:00,025 --> 00:06:01,315
יוחזר ערך בודד

158
00:06:01,315 --> 00:06:02,375
שערכו יהיה במשתנה

159
00:06:02,375 --> 00:06:04,443
Y וזה

160
00:06:04,443 --> 00:06:06,003
גם מגדיר לאוקטבה

161
00:06:06,003 --> 00:06:08,068
שלפונקציה הזו יש ארגומנט אחד,

162
00:06:08,070 --> 00:06:10,408
שהוא X,

163
00:06:10,420 --> 00:06:11,846
ואת הגדרת

164
00:06:11,846 --> 00:06:15,156
הפונקציה שהיא Y מקבל את squareThisNumber של X.

165
00:06:15,180 --> 00:06:16,553
אז בואו ננסה לקרוא

166
00:06:16,553 --> 00:06:19,071
לפונקציה הזו "square", עם המספר

167
00:06:19,071 --> 00:06:21,854
5, וזה בעצם

168
00:06:21,854 --> 00:06:23,115
לא יעבוד,

169
00:06:23,115 --> 00:06:25,693
ואוקטבה טוען שהביטוי הזה הוא לא מוגדר.

170
00:06:25,693 --> 00:06:28,902
הסיבה לכך היא שאוקטבה לא יודעת איפה למצוא את הקובץ הזה.

171
00:06:28,902 --> 00:06:30,682
אז כרגיל, בואו נשתמש ב-PWD

172
00:06:30,690 --> 00:06:32,592
לראות איפה אנחנו, אה, אנחנו לא בספרייה שלי,

173
00:06:32,592 --> 00:06:36,151
אז בואו נעבור לשם: c:\users\ang\desktop.

174
00:06:36,151 --> 00:06:39,888
שם נמצא שולחן העבודה שלי.

175
00:06:39,888 --> 00:06:41,276
אופס, טעות הקלדה קטנה.

176
00:06:41,276 --> 00:06:42,848
Users ANG Desktop

177
00:06:42,848 --> 00:06:44,157
ואם עכשיו אני מקליד

178
00:06:44,157 --> 00:06:46,728
(sqaureThisNumber(5,

179
00:06:46,728 --> 00:06:48,505
אני מקבל את התשובה 25.

180
00:06:48,505 --> 00:06:50,347
כמין תכונה מתקדמת,

181
00:06:50,347 --> 00:06:51,972
רק עבור אלה מכם

182
00:06:51,972 --> 00:06:54,596
שמכירים את המונח נתיב חיפוש.

183
00:06:54,596 --> 00:06:55,945
אבל אם אתה

184
00:06:55,945 --> 00:06:57,497
רוצה לשנות את נתיב החיפוש

185
00:06:57,497 --> 00:06:58,863
של אוקטבה אז

186
00:06:58,863 --> 00:06:59,866
זה אפשרי, אבל תחשבו על

187
00:06:59,866 --> 00:07:01,827
הדבר הבא כחומר

188
00:07:01,827 --> 00:07:03,292
מתקדם או אופציונלי.

189
00:07:03,292 --> 00:07:04,214
רק למי שמכירים

190
00:07:04,214 --> 00:07:05,484
את המושגים של

191
00:07:05,484 --> 00:07:07,642
תיקיות חיפוש בסביבות עבודה של שפות,

192
00:07:07,650 --> 00:07:08,962
אתם יכולים להשתמש

193
00:07:08,962 --> 00:07:11,875
בפקודה addpath, עם

194
00:07:11,880 --> 00:07:16,241
התיקייה שאתם רוצים להוסיף

195
00:07:16,241 --> 00:07:17,972
כדי להוסיף את התיקייה הזו

196
00:07:17,972 --> 00:07:19,744
לרשימת תיקיות החיפוש של אוקטבה כך

197
00:07:19,744 --> 00:07:21,065
שגם אם אתם

198
00:07:21,065 --> 00:07:22,611
עוברים לאיזו ספרייה אחרת

199
00:07:22,611 --> 00:07:24,510
אוקטבה עדיין תדע

200
00:07:24,510 --> 00:07:26,005
לחפש פונקציות בספריית שולחן העבודה

201
00:07:26,005 --> 00:07:29,214
של המשתמש ANG,

202
00:07:29,214 --> 00:07:30,521
כך שלמרות

203
00:07:30,521 --> 00:07:31,868
שעברנו לספרייה שונה, היא עדיין

204
00:07:31,868 --> 00:07:35,297
תדע איפה למצוא את פונקצית ריבוע המספר הזו.

205
00:07:35,297 --> 00:07:35,935
בסדר?

206
00:07:35,935 --> 00:07:37,407
אבל אם אתם לא מכירים

207
00:07:37,407 --> 00:07:39,184
את המושג של תיקיות לחיפוש, אין לכם

208
00:07:39,184 --> 00:07:40,068
מה לדאוג בקשר לזה.

209
00:07:40,068 --> 00:07:40,889
פשוט תוודאו בכניסה לאוקטבה

210
00:07:40,889 --> 00:07:42,053
להריץ cd

211
00:07:42,053 --> 00:07:43,926
וללכת לספרייה שבה מוגדרות הפונקציות שלכם

212
00:07:43,940 --> 00:07:47,441
לפני שתפעילו אותן וזה יעבוד בסדר גמור.

213
00:07:47,441 --> 00:07:49,587
תכונה אחת שיש לאוקטבה

214
00:07:49,600 --> 00:07:51,058
שלא קיימת בהרבה

215
00:07:51,058 --> 00:07:52,969
שפות תכנות אחרות היא

216
00:07:52,969 --> 00:07:54,909
שאפשר גם להגדיר

217
00:07:54,909 --> 00:07:58,873
פונקציות המחזירות ערכים מרובים או ארגומנטים מרובים.

218
00:07:58,873 --> 00:08:00,889
אז הנה דוגמה לכך.

219
00:08:00,889 --> 00:08:02,931
הגדרתי פונקציה שנקראת SquareAndCubeThisNumber

220
00:08:02,931 --> 00:08:04,964
של המספר X

221
00:08:04,964 --> 00:08:06,644
והפונקציה הזו

222
00:08:06,660 --> 00:08:08,547
מחזירה 2 ערכים, y1 ו-y2.

223
00:08:08,547 --> 00:08:09,955
כאשר y1

224
00:08:09,960 --> 00:08:13,603
הוא X בריבוע, ו-y2 הוא X בשלישית.

225
00:08:13,603 --> 00:08:16,972
והמשמעות של זה היא שהפונקציה אכן מחזירה 2 מספרים.

226
00:08:16,980 --> 00:08:18,855
חלק מכם, תלוי

227
00:08:18,855 --> 00:08:20,195
באילו שפות תכנות אתם משתמשים,

228
00:08:20,195 --> 00:08:22,931
אם נניח אתה מכיר ויודע, לדוגמא, את C או ++C.

229
00:08:22,940 --> 00:08:26,051
אז בדרך כלל אנו חושבים על פונקציה כדבר שמחזיר רק ערך אחד.

230
00:08:26,051 --> 00:08:27,847
אבל התחביר באוקטבה

231
00:08:27,847 --> 00:08:31,679
נבנה כך שיוכל להחזיר ערכים מרובים.

232
00:08:32,430 --> 00:08:34,087
עכשיו אנחנו בחזרה בחלון אוקטבה.

233
00:08:34,087 --> 00:08:37,914
אני מקליד a, b =

234
00:08:37,914 --> 00:08:41,263
SquareCubeThisNumber

235
00:08:41,263 --> 00:08:44,599
של המספר 5, אז

236
00:08:44,610 --> 00:08:46,338
עכשיו a שווה

237
00:08:46,338 --> 00:08:47,778
25 ו-b שווה

238
00:08:47,778 --> 00:08:49,729
5 בשלישית שזה 125.

239
00:08:49,729 --> 00:08:51,645
אז זה די

240
00:08:51,670 --> 00:08:53,010
נוח אם אנחנו צריכים

241
00:08:53,010 --> 00:08:56,447
פונקציה שמחזירה ערכים מרובים.

242
00:08:56,447 --> 00:08:57,480
לסיום אני עומד להראות

243
00:08:57,480 --> 00:09:01,123
לכם איזו דוגמא יותר מתוחכמת של פונקציה.

244
00:09:01,130 --> 00:09:02,361
נניח שיש לי סדרת נתונים

245
00:09:02,370 --> 00:09:04,400
שנראית ככה, עם נתונים בנקודות 1, 1, 2, 2, 3, 3.

246
00:09:04,430 --> 00:09:07,636
ומה שאני רוצה

247
00:09:07,636 --> 00:09:09,113
לעשות הוא להגדיר

248
00:09:09,113 --> 00:09:10,798
פונקציה באוקטבה כדי לחשב את פונקצית

249
00:09:10,830 --> 00:09:14,341
העלות J של תטא עבור ערכים שונים של תטא.

250
00:09:14,360 --> 00:09:16,157
קודם כל בואו נכניס את הנתונים לאוקטבה.

251
00:09:16,160 --> 00:09:17,694
אז נבנה מטריצה

252
00:09:17,700 --> 00:09:20,998
עם ערכים 1,1,1,2,1,3.

253
00:09:21,010 --> 00:09:24,043
זוהי מטריצת העיצוב

254
00:09:24,050 --> 00:09:26,073
x שבה X0,

255
00:09:26,073 --> 00:09:27,428
העמודה הראשונה היא המקדם של

256
00:09:27,428 --> 00:09:28,746
תטא-0 שהוא 1 והעמודה השנייה הם

257
00:09:28,770 --> 00:09:32,375
ערכי ה-x של שלוש דוגמאות האימון שלי.

258
00:09:32,375 --> 00:09:33,594
וכן נגדיר

259
00:09:33,594 --> 00:09:35,488
y להיות 1-2-3,

260
00:09:35,488 --> 00:09:38,793
שהם ערכי ציר y.

261
00:09:38,810 --> 00:09:40,431
אז בואו נניח שהמקדמים,

262
00:09:40,431 --> 00:09:43,714
הוקטור תטא הם 0 נקודה-פסיק 1.

263
00:09:43,730 --> 00:09:45,652
כאן על שולחן העבודה שלי,

264
00:09:45,660 --> 00:09:47,483
הגדרתי מראש את פונקצית העלות

265
00:09:47,490 --> 00:09:49,008
j ואם

266
00:09:49,010 --> 00:09:52,019
נציג אותה על המסך היא נראית כך.

267
00:09:52,019 --> 00:09:53,579
אז הפונקציה j שווה CostFunctionJ

268
00:09:53,580 --> 00:09:55,192
של X, y

269
00:09:55,192 --> 00:09:57,151
ותטא, קצת הערות שמתארות

270
00:09:57,151 --> 00:09:59,546
את הקלט ואז

271
00:09:59,560 --> 00:10:01,383
מספר קטן של פעולות, m מחושב

272
00:10:01,383 --> 00:10:02,995
כגודל סדרת האימון,

273
00:10:03,020 --> 00:10:05,495
דהיינו מספר השורות ב-x.

274
00:10:05,510 --> 00:10:07,596
חישוב ההשערה, ההשערה שווה

275
00:10:07,596 --> 00:10:10,137
x כפול תטא,

276
00:10:10,170 --> 00:10:11,670
עכשיו עוד הערה שגלשה לשורה הבאה,

277
00:10:11,710 --> 00:10:14,693
והיא כנראה חלק מההערה הקודמת.

278
00:10:14,720 --> 00:10:16,823
חישוב סכום ריבועי השגיאות, אתם רואים, אנחנו לוקחים

279
00:10:16,823 --> 00:10:18,637
את ההפרש בין התחזית

280
00:10:18,640 --> 00:10:20,265
ובין ערכי y בפועל

281
00:10:20,265 --> 00:10:22,126
ומעלים בריבוע,

282
00:10:22,140 --> 00:10:24,376
ובסוף חישוב של

283
00:10:24,376 --> 00:10:26,128
פונקצית העלות J. ואוקטבה יודעת

284
00:10:26,128 --> 00:10:27,439
ש-J הוא הערך

285
00:10:27,439 --> 00:10:31,383
שאני רוצה להחזיר כי J מופיע כאן בהגדרת הפונקציה.

286
00:10:31,420 --> 00:10:34,127
דרך אגב, תרגישו חופשיים להשהות

287
00:10:34,170 --> 00:10:35,292
את הוידאו אם תרצו

288
00:10:35,292 --> 00:10:36,712
להסתכל על הגדרת

289
00:10:36,712 --> 00:10:38,820
הפונקציה יותר לעומק

290
00:10:38,820 --> 00:10:44,031
כדי לוודא שאתם מבינים את הצעדים השונים.

291
00:10:44,031 --> 00:10:45,184
כשמריצים את זה

292
00:10:45,184 --> 00:10:46,630
באוקטבה, מריצים

293
00:10:46,630 --> 00:10:51,197
(j = CostFunctionJ(x, y, theta

294
00:10:51,197 --> 00:10:55,142
וזה מחשב, אופס, טעות הקלדה,

295
00:10:55,142 --> 00:10:57,018
הייתי צריך לכתוב X גדולה.

296
00:10:57,018 --> 00:11:00,472
התשובה היא J שווה 0 כי

297
00:11:00,510 --> 00:11:03,367
סדרת נתוני האימון היא

298
00:11:03,367 --> 00:11:06,963
כזכור 1 2 3, 1 2 3 ואז כשמגדירים תטא-0

299
00:11:06,980 --> 00:11:08,741
שווה 0 ותטא-1 שווה

300
00:11:08,770 --> 00:11:11,259
1, אנחנו מקבלים בדיוק

301
00:11:11,259 --> 00:11:15,559
קו של 45 מעלות שמתאים לסדרת הנתונים בצורה מושלמת.

302
00:11:15,600 --> 00:11:16,887
בניגוד לכך, אם נגדיר

303
00:11:16,887 --> 00:11:19,828
תטא שווה נניח 0, 0,

304
00:11:19,830 --> 00:11:22,524
אז פונקצית ההשערה

305
00:11:22,540 --> 00:11:24,050
מנבאת או חוזה שכל ערכי התוצאה הם 0,

306
00:11:24,050 --> 00:11:25,803
תטא-0 שווה 0,

307
00:11:25,810 --> 00:11:27,139
תטא-1 שווה 0,

308
00:11:27,139 --> 00:11:29,345
עכשיו נחשב את פונקציית העלות

309
00:11:29,370 --> 00:11:31,830
J, עכשיו נקבל 2.333 שזה

310
00:11:31,830 --> 00:11:35,495
בעצם 1 בריבוע

311
00:11:35,520 --> 00:11:36,745
שהיא ריבוע השגיאה

312
00:11:36,745 --> 00:11:39,789
בדוגמה הראשונה, ועוד 2 בריבוע,

313
00:11:39,800 --> 00:11:42,377
ועוד 3 בריבוע והכל

314
00:11:42,440 --> 00:11:45,288
חלקי 2m, דהיינו

315
00:11:45,288 --> 00:11:47,091
2 כפול מספר דוגמאות האימון,

316
00:11:47,091 --> 00:11:50,643
וזה אכן יוצא 2.33,

317
00:11:50,643 --> 00:11:53,289
פשוט וידאתי

318
00:11:53,330 --> 00:11:54,909
שהפונקציה הזו כאן

319
00:11:54,909 --> 00:11:56,302
באמת מחשבת את

320
00:11:56,302 --> 00:11:58,212
פונקצית העלות כמו שצריך, ואלה היו פשוט שתי דוגמאות

321
00:11:58,250 --> 00:12:00,222
שבדקנו על

322
00:12:00,222 --> 00:12:03,433
סדרת האימון הפשוטה שלנו.

323
00:12:03,490 --> 00:12:04,914
אז בדקנו בצורה שטחית

324
00:12:04,960 --> 00:12:08,689
שפונקצית העלות J,

325
00:12:08,720 --> 00:12:10,202
כפי שהיא מוגדרת כאן באוקטבה,

326
00:12:10,230 --> 00:12:12,992
אכן מחשבת את

327
00:12:12,992 --> 00:12:14,908
פונקציית העלות האמיתית, לפחות

328
00:12:14,920 --> 00:12:17,424
על סדרת האימון הפשוטה שלנו

329
00:12:17,430 --> 00:12:18,835
כאן עם ה-X

330
00:12:18,835 --> 00:12:20,823
וה-Y שהם

331
00:12:20,823 --> 00:12:25,189
הדוגמה הפשוטה הזו שפתרנו.

332
00:12:25,230 --> 00:12:26,285
אז עכשיו אתם יודעים איך

333
00:12:26,285 --> 00:12:28,171
לכתוב משפטי בקרה כמו לולאות "for"

334
00:12:28,171 --> 00:12:29,838
ו-"while" ומשפטי "if"

335
00:12:29,838 --> 00:12:33,197
באוקטבה, כמו גם איך להגדיר פונקציות ואיך להשתמש בהן.

336
00:12:33,197 --> 00:12:34,530
בסרטון הבא, אני

337
00:12:34,530 --> 00:12:36,123
ארפרף על

338
00:12:36,123 --> 00:12:38,144
הלוגיסטיקה של

339
00:12:38,144 --> 00:12:39,873
איך עובדים על

340
00:12:39,873 --> 00:12:41,664
תרגילים ואיך מגישים אותם

341
00:12:41,664 --> 00:12:45,212
בקורס הזה, ואת אופן השימוש במערכת הגשת התרגילים שלנו.

342
00:12:45,230 --> 00:12:46,794
ולאחר מכן,

343
00:12:46,794 --> 00:12:48,856
בסרטון האחרון של לימוד אוקטבה,

344
00:12:48,856 --> 00:12:51,400
אני מתכוון לספר לכם על וקטוריזציה,

345
00:12:51,400 --> 00:12:52,938
שהוא הרעיון של איך

346
00:12:52,938 --> 00:12:56,126
לגרום לתוכניות אוקטבה לרוץ הרבה יותר מהר.