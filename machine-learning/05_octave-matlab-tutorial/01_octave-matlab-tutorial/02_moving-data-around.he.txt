בסרטון ההדרכה השני הזה על אוקטבה, הייתי רוצה להתחיל להסביר איך מטפלים בנתונים באוקטבה. אם יש לך נתונים עבור בעית למידה חישובית, איך טוענים את הנתונים לתוך אוקטבה? איך מכניסים אותם למטריצה? איך גורמים למטריצות האלה לעבוד? איך שומרים את התוצאות? איך מעבירים נתונים בסביבת אוקטבה ואיך מפעילים אותם? הנה חלון אוקטבה שלי כמו קודם, ונמשיך מאיפה שהפסקנו בסרטון האחרון. אם אני מקיש A, ​​כך אנו יוצרים מטריצה, נכון, עם הפקודה הזאת שווה אחת, שתיים, שלוש, ארבע, חמש, שש, וזו מטריצה שלוש על שתיים. פקודת size באוקטבה אומרת לך מה גודל המטריצה. אז הגודל שמודפס הוא שלוש, שתיים. מתברר כי שהפקודה size בעצמה בעצם מחזירה מטריצה אחת על שתיים. אז אתה בעצם יכול להגדיר SZ שווה size של A ותקבל משתנה SZ שהוא כעת מטריצה אחת על שתיים ובו המרכיב הראשון הוא שלוש, והמרכיב השני הוא שתיים. אז אם פשוט תקליד (size(SZ. מכיוון ש-SZ הוא מטריצה אחת על שתיים ששני האברים שלה מכילים את הממדים של המטריצה A. ​​ניתן גם להקליד (size(A,1 כדי לקבל את הממד הראשון של A, גודל הממד הראשון של A. דהיינו מספר השורות, (size(A,2 כדי לקבל שתיים שהוא מספר העמודות במטריצה A. אם יש לך וקטור V, נאמר V שווה אחת, שתיים, שלוש, ארבע, ואתה מקליד (length(V. מה שזה עושה הוא לתת את הגודל של המימד הארוך יותר. אז אתה יכול גם להקליד length A ומכיוון ש-A היא מטריצה שלוש על שתיים, תקבל שלוש, כי שלוש הוא המימד הגדול. אבל בדרך כלל אנחנו משתמשים בפונקציה length רק עבור וקטורים. דהיינו, length של הוקטור אחד, שתיים, שלוש, ארבע, חמש, אנחנו לא משתמשים בפונקציה length עבור מטריצות כי זה קצת מבלבל. עכשיו, בואו נראה איך טוענים נתונים ואיך מוצאים אותם במערכת הקבצים. כשאנחנו מריצים את אוקטבה אנחנו בדרך כלל, רוב הפעמים מתחילים בתיקיה הזו, המיקום של אוקטבה. אז הפקודה PWD מציגה את הספרייה הנוכחית, או את המסלול הנוכחי של אוקטבה. אז עכשיו אנחנו נמצאים באיזו ספרייה צדדית משהו. הפקודה CD משמעותה עבור לספרייה זו, אז אני יכול ללכת ל- c:/users/Ang/Desktop, ועכשיו אני נמצא בשולחן העבודה שלי ואם אני מקליד ls, ls היא פקודה שמקורה ביוניקס או לינוקס. בכל אופן, ls ייתן רשימה של הספריות והקבצים בשולחן העבודה שלי אז הנה הקבצים שנמצאים בשולחן העבודה שלי עכשיו. למעשה יש בשולחן העבודה שלי שני קבצים: featuresX ו-priceY שאולי מגיעים מבעיה של למידה חישובית שאותה אני מנסה לפתור. אז הנה שולחן העבודה שלי. הנה featuresX, וfeaturesX הוא החלון הזה, סליחה, הקובץ הזה עם שתי עמודות של נתונים. זו למעשה רשימת הנתונים של מחירי הבתים שלנו. אז אני חושב, אני חושב שיש ארבעים ושבע שורות במערך הנתונים הזה. אז לבית הראשון יש גודל של מאתיים וארבעה רגל רבוע, יש בו שלושה חדרי שינה; הבית השני הוא של אלף שש מאות רגל רבוע, יש בו שלושה חדרי שינה; וכולי. ו-priceY הוא הקובץ הזה שבו נמצאים המחירים של הבתים בסדרת האימון. אז featuresX ו-priceY הם פשוט קבצי טקסט עם נתונים. כיצד ניתן לטעון את הנתונים האלה לתוך אוקטבה? ובכן, אני פשוט מקליד את הפקודה load featuresX.dat ואם אני עושה את זה, אני טוען את featuresX, ויכול לטעון גם את priceY.dat. ודרך אגב, יש מספר דרכים לעשות זאת. הפקודה הזו אם תשים 'featuresX.dat' במחרוזת ותטען אותו כך, סליחה, טעות, אז זו פקודה שקולה לראשונה. אז אתה יכול ככה פשוט לשים את שם הקובץ במחרוזת, באוקטבה משתמשים בגרשיים בודדים כדי לייצג מחרוזות, כמו כאן. אז זוהי מחרוזת, ואנחנו יכולים לטעון את הקובץ ששמו ניתן על ידי המחרוזת. עכשיו הפקודה who מראה לנו את המשתנים בסביבת העבודה באוקטבה. אז who מראה את המשתנים שיש לאוקטבה בזיכרון כרגע. featuresX ו-priceY נמצאים שם, כמו גם שאר המשתנים שיצרנו קודם לכן בהרצה הזו. אז אני יכול להקליד featuresX כדי להציג את הטבלה featuresX. והנה הם הנתונים. ואני יכול להקליד (size(featuresX ומקבלים מטריצה 47 על שתיים. ומה הגודל של priceY, זה נותן 47 על אחת. זהו וקטור 47-ממדי. זה וקטור העמודה שמכיל את priceY של סדרת האימון. עכשיו הפונקציה who מראה את המשתנים בסביבת העבודה הנוכחית. וקיימת גם פקודת whos שנותנת תצוגה יותר מפורטת. אז עם s בסוף הפקודה מפרט גם את המשתנים וגם את הגדלים שלהם. אז A היא מטריצה שלוש על שתיים ו-featuresX היא מטריצה 47 על 2. priceY היא מטריצה 47 על אחת. כלומר זה פשוט וקטור. וזה מראה כמה בייט של זיכרון זה תופס. וגם מהו סוג הנתונים. double אומר שאלה משתני נקודה צפה בדיוק כפול, או פשוט שאלה הם ערכים ממשיים, מספרי נקודה צפה. עכשיו, כדי להיפטר ממשתנה השתמש בפקודה clear. אז אם תקיש clear featuresX ואחר כך שוב whos. תראה שהמשתנה featuresX נעלם עכשיו. ואיך שומרים נתונים? בואו נראה. בואו ניקח משתנה V ונציב בו את priceY 1:10. זה מגדיר את V כוקטור המכיל את 10 האברים הראשונים של priceY. בואו נריץ את who או whos. בעוד priceY היה וקטור של 47 על 1. V הוא 10 על 1. V שווה priceY ​​עמודה אחת עד עשר מציב בו רק את עשרת האברים הראשונים של priceY, נניח שאני רוצה לשמור את זה על הדיסק, אז הפקודה save hello.mat V תשמור את המשתנה V לתוך קובץ בשם hello.mat. בואו נעשה את זה. ועכשיו הופיע קובץ על שולחן העבודה שלי, אתם רואים, בשם Hello.mat. במקרה מותקן לי MATLAB על המחשב, וזו הסיבה, אתם מבינים, שהסמליל - האייקון - הזה נראה ככה כי Windows מזהה אותו כקובץ MATLAB, אבל אל תדאגו אם הסמליל של הקובץ הזה נראה שונה על המחשב שלכם. עכשו בואו נאמר שאני מוחק ומנקה את כל המשתנים שלי. אז אם אתם מקלידים clear בלי שום פרמטרים אז זה בעצם מוחק את כל המשתנים בסביבת העבודה. אז עכשיו אין כלום בסביבת העבודה. ואם אני אטען את hello.mat, אני יכול עכשיו לטעון חזרה את המשתנה V שלי, שבו נמצאים הנתונים ששמרתי קודם בקובץ hello.mat. אז hello.mat, מה שעשינו עכשיו היה לשמור את hello.mat לתוך הדיסק, והנתונים נשמרו בפורמט בינארי, בפורמט בינארי שהוא מעט יותר דחוס. אז אם ב-v יש הרבה נתונים, אז הוא יהיה קצת יותר דחוס. יתפוס פחות שטח איחסון. אם אתה רוצה לשמור את הנתונים בפורמט קריא יותר, תקליד save hello.text V ואז ascii-. אז הוא יישמר כטקסט או כפורמט ASCII של טקסט. ואחרי שעשיתי את זה, יש לי כאן הקובץ הזה. Hello.text הופיע זה עתה על שולחן העבודה שלי, וכשאני פותח אותו רואים שזה קובץ טקסט בו שמורים הנתונים שלי. אז ככה טוענים ושומרים נתונים. עכשיו בואו נדבר קצת על איך מטפלים בנתונים. בואו להגדיר מטריצה A שווה לנתונים כרגיל אז היא מטריצה שלוש על שתיים. איך מצביעים לתוכה. אני מקליד A 3,2. זהו אינדקס או מצביע לאיבר במקום 3,2 של המטריצה A, זה מה שאנחנו בדרך כלל היינו כותבים כA עם אינדקס תחתון 3,2 או A אינדקס 3,2 אז זה האלמנט בשורה השלישית בטור השני של A שערכו הוא שש. אני יכול גם להקליד A שתיים פסיק נקודתיים את כל השורה השנייה. הנקודתיים משמעותן כל האיברים בשורה או בעמודה. אז, A 2 פסיק נקודתיים היא כל השורה השנייה של A. טוב. ובאופן דומה, אם אני עושה A נקודתיים פסיק 2 אז נקבל את כל העמודה השנייה של A, דהיינו נקבל 2 4 6. נכון? הפירוש הוא A, הכל, עמודה שנייה. אז זו העמודה השניה של A, שהיא 2 4 6. אפשר להשתמש באינדקסים גם בצורה קצת יותר מתוחכמת. אני אעבור בזריזות על מספר דוגמאות. עושים את זה כנראה בתדירות יותר נמוכה, לדוגמה ראו [A[1 3, פסיק, נקודה-פסיק. המשמעות של זה היא כל האיברים בשורה אחת או שלוש. זה אומר שנקבל את השורות הראשונה והשלישית של A ואת כל העמודות שלהם. זו הייתה המטריצה ​​A אז A 1 3 פסיק נקודה-פסיק פירושו לקבל את השורה הראשונה ואת השורה השלישית והנקודה-פסיק כמובן אומר שאנחנו רוצים לקבל את שתי העמודות, ולכן נקבל 1 2 5 6, כך. אבל משתמשים בסוג פעולות האינדקס המתוחכמות האלה לעתים קצת יותר נדירות. וכדי להראות לך מה אפשר עוד לעשות. הנה המטריצה ​​A ו-A נקודתיים פסיק 2 מחזיר את העמודה השניה. אפשר להשתמש בזה גם כדי לעשות השמות. אני יכול לקחת את העמודה השניה של A ולשים בה 10, 11, 12, ואז הערכים במטריצה משתנים, נעשה ניקח את העמודה השניה של A ונשים בה את וקטור העמודה הזה 10, 11, 12. אז, עכשיו המטריצה A היא 1, 3, 5. והעמודה השניה שונתה והיא עכשיו 10, 11, 12. הנה עוד פעולה. בואו נגדיר את A שווה A פסיק 100, 101, 102 כמו זה ומה שזה יעשה הוא לשרשר עוד וקטור עמודה לימין המטריצה. אז, עכשיו, אופס. אני חושב שעשיתי טעות קטנה. צריך לשים שם נקודה-פסיק, ועכשיו A שווה לזה. בסדר? אני מקווה שזה הגיוני. אז 100, 101, 102. זה וקטור עמודה ומה שעשינו היה השמת ערך ל-A, לקחנו את A ושמנו בו את הערך המקורי שלו. ואז הוספנו עוד וקטור עמודה מימין, בסיכומו של דבר לקחנו את המטריצה A - שהיתה שישה האברים כאן משמאל. לקחנו את המטריצה A וצרפנו עוד וקטור עמודה בצד ימין; ובגלל זה היא עכשיו מטריצה שלוש על שלוש שנראית ככה. ועוד טריק אחד שאני לפעמים משתמש בו, אם תכתוב רק A נקודתיים כמו כאן. זהו מקרה מיוחד במקצת מבחינה תחבירית. מה שזה אומר הוא לשרשר את כל האברים של A לתוך וקטור עמודה אחד מה שמחזיר לנו וקטור 9 על 1. הם פשוט כל השורות משורשרות. רק עוד מעט דוגמאות. בואו נראה. נאמר שאני שם ב-A את האברים 1 2 3 4 5 6, בסדר? ונניח אני מגדיר את B להיות 11, 12, 13, 14, 15, 16. אני יכול ליצור מטריצה C חדשה שווה ל-A B זה פשוט אומר הנה המטריצה A, הנה B ואני מגדיר C שווה ל-A B. מה שאני עושה הוא לקחת את שתי המטריצות האלה ופשוט לשרשר אותן זו לזו. אז משמאל, המטריצה A היא משמאל. והמטריצה B ​​מימין. וכך יצרתי את המטריצה C ה​​זאת על ידי שרשור שלהם. אני יכול גם לעשות C שווה A נקודה-פסיק B. הסימון נקודה-פסיק אומר שיש לשים את הדבר השני מתחת לראשון. אז כשאני כותב A נקודה-פסיק B, גם זה משרשר את שתי המטריצות אבל הפעם זו מעל זו. אז עכשיו יש לי A למעלה ו-B למטה, ולכן C היא מטריצה 6 על 2. אז כמו שבדרך כלל נקודה-פסיק משמעותו ללכת לשורה הבאה, גם כאן C מורכבת מ-A ואז יורדים שורה מתחת ל-A ושותלים שם את B, ודרך אגב, A B זה כמו A,B ושתי האפשרויות נותנות אותה תוצאה. אז עכשיו אני מקווה שאתם כבר יודעים איך בונים מטריצות ובתקווה אתם מתחילים לשלוט בחלק מהפקודות בהן משתמשים כדי לבנות מטריצות במהירות ולקחת מטריצות ולהדביק אותן זו לזו כדי ליצור מטריצות גדולות יותר, וכל זה רק עם כמה שורות קוד, אוקטבה היא שפה מאוד נוחה מבחינת כמה מהר אפשר להרכיב מטריצות מורכבות ולהעביר ולשחק בנתונים. אז זהו זה בקשר לטיפול בנתונים. בסרטון הבא נתחיל לדבר על האופן בו ניתן לעשות חישובים מורכבים על הנתונים שלנו. אני מקווה שזה נתן לכם איזו תחושה של איך בעזרת מספר קטן של פקודות אפשר לעצב נתונים מהר מאוד באוקטבה. אתם מבינים, לטעון ולשמור וקטורים ומטריצות, לטעון ולשמור נתונים, להרכיב מטריצות כדי ליצור מטריצות גדולות, לבחור אינדקסים לתוך מטריצות או לבחור אלמנטים ספציפיים של המטריצות. אני יודע שעברתי על הרבה פקודות, אני חושב שהשיטה הכי טובה בשבילכם היא לעיין בהיסטוריה של הפקודות שכתבנו כאן. אתם מבינים, תסתכלו על זה. גשו לאתר הקורס והורידו משם את תמליל ההרצאה ועיינו בתמליל והקלידו מספר פקודות בעצמכם לתוך אוקטבה והתחילו לשחק עם הפקודות האלה ותגרמו להן לעבוד. כמובן, אין שום טעם לנסות לשנן את כל הפקודות הללו. מה שאתם צריכים לעשות הוא, אני מקווה שהסרטון הזה נתן לכם תחושה של סוגי הדברים שאפשר לעשות. כך שמאוחר יותר כשתנסו לתכנת אלגוריתמי למידה בעצמכם, אם אתם מנסים למצוא פקודה מסוימת שאתם חושבים שיכול להיות שקיימת באוקטבה, כי תיזכרו שאולי ראיתם אותה כאן, אז תחפשו בתמליל של ההרצאה כדי למצוא את הפקודות שבהן תרצו להשתמש. אז, זה הכל בקשר העתקות של נתונים. ובסרטון הבא מה שהייתי רוצה לעשות הוא להתחיל לספר לכם איך לעשות למעשה חישובים מורכבים על נתונים, וכיצד לחשב תוצאות מן הנתונים, ולהתחיל ליישם בצורה מעשית אלגוריתמי למידה.