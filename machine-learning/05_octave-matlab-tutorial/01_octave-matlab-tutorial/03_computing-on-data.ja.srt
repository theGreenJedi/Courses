1
00:00:00,280 --> 00:00:02,820
help magic と入力してみましょう

2
00:00:02,820 --> 00:00:05,100
Octave でどのようにデータを読み込んだり

3
00:00:05,100 --> 00:00:10,028
保存したり、データを行列に代入したり

4
00:00:10,028 --> 00:00:14,880
などを理解できたところで、

5
00:00:14,880 --> 00:00:15,870
このビデオでは、

6
00:00:17,130 --> 00:00:17,810
データに対してどのように演算

7
00:00:19,650 --> 00:00:21,040
これが私の Octave ウィンドウです。

8
00:00:21,040 --> 00:00:25,900
後に、このような演算処理を使って

9
00:00:25,900 --> 00:00:33,470
学習アルゴリズムを実装していくことになります。

10
00:00:33,470 --> 00:00:37,855
では、始めましょう。

11
00:00:39,195 --> 00:00:42,235
これが私の Octave ウィンドウです。

12
00:00:42,235 --> 00:00:47,195
では、さっそく、いくつか

13
00:00:47,195 --> 00:00:52,215
例題に使う変数を

14
00:00:52,215 --> 00:00:57,145
初期化します。A を

15
00:00:57,145 --> 00:01:02,580
3 x 2 の行列に、

16
00:01:02,580 --> 00:01:06,208
そして B を

17
00:01:06,208 --> 00:01:11,230
3 x 2 の行列に設定し、

18
00:01:11,230 --> 00:01:17,140
さらに C を

19
00:01:17,140 --> 00:01:20,840
2 x 2 の行列に設定します。

20
00:01:20,840 --> 00:01:23,200
さて、二つの行列の乗算をしたいとします。

21
00:01:23,200 --> 00:01:27,440
例えば、A 掛ける C を計算するとします。

22
00:01:27,440 --> 00:01:31,494
これは単に A * Cと入力するだけです。

23
00:01:31,494 --> 00:01:36,500
これは、3 x 2 行列掛ける 2 x 2 行列です。

24
00:01:36,500 --> 00:01:39,440
すると、この 3 x 2 の行列が得られます。

25
00:01:41,100 --> 00:01:42,560
また、要素単位での

26
00:01:42,560 --> 00:01:46,230
演算も可能で、A .* B

27
00:01:46,230 --> 00:01:52,010
とすると、これが実行するのは、

28
00:01:52,010 --> 00:01:56,040
A の各要素を

29
00:01:56,040 --> 00:02:00,610
対応する B の各要素に

30
00:02:02,760 --> 00:02:08,173
掛け合わせます。

31
00:02:08,173 --> 00:02:15,080
ですから、これが A、これが B、そしてこれが A.*B

32
00:02:15,080 --> 00:02:20,300
だから、例えば、最初の要素は

33
00:02:20,300 --> 00:02:25,600
1 x 11 なので、11

34
00:02:25,600 --> 00:02:31,040
二番目の要素は

35
00:02:31,040 --> 00:02:36,660
2 x 12 で 24、という具合になります。

36
00:02:36,660 --> 00:02:42,973
このように要素単位での

37
00:02:42,973 --> 00:02:45,930
二つの行列の

38
00:02:45,930 --> 00:02:48,720
乗算です。一般的に、

39
00:02:48,720 --> 00:02:54,024
ピリオドは、

40
00:02:54,024 --> 00:02:56,050
通常、要素単位での

41
00:02:56,050 --> 00:02:57,240
操作を示す記号として Octave で使われます。

42
00:02:57,240 --> 00:02:58,360
ですから、ここにある 行列

43
00:02:58,360 --> 00:03:01,700
A に対し、A .^2 とすると、

44
00:03:01,700 --> 00:03:06,590
これは、

45
00:03:06,590 --> 00:03:11,430
要素単位での A の

46
00:03:11,430 --> 00:03:14,590
二乗になるので、1の二乗は

47
00:03:14,590 --> 00:03:21,520
1、2 の二乗は 4、という風になります。

48
00:03:21,520 --> 00:03:27,260
では、V をベクトルに設定します。

49
00:03:27,260 --> 00:03:33,620
V を 1、2、3 の列ベクトルにします。

50
00:03:33,620 --> 00:03:38,950
また、1./V

51
00:03:40,000 --> 00:03:44,190
とすると、

52
00:03:44,190 --> 00:03:45,450
V の要素単位の逆行列を求めると、

53
00:03:45,450 --> 00:03:50,840
これが戻すのは、

54
00:03:52,470 --> 00:03:55,490
1/1、1/2、そして 1/3 です。

55
00:03:55,490 --> 00:03:59,520
これは行列でも使えますので、

56
00:03:59,520 --> 00:04:03,720
1 ./ A とすると、

57
00:04:03,720 --> 00:04:08,350
これは 要素単位の A の逆行列

58
00:04:08,350 --> 00:04:11,260
となります。もう一度

59
00:04:11,260 --> 00:04:18,330
繰り返すと、ピリオドは、

60
00:04:18,330 --> 00:04:19,700
要素単位の処理であることを示すヒントとなります。

61
00:04:19,700 --> 00:04:22,970
また、こうしたこともできます log

62
00:04:25,160 --> 00:04:27,570
V これは、要素単位での

63
00:04:27,570 --> 00:04:34,300
V の対数で、

64
00:04:34,300 --> 00:04:38,880
exp(V) は、

65
00:04:38,880 --> 00:04:42,970
e を底にとった

66
00:04:42,970 --> 00:04:48,430
これらの要素の冪乗で、

67
00:04:48,430 --> 00:04:52,940
これが e、これが e

68
00:04:52,940 --> 00:04:58,790
squared EQ、これは

69
00:04:58,790 --> 00:05:03,230
V です。

70
00:05:03,230 --> 00:05:07,920
また、abs(V) とすることもでき、

71
00:05:07,920 --> 00:05:09,860
これは要素単位での V の

72
00:05:11,610 --> 00:05:14,760
絶対値です。ですから、

73
00:05:14,760 --> 00:05:19,630
ここでは、V は全て正の値でしたが、

74
00:05:19,630 --> 00:05:24,030
abs、マイナス 1 からマイナス 3、

75
00:05:24,030 --> 00:05:24,970
要素単位の絶対値は、

76
00:05:24,970 --> 00:05:29,970
として戻されるのは、

77
00:05:29,970 --> 00:05:36,590
これらの負でない数値となります。

78
00:05:36,590 --> 00:05:42,970
-V は、負の V を返します。

79
00:05:42,970 --> 00:05:47,440
これは、-1*V と同じ

80
00:05:47,440 --> 00:05:53,615
ことですが、通常は、

81
00:05:53,615 --> 00:05:55,235
-V とだけ表記し、-1*V

82
00:05:55,235 --> 00:05:59,545
とはしません。他に何があるでしょう。

83
00:05:59,545 --> 00:06:05,205
ここに、別のいいコツがあります。

84
00:06:05,205 --> 00:06:08,985
さて、見てみましょう。

85
00:06:08,985 --> 00:06:15,370
V に対して、その要素をそれぞれ 1 増やしたいとします。

86
00:06:15,370 --> 00:06:20,830
一つのやり方は

87
00:06:20,830 --> 00:06:23,690
3 x 1 ベクトルを

88
00:06:23,690 --> 00:06:28,830
作成して

89
00:06:28,830 --> 00:06:34,450
これは全て 1 です、そしてこれを V に足します。

90
00:06:34,450 --> 00:06:38,788
これを実行すると 1 2 3 だった V が 2 3 4 にインクリメントされます。

91
00:06:38,788 --> 00:06:41,751
このやり方は

92
00:06:41,751 --> 00:06:44,300
V の長さが 3 ですから

93
00:06:44,300 --> 00:06:48,820
ones、length(V)、

94
00:06:48,820 --> 00:06:53,760
1、これはones

95
00:06:53,760 --> 00:06:58,886
(3, 1) です。

96
00:06:58,886 --> 00:07:04,231
だから、ones(3, 1)

97
00:07:04,231 --> 00:07:07,740
確かに、そして次にしたのは

98
00:07:07,740 --> 00:07:11,750
V + ones

99
00:07:11,750 --> 00:07:13,270
(3, 1)、つまりこの全て

100
00:07:13,270 --> 00:07:14,360
1 のベクトルを V に

101
00:07:14,360 --> 00:07:17,740
足したわけです。これで、 V が

102
00:07:17,740 --> 00:07:24,270
1 インクリメントされます。

103
00:07:24,270 --> 00:07:28,820
もう一つ、より簡単な方法は、

104
00:07:28,820 --> 00:07:30,220
V + 1 と入力することですね。

105
00:07:30,220 --> 00:07:34,180
ですから、これが V で

106
00:07:34,180 --> 00:07:38,020
V + 1 が意味するのは、

107
00:07:38,020 --> 00:07:40,130
1 を要素単位で

108
00:07:40,130 --> 00:07:44,270
V の各要素に加えなさいということです。

109
00:07:44,270 --> 00:07:48,140
では、さらに演算についてお話します。

110
00:07:48,140 --> 00:07:50,940
ここに 行列 A があります。この A の転置行列を求めたい場合、

111
00:07:50,940 --> 00:07:54,225
そのやり方は、A' と入力することです。

112
00:07:54,225 --> 00:08:01,630
これはアポストロフィー記号です。

113
00:08:01,630 --> 00:08:06,600
左の引用符です。

114
00:08:06,600 --> 00:08:10,900
ですから、お手持ちのキーボードには

115
00:08:10,900 --> 00:08:13,330
左の引用符と

116
00:08:13,330 --> 00:08:16,720
右の引用符があると思います。

117
00:08:16,720 --> 00:08:21,790
ですから、これは、

118
00:08:21,790 --> 00:08:27,000
行順的な引用符です

119
00:08:27,000 --> 00:08:30,680
単に A' と入力すると

120
00:08:30,680 --> 00:08:33,150
これは、ご存知のように

121
00:08:34,490 --> 00:08:37,515
行列 A の転置行列が

122
00:08:37,515 --> 00:08:38,280
得られます。もちろん、

123
00:08:38,280 --> 00:08:43,050
転置の再転置を

124
00:08:43,050 --> 00:08:48,270
行えば、

125
00:08:48,270 --> 00:08:53,580
元の 行列 A に戻ります。さらに便利な関数をいくつか。

126
00:08:53,580 --> 00:08:58,260
例えば、小文字の a は

127
00:08:58,260 --> 00:08:59,960
1、15、2、0.5 とします。

128
00:08:59,960 --> 00:09:04,194
つまり、これは 1 x 4 行列です。

129
00:09:05,200 --> 00:09:08,780
そこで、 val = max(a) とすると

130
00:09:08,780 --> 00:09:12,480
これが戻すのは

131
00:09:12,480 --> 00:09:17,210
A の最大値です。これは、

132
00:09:17,210 --> 00:09:23,570
この場合は 15 です。そして

133
00:09:24,760 --> 00:09:30,050
val、ind、max(A)

134
00:09:30,050 --> 00:09:34,880
とすることも出来、これが返すのは

135
00:09:34,880 --> 00:09:39,660
val と ind、それは

136
00:09:39,660 --> 00:09:45,130
A の最大値、

137
00:09:45,130 --> 00:09:50,160
つまり 15 と、さらにそのインデックスです。

138
00:09:52,130 --> 00:09:56,220
A の 二番目の要素が 15 でしたので、

139
00:09:56,220 --> 00:10:00,700
ind はそれに対応するインデックスです。

140
00:10:00,700 --> 00:10:03,650
すこしご注意したいことがあります。

141
00:10:03,650 --> 00:10:06,280
もし A が行列の場合、 max(A) は

142
00:10:06,280 --> 00:10:07,470
それが返すのは実は

143
00:10:07,470 --> 00:10:12,050
列単位での最大値です。

144
00:10:12,050 --> 00:10:15,550
これについてはこの後で触れます。

145
00:10:15,550 --> 00:10:20,150
さて、この小文字の変数 a の例

146
00:10:20,150 --> 00:10:21,978
を引き続き使います。もし、a < 3 とすると、

147
00:10:21,978 --> 00:10:26,870
これは、要素単位での演算、

148
00:10:26,870 --> 00:10:32,950
要素単位での比較となります。

149
00:10:32,950 --> 00:10:36,110
ですから、a の最初の要素

150
00:10:36,110 --> 00:10:39,800
は 3 以下ですので 1 となり、

151
00:10:39,800 --> 00:10:45,558
a の二番目の要素は

152
00:10:45,558 --> 00:10:52,330
3 以下ではないので、

153
00:10:52,330 --> 00:10:56,290
その値は 0、なぜなら偽だからです。

154
00:10:56,290 --> 00:11:00,970
a の三番目と四番目の要素は

155
00:11:00,970 --> 00:11:05,820
レッスン、いえ、

156
00:11:05,820 --> 00:11:11,130
3 以下なので、三番目と四番目の要素は3 以下なので

157
00:11:11,130 --> 00:11:17,830
これは 1、1、ですから

158
00:11:17,830 --> 00:11:20,260
これは要素単位で

159
00:11:20,260 --> 00:11:22,340
四つの全ての要素を

160
00:11:22,340 --> 00:11:27,410
比較します。小文字の変数 a

161
00:11:27,410 --> 00:11:29,791
< 3 は、要素が 3 以下か

162
00:11:29,791 --> 00:11:31,600
どうかに応じて、真あるいは偽を返します。

163
00:11:31,600 --> 00:11:34,790
さて、もし find

164
00:11:34,790 --> 00:11:38,390
(a < 3) とすると、これが

165
00:11:38,390 --> 00:11:40,685
返すのは、a の

166
00:11:40,685 --> 00:11:45,760
どの要素が、

167
00:11:45,760 --> 00:11:50,090
変数 A が、3 以下かです。

168
00:11:50,090 --> 00:11:52,020
よってこの場合は、一番目、三番目

169
00:11:52,020 --> 00:11:54,262
そして四番目の要素が 3 以下です。

170
00:11:54,262 --> 00:11:59,470
次の例として、

171
00:11:59,470 --> 00:12:02,890
A を =

172
00:12:02,890 --> 00:12:06,480
magic(3) に設定します。

173
00:12:08,780 --> 00:12:12,750
magic 関数が戻すのは、

174
00:12:12,750 --> 00:12:16,820
magic 関数が戻すのは、

175
00:12:16,820 --> 00:12:20,340
魔方陣とよばれる行列です。

176
00:12:20,340 --> 00:12:23,120
こうした行列は、

177
00:12:23,120 --> 00:12:27,830
特有の数学的な特性があり、

178
00:12:27,830 --> 00:12:34,130
その全ての行と列と対角線上の

179
00:12:34,130 --> 00:12:38,110
数字の合計が同じ数になります。

180
00:12:38,110 --> 00:12:41,650
ですから、

181
00:12:44,210 --> 00:12:45,596
機械学習においては、実際には

182
00:12:45,596 --> 00:12:50,630
私の知る限り用途は限定されていますが、

183
00:12:50,630 --> 00:12:55,548
わたしは、単に

184
00:12:55,548 --> 00:12:59,760
3 x 3 の 行列を作成する

185
00:12:59,760 --> 00:13:04,342
のに便利なので、

186
00:13:04,342 --> 00:13:06,260
使います。この画面上の魔方陣

187
00:13:06,260 --> 00:13:09,255
の特徴は、

188
00:13:09,255 --> 00:13:13,340
それぞれの行、それぞれの列、そして