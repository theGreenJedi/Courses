Di video ini, saya ingin membahas
tentang ide vektorisasi. Apakah Anda menggunakan Octave atau bahasa serupa seperti MATLAB, atau apakah Anda menggunakan Pyhton, NumPy, atau Java, C, C++. Semua bahasa ini punya pustaka aljabar linier numerik berbeda yang terintegrasi atau yang mudah dan siap diakses. Pustaka-pustaka tsb biasanya dibuat
dengan sangat baik, sangat dioptimalkan, dikembangkan oleh orang yang punya gelar PhD dalam
perhitungan numerik atau ahli dalam perhitungan numerik. Dan, ketika Anda mengimplementasikan algoritma machine learning, jika Anda
bisa, ambil keuntungan dari pustaka aljabar linier ini atau pustaka alajabar linier numerik ini, dan gabungkan beberapa rutin untuk
memanggilnya daripada Anda buat sendiri hal-hal yang bisa dilakukan pustaka tsb. Jika Anda melakukannya, maka Anda akan dapatkan kode yang, pertama,
lebih efisien. Yang bekerja lebih cepat, dan mendapatkan keuntungan atas perangkat keras paralel yang dimiliki komputer Anda, dst. Kedua, itu juga berarti Anda hanya perlu menulis sedikit kode. Jadi, implementasinya sederhana, dan mungkin bisa terbebas dari bug. Sebagai contoh konkrit. Daripada menulis sendiri kode untuk mengalikan matriks, jika
Anda ijinkan Octave melakukannya dengan mengetik a * b, itu akan menggunakan rutin yang sangat efisien untuk mengalikan
2 matriks. Ada banyak contoh seperti ini dimana Anda menggunakan
implementasi vektor yang tepat. Anda mendapatkan kode yang jauh lebih
sederhana dan efisien. Mari lihat beberapa contoh. Ini hipotesis regresi linier. Jika Anda ingin menghitung h(x), perhatikan ada penjumlahan di kanan. Satu hal yang dapat Anda lakukan adalah menghitung sendiri penjumlahan dari j=0 hingga j=n. Cara lainnya adalah pikirkan h(x) sebagai theta' x. Dan, yang bisa Anda lakukan adalah menghitungnya dalam sebuah perkalian antara 2 vektor, dimana theta adalah vektor theta0, theta1, theta2, jika Anda punya 2 fitur. Jika n = 2 pikirkan x sebagai vektor x0, x1, x2. Dua tampilan ini memberi Anda 2 implementasi berbeda. Ini yang saya maksudkan. Ini implementasi untuk menghitung h(x) tanpa vektorisasi. Pertama, inisialisasi prediksi = 0.0. Prediksi ini akhirnya akan jadi nilai h(x), lalu akhirnya akan jadi untuk j=1 hingga n+1, prediksi ditambahkan dengan theta(j) * x(j). Itu adalah ekspresi yang ini. Ngomong-ngomong, saya harus katakan vektor ini dimulai dari indeks 0. Jadi, saya punya theta0, theta1, theta2. Tapi, karena di MATLAB indeksnya dimulai dari 1, theta0 dalam MATLAB, akan kita tampilkan sebagai theta1, elemen keduanya sebagai theta2, dan elemen ketiganya sebagai theta3, karena indeks vektor dalam MATLAB dimulai dari 1 meskipun theta dan x kita di sini dimulai dari indeks 0. Itulah sebabnya for loop ini j dimulai dari 1 hingga n+1 bukannya dari 0 hingga n. Ini adalah implementasi tanpa vektorisasi dimana kita menggunakan for loop untuk menjumlahkan n elemen. Sebaliknya, ini cara implementasi tervektorisasi, yaitu Anda pikirkan x dan theta sebagai vektor, dan Anda set prediksi = theta' * x. Anda hitung seperti demikian. Daripada menulis semua kode ini dengan for loop, sebagai gantinya Anda punya 1 baris kode, dan apa yang akan dilakukan kode di kanan ini adalah menggunakan rutin aljabar linier numerik Octave yang sangat dioptimalkan untuk menghitung perkalian antara 2 vektor, theta dan x.
Tidak hanya implementasi tervektorisasi lebih sederhana, itu juga bekerja lebih
efisien. Itulah Octave, tapi soal vektorisasi diterapkan juga pada bahasa pemrograman lainnya. Mari lihat contoh dalam C++. Begini tampilan implementasi tanpa
vektorisasi. Kita inisialisasi prediksi = 0.0, lalu kita punya for loop untuk j=0 hingga n. Prediksi += theta[j] * x[j] dimana lagi-lagi, Anda menulis sendiri
for loop ini. Sebaliknya, menggunakan pustaka aljabar linier numerik yang bagus dalam C++, Anda bisa menulis fungsi seperti ... Sebaliknya, menggunakan pustaka aljabar linier numerik yang bagus dalam C++, sebagai gantinya Anda bisa tulis kode seperti ini. Jadi, tergantung pada rincian pustaka aljabar linier numerik, Anda mungkin punya sebuah objek C++, yaitu vektor theta dan sebuah objek C++, yakni vektor x, dan lakukan theta.transpose() * x, dimana tanda * merupakan pustaka C++ untuk memuat operator perkalian sehingga Anda bisa mengalikan 2 vektor ini
dalam C++. Tergantung pada rincian pustaka aljabar linier numerik, Anda mungkin menggunakan sintaks yang sedikit berbeda, tapi dengan
mempercayakan sebuah pustaka untuk melakukan
perkalian ini, Anda bisa memperoleh bagian kode yang jauh lebih sederhana dan efisien. Mari lihat contoh yang lebih rumit. Hanya untuk mengingatkan Anda, ini aturan pembaruan gradient descent untuk regresi linier, jadi kita baharui theta j menggunakan aturan
ini untuk semua nilai j=0,1,2, dst. Jika saya tulis persamaan ini untuk theta0, theta1, theta2. Dengan asumsi kita punya 2 fitur. Jadi n = 2. Maka, ini adalah pembaharuan yang kita lakukan untuk theta0, theta1,
theta2. Anda mungkin ingat perkataan saya di video awal-awal bahwa pembaruan ini harus dilakukan
bersama. Jadi, mari lihat jika kita bisa melakukan implementasi vektorisasi pada
pembaruan ini. Ini 3 persamaan yang sama, ditulis dengan font yang lebih kecil dan Anda bisa bayangkan 1 cara untuk mengimplementasikan 3 baris kode ini adalah dengan for loop seperti for j = 0, 1 hingga 2 untuk membarui theta j atau sesuatu yang seperti itu. Tapi sebagai gantinya, mari implementasikan vektorisasi dan lihat
jika caranya bisa lebih sederhana. Jadi, pada dasarnya padatkan 3 baris kode ini atau