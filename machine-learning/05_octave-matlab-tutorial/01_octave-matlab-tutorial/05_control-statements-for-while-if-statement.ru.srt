1
00:00:00,180 --> 00:00:01,178
В этом

2
00:00:01,178 --> 00:00:02,587
видео мне хотелось бы рассказать вам,

3
00:00:02,600 --> 00:00:03,842
как писать управляющие

4
00:00:03,842 --> 00:00:05,672
операторы для ваших программ на

5
00:00:05,700 --> 00:00:07,280
Octave, такие как "for", "while" и "if", а также как

6
00:00:07,350 --> 00:00:12,176
описывать и использовать функции.

7
00:00:12,480 --> 00:00:13,980
Вот окно Octave.

8
00:00:13,980 --> 00:00:16,502
Сначала я покажу, как используется цикл for.

9
00:00:16,502 --> 00:00:17,888
Для начала я задам

10
00:00:17,888 --> 00:00:18,852
нулевой вектор v размера

11
00:00:18,870 --> 00:00:20,808
10х1.

12
00:00:20,830 --> 00:00:22,209
Теперь я создам цикл, в котором переменная i принимает

13
00:00:22,240 --> 00:00:25,071
значения от 1 до 10.

14
00:00:25,090 --> 00:00:27,608
Таков смысл выражения "for i=1:10".

15
00:00:27,608 --> 00:00:29,905
И давайте посмотрим,

16
00:00:29,905 --> 00:00:31,466
я собираюсь назначить v(i)

17
00:00:31,466 --> 00:00:33,214
равным 2 в степени i и наконец написать

18
00:00:33,220 --> 00:00:36,848
ключевое

19
00:00:36,848 --> 00:00:37,671
пишем end.

20
00:00:37,671 --> 00:00:39,082
Пробелы не имеют значения,

21
00:00:39,090 --> 00:00:40,538
таким образом, я их добавляю, чтобы код выглядел хорошо

22
00:00:40,538 --> 00:00:41,960
читаемым, но вы помните, что больше

23
00:00:41,990 --> 00:00:44,385
ни на что они не влияют.

24
00:00:44,420 --> 00:00:46,163
Если я запущу этот код, v

25
00:00:46,163 --> 00:00:48,626
будет принимать значения

26
00:00:48,626 --> 00:00:49,420
два в степени один,

27
00:00:49,500 --> 00:00:51,478
два в степени два, и так далее.

28
00:00:51,490 --> 00:00:52,665
Синтаксис цикла

29
00:00:52,665 --> 00:00:55,410
выглядит как i=1:10, и i

30
00:00:55,410 --> 00:00:57,429
изменяется в

31
00:00:57,440 --> 00:00:59,662
пределах от 1 до 10.

32
00:00:59,662 --> 00:01:00,830
Кстати, то же самое можно

33
00:01:00,830 --> 00:01:02,481
сделать, присвоив

34
00:01:02,481 --> 00:01:04,795
indices=1:10, так что

35
00:01:04,800 --> 00:01:07,260
indices равно вектору чисел

36
00:01:07,270 --> 00:01:09,305
от 1 до 10.

37
00:01:09,305 --> 00:01:13,249
Вы также можете написать: for i=indices

38
00:01:15,040 --> 00:01:17,805
Это то же самое, что i=1:10.

39
00:01:17,820 --> 00:01:19,459
Команда disp(i) покажет, что это

40
00:01:19,480 --> 00:01:23,498
одно и то же.

41
00:01:23,498 --> 00:01:24,698
Итак, это цикл "for".

42
00:01:24,698 --> 00:01:27,201
Если вы знакомы с операторами

43
00:01:27,230 --> 00:01:29,375
"break" и "continue", то их вы

44
00:01:29,375 --> 00:01:30,809
также можете использовать

45
00:01:30,809 --> 00:01:32,061
внутри цикла в Octave. Но позвольте

46
00:01:32,061 --> 00:01:33,902
мне сначала

47
00:01:33,902 --> 00:01:36,550
показать вам, как работает цикл "while".

48
00:01:36,570 --> 00:01:39,088
Итак, вот мой вектор V.

49
00:01:39,120 --> 00:01:40,912
Давайте напишем цикл while.

50
00:01:40,920 --> 00:01:44,037
i=1; while i<=5, скажем,

51
00:01:44,037 --> 00:01:45,259
мы присваиваем v(i)

52
00:01:45,259 --> 00:01:47,662
значение 100 и

53
00:01:47,662 --> 00:01:51,082
увеличиваем i

54
00:01:51,530 --> 00:01:54,449
на единицу,

55
00:01:54,449 --> 00:01:56,644
end.

56
00:01:56,700 --> 00:01:58,090
Что это означает?

57
00:01:58,090 --> 00:01:59,932
Изначально i равно единице.

58
00:01:59,970 --> 00:02:01,359
Элементу v(i) я присваиваю

59
00:02:01,380 --> 00:02:02,629
значение 100 и увеличиваю i

60
00:02:02,629 --> 00:02:04,249
на один до тех пор, пока i не

61
00:02:04,260 --> 00:02:07,666
станет больше пяти.

62
00:02:07,690 --> 00:02:09,377
В результате если раньше v представлял собой

63
00:02:09,377 --> 00:02:13,022
вектор степеней двоек,

64
00:02:13,022 --> 00:02:14,573
теперь первые пять элементов

65
00:02:14,580 --> 00:02:17,225
вектора были изменены на

66
00:02:17,260 --> 00:02:19,618
значение 100.

67
00:02:19,618 --> 00:02:22,797
Итак, это синтаксис для цикла while.

68
00:02:23,140 --> 00:02:24,503
Давайте рассмотрим другой пример.

69
00:02:24,503 --> 00:02:26,600
i=1; while true, и далее мы

70
00:02:26,600 --> 00:02:28,491
будем учиться использовать

71
00:02:28,500 --> 00:02:31,892
оператор break.

72
00:02:31,892 --> 00:02:34,040
В теле цикла: V(i) присвоим 999, увеличим

73
00:02:34,070 --> 00:02:37,331
счетчик i на 1 и добавим условие

74
00:02:38,110 --> 00:02:45,900
если i == 6 то прерываем цикл оператором break,

75
00:02:47,910 --> 00:02:47,910
пишем end.

76
00:02:48,410 --> 00:02:49,425
Здесь мы впервые использовали оператор условия if,

77
00:02:49,425 --> 00:02:51,945
я надеюсь логика его использования

78
00:02:51,945 --> 00:02:53,308
понятна.

79
00:02:53,308 --> 00:02:57,297
Изначально i равно 1, и увеличивается на 1 с каждым шагом цикла.

80
00:02:57,340 --> 00:02:59,900
В цикле V(i) присваивается значение, счетчик i

81
00:02:59,900 --> 00:03:01,527
увеличивается на 1, и когда i увеличивается

82
00:03:01,527 --> 00:03:02,901
до 6 происходит прерывание

83
00:03:02,920 --> 00:03:04,451
цикла оператором break

84
00:03:04,451 --> 00:03:05,757
и в результате

85
00:03:05,757 --> 00:03:07,284
работы цикла

86
00:03:07,284 --> 00:03:08,596
первые 5 элементов

87
00:03:08,596 --> 00:03:09,929
вектора должны быть равны

88
00:03:09,929 --> 00:03:11,748
999.

89
00:03:11,748 --> 00:03:14,832
И, да, действительно, мы перезаписали первые пять

90
00:03:14,832 --> 00:03:18,345
элементов V значением 999.

91
00:03:18,345 --> 00:03:20,172
Итак, таков синтаксис

92
00:03:20,172 --> 00:03:21,974
операторов if и while, и обратите внимание на

93
00:03:21,974 --> 00:03:25,058
оператор end.

94
00:03:25,070 --> 00:03:27,159
У нас тут два ключевых слова end.

95
00:03:27,170 --> 00:03:29,719
Первый end заканчивает условие if, второй end заканчивает

96
00:03:29,730 --> 00:03:33,228
цикл while.

97
00:03:33,250 --> 00:03:35,265
Сейчас я продемонстрирую более общий синтаксис для

98
00:03:35,265 --> 00:03:37,763
связки if-else.

99
00:03:37,763 --> 00:03:40,274
Итак, v(1)=999. Ради

100
00:03:40,274 --> 00:03:42,776
примера присвоим v(1)

101
00:03:42,860 --> 00:03:46,996
значение 2.

102
00:03:47,020 --> 00:03:48,758
Создадим условие: если v(1) равно 1, то отобразить текст

103
00:03:48,758 --> 00:03:55,050
"Значение равно 1".

104
00:03:56,855 --> 00:03:58,588
Вот как применяется

105
00:03:58,588 --> 00:04:00,040
оператор

106
00:04:00,040 --> 00:04:03,853
else, вернее,

107
00:04:03,853 --> 00:04:07,815
elseif.

108
00:04:07,815 --> 00:04:12,268
Если v(i) равно 2, то отобразится текст "Значение равно 2", во всех

109
00:04:13,650 --> 00:04:17,960
остальных случаях - "Значение не равно 1 или 2".

110
00:04:17,990 --> 00:04:21,699
Хорошо, вот так мы заканчиваем выражение

111
00:04:21,700 --> 00:04:23,889
if-elseif.

112
00:04:23,889 --> 00:04:25,271
Конечно, так как мы только

113
00:04:25,271 --> 00:04:27,589
что присвоили v(1) зачение 2, и

114
00:04:27,610 --> 00:04:30,729
да, мы видим текст "Значение равно 2".

115
00:04:30,780 --> 00:04:32,844
Наконец, кажется, я об этом

116
00:04:32,880 --> 00:04:34,143
еще не говорил, но

117
00:04:34,143 --> 00:04:35,622
если вы хотите выйти из Octave, вы

118
00:04:35,622 --> 00:04:36,947
можете использовать команду

119
00:04:36,947 --> 00:04:38,373
exit. Команда quit

120
00:04:38,400 --> 00:04:39,981
также завершит работу

121
00:04:39,981 --> 00:04:42,428
Octave.

122
00:04:42,450 --> 00:04:43,857
Наконец, давайте поговорим

123
00:04:43,857 --> 00:04:45,292
о функциях, их

124
00:04:45,310 --> 00:04:48,592
определении и использовании.

125
00:04:48,620 --> 00:04:49,680
Вот мой рабочий стол,

126
00:04:49,720 --> 00:04:52,078
где я уже подготовил заранее

127
00:04:52,078 --> 00:04:56,818
созданный файл с именем "squarethisnumber.m".

128
00:04:56,830 --> 00:04:59,471
Так в Octave обозначаются функции.

129
00:04:59,480 --> 00:05:01,681
Вы создаете файл с именем функции и присваиваете ему

130
00:05:01,681 --> 00:05:03,958
расширение ".m". Когда Octave находит

131
00:05:03,960 --> 00:05:05,694
файл "squarethisnumber.m", то

132
00:05:05,730 --> 00:05:07,643
понимает, что в нем нужно искать

133
00:05:07,680 --> 00:05:12,322
определение функции "squarethisnumber".

134
00:05:12,340 --> 00:05:14,076
Давайте откроем этот файл.

135
00:05:14,076 --> 00:05:15,717
Заметьте, что я использую программу Microsoft Wordpad, чтобы

136
00:05:15,717 --> 00:05:19,352
открыть этот файл.

137
00:05:19,352 --> 00:05:20,250
Я рекомендую, если вы

138
00:05:20,250 --> 00:05:23,379
используете Microsoft Windows, для

139
00:05:23,379 --> 00:05:25,075
работы с этими файлами

140
00:05:25,110 --> 00:05:27,477
вместо Блокнота использовать Wordpad, или

141
00:05:27,490 --> 00:05:28,557
какой-нибудь другой

142
00:05:28,557 --> 00:05:29,938
редактор. Блокнот иногда

143
00:05:29,938 --> 00:05:33,325
повреждает форматирование.

144
00:05:33,350 --> 00:05:34,775
Если у вас есть только

145
00:05:34,800 --> 00:05:36,312
Блокнот, его вы тоже можете

146
00:05:36,312 --> 00:05:37,779
использовать. Но если у вас есть

147
00:05:37,779 --> 00:05:39,354
выбор, лучше используйте Wordpad

148
00:05:39,354 --> 00:05:40,609
или другой текстовый

149
00:05:40,610 --> 00:05:45,053
редактор.

150
00:05:45,060 --> 00:05:47,155
Итак, как в Octave Определяются функции?

151
00:05:47,155 --> 00:05:49,816
Позвольте мне немного увеличить.

152
00:05:49,816 --> 00:05:52,516
И этот файл содержит всего лишь три строки.

153
00:05:52,516 --> 00:05:54,440
Первая строка

154
00:05:54,440 --> 00:05:56,448
сигнализирует Octave, что

155
00:05:56,448 --> 00:05:57,705
функция

156
00:05:57,705 --> 00:06:00,025
возвращает переменную y; результатом

157
00:06:00,025 --> 00:06:01,315
функции будет одна

158
00:06:01,315 --> 00:06:02,375
переменная, которая будет

159
00:06:02,375 --> 00:06:04,443
храниться в y. Кроме того,

160
00:06:04,443 --> 00:06:06,003
тут указано,

161
00:06:06,003 --> 00:06:08,068
что у этой функции всего

162
00:06:08,070 --> 00:06:10,408
один аргумент, аргумент х. В теле

163
00:06:10,420 --> 00:06:11,846
функции значение y вычисляется как квадратный

164
00:06:11,846 --> 00:06:15,156
корень из х.

165
00:06:15,180 --> 00:06:16,553
Давайте попробуем вызвать эту  функцию для числа 5. У нас

166
00:06:16,553 --> 00:06:19,071
ничего не получится: Octave

167
00:06:19,071 --> 00:06:21,854
говорит,

168
00:06:21,854 --> 00:06:23,115
что функция squareThisNumber

169
00:06:23,115 --> 00:06:25,693
не определена.

170
00:06:25,693 --> 00:06:28,902
Это потому, что Octave не знает, где найти этот файл.

171
00:06:28,902 --> 00:06:30,682
Как обычно, командами pwd и

172
00:06:30,690 --> 00:06:32,592
cd давайте перейдем в

173
00:06:32,592 --> 00:06:36,151
каталог c:\users\ang\desktop.

174
00:06:36,151 --> 00:06:39,888
Это мой рабочий стол.

175
00:06:39,888 --> 00:06:41,276
Упс, маленькая опечатка.

176
00:06:41,276 --> 00:06:42,848
Если я теперь

177
00:06:42,848 --> 00:06:44,157
вызову squareThisNumber с

178
00:06:44,157 --> 00:06:46,728
аргументом 5,

179
00:06:46,728 --> 00:06:48,505
мне вернется 25.

180
00:06:48,505 --> 00:06:50,347
Заметка из разряда "для продвинутых",

181
00:06:50,347 --> 00:06:51,972
для тех из вас,

182
00:06:51,972 --> 00:06:54,596
кто знает, что такое пути поиска.

183
00:06:54,596 --> 00:06:55,945
Пусть

184
00:06:55,945 --> 00:06:57,497
это идет как

185
00:06:57,497 --> 00:06:58,863
дополнительный материал. В Octave

186
00:06:58,863 --> 00:06:59,866
можно

187
00:06:59,866 --> 00:07:01,827
модифицировать путь

188
00:07:01,827 --> 00:07:03,292
поиска.

189
00:07:03,292 --> 00:07:04,214
Те из вас, кто знаком с понятиями

190
00:07:04,214 --> 00:07:05,484
пути поиска и правами,

191
00:07:05,484 --> 00:07:07,642
могут использовать

192
00:07:07,650 --> 00:07:08,962
команду addpath('C:\users\ANG\desktop')

193
00:07:08,962 --> 00:07:11,875
для добавления

194
00:07:11,880 --> 00:07:16,241
папки, в которой

195
00:07:16,241 --> 00:07:17,972
Octave будет искать

196
00:07:17,972 --> 00:07:19,744
файлы. Даже если

197
00:07:19,744 --> 00:07:21,065
вы находитесь

198
00:07:21,065 --> 00:07:22,611
в другой папке,

199
00:07:22,611 --> 00:07:24,510
Octave будет знать,

200
00:07:24,510 --> 00:07:26,005
что в папке

201
00:07:26,005 --> 00:07:29,214
рабочего стола

202
00:07:29,214 --> 00:07:30,521
пользователя ANG

203
00:07:30,521 --> 00:07:31,868
можно поискать

204
00:07:31,868 --> 00:07:35,297
файл squareThisNumber, пусть даже я по-прежнему остаюсь в другой директории.

205
00:07:35,297 --> 00:07:35,935
Понятно?

206
00:07:35,935 --> 00:07:37,407
Но, если вы не знакомы с

207
00:07:37,407 --> 00:07:39,184
понятием пути поиска, не беспокойтесь об

208
00:07:39,184 --> 00:07:40,068
этом.

209
00:07:40,068 --> 00:07:40,889
Просто убедитесь, что с помощью команды

210
00:07:40,889 --> 00:07:42,053
cd перешли в папку с

211
00:07:42,053 --> 00:07:43,926
файлом функции перед

212
00:07:43,940 --> 00:07:47,441
ее вызовом, и все будет работать.

213
00:07:47,441 --> 00:07:49,587
В Octave есть то, чего нет во

214
00:07:49,600 --> 00:07:51,058
многих других языках программирования,

215
00:07:51,058 --> 00:07:52,969
он позволяет Вам

216
00:07:52,969 --> 00:07:54,909
определять функции возвращающие множество

217
00:07:54,909 --> 00:07:58,873
аргументов.

218
00:07:58,873 --> 00:08:00,889
Вот пример.

219
00:08:00,889 --> 00:08:02,931
Определим функцию squareAndCubeThisNumber

220
00:08:02,931 --> 00:08:04,964
от х. Как видите,

221
00:08:04,964 --> 00:08:06,644
она возвращает два

222
00:08:06,660 --> 00:08:08,547
значения, y1 и y2.

223
00:08:08,547 --> 00:08:09,955
Далее я определяю, что y1 равно x

224
00:08:09,960 --> 00:08:13,603
в квадрате, y2 равно x в кубе.

225
00:08:13,603 --> 00:08:16,972
В конечном итоге мне возвращаются два числа.

226
00:08:16,980 --> 00:08:18,855
В зависимости от предпочитаемых вами языков

227
00:08:18,855 --> 00:08:20,195
программирования, вы можете знать С++,

228
00:08:20,195 --> 00:08:22,931
например.

229
00:08:22,940 --> 00:08:26,051
Часто считается, что функция должна возвращать всего одно значение.

230
00:08:26,051 --> 00:08:27,847
Но синтаксис языка Octave таков, что функция может возвращать

231
00:08:27,847 --> 00:08:31,679
несколько значений.

232
00:08:32,430 --> 00:08:34,087
Сейчас вернемся в окно Octave.

233
00:08:34,087 --> 00:08:37,914
Если я наберу [a,b]=squareAndCubeThisNumber(5),

234
00:08:37,914 --> 00:08:41,263
то а станет

235
00:08:41,263 --> 00:08:44,599
равно 25, а b

236
00:08:44,610 --> 00:08:46,338
станет

237
00:08:46,338 --> 00:08:47,778
равно 5 в кубе,

238
00:08:47,778 --> 00:08:49,729
то есть 125.

239
00:08:49,729 --> 00:08:51,645
Это удобно в случаях,

240
00:08:51,670 --> 00:08:53,010
когда определяемая функция должна возвращать несколько

241
00:08:53,010 --> 00:08:56,447
значений.

242
00:08:56,447 --> 00:08:57,480
Наконец, я собираюсь показать

243
00:08:57,480 --> 00:09:01,123
вам еще один, более сложный, пример функции.

244
00:09:01,130 --> 00:09:02,361
Допустим, у меня есть набор

245
00:09:02,370 --> 00:09:04,400
данных с координатами точек 1, 1; 2, 2; 3, 3.

246
00:09:04,430 --> 00:09:07,636
И я бы хотел написать

247
00:09:07,636 --> 00:09:09,113
функцию Octave, которая вычисляла

248
00:09:09,113 --> 00:09:10,798
бы функцию стоимости J для

249
00:09:10,830 --> 00:09:14,341
различных значений тета.

250
00:09:14,360 --> 00:09:16,157
Сначала давайте введем данные в Octave.

251
00:09:16,160 --> 00:09:17,694
Итак, моя матрица плана будет:

252
00:09:17,700 --> 00:09:20,998
X=[1 1; 2 2; 3 3]

253
00:09:21,010 --> 00:09:24,043
И вот моя матрица плана х

254
00:09:24,050 --> 00:09:26,073
с элементом х0, с первым

255
00:09:26,073 --> 00:09:27,428
столбцом и вторым столбцом,

256
00:09:27,428 --> 00:09:28,746
содержащим х-координаты

257
00:09:28,770 --> 00:09:32,375
исследуемых точек.

258
00:09:32,375 --> 00:09:33,594
И пусть y=[1; 2; 3], это будут

259
00:09:33,594 --> 00:09:35,488
у-координаты

260
00:09:35,488 --> 00:09:38,793
точек.

261
00:09:38,810 --> 00:09:40,431
Предположим, что

262
00:09:40,431 --> 00:09:43,714
theta=[1; 2].

263
00:09:43,730 --> 00:09:45,652
Я рабочем столе я подготовил

264
00:09:45,660 --> 00:09:47,483
файл функции стоимости J, и

265
00:09:47,490 --> 00:09:49,008
если я открою его, то увижу, что функция выглядит следующим

266
00:09:49,010 --> 00:09:52,019
образом.

267
00:09:52,019 --> 00:09:53,579
В первой строке выражение

268
00:09:53,580 --> 00:09:55,192
для функции. Потом

269
00:09:55,192 --> 00:09:57,151
идут комментарии касательно

270
00:09:57,151 --> 00:09:59,546
параметров. Затем

271
00:09:59,560 --> 00:10:01,383
m присваивается количество

272
00:10:01,383 --> 00:10:02,995
примеров, то есть число

273
00:10:03,020 --> 00:10:05,495
строк в х.

274
00:10:05,510 --> 00:10:07,596
Вычислим прогнозы как X умножить на тета. Далее

275
00:10:07,596 --> 00:10:10,137
после знака %

276
00:10:10,170 --> 00:10:11,670
идет следующий

277
00:10:11,710 --> 00:10:14,693
комментарий.

278
00:10:14,720 --> 00:10:16,823
Вычисление ошибок

279
00:10:16,823 --> 00:10:18,637
прогнозирования как

280
00:10:18,640 --> 00:10:20,265
разницу между прогнозом и

281
00:10:20,265 --> 00:10:22,126
значением y с поэлементным возведением

282
00:10:22,140 --> 00:10:24,376
в квадрат. Наконец,

283
00:10:24,376 --> 00:10:26,128
вычисление

284
00:10:26,128 --> 00:10:27,439
значения J. Octave знает,

285
00:10:27,439 --> 00:10:31,383
что эту величину нужно вернуть мне, потому что я указал это при определении функции.

286
00:10:31,420 --> 00:10:34,127
Кстати, не стесняйтесь ставить

287
00:10:34,170 --> 00:10:35,292
видео на паузу и

288
00:10:35,292 --> 00:10:36,712
внимательно изучать текст функции,

289
00:10:36,712 --> 00:10:38,820
чтобы лучше понимать, что она

290
00:10:38,820 --> 00:10:44,031
делает.

291
00:10:44,031 --> 00:10:45,184
Я запускаю

292
00:10:45,184 --> 00:10:46,630
ее в Octave,

293
00:10:46,630 --> 00:10:51,197
вводя j = costFunctionJ(x,y,theta).

294
00:10:51,197 --> 00:10:55,142
Вычисляется результат.Ой, тут опечатка.

295
00:10:55,142 --> 00:10:57,018
Надо было использовать

296
00:10:57,018 --> 00:11:00,472
заглавную Х. В результате J равно 0,

297
00:11:00,510 --> 00:11:03,367
так как вводя 1, 2 и 3, 1, 2 и 3, с theta(0)

298
00:11:03,367 --> 00:11:06,963
равным 0 и theta(1) равным 1, я

299
00:11:06,980 --> 00:11:08,741
получаю прямую под

300
00:11:08,770 --> 00:11:11,259
углом 45 градусов,

301
00:11:11,259 --> 00:11:15,559
которая идеально соответствует моим данным.

302
00:11:15,600 --> 00:11:16,887
А вот если я присвою

303
00:11:16,887 --> 00:11:19,828
theta=[0;0], то моя гипотеза

304
00:11:19,830 --> 00:11:22,524
предсказывает нули

305
00:11:22,540 --> 00:11:24,050
во всех

306
00:11:24,050 --> 00:11:25,803
точках; theta(0) равно 0, theta(1) равно 0, и функция

307
00:11:25,810 --> 00:11:27,139
стоимости получается

308
00:11:27,139 --> 00:11:29,345
равной 2.333.

309
00:11:29,370 --> 00:11:31,830
Это значение

310
00:11:31,830 --> 00:11:35,495
рассчитывается как 1

311
00:11:35,520 --> 00:11:36,745
в квадрате, то

312
00:11:36,745 --> 00:11:39,789
есть квадрат

313
00:11:39,800 --> 00:11:42,377
ошибки в первом

314
00:11:42,440 --> 00:11:45,288
случае,

315
00:11:45,288 --> 00:11:47,091
плюс 2 в

316
00:11:47,091 --> 00:11:50,643
квадрате, плюс 3 в

317
00:11:50,643 --> 00:11:53,289
квадрате, и все

318
00:11:53,330 --> 00:11:54,909
это поделить

319
00:11:54,909 --> 00:11:56,302
на 2*m, то есть

320
00:11:56,302 --> 00:11:58,212
удвоенное число

321
00:11:58,250 --> 00:12:00,222
образцов.

322
00:12:00,222 --> 00:12:03,433
Результат действительно равен 2.333, значит, в этом примере мы правильно рассчитали функцию затрат.

323
00:12:03,490 --> 00:12:04,914
То есть наша проверка

324
00:12:04,960 --> 00:12:08,689
показала, что costFunctionJ,

325
00:12:08,720 --> 00:12:10,202
определенная следующим

326
00:12:10,230 --> 00:12:12,992
образом, действительно вычисляет

327
00:12:12,992 --> 00:12:14,908
функцию стоимости,

328
00:12:14,920 --> 00:12:17,424
по крайней мере

329
00:12:17,430 --> 00:12:18,835
на нашем

330
00:12:18,835 --> 00:12:20,823
простом примере с

331
00:12:20,823 --> 00:12:25,189
простыми парами координат X и Y

332
00:12:25,230 --> 00:12:26,285
Итак, вы познакомились с операторами

333
00:12:26,285 --> 00:12:28,171
циклов for и while, с оператором

334
00:12:28,171 --> 00:12:29,838
условного перехода if в Octave, а также научились

335
00:12:29,838 --> 00:12:33,197
пользоваться функциями.

336
00:12:33,197 --> 00:12:34,530
В следующем видео я

337
00:12:34,530 --> 00:12:36,123
вкратце познакомлю

338
00:12:36,123 --> 00:12:38,144
вас с процессом

339
00:12:38,144 --> 00:12:39,873
решения и

340
00:12:39,873 --> 00:12:41,664
проверки ваших самостоятельных

341
00:12:41,664 --> 00:12:45,212
заданий, с нашей системой загрузки результатов.

342
00:12:45,230 --> 00:12:46,794
Наконец, в последнем

343
00:12:46,794 --> 00:12:48,856
видеоуроке по Octave я

344
00:12:48,856 --> 00:12:51,400
расскажу о векторизации, способе

345
00:12:51,400 --> 00:12:52,938
значительно

346
00:12:52,938 --> 00:12:56,126
ускорить выполнение ваших программ в Octave.