1
00:00:00,090 --> 00:00:02,346
1/2、

2
00:00:02,390 --> 00:00:03,635
ここまでで機械学習について様々な知識が得られました。

3
00:00:03,635 --> 00:00:05,448
このビデオでは、

4
00:00:05,470 --> 00:00:06,718
プログラミング言語

5
00:00:06,760 --> 00:00:08,878
Octave を使って、

6
00:00:08,890 --> 00:00:10,259
既に見た

7
00:00:10,259 --> 00:00:11,770
学習アルゴリズムおよび、

8
00:00:11,770 --> 00:00:14,872
今後の授業で学ぶ学習アルゴリズムを

9
00:00:14,900 --> 00:00:16,381
手早く実装する方法を学びます。

10
00:00:16,381 --> 00:00:19,497
過去に、機械学習を教えるにあたって、

11
00:00:19,500 --> 00:00:22,046
様々な種類のプログラミング言語を使ってきました。

12
00:00:22,825 --> 00:00:25,379
たとえば C++、 Java、

13
00:00:25,379 --> 00:00:27,128
Python、NumPy、R、そして

14
00:00:27,160 --> 00:00:28,783
Octave などです。その経験から

15
00:00:28,790 --> 00:00:30,535
学んだことは、学生たちが

16
00:00:30,570 --> 00:00:32,497
一番効率よく、

17
00:00:32,497 --> 00:00:33,780
手早く学ぶことができ、

18
00:00:33,780 --> 00:00:35,569
そして アルゴリズムの試作を

19
00:00:35,569 --> 00:00:38,262
迅速に行えるのは、

20
00:00:38,290 --> 00:00:39,798
Octave のような高級言語であるということです。

21
00:00:39,798 --> 00:00:41,516
実際に、私がよく

22
00:00:41,520 --> 00:00:43,655
シリコンバレーで見かけるのは、

23
00:00:43,655 --> 00:00:44,714
たとえ構築する必要があるのが

24
00:00:44,740 --> 00:00:46,548
構築したいものが

25
00:00:46,610 --> 00:00:48,242
大規模な学習

26
00:00:48,242 --> 00:00:50,637
アルゴリズムであっても、多くの場合、

27
00:00:50,660 --> 00:00:52,200
まず試作を行い、その言語は Octave であることです。

28
00:00:52,210 --> 00:00:55,264
これは 試作用の言語として優れています。

29
00:00:55,270 --> 00:00:56,629
ですから、学習アルゴリズムを手早く動作させることが出来、

30
00:00:56,629 --> 00:00:58,459
本当に、必要な時のみ、

31
00:00:58,480 --> 00:01:00,362
それを大規模に展開する段階になって、

32
00:01:00,362 --> 00:01:03,059
その時にのみ、時間をかけて

33
00:01:03,059 --> 00:01:05,150
アルゴリズムを

34
00:01:05,160 --> 00:01:06,273
C++ や Java などの言語で再実装します。

35
00:01:06,300 --> 00:01:08,679
なぜなら、これまで学んだ教訓として、

36
00:01:08,710 --> 00:01:09,848
プログラミングの時間、開発の時間、

37
00:01:09,870 --> 00:01:13,309
つまりあなたの時間は、

38
00:01:13,320 --> 00:01:15,101
機械学習に使う時間は、非常に貴重だ、ということです。

39
00:01:15,101 --> 00:01:17,898
このため、もし Octave を使って

40
00:01:17,898 --> 00:01:18,932
学習アルゴリズムを手早く稼動させることができれば

41
00:01:18,932 --> 00:01:20,697
結果的に、開発時間

42
00:01:20,720 --> 00:01:22,143
の大幅な節約につながるのは

43
00:01:22,150 --> 00:01:23,971
最初にアルゴリズムの開発を

44
00:01:23,971 --> 00:01:28,145
Octave で行い、次に、アイディアが有効で

45
00:01:28,160 --> 00:01:30,238
あることを確認した後で C++ や Java などで実装することです。

46
00:01:30,238 --> 00:01:31,538
私が見た中で、人々が一番一般的に

47
00:01:31,560 --> 00:01:34,058
機械学習で使う試作用の言語は、

48
00:01:34,070 --> 00:01:37,230
Octave、 MATLAB、

49
00:01:38,150 --> 00:01:40,032
Python、NumPy、そして R です。

50
00:01:40,032 --> 00:01:42,660
Octave はオープンソースなのでナイスですが、

51
00:01:42,670 --> 00:01:44,656
MATLAB も有効です。

52
00:01:44,656 --> 00:01:45,956
しかし多くの人にとって、

53
00:01:45,960 --> 00:01:47,972
価格が高すぎます。

54
00:01:47,988 --> 00:01:50,095
もしMATLAB のコピーにアクセス可能であれば、

55
00:01:50,110 --> 00:01:52,037
このクラスで MATLAB を使うこともできます。

56
00:01:52,037 --> 00:01:54,853
もし Python、NumPy を知っているか

57
00:01:54,870 --> 00:01:56,353
R を知っているなら、それを使う人も中にはいます。

58
00:01:56,360 --> 00:01:57,739
しかし、私が見る限り、

59
00:01:57,760 --> 00:02:00,041
結果的にこうした人たちは、

60
00:02:00,050 --> 00:02:02,121
こうした言語では、開発により時間がかかる

61
00:02:02,121 --> 00:02:04,048
傾向があります。

62
00:02:04,048 --> 00:02:08,391
というのは、Python、NumPy の構文は、

63
00:02:08,410 --> 00:02:09,704
Octave の構文に比べてやや取り扱いにくいからです。

64
00:02:09,704 --> 00:02:11,372
ということで、また

65
00:02:11,380 --> 00:02:13,039
スターターコードを Octave で

66
00:02:13,039 --> 00:02:14,363
リリースすることもあわせ、

67
00:02:14,363 --> 00:02:18,321
私として、強くお勧めするのは、

68
00:02:18,330 --> 00:02:19,805
NumPy や R で このクラスの演習問題を試みないこと、

69
00:02:19,805 --> 00:02:21,498
しかし、お勧めしたいのは、

70
00:02:21,520 --> 00:02:24,292
代わりにこのクラスのプログラミング演習を

71
00:02:24,330 --> 00:02:25,428
Octave で行うことです。

72
00:02:25,428 --> 00:02:26,708
このビデオで私が

73
00:02:26,708 --> 00:02:28,667
お見せしたいのは、

74
00:02:28,667 --> 00:02:29,879
コマンドをざっと通して

75
00:02:29,879 --> 00:02:31,073
紹介し、そのゴールとして

76
00:02:31,080 --> 00:02:34,807
Octave で利用可能なコマンドの

77
00:02:34,807 --> 00:02:36,493
範囲やどのようなことが出きるか手早く紹介することです。

78
00:02:36,520 --> 00:02:38,965
コースウェブサイトでは

79
00:02:38,965 --> 00:02:42,095
私がお見せすることは

80
00:02:42,095 --> 00:02:43,185
全て講義録として掲載しますので、

81
00:02:43,185 --> 00:02:44,905
このビデオを見終わったら、

82
00:02:44,905 --> 00:02:46,635
コースウェブサイトに掲載された

83
00:02:46,635 --> 00:02:48,247
講義録を参考にして

84
00:02:48,247 --> 00:02:50,226
コマンドを見つけたい時に利用してください。

85
00:02:50,226 --> 00:02:53,225
具体的に、私がお勧めするのは、

86
00:02:53,230 --> 00:02:55,118
まずこのチュートリアルビデオを見て、

87
00:02:55,120 --> 00:02:58,728
最後まで見終わったら、

88
00:02:58,728 --> 00:02:59,738
Octave をコンピュータにインストールし、

89
00:02:59,738 --> 00:03:01,769
最後に、コースウェブサイトへ

90
00:03:01,770 --> 00:03:02,983
行き、講義録をダウンロードして

91
00:03:02,983 --> 00:03:04,915
このセッションで見たことを

92
00:03:04,930 --> 00:03:07,162
参考に、

93
00:03:07,200 --> 00:03:09,132
興味のあるコマンドを

94
00:03:09,132 --> 00:03:10,602
自分の Octave で試してみることです。

95
00:03:10,602 --> 00:03:12,962
自分のコンピュータで実行することで

96
00:03:12,970 --> 00:03:15,535
自分の目で確認してください。

97
00:03:15,920 --> 00:03:19,363
では、始めましょう。

98
00:03:19,370 --> 00:03:20,977
これは、私の Windows デスクトップで、今から Octave を起動します。

99
00:03:20,977 --> 00:03:22,522
今、Octave を開きました。

100
00:03:22,522 --> 00:03:24,475
これが Octave のプロンプトです。

101
00:03:24,475 --> 00:03:27,291
最初に初歩的な Octave の

102
00:03:27,330 --> 00:03:28,505
操作をお見せします。

103
00:03:28,505 --> 00:03:30,493
まず 5 + 6 と入力すると

104
00:03:30,493 --> 00:03:31,516
11 が答えとして戻ります。

105
00:03:31,540 --> 00:03:33,710
3 - 2、

106
00:03:35,733 --> 00:03:37,747
5 x 8、

107
00:03:37,810 --> 00:03:42,361
2^6 は 64

108
00:03:42,390 --> 00:03:44,495
これらが初歩的な算術演算です。

109
00:03:44,550 --> 00:03:45,929
また論理演算も可能です。

110
00:03:45,929 --> 00:03:47,722
よって、 1 == 2 は

111
00:03:47,722 --> 00:03:51,658
偽 を返します。

112
00:03:51,658 --> 00:03:53,861
% コマンドは、ここではコメントを意味します。

113
00:03:53,861 --> 00:03:55,622
よって、 1 == 2 は偽を返し、

114
00:03:55,650 --> 00:03:58,028
これは ゼロで表されます。

115
00:03:58,028 --> 00:03:59,312
1 が 2 と同等ではない、とすると、これは真です。

116
00:03:59,312 --> 00:04:00,718
これは真です。

117
00:04:00,718 --> 00:04:02,146
これは、1 を戻します。

118
00:04:02,146 --> 00:04:05,478
ご注意頂きたいのは、同等ではないという演算子は

119
00:04:05,550 --> 00:04:07,336
この ~= という記号だということです。

120
00:04:07,336 --> 00:04:09,267
つまり != ではない、ということです。

121
00:04:09,267 --> 00:04:10,878
これは、いくつか

122
00:04:10,910 --> 00:04:13,616
プログラミング言語では使われます。

123
00:04:13,616 --> 00:04:15,545
さて、論理演算 1 AND 0

124
00:04:15,545 --> 00:04:17,340
これは && という記号を使って

125
00:04:18,120 --> 00:04:20,188
論理積を表します。

126
00:04:20,188 --> 00:04:23,886
そしてこれは偽となります。

127
00:04:23,900 --> 00:04:25,736
1 または 0 は 論理和演算で、

128
00:04:25,736 --> 00:04:27,131
それは 真となります。

129
00:04:27,131 --> 00:04:30,333
また xor(1,

130
00:04:30,333 --> 00:04:32,928
0)、とすることも出来、これは 1 を返します。

131
00:04:32,928 --> 00:04:35,683
この左側にあるもの、この octave-3.2.4.exe:11

132
00:04:35,700 --> 00:04:37,513
これはデフォルトの Octave プロンプトです。

133
00:04:37,520 --> 00:04:39,150
これが表示するのは、

134
00:04:39,150 --> 00:04:40,423
Octave のバージョンなどです。

135
00:04:40,450 --> 00:04:43,025
このプロンプトが不要な場合、

136
00:04:43,025 --> 00:04:44,670
少し暗号的なコマンド PS

137
00:04:44,670 --> 00:04:46,602
引用符、>>

138
00:04:46,602 --> 00:04:48,800
などなど

139
00:04:48,810 --> 00:04:51,272
を使って、プロンプトを変えることができます。

140
00:04:51,272 --> 00:04:53,362
そして、この引用符に囲まれた真ん中の文字列、

141
00:04:53,400 --> 00:04:55,592
この '>> '

142
00:04:55,592 --> 00:04:57,722
これが私の好みの Octave のプロンプトです。

143
00:04:57,920 --> 00:04:59,763
ですから、Enterを押すと、

144
00:04:59,763 --> 00:05:00,786
おっと、失礼、

145
00:05:00,786 --> 00:05:02,622
このように、

146
00:05:02,622 --> 00:05:05,420
PS1 とすると、

147
00:05:05,500 --> 00:05:09,263
このように Octave のプロンプトが >> という記号に変わり、

148
00:05:09,710 --> 00:05:12,384
前より見やすくなりました。

149
00:05:12,384 --> 00:05:13,865
次に、Octave の変数についてお話します。

150
00:05:13,865 --> 00:05:16,165
変数

151
00:05:16,165 --> 00:05:18,421
A を指定してそれに 3 を代入し

152
00:05:18,440 --> 00:05:20,043
Enterを押します。

153
00:05:20,070 --> 00:05:22,861
これで A = 3 となりました。

154
00:05:22,861 --> 00:05:26,758
変数に代入したいけれども、結果を出力したくない場合は、

155
00:05:26,920 --> 00:05:30,824
セミコロンをつけると、セミコロンが

156
00:05:30,824 --> 00:05:33,160
結果のプリント出力を抑制します。

157
00:05:33,160 --> 00:05:35,399
そうすると、Enter を押しても、何も出力されません。

158
00:05:35,420 --> 00:05:36,719
一方、 A = 3

159
00:05:36,719 --> 00:05:39,845
とすると、出力され、

160
00:05:39,850 --> 00:05:41,845
A = 3; だと、出力されません。

161
00:05:41,845 --> 00:05:43,473
文字列の代入もできます。

162
00:05:43,520 --> 00:05:45,047
B = 'Hi'

163
00:05:45,047 --> 00:05:46,072
ここで単に

164
00:05:46,072 --> 00:05:48,338
Enter Bとすると変数が出力されます。

165
00:05:48,370 --> 00:05:51,118
よって、 B は文字列 'Hi' です。

166
00:05:51,130 --> 00:05:54,538
C = (3 >= 1)

167
00:05:55,710 --> 00:05:57,999
とすると、C は真となります。

168
00:05:58,030 --> 00:06:00,832
プリント出力、

169
00:06:00,832 --> 00:06:03,725
つまり変数を画面に表示するには、このようにします。

170
00:06:03,760 --> 00:06:04,985
まずは A = Pi とします。

171
00:06:04,985 --> 00:06:08,545
これをプリント出力したい場合は、

172
00:06:08,545 --> 00:06:10,344
このように A とだけ入力します。すると出力されます。

173
00:06:10,344 --> 00:06:13,674
より複雑な出力方法としては、

174
00:06:13,710 --> 00:06:15,858
disp コマンドがあり、これは display の略です。

175
00:06:15,890 --> 00:06:18,337
display A とすると、A をこのように出力します。

176
00:06:18,350 --> 00:06:21,392
文字列を表示することもできます。

177
00:06:21,460 --> 00:06:24,990
例えば、 disp、sprintf、2

178
00:06:25,260 --> 00:06:28,273
decimals、%0.2、

179
00:06:28,273 --> 00:06:29,863
F、カンマ、A、とこのように入力します。

180
00:06:29,863 --> 00:06:31,722
するとこれは文字列として

181
00:06:31,722 --> 00:06:33,651
'2 decimals: 3.14' を出力します。

182
00:06:33,670 --> 00:06:35,993
これはちょっと

183
00:06:35,993 --> 00:06:37,404
一様分布から抽出されます。

184
00:06:37,420 --> 00:06:39,073
みなさんの中で

185
00:06:39,073 --> 00:06:41,378
以前C でプログラミングされた方は、これと

186
00:06:41,380 --> 00:06:44,498
基本的に同じ構文が画面出力で使われます。

187
00:06:44,510 --> 00:06:46,021
ですから、sprintf は

188
00:06:46,021 --> 00:06:48,274
文字列を出力し、

189
00:06:48,290 --> 00:06:50,644
それはこの '2 deciamals: 3.14' という文字列です

190
00:06:50,644 --> 00:06:52,475
この %0.2f の意味は

191
00:06:52,475 --> 00:06:55,926
これを A と差し替えなさいということ、

192
00:06:55,926 --> 00:06:58,104
また小数点から二桁まで表示、ということです。

193
00:06:58,130 --> 00:07:00,691
そして disp はこの文字列を

194
00:07:00,691 --> 00:07:01,683
sprintf コマンドから出力されたものを

195
00:07:01,683 --> 00:07:03,091
sprintf

196
00:07:03,091 --> 00:07:05,835
sprintf コマンド

197
00:07:05,870 --> 00:07:07,020
そして disp が実際にその文字列を表示します。

198
00:07:07,020 --> 00:07:11,360
では、別の

199
00:07:11,361 --> 00:07:14,551
例として sprintf、6 decimals

200
00:07:14,930 --> 00:07:17,075
%0.6f、カンマ、A

201
00:07:17,090 --> 00:07:21,100
すると、これは、円周率 Pi を

202
00:07:22,060 --> 00:07:25,728
小数点六桁まで出力します。

203
00:07:25,740 --> 00:07:28,633
最後に、前に見たように A はこのように出力されます。

204
00:07:28,633 --> 00:07:31,759
便利なショートカットがあり、format long と入力すると、

205
00:07:31,760 --> 00:07:33,748
文字列がデフォルトで

206
00:07:33,748 --> 00:07:35,593
より多くの小数点以下の桁数で表示されます。

207
00:07:35,593 --> 00:07:37,095
そして format short は

208
00:07:37,120 --> 00:07:40,113
これをデフォルトに戻すコマンドです。

209
00:07:40,600 --> 00:07:43,934
出力される桁数が減ります。

210
00:07:43,934 --> 00:07:47,047
OK、これが変数の取り扱い方です。

211
00:07:47,070 --> 00:07:49,274
では、ベクトルと行列について見てみましょう。

212
00:07:49,280 --> 00:07:50,974
例えば、A に行列を代入したいとします。

213
00:07:50,980 --> 00:07:54,593
では例をお見せします。1、2、

214
00:07:54,600 --> 00:07:56,235
セミコロン、3、4、セミコロン、5、6

215
00:07:56,240 --> 00:07:58,572
これは 3 x 2 の

216
00:07:58,580 --> 00:07:59,818
行列を作成し、その最初の

217
00:07:59,820 --> 00:08:02,030
行は 1、2、二番目の行

218
00:08:02,030 --> 00:08:04,385
3、4、三番目の行は 5、6

219
00:08:04,390 --> 00:08:05,818
セミコロンが意味するのは

220
00:08:05,820 --> 00:08:07,915
本質的に、行列の

221
00:08:07,915 --> 00:08:09,016
次の行に行きなさいということです。

222
00:08:09,016 --> 00:08:11,536
これを入力する方法は他にもあります。

223
00:08:11,536 --> 00:08:15,046
A 1、2、セミコロン

224
00:08:15,046 --> 00:08:17,038
3、4、セミコロン、5、6、とこのように

225
00:08:17,038 --> 00:08:18,576
するのも、別の同等のやり方で

226
00:08:18,576 --> 00:08:22,183
A に

227
00:08:22,200 --> 00:08:23,568
この 3 x 2 の行列の値を代入します。

228
00:08:23,568 --> 00:08:25,532
同様に、ベクトルも代入できます。

229
00:08:25,560 --> 00:08:27,359
ですから V = 1、2、3

230
00:08:27,359 --> 00:08:29,915
これは実は行ベクトルです。

231
00:08:29,940 --> 00:08:32,016
3 x 1 ベクトルとも言います。

232
00:08:32,030 --> 00:08:34,375
これは 太い Y ベクトル...

233
00:08:34,380 --> 00:08:37,998
失礼、違います、これは

234
00:08:37,998 --> 00:08:39,256
1 x 3 行列でした。

235
00:08:39,256 --> 00:08:41,015
3 x 1 ではありません。

236
00:08:41,015 --> 00:08:43,975
もしこれに

237
00:08:43,975 --> 00:08:48,778
列ベクトルを代入したい場合は、

238
00:08:48,830 --> 00:08:50,030
代わりに行うのは、V = 1、セミコロン、2、セミコロン、3

239
00:08:50,100 --> 00:08:51,797
これで 3 x 1 のベクトルができます

240
00:08:51,797 --> 00:08:55,892
1 x 3 ベクトルの代わりに。

241
00:08:56,250 --> 00:08:57,968
ですからこれは列ベクトルです。

242
00:08:57,968 --> 00:09:02,343
さらにいくつか便利な表記方法をお見せします。

243
00:09:02,343 --> 00:09:03,598
V = 1、コロン、0.1、コロン、2。

244
00:09:03,620 --> 00:09:05,716
これが意味するのは、

245
00:09:05,716 --> 00:09:08,714
V にいくつか

246
00:09:08,714 --> 00:09:10,392
の要素を1 から始めて代入し

247
00:09:10,410 --> 00:09:13,657
ステップの増分を

248
00:09:13,660 --> 00:09:19,168
0.1単位で増やし、2 に至るまで続ける、ということです。

249
00:09:19,168 --> 00:09:23,022
ですから、これを実行すると、V はこのような行ベクトルになります。

250
00:09:23,022 --> 00:09:23,739
これは、そうですね、1 x 11 行列ですね。

251
00:09:23,739 --> 00:09:26,921
これが 1、1.1、

252
00:09:27,630 --> 00:09:30,141
1.2、1.3 と

253
00:09:31,440 --> 00:09:33,269
続き最後は2 まで行きます。

254
00:09:33,269 --> 00:09:35,049
さらに、

255
00:09:35,060 --> 00:09:38,270
V = 1、コロン、6 と指定すると

256
00:09:38,270 --> 00:09:41,291
V にこれらの数字が代入されます。

257
00:09:41,620 --> 00:09:44,254
1 から 6、OKです。

258
00:09:44,254 --> 00:09:47,426
さらに、行列を作成するにはいくつか他の方法もあります。

259
00:09:47,426 --> 00:09:49,134
ones(2,3) はコマンドで

260
00:09:49,140 --> 00:09:50,790
それは行列を作成し

261
00:09:50,790 --> 00:09:52,712
2 x 3 行列ですね

262
00:09:52,712 --> 00:09:53,991
これは 全て 1 の行列です。

263
00:09:54,000 --> 00:09:56,845
ですから、もし C = 2

264
00:09:56,845 --> 00:09:59,798
掛ける ones(2,

265
00:09:59,798 --> 00:10:03,061
3) とするとこれは

266
00:10:03,080 --> 00:10:04,258
2 x 3 行列で全てが 2 となります。

267
00:10:04,258 --> 00:10:05,513
これは、

268
00:10:05,550 --> 00:10:06,943
これをより簡潔に書く方法として見なすことができます

269
00:10:06,943 --> 00:10:10,951
C = 2、2、2

270
00:10:11,450 --> 00:10:13,910
セミコロン、 2、2、2、これも同じ結果を戻します。

271
00:10:13,920 --> 00:10:15,485
仮に W = ones(1,

272
00:10:15,485 --> 00:10:17,937
3) ということはこれは

273
00:10:17,940 --> 00:10:20,998
行ベクトルになります

274
00:10:20,998 --> 00:10:23,853
三つの要素からなる行

275
00:10:23,853 --> 00:10:25,463
で全てが 1、そして

276
00:10:25,463 --> 00:10:27,469
同様に W =

277
00:10:27,469 --> 00:10:30,209
zeros(1,

278
00:10:30,220 --> 00:10:34,732
3) そしてこれが作成する行列は

279
00:10:34,732 --> 00:10:36,910
1 x 3 の全てゼロの行列です。

280
00:10:36,930 --> 00:10:39,175
さらに二つほど行列の作成方法を紹介します。

281
00:10:39,175 --> 00:10:41,512
もし W =

282
00:10:41,520 --> 00:10:43,050
rand(1, 3) とすると

283
00:10:43,050 --> 00:10:45,370
これで返されるのは、1 x 3

284
00:10:45,372 --> 00:10:47,118
の乱数の行列です。

285
00:10:47,215 --> 00:10:49,008
もし rand

286
00:10:49,050 --> 00:10:50,417
(3, 3) とすると

287
00:10:50,417 --> 00:10:51,918
これは、3 x 3

288
00:10:51,930 --> 00:10:54,009
の行列で、全て

289
00:10:54,009 --> 00:10:55,830
0 から 1 の間の 一様分布からの

290
00:10:55,830 --> 00:10:56,937
乱数となります。

291
00:10:56,937 --> 00:10:58,608
このため、これを実行するたびに

292
00:10:58,608 --> 00:11:00,510
異なる組み合わせの

293
00:11:00,540 --> 00:11:02,573
乱数が 0 から 1 の間の

294
00:11:02,573 --> 00:11:03,718
一様分布から抽出されます。

295
00:11:03,718 --> 00:11:05,375
皆さんの中で

296
00:11:05,410 --> 00:11:06,275
ガウス確率変数をご存知の方は、

297
00:11:06,275 --> 00:11:07,659
あるいは正規確率変数を

298
00:11:07,660 --> 00:11:09,112
ご存知なら

299
00:11:09,112 --> 00:11:11,956
W を

300
00:11:11,990 --> 00:11:13,565
= randn(1, 3) と指定することも出来ます。

301
00:11:13,570 --> 00:11:15,435
すると、これらは、

302
00:11:15,435 --> 00:11:17,798
ガウス分布から抽出された

303
00:11:17,798 --> 00:11:19,266
三つの値で、平均値が

304
00:11:19,266 --> 00:11:21,642
0 で 分散あるいは

305
00:11:21,642 --> 00:11:23,148
標準偏差が 1 となる分布から抽出されます。

306
00:11:23,150 --> 00:11:24,698
さらにもっと複雑なことも可能で、

307
00:11:24,698 --> 00:11:26,194
例えば、 W = マイナス 6

308
00:11:26,210 --> 00:11:28,656
足す 10の平方根

309
00:11:28,660 --> 00:11:31,978
掛ける、例えば、

310
00:11:31,978 --> 00:11:33,106
randn (1, 10000)

311
00:11:33,106 --> 00:11:35,623
一番最後にセミコロンをつけます。

312
00:11:35,623 --> 00:11:37,599
というのもこれを出力したくないからです。

313
00:11:37,599 --> 00:11:38,905
これを出力すると、なんというか、

314
00:11:38,910 --> 00:11:40,582
まあ、出てくるのは

315
00:11:40,610 --> 00:11:44,481
10万、失礼、1万要素

316
00:11:44,490 --> 00:11:47,596
のベクトルです。

317
00:11:47,596 --> 00:11:48,373
ですから、えっと、まあいいか、

318
00:11:48,373 --> 00:11:51,570
出力してみましょう。

319
00:11:51,570 --> 00:11:52,408
といいことでこのような行列が作成されます。

320
00:11:52,408 --> 00:11:53,978
この通り

321
00:11:53,978 --> 00:11:55,835
1万の要素があります。

322
00:11:55,835 --> 00:11:57,392
これが W の中身です。

323
00:11:57,392 --> 00:11:59,442
ですから、ここで

324
00:11:59,442 --> 00:12:01,818
W のヒストグラムをプロットすると

325
00:12:01,820 --> 00:12:04,752
hist コマンドを使います

326
00:12:04,752 --> 00:12:06,130
Octave の hist

327
00:12:06,130 --> 00:12:07,297
コマンドは、数秒かかりますが、

328
00:12:07,297 --> 00:12:08,965
これが出力されます。

329
00:12:08,970 --> 00:12:10,646
これは、W に含まれる

330
00:12:10,650 --> 00:12:12,732
確率変数のヒストグラムです。

331
00:12:12,732 --> 00:12:15,537
これはマイナス 6 足す 10の平方根

332
00:12:15,537 --> 00:12:17,537
掛ける このガウス確率変数でした。

333
00:12:17,560 --> 00:12:21,032
そして、ヒストグラムをプロットするのに

334
00:12:21,032 --> 00:12:22,578
もっとビンの数を増やして、例えば 50 ビンとしてみます

335
00:12:22,578 --> 00:12:25,735
するとこれが

336
00:12:25,735 --> 00:12:27,285
平均が -6 のガウス分布のヒストグラムです。

337
00:12:27,285 --> 00:12:29,208
なぜなら、ここに -6があって、

338
00:12:29,230 --> 00:12:32,952
それ足す 10 の平方根掛けるこれです。

339
00:12:32,952 --> 00:12:34,961
ですから、この

340
00:12:34,961 --> 00:12:36,696
ガウス確率変数の分散は

341
00:12:36,700 --> 00:12:38,935
10で、その標準偏差は、

342
00:12:38,950 --> 00:12:41,063
10 の平方根、それはなんだっけ、

343
00:12:41,780 --> 00:12:43,857
3.1 です。

344
00:12:43,857 --> 00:12:46,208
最後に、行列を作成する特別なコマンド

345
00:12:46,208 --> 00:12:48,394
が一つあります。これは、eye コマンドです。

346
00:12:48,394 --> 00:12:51,028
eye は、おそらくダジャレでしょうが

347
00:12:51,050 --> 00:12:52,650
identity matrix (単位行列) という言葉の略で

348
00:12:52,720 --> 00:12:56,004
例えば eye(4) とすると、

349
00:12:56,004 --> 00:12:57,681
これは 4 x 4 の単位行列です。

350
00:12:57,681 --> 00:13:00,458
ということで I = eye(4)

351
00:13:00,458 --> 00:13:04,475
とすると 4 x 4 の単位行列が得られます。

352
00:13:04,475 --> 00:13:05,611
さらに I = eye(5)、じゃなくて eye(6)

353
00:13:05,611 --> 00:13:08,089
は 6 x 6 の

354
00:13:08,120 --> 00:13:09,134
単位行列、eye(3)

355
00:13:09,134 --> 00:13:12,064
は 3 x 3 の単位行列です。

356
00:13:12,064 --> 00:13:14,263
最後に、

357
00:13:14,280 --> 00:13:15,479
このビデオのまとめとして、もう一つ便利なコマンドがあります。

358
00:13:15,479 --> 00:13:17,454
これば help コマンドです。

359
00:13:17,454 --> 00:13:21,181
help eye と入力すると、

360
00:13:21,190 --> 00:13:22,803
単位行列についてのヘルプ機能が表示されます。

361
00:13:22,803 --> 00:13:25,375
Q を押すと終了します。

362
00:13:25,380 --> 00:13:27,793
また、help rand と入力すると

363
00:13:27,793 --> 00:13:29,734
rand 、つまり乱数作成関数についての

364
00:13:29,734 --> 00:13:31,898
ドキュメンテーションが表示されます。

365
00:13:31,900 --> 00:13:35,615
あるいは help help とすると、

366
00:13:36,455 --> 00:13:39,022
help 機能についてのヘルプが表示されます。

367
00:13:39,022 --> 00:13:41,612
ということで、これらが

368
00:13:41,612 --> 00:13:42,699
Octave の基本操作となります。

369
00:13:42,699 --> 00:13:47,131
そしてこれによって、

370
00:13:47,131 --> 00:13:50,553
行列をいくつか作成し、掛け算や足し算を行ったり

371
00:13:50,560 --> 00:13:51,893
Octave の基本操作を利用することができます。

372
00:13:51,920 --> 00:13:53,818
次のビデオで

373
00:13:53,818 --> 00:13:55,700
お話していきたいのは、

374
00:13:55,750 --> 00:13:59,180
より高度なコマンドと、