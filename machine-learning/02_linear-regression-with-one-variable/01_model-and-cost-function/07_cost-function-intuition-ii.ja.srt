1
00:00:00,960 --> 00:00:05,684
このビデオでは、もっと深く掘り下げて、目的関数が何をしているかさらに直感的理解を

2
00:00:05,684 --> 00:00:10,523
深めていきます。このビデオは皆さんが等高線図をご存知であることを前提にしています。

3
00:00:10,523 --> 00:00:15,189
もし等高線図に馴染みがなければ、このビデオで見る図の中には

4
00:00:15,189 --> 00:00:20,144
意味をなさないものがあるかもしれません。でも大丈夫です。このビデオを飛ばしたり

5
00:00:20,144 --> 00:00:24,522
その一部の意味が等高線図を見たことがないためによくわからなくても、

6
00:00:24,522 --> 00:00:29,246
それは大丈夫です。こうした部分が抜けてもこのコースの他の内容の理解には

7
00:00:29,246 --> 00:00:34,935
支障ありません。ここに、いつも通りの問題の定式があります。

8
00:00:34,935 --> 00:00:39,882
仮説、パラメータ、目的関数、そして最適化の目的です。

9
00:00:39,882 --> 00:00:45,163
前のビデオとは異なり、今回は両方のパラメータをキープし、

10
00:00:45,163 --> 00:00:50,573
theta 0 と theta 1 を使って目的関数の可視化を行います。

11
00:00:50,573 --> 00:00:57,204
さて、前と同じように、仮説 h と 目的関数 J を理解したいと思います。

12
00:00:57,204 --> 00:01:04,167
ですから、ここに住宅価格の訓練セットがあり、適当に仮説を設定しましょう。そうですね、こんな感じに。

13
00:01:04,167 --> 00:01:10,219
これは特に良い仮説ではありませんが、theta 0 = 50

14
00:01:10,219 --> 00:01:16,270
theta 1 = 0.06 と設定するとこの下の仮説になり、

15
00:01:16,270 --> 00:01:22,190
それがこの直線に対応します。さて、こうしたtheta 0 と theta 1 の値に対して、

16
00:01:22,190 --> 00:01:27,511
それに対応する目的関数を右にプロットしたいと思います。

17
00:01:27,511 --> 00:01:33,150
前回の場合は、theta 1 しかありませんでしたので、このようなプロットを

18
00:01:33,150 --> 00:01:37,814
theta 1 の関数として作成しました。しかし今回はパラメータが theta 0 と theta 1 の二つです。

19
00:01:37,814 --> 00:01:42,340
ですからプロットは少し複雑になります。実は

20
00:01:42,340 --> 00:01:47,699
パラメータが一つだけであれば、プロットはこのように弓なりの形の関数になります。

21
00:01:47,699 --> 00:01:52,925
今回のようにパラメータが二つある場合、実は目的関数は

22
00:01:52,925 --> 00:01:58,218
また弓なりの形に似たものになります。そして実際に、訓練セット次第では、

23
00:01:58,218 --> 00:02:03,511
目的関数はこのようなものになるかもしれません。さて、これは三次元表面プロットです。

24
00:02:03,511 --> 00:02:09,404
その軸は theta 0 と theta 1 とラベル付けされています。

25
00:02:09,404 --> 00:02:15,326
ですから、二つのパラメータ theta 0 と theta 1 を変えるに従い、

26
00:02:15,326 --> 00:02:20,964
目的関数 J(theta 0, theta 1) の値も変わります。 そしてこの表面の高さが

27
00:02:20,964 --> 00:02:26,347
theta 0 と theta 1 の特定の点の上に来ています。これが、縦軸です。

28
00:02:26,347 --> 00:02:31,200
ある点の表面の高さは、J(theta 0, theta 1) の値を示しています。

29
00:02:31,200 --> 00:02:36,471
そして、ご覧になってお分かりの通り、これはボウルの形状をしています。このプロットを

30
00:02:36,471 --> 00:02:46,351
三次元的に見てみましょう。これは、同じプロットを三次元にしたものです。横軸はtheta 0 と theta 1 、縦軸は

31
00:02:46,351 --> 00:02:52,122
J(theta 0, theta 1) 、そしてこのプロットを回転させてみると、感覚的に

32
00:02:52,122 --> 00:02:57,608
表面がボウルの形をしているのがお分かりいただけると思います。これが目的関数 J

33
00:02:57,608 --> 00:03:03,592
の形です。さて、図解を目的として今後このビデオでは

34
00:03:03,592 --> 00:03:09,077
このような三次元表面を使って目的関数 J をお見せすることはしません。代わりに、

35
00:03:09,077 --> 00:03:16,475
等高線図を使って

36
00:03:16,475 --> 00:03:24,748
このような表面をお見せします。さて、ここに

37
00:03:24,748 --> 00:03:31,135
等高線図の例が右にあります。横軸と縦軸は theta 0 と

38
00:03:31,135 --> 00:03:37,602
theta 1 です。そして、これらの長円形、これらの楕円形がそれぞれ示しているのは

39
00:03:37,602 --> 00:03:43,757
J(theta 0, theta 1) の値が同じになる点の一組です。ですから

40
00:03:43,757 --> 00:03:50,514
具体的に、例えば、その点と、その点と、その点を選びます。

41
00:03:50,514 --> 00:03:55,583
今マジェンタ色で書いたこの三つの点は全て同じ値です。

42
00:03:55,583 --> 00:03:59,730
J (theta 0, theta 1) の値が。これらは、軸は theta 0 と

43
00:03:59,730 --> 00:04:04,774
theta 1 となっていますが、これら三つの値が同じなのは、J(theta 0, theta 1) に対してです。

44
00:04:04,774 --> 00:04:10,218
そしてもし以前にあまり等高線図を見たことがなければ、想像してみて下さい。

45
00:04:10,218 --> 00:04:14,992
ボウルの形をした関数が画面から飛び出していると。最小値、

46
00:04:14,992 --> 00:04:19,668
つまり、ボウルの底は、この点です。分かりますか。この真ん中、

47
00:04:19,668 --> 00:04:24,285
同中心の楕円の真ん中です。そしてボウルの形をしたものが、このように画面から飛び出していると

48
00:04:24,285 --> 00:04:28,786
想像してください。そして、これらの楕円はそれぞれ同じ高さで

49
00:04:28,786 --> 00:04:33,345
画面から飛び出していると。そしてボウルの最小値がちょうどそこにあると。ですから、

50
00:04:33,345 --> 00:04:37,787
等高線図は、目的関数 J を可視化する一つの方法、

51
00:04:37,787 --> 00:04:45,185
たぶんもっと便利な方法です。では、いくつか例を見てみましょう。こちらに、

52
00:04:45,185 --> 00:04:53,275
ある特定の点があります。そしてこれは、だいたい、theta 0 = 800、

53
00:04:53,275 --> 00:05:01,964
そして多分 theta 1 = -0.15 ぐらいでしょう。そしてこの点、

54
00:05:01,964 --> 00:05:07,322
この赤い点は、theta 0、theta 1 のある特定の値の組み合わせに対応します。

55
00:05:07,322 --> 00:05:12,092
そして実際に、それはこの仮説に対応しています。theta 0 は

56
00:05:12,092 --> 00:05:17,189
ほぼ 800、つまり縦軸と 800 あたりで交差し、そして傾きはほぼ

57
00:05:17,189 --> 00:05:21,763
-0.15です。さて、この線は、データに対してあまりよく

58
00:05:21,763 --> 00:05:26,859
適合していません。この仮説 h(x) とこの値の theta 0 と

59
00:05:26,859 --> 00:05:32,283
theta 1, これは実にあまりデータによくフィットしているとは言えません。ですから、その評価値、

60
00:05:32,283 --> 00:05:37,531
そこにある値は、最小値からはほど遠いということが分かります。

61
00:05:37,531 --> 00:05:42,901
これは、かなり遠く、かなり高い評価値です。これはあまりにもデータによくフィットしていないからです。

62
00:05:42,901 --> 00:05:47,247
さらにいくつか例を見てみましょう。さて、ここに別の仮説があります。

63
00:05:47,247 --> 00:05:52,489
これも、それほどデータにフィットしてはいませんが、多少はましなようです。ですから、これがその点、

64
00:05:52,489 --> 00:05:57,986
パラメータ theta 0 と theta 1 の値です。

65
00:05:57,986 --> 00:06:07,387
ですから、theta 0 の値は、これは約 360 です。そしてtheta 1 の値は

66
00:06:07,387 --> 00:06:14,047
= 0 です。ではこれを書き出しましょう。theta 0 = 360、

67
00:06:14,047 --> 00:06:20,063
theta 1 = 0。そしてこの一組のパラメータはこの

68
00:06:20,063 --> 00:06:26,161
仮説に対応し、それはこの横線に対応します。これは h(x) = 360

69
00:06:26,161 --> 00:06:32,421
+ 0 * x です。ですからこれが仮説です。そしてこの仮説にも評価値があり、そして

70
00:06:32,421 --> 00:06:38,600
その評価値は、その点での J 関数の高さとしてプロットされています。

71
00:06:38,791 --> 00:06:44,886
さらに二つほど例を見てみましょう。ここにもう一つあります。この値の

72
00:06:44,886 --> 00:06:52,231
theta 0 と この値の theta 1 は、この仮説 h(x) に対応します。

73
00:06:52,231 --> 00:06:58,599
そしてまた、データに対しあまりよいフィットではありません。事実、最小値から遠ざかっています。最後の例として、

74
00:06:58,599 --> 00:07:03,450
これは完全には最小値ではありませんが、かなり最小値に近くなっています。ですから、これはそれほど

75
00:07:03,450 --> 00:07:08,486
データへのフィットは悪くありません。ある特定の値の theta 0 に対し

76
00:07:08,486 --> 00:07:13,337
その値がなんであれ、そして特定の値の theta 1 では、

77
00:07:13,337 --> 00:07:18,004
特定の h(x) が得られます。これは最小値にはなっていませんが、かなり近くなっています。

78
00:07:18,004 --> 00:07:23,039
二乗誤差の総和は、訓練サンプルと仮説の間の

79
00:07:23,039 --> 00:07:28,259
距離の二乗の総和です。実際、これは距離の二乗の総和ですよね。

80
00:07:28,259 --> 00:07:32,548
こうした全ての誤差の。これはかなり最小値に近くなっています、

81
00:07:32,548 --> 00:07:37,096
完全に最小値ではないにしろ。さて、こうした図解を通して、

82
00:07:37,096 --> 00:07:41,869
目的関数 J の値が何か、どのような形をしていて、

83
00:07:41,869 --> 00:07:47,324
どのように異なる仮説に対応するか、そしていかに仮説がよいほど、対応する点が、目的関数 J の最小値に

84
00:07:47,324 --> 00:07:52,983
より近くなるか、お分かり頂けたと思います。さて、もちろん、

85
00:07:52,983 --> 00:07:57,619
本当に欲しいのは、効率的なアルゴリズム、効率的なソフトウェアを使って、

86
00:07:57,619 --> 00:08:02,218
自動的に目的関数 J を最小化する theta 0 と theta 1 の値を見つけることです。

87
00:08:02,218 --> 00:08:06,566
私たちが避けたいのは、

88
00:08:06,566 --> 00:08:10,697
こうした点をプロットして目視で数値を読み取っていくようなソフトウェアを書くことです。

89
00:08:10,697 --> 00:08:15,263
それは、あまり良いやり方ではありません。そして、事実、後ほど見る通り

90
00:08:15,426 --> 00:08:19,938
もっと複雑な例を見る場合、高次元の図でより多くのパラメータ

91
00:08:19,938 --> 00:08:23,906
を扱うことになり、結果的に、後で実例をいくつか

92
00:08:23,906 --> 00:08:28,091
このコースで見ますが、こうした図をプロットすることはできず、

93
00:08:28,091 --> 00:08:33,664
可視化がより困難になって行きます。ですから、私たちが欲しいのは

94
00:08:33,664 --> 00:08:37,729
この関数を最小化するような theta 0 と theta 1 の値を見つけてくれるソフトウェアです。そして

95
00:08:37,916 --> 00:08:42,914
次のビデオで、自動的に目的関数 J を最小化するような

96
00:08:42,914 --> 00:08:47,600
theta 0 と theta 1 の値を見つけるアルゴリズムについてお話して行きます。