पिछले वीडियो में, हमने दी एक गणितीय परिभाषा ग्रेडीयंट डिसेंट की. चलो जाते हैं गहराई में और इस वीडियो में लेते है और भी बेहतर अनुभव कि अल्गोरिद्म क्या कर रहा है और क्यों ग्रेडीयंट डिसेंट अल्गोरिद्म के स्टेप्स उचित लगते हैं. यहाँ है एक ग्रेडीयंट डिसेंट अल्गोरिद्म जो हमने देखा पिछली बार और सिर्फ आपको याद दिलाने के लिए यह पेरामिटर, या यह टर्म अल्फा को लर्निंग रेट कहते हैं. और यह नियंत्रित करता है कि कितना बड़ा स्टेप हम लें जब अपडेट कर रहे हैं पेरामिटर थीटा जे. और यह दूसरी टर्म यहाँ है डेरिवेटिव टर्म और इस वीडियो में मैं क्या करना चाहता हूँ कि दूँ आपको अनुभव कि क्या प्रत्येक इन टर्म्ज़ में से कर रही हैं और क्यों जब एक साथ रखी जाती हैं, यह पूरा अपडेट उचित लगता है. व्यक्त करने के लिए ये अनुभव, मैं क्या करूँगा कि इस्तेमाल करूँगा एक थोड़ा सरल उदाहरण, जहाँ हम न्यूनतम करना चाहते हैं सिर्फ़ एक पेरामिटर के फ़ंक्शन को. तो हम कहते हैं हमारे पास है एक कॉस्ट फ़ंक्शन, जे केवल एक पेरामिटर का, थीटा एक, जैसे हमने किया था कुछ वीडियोस पहले, जहाँ थीटा एक है एक रियल नम्बर. तो हम कर सकते हैं एक डिमेन्शन के प्लॉट, जो थोड़े ज़्यादा सरल हैं समझने के लिए. चलो कोशिश करते हैं समझने की कि ग्रेडीयंट डिसेंट क्या करेगा इस फ़ंक्शन पर. तो मान लो, यहाँ है मेरा फ़ंक्शन, जे ऑफ़ थीटा 1. और तो वह है मेरा. और जहां थीटा 1 एक रियल नम्बर है. ठीक है? अब, चलो इस स्लाइड में शुरू करते हैं ग्रेडीयंट डिसेंट थीटा एक के साथ इस स्थान से. तो कल्पना करें कि हम शुरू करते हैं उस पोईँट से मेरे फ़ंक्शन पर. ग्रेडीयंट डिसेंट क्या करेगा कि यह अपडेट करेगा. थीटा एक अपडेट होता है ऐसे, थीटा वन माइनस अल्फ़ा टाइम्ज़ डी डी थीटा वन जे ऑफ़ थीटा वन, सही? और सिरफ थोड़ा हट के, यह डेरिवेटिव टर्म, ठीक है, यदि आप सोच रहे हैं कि क्यों मैंने बदल दी नोटेशन इस पर्शियल डेरिवेटिव चिन्हों की. यदि आप नहीं जानते कि क्या फर्क है इन पर्शियल डेरिवेटिव चिन्हों और डी डी थीटा में, इसके बारे में चिंता मत करो॰ तकनीकी तौर पर गणित के क्षेत्र में आप कहते हैं इसे एक पर्शियल डेरिवेटिव और कहते हैं इसे एक डेरिवेटिव, निर्भर करते हुए संख्या पर पेरमिटर्स की फ़ंक्शन जे में. लेकिन यह है कि एक गणितीय परिभाषा. और इसलिए इस लेक्चर के प्रयोजन के लिए, सोचें इन पर्शियल चिन्हों और डी, डी थीटा 1, वास्तव में एक ही चीज़. और क्या असली फर्क है के बारे में चिंता मत करें. मैं कोशिश करूँगा इस्तेमाल करने की गणितीय रूप मैं सही नोटेशन, लेकिन हमारे लिए ये दोनो नोटेशन वास्तव में एक ही चीज़ हैं. तो चलो देखते हैं कि यह इक्वेज़न क्या करेगी. तो हम करेंगे कम्प्यूट ये डेरिवेटिव, निश्चित नहीं हूँ कि आपने देखें हैं डेरिवेटिव कैल्क्युलुस में पहले, लेकिन डेरिवेटिव इस पोईँट पर क्या करता है, यह मूलत: बताता है, चलो लेते हैं एक स्पर्श रेखा उस पोईँट पर, जैसे वह सीधी रेखा, वह लाल रेखा, जो सिर्फ़ छू रही है इस फ़ंक्शन को, और चलो देखते हैं स्लोप इस लाल रेखा की. वह है जो डेरिवेटिव है, यह बताता है क्या है स्लोप रेखा की जो है सिर्फ़ स्पर्श रेखा फ़ंक्शन को. ठीक है, एक लाइन की स्लोप है सिर्फ यह ऊंचाई विभाजित की गई इस हॉरिज़ॉंटल वैल्यू से. अब, इस रेखा की है पॉज़िटिव स्लोप, तो इसका है पॉज़िटिव डेरिवेटिव. और इसलिए मेरा अपडेट थीटा को होगा थीटा 1, यह अपडेट होता है ऐसे, थीटा 1 माइनस अल्फ़ा टाइम्ज़ कोई पॉज़िटिव संख्या. ठीक है. अल्फ़ा है लर्निंग रेट, वह हमेशा एक पॉज़िटिव नम्बर है. और, इसलिए हम लेंगे थीटा 1 जो अपडेट होगा थीटा वन माइनस कुछ वैल्यू. तो मैं स्थान परिवर्तन करूँगा थीटा एक का बाईं तरफ़. मैं कम करूँगा थीटा एक, और हम देख सकते हैं यह है सही काम क्योंकि मैं वास्तव में उस दिशा में जाना चाहता हूँ. आप जानते हैं, मुझे नज़दीक जाने के लिए न्यूनतम पर वहाँ. तो, ग्रेडीयंट डिसेंट अब तक कहता है कि हम सही काम कर रहे हैं. चलो एक और उदाहरण पर नजर डालते हैं. तो लेते हैं मेरा वही फ़ंक्शन जे, प्रयास करते हैं बनाने का वही फ़ंक्शन, जे ऑफ़ थीटा 1. और अब, मान लो मैं कहता हूँ ईनिशीयलाइज करें मेरा पेरामिटर वहाँ बाईं तरफ़. तो थीटा 1 यहाँ है. मैं देखता हूँ उस पोईँट को सतह पर. अब मेरी डेरिवेटिव टर्म डी वी थीटा वन जे ऑफ़ थीटा वन जब आप वैल्यू डालते हैं कि यह पोईँट, हम देखेंगे दाईं तरफ़ स्लोप उस लाइन की, तो यह डेरिवेटिव टर्म है स्लोप इस लाइन की. लेकिन यह लाइन है नीचे झुकी हुई, इसलिए इस लाइन की स्लोप नेगेटिव है. सही या वैकल्पिक रूप से, मैं कहता हूँ कि इस फ़ंक्शन का नेगेटिव डेरिवेटिव है, मतलब है सिर्फ़ कि नेगेटिव स्लोप है उस पोईँट पर. तो यह कम है या बराबर है 0 के, इसलिए जब मैं थीटा अपडेट करता हूँ, मुझे मिलेगा थीटा. सिर्फ़ अपडेट करें इसे थीटा माइनस अल्फ़ा टाइम्ज़ एक नेगेटिव नम्बर. और इसलिए मुझे मिलता है थीटा 1 माइनस एक नेगेटिव नम्बर जिसका मतलब है मैं वास्तव में बढ़ाऊँगा थीटा को, क्योंकि यह है माइनस एक नेगेटिव नम्बर का, इसका मतलब है मैं थीटा में कुछ जोड़ रहा हूँ. और क्या इसका मतलब है कि मुझे मिलेगा बढ़ा हुआ थीटा जब तक यह यहाँ नही आता, बढ़ाना थीटा प्रतीत होता है ऐसा जो मैं चाहता था करना ताकि मैं पहुँच सकूँ नज़दीक न्यूनतम के. तो यह है सिद्धांत पूरा इस अनुभव के पीछे कि एक डेरिवेटिव क्या करता है, चलो डालते हैं एक नज़र रेट टर्म अल्फ़ा पर और देखते हैं कि वह क्या करता है. तो यहाँ है मेरा ग्रेडीयंट डिसेंट अपडेट, वह है यह इक्वेज़न. और चलो देखते हैं क्या हो सकता है यदि अल्फ़ा है या तो बहुत छोटा या यदि अल्फ़ा है बहुत बड़ा. तो यह है पहला उदाहरण, क्या होता है यदि अल्फ़ा बहुत छोटा है? तो, यहाँ है मेरा फ़ंक्शन जे, जे ऑफ़ थीटा. चलो यहाँ से शुरू करते हैं. अगर अल्फा बहुत छोटा है, तो मैं करूँगा गुणा मेरे अपडेट को एक कोई छोटी संख्या से, तो मिलेगा एक छोटा स्टेप उस तरह का. ठीक है, तो यह एक स्टेप है. फिर इस नए पोईँट से, मुझे लेना होगा एक और स्टेप. लेकिन यदि अल्फा बहुत छोटा है, तो मैं लूँगा एक और छोटा स्टेप. और यदि मेरी लर्निंग रेट बहुत छोटी है, मैं कर पाऊँगा लेना ये छोटे छोटे क़दम पहुँचने के लिए नज़दीक न्यूनतम के. और मुझे चाहिए होंगे बहुत से स्टेप न्यूनतम तक जाने के लिए और इसलिए यदि अल्फ़ा बहुत छोटा है, ग्रेडीयंट डिसेंट कर सकता है धीमी प्राग्रेस क्योंकि यह लेगा ये छोटे छोटे क़दम और इसलिए इसे चाहिए होंगे बहुत से स्टेप इस से पहले कि यह पहुँचे कहीं नज़दीक ग्लोबल मिनिमम के. अब सोचो यदि अल्फ़ा है बहुत बड़ा तो कैसा हो? तो, यहाँ है मेरा फ़ंक्शन जे ऑफ़ थीटा, ऐसा है कि थीटा बहुत बड़ा है, तब ग्रेडीयंट डिसेंट शायद पार कर जाए मिनिमम और शायद न भी कर पाए कन्वर्ज या यहाँ तक कि डाईवर्ज हो जाए, तो यहाँ है के मेरा क्या मतलब है. मान लो हमारा सारा डेटा वहाँ है, जो वास्तव में नज़दीक है न्यूनतम के. तो डेरिवेटिव इंगित करता है दाईं तरफ़, लेकिन यदि अल्फ़ा बहुत बड़ा है, मैं लूँगा एक बहुत बड़ा स्टेप. याद रखें, लेना एक बहुत बड़ा स्टेप उस तरह. तो यह लेता है एक बहुत बड़ा स्टेप, और अब मेरे फ़ंक्शन की हैं मज़बूत जड़ें. क्योंकि यह शुरू होता है इस वैल्यू से, और अब मेरी वैल्यूज़ हैं बड़ी. अब मेरा डेरिवेटिव इंगित करता है बाईं तरफ़, यह बताता है मुझे काम करना चाहिए थीटा. लेकिन यदि मेरी लर्निंग रेट बहुत बड़ी है, मैं शायद लूँगा एक बड़ा स्टेप और जाता हूँ यहाँ से दूर वहाँ. तो हम पहुँचते है वहाँ, ठीक है? और यदि मेरी लर्निंग रेट बहुत बड़ी है, हम ले सकते हैं एक और बहुत बड़ा स्टेप अगली आइटरेशन में और एक प्रकार से पार कर जाते और फिर पार कर जाते है और इसी प्रकार करते रहते हैं, जब तक कि आप ध्यान दें मैं वास्तव में लगातार न्यूनतम से दूर हो रहा हूँ. तो अगर अल्फा बड़ा है, यह कन्वर्ज नहीं भी हो सकता और शायद डाईवर्ज हो सकता है. अब, मेरे पास आपके लिए एक सवाल है. तो यह एक थोड़ा मुश्किल सवाल है और जब मैं पहली बार यह सीख रहा था मुझे लगा था काफ़ी समय इसे समझने में. क्या होगा यदि आपका पेरामिटर थीटा 1 है पहले से ही लोकल न्यूनतम पर, क्या आपको लगता है कि एक स्टेप ग्रेडीयंट डिसेंट का क्या करेगा? तो मान लो आप ईनिशीयलाइज करते हैं थीटा 1 को लोकल न्यूनतम पर. तो, मान लो यह है आपकी प्रारम्भिक वैल्यू थीटा 1 की यहाँ पर और है पहले से ही एक लोकल ओप्टिमम पर या लोकल मिनिमम पर. ऐसा हुआ कि लोकल ओप्टिमम पर, आपकी डेरिवेटिव टर्म होगा ज़ीरो. तो उस स्लोप के लिए, वह स्पर्श-रेखा पोईँट, तो स्लोप इस लाइन की होगी ज़ीरो और इसलिए यह डेरिवेटिव टर्म होगी ज़ीरो. और इसलिए आपका ग्रेडीयंट डिसेंट अपडेट करेगा, आपके पास होगा थीटा वन क्योंकि यह अपडेट हुआ थीटा वन माइनस अल्फ़ा टाइम्ज़ ज़ीरो. तो यह है इसका मतलब कि यदि आप पहले से ही लोकल मिनिमम पर है यह रखता है थीटा 1 बिना बदले क्योंकि यह अपडेट करता है थीटा 1 ईक्वल्ज़ थीटा 1. तो यदि आपके पेरामिटर्स है पहले से ही लोकल न्यूनतम पर, एक स्टेप ग्रेडीयंट डिसेंट का बिल्कुल कुछ नहीं करता यह नहीं बदलता है आपके पेरामिटर जो आप चाहते हैं क्योंकि यह रखता है आपका हल लोकल मिनिमम ओप्टिमम पर. इससे स्पष्ट भी होता है क्यों ग्रेडीयंट डिसेंट कन्वर्ज हो सकता है लोकल मिनिमम पर लर्निंग रेट अल्फ़ा निर्धारित रखने के बाद भी. यहाँ है कि मेरा क्या मतलब है उससे, चलिए देखते है एक उदाहरण. तो, यहाँ है मेरा फ़ंक्शन जे ऑफ़ थीटा जो शायद में चाहता हूँ न्यूनतम करना और मान लो में इनिशियलाइज करता हूँ मेरा अल्गोरिद्म, मेरा ग्रेडीयंट डिसेंट अल्गोरिद्म, वहाँ उस मजेंटा पोईँट पर. यदि मैं लेता हूँ एक स्टेप ग्रेडीयंट डिसेंट में, शायद यह मुझे ले जाएगा उस पोईँट पर, क्योंकि मेरे डेरिवेटिव्स हैं काफ़ी स्टीप / तीव्र ढलान वाले वहाँ पर. ठीक? अब, मैं यहाँ हरे पोईँट पर हूँ, और यदि मैं लेता हूँ एक और स्टेप ग्रेडीयंट डिसेंट में, आप ध्यान दें कि मेरे डेरिवेटिव मतलब स्लोप, है कम स्टीप हरे पोईँट पर तुलना में उस मजेंटा पोईँट के वहाँ. क्योंकि जैसे जैसे मैं क़रीब पहुँचता हूँ न्यूनतम के, मेरे डेरिवेटिव होते जाते हैं क़रीब ज़ीरो के, जैसे मैं पहुँचता हूँ न्यूनतम पर. तो एक क़दम डिसेंट के बाद, मेरे नए डेरिवेटिव हैं थोड़े छोटे. तो मैं लेता हूँ एक और स्टेप ग्रेडीयंट डिसेंट में. मैं स्वाभाविक रूप से लूँगा एक छोटा स्टेप इस हरे पोईँट से तुलना में उस मजेंटा पोईँट से. आप एक नए पोईँट से, एक लाल पोईँट, और मैं और भी नज़दीक ग्लोबल न्यूनतम के तो डेरिवेटिव यहाँ होगा और भी छोटा तुलना में जो यह था हरे पोईँट पर. तो मैं लेता हूँ एक और स्टेप ग्रेडीयंट डिसेंट में. अब, मेरी डेरिवेटिव टर्म है और भी छोटी और इसलिए परिमाण / मैग्निटूड थीटा वन के अपडेट का है और भी छोटा, तो लें एक छोटा स्टेप इस तरह. और जैसे ग्रेडीयंट डिसेंट रन करता है, आप अपने आप लेंगे छोटे और छोटे स्टेप. जब तक अंत में आप लेंगे बहुत ही छोटे स्टेप, आप जानते हैं, और आप अंत में कन्वर्ज करेंगे लोकल मिनिमम पर. तो पुनरावृति के लिए, ग्रेडीयंट डिसेंट में जैसे हम पहुँचते है एक लोकल मिनिमम पर, ग्रेडीयंट डिसेंट अपने आप लेगा छोटे स्टेप. और वह इसलिए क्योंकि जैसे हम पहुँचते है लोकल मिनिमम पर, परिभाषा से लोकल मिनिमम है जहाँ डेरिवेटिव है बराबर ज़ीरो. जैसे हम पहुँचते हैं लोकल मिनिमम पर, यह डेरिवेटिव टर्म अपने आप हो जाएगी छोटी, और इसलिए ग्रेडीयंट डिसेंट अपने आप लेगा छोटे स्टेप. ऐसा है इसलिए कोई आवश्यकता नहीं है अल्फ़ा को कम करने की या समय. तो वह है ग्रेडीयंट डिसेंट अल्गोरिद्म और आप इस्तेमाल कर सकते हैं इसे करने के लिए न्यूनतम किसी भी कॉस्ट फ़ंक्शन जे को, नहीं कॉस्ट फ़ंक्शन जे जो हमने परिभाषित किया था लिनीअर रेग्रेशन के लिए. अगले वीडियो में हम लेंगे फ़ंक्शन जे और सेट करेंगे उसे वापिस उसी लिनीअर रेग्रेशन के कॉस्ट फ़ंक्शन पर, स्क्वेर कॉस्ट फ़ंक्शन जो हमने पहले बनाया था. और लेंगे ग्रेडीयंट डिसेंट फ़ंक्शन और यह कॉस्ट फ़ंक्शन और रखेंगे दोनो को एक साथ. वह देगा हमें हमारा पहला लर्निंग अल्गोरिद्म. वह देगा हमें एक लिनीअर रेग्रेशन अल्गोरिद्म.