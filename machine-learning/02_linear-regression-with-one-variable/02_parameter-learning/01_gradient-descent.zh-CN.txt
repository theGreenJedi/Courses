我们已经定义了代价函数J 而在这段视频中 我想向你们介绍梯度下降这种算法 这种算法可以将代价函数J最小化 梯度下降是很常用的算法 它不仅被用在线性回归上 它实际上被广泛的应用于机器学习领域中的众多领域 在后面课程中 为了解决其他线性回归问题 我们也将使用梯度下降法 最小化其他函数 而不仅仅是只用在本节课的代价函数J 因此在这个视频中 我将讲解用梯度下降算法最小化函数 J 在后面的视频中 我们还会将此算法应用于具体的 代价函数J中来解决线性回归问题 下面是问题概述 在这里 我们有一个函数J(θ0, θ1) 也许这是一个线性回归的代价函数 也许是一些其他函数 要使其最小化 我们需要用一个算法 来最小化函数J(θ0, θ1) 就像刚才说的 事实证明 梯度下降算法可应用于 多种多样的函数求解 所以想象一下如果你有一个函数 J(θ0, θ1, θ2, ...,θn ) 你希望可以通过最小化 θ0到θn 来最小化此代价函数J(θ0 到θn) 用n个θ是为了证明梯度下降算法可以解决更一般的问题 但为了简洁起见 为了简化符号 在接下来的视频中 我只用两个参数 下面就是关于梯度下降的构想 我们要做的是 我们要开始对θ0和θ1 进行一些初步猜测 它们到底是什么其实并不重要 但通常的选择是将 θ0设为0 将θ1也设为0 将它们都初始化为0 我们在梯度下降算法中要做的 就是不停地一点点地改变 θ0和θ1 试图通过这种改变使得J(θ0, θ1)变小 直到我们找到 J 的最小值 或许是局部最小值 让我们通过一些图片来看看梯度下降法是如何工作的 我在试图让这个函数值最小 注意坐标轴 θ0和θ1在水平轴上 而函数 J在垂直坐标轴上 图形表面高度则是 J的值 我们希望最小化这个函数 所以我们从 θ0和θ1的某个值出发 所以想象一下 对 θ0和θ1赋以某个初值 也就是对应于从这个函数表面上的某个起始点出发 对吧 所以不管 θ0和θ1的取值是多少 我将它们初始化为0 但有时你也可把它初始化为其他值 现在我希望大家把这个图像想象为一座山 想像类似这样的景色 公园中有两座山 想象一下你正站立在山的这一点上 站立在你想象的公园这座红色山上 在梯度下降算法中 我们要做的就是旋转360度 看看我们的周围 并问自己 我要在某个方向上 用小碎步尽快下山 如果我想要下山 如果我想尽快走下山 这些小碎步需要朝什么方向? 如果我们站在山坡上的这一点 你看一下周围 ​​你会发现最佳的下山方向 大约是那个方向 好的 现在你在山上的新起点上 你再看看周围 然后再一次想想 我应该从什么方向迈着小碎步下山? 然后你按照自己的判断又迈出一步 往那个方向走了一步 然后重复上面的步骤 从这个新的点 你环顾四周 并决定从什么方向将会最快下山 然后又迈进了一小步 又是一小步
并依此类推 直到你接近这里 直到局部最低点的位置 此外 这种下降有一个有趣的特点 第一次我们是从这个点开始进行梯度下降算法的 是吧 在这一点上从这里开始 现在想象一下 我们在刚才的右边一些的位置 对梯度下降进行初始化 想象我们在右边高一些的这个点 开始使用梯度下降 如果你重复上述步骤 停留在该点 并环顾四周 往下降最快的方向迈出一小步 然后环顾四周 又迈出一步 然后如此往复 如果你从右边不远处开始 梯度下降算法将会带你来到 这个右边的第二个局部最优处 如果从刚才的第一个点出发 你会得到这个局部最优解 但如果你的起始点偏移了一些 起始点的位置略有不同 你会得到一个 非常不同的局部最优解 这就是梯度下降算法的一个特点 我们会在之后继续探讨这个问题 好的 这是我们从图中得到的直观感受 看看这个图 这是梯度下降算法的定义 我们将会反复做这些 直到收敛 我们要更新参数 θj 方法是 用 θj 减去 α乘以这一部分 让我们来看看 这个公式有很多细节问题 我来详细讲解一下 首先 注意这个符号 := 我们使用 := 表示赋值 这是一个赋值运算符 具体地说 如果我写 a:= b 在计算机专业内 这意味着不管 a的值是什么 取 b的值 并将其赋给a 这意味着我们让 a等于b的值 这就是赋值 我也可以做 a:= a+1 这意味着 取出a值 并将其增加1 与此不同的是 如果我使用等号 = 并且写出a=b 那么这是一个判断为真的声明 如果我写 a=b 就是在断言 a的值是等于 b的值的 在左边这里 这是计算机运算 将一个值赋给 a 而在右边这里 这是声明 声明 a的值 与b的值相同 因此 我可以写 a:=a+1 这意味着 将 a的值再加上1 但我不会写 a=a+1 因为这本来就是错误的 a 和 a+1 永远不会是同一个值 这是这个定义的第一个部分 这里的α 是一个数字 被称为学习速率 什么是α呢?  在梯度下降算法中 它控制了 我们下山时会迈出多大的步子 因此如果 α值很大 那么相应的梯度下降过程中 我们会试图用大步子下山 如果α值很小 那么我们会迈着很小的小碎步下山 关于如何设置 α的值等内容 在之后的课程中 我会回到这里并且详细说明 最后 是公式的这一部分 这是一个微分项 我现在不想谈论它 但我会推导出这个微分项 并告诉你到底这要如何计算 你们中有人大概比较熟悉微积分 但即使你不熟悉微积分 也不用担心 我会告诉你 对这一项 你最后需要做什么 现在 在梯度下降算法中 还有一个更微妙的问题 在梯度下降中 我们要更新 θ0和θ1 当 j=0 和 j=1 时 会产生更新 所以你将更新 J θ0还有θ1 实现梯度下降算法的微妙之处是 在这个表达式中 如果你要更新这个等式 你需要同时更新 θ0和θ1 我的意思是在这个等式中 我们要这样更新 θ0:=θ0 - 一些东西 并更新 θ1:=θ1 - 一些东西 实现方法是 你应该计算公式右边的部分 通过那一部分计算出θ0和θ1的值 然后同时更新 θ0和θ1 让我进一步阐述这个过程 在梯度下降算法中 这是正确实现同时更新的方法 我要设 temp0等于这些 设temp1等于那些 所以首先计算出公式右边这一部分 然后将计算出的结果 一起存入 temp0和 temp1 之中 然后同时更新 θ0和θ1 因为这才是正确的实现方法 与此相反 下面是不正确的实现方法 因为它没有做到同步更新 在这种不正确的实现方法中 我们计算 temp0 然后我们更新θ0 然后我们计算 temp1 然后我们将 temp1 赋给θ1 右边的方法和左边的区别是 让我们看这里 就是这一步 如果这个时候你已经更新了θ0 那么你会使用 θ0的新的值来计算这个微分项 所以由于你已经在这个公式中使用了新的 θ0的值 那么这会产生一个与左边不同的 temp1的值 所以右边并不是正确地实现梯度下降的做法 我不打算解释为什么你需要同时更新 同时更新是梯度下降中的一种常用方法 我们之后会讲到 实际上同步更新是更自然的实现方法 当人们谈到梯度下降时 他们的意思就是同步更新 如果用非同步更新去实现算法 代码可能也会正确工作 但是右边的方法并不是人们所指的那个梯度下降算法 而是具有不同性质的其他算法 由于各种原因 这其中会表现出微小的差别 你应该做的是 在梯度下降中真正实现同时更新 这些就是梯度下降算法的梗概 在接下来的视频中 我们要进入这个微分项的细节之中 我已经写了出来但没有真正定义 如果你已经修过微积分课程 如果你熟悉偏导数和导数 这其实就是这个微分项 如果你不熟悉微积分 不用担心 即使你之前没有看过微积分 或者没有接触过偏导数 在接下来的视频中 你会得到一切你需要知道的 如何计算这个微分项的知识 下一个视频中 希望我们能够给出 实现梯度下降算法的所有知识 【教育无边界字幕组】翻译: 10号少年  校对: 小白_远游 审核: 所罗门捷列夫