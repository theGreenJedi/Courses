1
00:00:00,109 --> 00:00:02,030
このビデオでは、新しい

2
00:00:02,030 --> 00:00:03,738
大規模の機械学習の

3
00:00:03,738 --> 00:00:05,369
シチュエーションである、

4
00:00:05,369 --> 00:00:07,073
オンライン学習の場合について話したい。

5
00:00:07,442 --> 00:00:08,731
オンライン学習の状況は、

6
00:00:08,731 --> 00:00:10,659
問題を、以下のように定義出来る物だ：

7
00:00:10,659 --> 00:00:12,074
連続的な流れ、または

8
00:00:12,074 --> 00:00:14,064
連続的なストリームのデータが

9
00:00:14,064 --> 00:00:15,906
流入し続けていて、そしてアルゴリズムに

10
00:00:15,906 --> 00:00:17,839
そこから学習させたい、という。

11
00:00:18,762 --> 00:00:20,759
こんにちでは、大きなwebサイトの多くは

12
00:00:20,759 --> 00:00:22,245
または、大きな会社のwebサイトの多くで、

13
00:00:22,245 --> 00:00:24,335
各会社は様々なバージョンの

14
00:00:24,335 --> 00:00:25,901
オンライン学習アルゴリズムを

15
00:00:25,901 --> 00:00:28,102
どんどんやって来たり戻ってきたりする

16
00:00:28,117 --> 00:00:29,468
ユーザーの群れから学習するのに

17
00:00:29,468 --> 00:00:31,370
使っている。

18
00:00:31,370 --> 00:00:32,943
具体的には、サイトに次々とやってくる

19
00:00:32,943 --> 00:00:34,992
連続的なユーザーによって生成される

20
00:00:34,992 --> 00:00:36,371
連続的なデータのストリームが

21
00:00:36,371 --> 00:00:37,703
あるとすると、

22
00:00:37,703 --> 00:00:39,413
そこにあなたは

23
00:00:39,413 --> 00:00:40,844
オンライン学習のアルゴリズムを用いて

24
00:00:40,844 --> 00:00:42,632
データのストリームから

25
00:00:42,632 --> 00:00:44,492
ユーザーの嗜好を学習して、

26
00:00:44,492 --> 00:00:46,324
あなたのwebサイトの

27
00:00:46,324 --> 00:00:47,470
意思決定を最適化するのに

28
00:00:47,470 --> 00:00:49,632
使う事が出来る場合がある。

29
00:00:52,063 --> 00:00:54,506
配達サービスを運営しているとしよう。

30
00:00:54,506 --> 00:00:56,163
つまりユーザーがやってきて

31
00:00:56,163 --> 00:00:57,307
彼らの荷物を配達するのを手伝ってくれ、と頼まれる、

32
00:00:57,307 --> 00:01:01,533
場所Aから場所Bまで。

33
00:01:01,533 --> 00:01:02,717
そしてあなたはwebサイトを運営していて、

34
00:01:02,717 --> 00:01:04,110
ユーザーは繰り返しやってきては

35
00:01:04,110 --> 00:01:05,689
あなたに荷物をどこから、

36
00:01:05,689 --> 00:01:07,291
そしてどこまで送りたいか、

37
00:01:07,291 --> 00:01:08,523
それを伝える。

38
00:01:08,523 --> 00:01:10,947
つまり配達元と配達先だ。

39
00:01:10,947 --> 00:01:12,748
そしてあなたのwebサイトは荷物の配達に

40
00:01:12,748 --> 00:01:14,515
なんらかの価格をユーザーに提示する。

41
00:01:14,515 --> 00:01:16,092
だから私はあなたの荷物を$50で送り届けよう、

42
00:01:16,092 --> 00:01:17,926
私は$20で送り届けよう。

43
00:01:17,926 --> 00:01:19,343
そしてあなたがユーザーにオファーした

44
00:01:19,343 --> 00:01:20,922
価格に基づいて、

45
00:01:20,922 --> 00:01:23,522
ユーザーは時には配達サービスを使う事を選ぶ；

46
00:01:23,522 --> 00:01:25,891
その場合は陽性のサンプルだ。

47
00:01:25,891 --> 00:01:28,168
時にはユーザーは立ち去り、

48
00:01:28,168 --> 00:01:29,722
あなたの配達サービスを

49
00:01:29,722 --> 00:01:31,719
購入しない事を選ぶ。

50
00:01:31,719 --> 00:01:34,552
さて、我らはユーザーに

51
00:01:34,552 --> 00:01:36,386
オファーしたい、と思う提示価格を

52
00:01:36,386 --> 00:01:38,499
最適化する為に使えるような

53
00:01:38,499 --> 00:01:41,680
学習アルゴリズムを求めているとする。

54
00:01:41,680 --> 00:01:43,724
具体的には、ユーザーの特徴を捉えた

55
00:01:43,724 --> 00:01:44,908
なんらかのフィーチャーを

56
00:01:44,908 --> 00:01:46,510
考え出したとする。

57
00:01:46,510 --> 00:01:49,376
ユーザーの年齢層などで分かってる事とか、

58
00:01:49,376 --> 00:01:50,875
荷物の送付元と送付先とか、つまり

59
00:01:50,875 --> 00:01:54,405
どこに荷物を送り届けたいのか、などを捉えた物。

60
00:01:54,405 --> 00:01:55,635
そして彼らにオファーする

61
00:01:55,635 --> 00:01:57,911
荷物の配達の価格。

62
00:01:57,911 --> 00:01:59,931
そして我らがやりたいのは、

63
00:01:59,931 --> 00:02:00,883
荷物を送る事を

64
00:02:00,883 --> 00:02:02,439
選択する確率を

65
00:02:02,439 --> 00:02:03,762
学習したい、

66
00:02:03,762 --> 00:02:05,457
これらのフィーチャーが与えられた時に

67
00:02:05,457 --> 00:02:07,315
我らの配達サービスを使ってくれる確率を。

68
00:02:07,315 --> 00:02:10,197
もう一度繰り返しておくと、このフィーチャーxには

69
00:02:10,197 --> 00:02:14,121
我らの提示する価格も含まれている。

70
00:02:14,121 --> 00:02:15,790
だからもし我らが

71
00:02:15,790 --> 00:02:17,486
ある価格を所与として、その価格で

72
00:02:17,486 --> 00:02:19,629
ユーザーが我らのサービスを使う事に

73
00:02:19,629 --> 00:02:20,962
同意してくれる確率を見積もる事が出来るなら、

74
00:02:20,962 --> 00:02:21,967
その時は我らはユーザーが

75
00:02:21,967 --> 00:02:23,183
高い確率で我らのサービスを使ってくれるような

76
00:02:23,183 --> 00:02:25,125
価格でありながら、同時に

77
00:02:25,125 --> 00:02:27,841
我らの側にも公正なリターンが、

78
00:02:27,841 --> 00:02:29,188
我らの側にも公正な利益が

79
00:02:29,188 --> 00:02:31,371
彼らの荷物を配達する事で得られるような

80
00:02:31,371 --> 00:02:34,293
価格を選ぶ事を試みる事が出来る。

81
00:02:34,585 --> 00:02:36,489
つまりもし特定の価格やその他のフィーチャーを

82
00:02:36,489 --> 00:02:37,733
提示された時の

83
00:02:37,733 --> 00:02:38,632
y=1となる条件付き確率を求める事が出来たら、

84
00:02:38,632 --> 00:02:39,660
それを実際に用いて

85
00:02:39,660 --> 00:02:41,657
新しいユーザーが来た時に

86
00:02:41,657 --> 00:02:44,072
適切な価格を提供する事が出来る。

87
00:02:44,072 --> 00:02:45,907
つまりy=1となる確率を

88
00:02:45,907 --> 00:02:47,277
モデリングする為に

89
00:02:47,277 --> 00:02:48,972
我らに出来る事といえば、

90
00:02:48,972 --> 00:02:51,781
ロジスティック回帰かニューラルネットワークか、

91
00:02:51,781 --> 00:02:53,756
とにかく何かしらそれ系のアルゴリズムを使う事だ。

92
00:02:53,756 --> 00:02:55,889
どれでも良いが、ロジスティック回帰を使う事から始めてみよう。

93
00:02:57,658 --> 00:02:59,583
今、継続的に運営されている

94
00:02:59,583 --> 00:03:01,835
webサイトを所有していたとして、

95
00:03:01,835 --> 00:03:05,342
オンライン学習アルゴリズムがやるのはこんな事だ。

96
00:03:05,342 --> 00:03:07,478
無限の繰り返しを書いて、

97
00:03:07,478 --> 00:03:09,730
これは単に、我らのwebサイトが

98
00:03:09,730 --> 00:03:11,170
起き続けていると

99
00:03:11,170 --> 00:03:12,911
言っているに過ぎない。

100
00:03:12,911 --> 00:03:14,351
webサイトに起こる事といえば、

101
00:03:14,351 --> 00:03:16,465
たまにユーザーが来て

102
00:03:16,465 --> 00:03:17,950
そして訪れたユーザーに対して

103
00:03:17,950 --> 00:03:19,576
その客なりユーザーなりに

104
00:03:19,576 --> 00:03:25,380
対応したあるペア、 x, yを

105
00:03:25,380 --> 00:03:29,096
得る事になる。

106
00:03:29,096 --> 00:03:30,884
フィーチャーxは

107
00:03:30,884 --> 00:03:32,811
このユーザーに指定された

108
00:03:32,811 --> 00:03:34,111
起点と目的地、

109
00:03:34,111 --> 00:03:35,358
それと彼らに今回

110
00:03:35,358 --> 00:03:37,292
オファーした価格、

111
00:03:37,292 --> 00:03:38,430
そしてyは1から0で、

112
00:03:38,430 --> 00:03:40,148
それは彼らが我らの配送サービスを

113
00:03:40,148 --> 00:03:41,518
利用したかどうかを

114
00:03:41,518 --> 00:03:43,980
表す値。

115
00:03:43,980 --> 00:03:45,419
今、ひとたびこのx, yのペアを得ると、

116
00:03:45,419 --> 00:03:46,813
オンライン学習のアルゴリズムが

117
00:03:46,813 --> 00:03:48,391
行う事は

118
00:03:48,391 --> 00:03:50,690
パラメータのシータを

119
00:03:50,690 --> 00:03:54,011
この手本 x, yだけを用いてアップデートする、という事。

120
00:03:54,011 --> 00:03:57,726
具体的に書くと

121
00:03:57,726 --> 00:03:59,839
パラメータシータを、このように

122
00:03:59,839 --> 00:04:01,842
シータjを シータj 引くことの学習率アルファ掛けることの

123
00:04:01,842 --> 00:04:06,619
いつも通りのロジスティック回帰の

124
00:04:06,619 --> 00:04:11,356
最急降下法のアップデートルール で、

125
00:04:11,356 --> 00:04:13,399
アップデートする。

126
00:04:13,399 --> 00:04:14,491
これをjが0からnまで

127
00:04:14,491 --> 00:04:15,652
実行する事になる。

128
00:04:15,652 --> 00:04:19,088
そこで中括弧を閉じる。

129
00:04:19,088 --> 00:04:21,218
その他のアルゴリズムだったら、

130
00:04:21,218 --> 00:04:22,873
x-yと書く代わりに

131
00:04:22,873 --> 00:04:24,011
xi, yiと書いてきた。

132
00:04:24,011 --> 00:04:26,495
だが、

133
00:04:26,495 --> 00:04:27,842
オンライン学習の状況では、

134
00:04:27,842 --> 00:04:29,723
固定したトレーニングセットの

135
00:04:29,723 --> 00:04:31,464
記述を捨てている、

136
00:04:31,464 --> 00:04:32,904
その代わりにこのアルゴリズムがある。

137
00:04:32,904 --> 00:04:34,924
今回やる事は、手本を取り出したら、

138
00:04:34,924 --> 00:04:37,014
その手本を使って

139
00:04:37,014 --> 00:04:38,825
こんな感じで学習を行い、

140
00:04:38,825 --> 00:04:41,031
そしてその手本を捨て去ってしまう。

141
00:04:41,031 --> 00:04:43,098
我らはその手本を捨て去り、

142
00:04:43,098 --> 00:04:45,141
それをもう一度用いる事は無い。

143
00:04:45,141 --> 00:04:47,161
だから一度に手本を一つしか見ない。

144
00:04:47,161 --> 00:04:48,879
その手本から学習する。

145
00:04:48,879 --> 00:04:50,412
それを捨てる。

146
00:04:50,412 --> 00:04:51,527
そんな訳だから、

147
00:04:51,527 --> 00:04:52,943
このiでインデックスされる

148
00:04:52,943 --> 00:04:54,615
固定されたトレーニングセットの

149
00:04:54,615 --> 00:04:58,191
記述無しでやっていける。

150
00:04:58,191 --> 00:04:59,328
そしてもしあなたが本当に大規模な

151
00:04:59,328 --> 00:05:01,488
webサイトを運営していて、

152
00:05:01,488 --> 00:05:03,624
連続的なやって来るユーザーのストリームが

153
00:05:03,624 --> 00:05:05,737
あるなら、

154
00:05:05,737 --> 00:05:07,525
この種のオンライン学習アルゴリズムは

155
00:05:07,525 --> 00:05:10,358
現実にも極めて合理的なアルゴリズムだろう。

156
00:05:10,358 --> 00:05:12,076
そんなにたくさんのデータがあるなら、

157
00:05:12,076 --> 00:05:13,330
データは本質的にはタダだから、

158
00:05:13,330 --> 00:05:14,979
そんなデータは本質的には

159
00:05:14,979 --> 00:05:17,022
無制限だから、

160
00:05:17,022 --> 00:05:17,997
その場合は本当に

161
00:05:17,997 --> 00:05:18,949
トレーニング手本を

162
00:05:18,949 --> 00:05:21,527
一回よりも多く見る理由は全く無い。

163
00:05:21,527 --> 00:05:22,432
もちろん、もしちょっとの数のユーザーしか

164
00:05:22,432 --> 00:05:24,220
いなかったら、その時は

165
00:05:24,220 --> 00:05:26,333
このようなオンライン学習アルゴリズムを

166
00:05:26,333 --> 00:05:27,912
用いるよりも、データの全てを

167
00:05:27,912 --> 00:05:29,421
固定したトレーニングセットに保存して、

168
00:05:29,421 --> 00:05:30,884
そのトレーニングセットに対して

169
00:05:30,884 --> 00:05:34,042
なんらかの学習アルゴリズムを走らせる方が賢いだろう。

170
00:05:34,042 --> 00:05:35,018
だがもし本当に連続的なデータのストリームを

171
00:05:35,018 --> 00:05:36,341
持っているなら、その時は

172
00:05:36,341 --> 00:05:39,881
オンライン学習アルゴリズムはとても効率的だ。

173
00:05:39,881 --> 00:05:41,171
また、この種のオンライン学習アルゴリズムの

174
00:05:41,171 --> 00:05:43,015
興味深い効果の一つに、

175
00:05:43,015 --> 00:05:44,073
ユーザーの嗜好に適応する事が出来る、

176
00:05:44,073 --> 00:05:49,391
というのがある事は、指摘しておくべきだろう。

177
00:05:51,006 --> 00:05:54,592
特に、時間とともに

178
00:05:54,592 --> 00:05:55,776
経済状況が変わって、

179
00:05:55,776 --> 00:05:58,377
ユーザーはより

180
00:05:58,377 --> 00:05:59,957
価格感応性が高まって、

181
00:05:59,957 --> 00:06:01,395
そして喜んで払っても良いと思う価格が、、、

182
00:06:01,395 --> 00:06:03,717
あー、高い価格を払うのを、より嫌がるようになる。

183
00:06:03,717 --> 00:06:06,527
あるいは、より価格感応度が下がれば、彼らはより高い価格でも、払って良いと思うようになる。

184
00:06:06,527 --> 00:06:08,292
あるいは、ユーザーにとって

185
00:06:08,292 --> 00:06:10,451
以前とは異なる物がより重要になった場合、

186
00:06:10,451 --> 00:06:11,496
webサイトに新しい種類のユーザー層が

187
00:06:11,496 --> 00:06:12,587
来るようになった場合など。

188
00:06:12,587 --> 00:06:14,933
その場合もこの種のオンライン学習のアルゴリズムは

189
00:06:14,933 --> 00:06:17,278
ユーザーの嗜好の変化や

190
00:06:17,278 --> 00:06:18,950
あなたにお金を払ってくれる

191
00:06:18,950 --> 00:06:20,157
ユーザー層の変化に

192
00:06:20,157 --> 00:06:21,991
適用し続ける事を

193
00:06:21,991 --> 00:06:24,685
可能にしてくれる。

194
00:06:24,685 --> 00:06:26,171
それが可能な理由は、

195
00:06:26,171 --> 00:06:28,168
ユーザーのプールが変化した時に、

196
00:06:28,168 --> 00:06:29,793
これらのアルゴリズムは

197
00:06:29,793 --> 00:06:31,953
パラメータのシータを、ゆっくりと適用させていく、

198
00:06:31,953 --> 00:06:33,555
あたなのパラメータをどんな物であれ最新のあなたの

199
00:06:33,555 --> 00:06:36,599
ユーザーのプールに合わせて。

200
00:06:36,599 --> 00:06:37,781
これはオンライン学習アルゴリズムを適用したいような、

201
00:06:37,781 --> 00:06:40,753
もう一つの例だ。

202
00:06:40,753 --> 00:06:43,472
これは商品検索のアプリケーションで、

203
00:06:43,472 --> 00:06:44,701
ユーザーに

204
00:06:44,701 --> 00:06:46,117
良い検索結果のリストを与えるよう学習するために

205
00:06:46,117 --> 00:06:48,973
機械学習のアルゴリズムを用いたい。

206
00:06:48,973 --> 00:06:51,156
電話機を売る

207
00:06:51,156 --> 00:06:53,083
オンラインストアを運営しているとしよう。

208
00:06:53,083 --> 00:06:55,312
そこでは携帯電話を売っている。

209
00:06:55,312 --> 00:06:56,682
そしてユーザーがwebサイトに来て

210
00:06:56,682 --> 00:06:58,284
検索のクエリをタイプするような

211
00:06:58,284 --> 00:06:59,445
UIがそこにはあるとする。

212
00:06:59,445 --> 00:07:02,626
クエリは「Android phone 1080p camera」とかそういう物。

213
00:07:02,626 --> 00:07:03,509
1080pは電話機に

214
00:07:03,509 --> 00:07:04,623
携帯電話に

215
00:07:04,623 --> 00:07:05,808
ついていて欲しいビデオカメラの

216
00:07:05,808 --> 00:07:08,710
仕様だ。

217
00:07:08,710 --> 00:07:12,100
商店に100個の電話機があるとしよう。

218
00:07:12,100 --> 00:07:13,354
そしてwebサイトの

219
00:07:13,354 --> 00:07:15,321
レイアウトの方法は、

220
00:07:15,321 --> 00:07:16,558
ユーザーがクエリをタイプした時には、

221
00:07:16,558 --> 00:07:18,277
もしそれが検索のクエリなら、

222
00:07:18,277 --> 00:07:19,601
10台の別々の電話機を

223
00:07:19,601 --> 00:07:20,900
ユーザーに提示する為に

224
00:07:20,900 --> 00:07:22,921
選びたい。

225
00:07:22,921 --> 00:07:24,987
我らがやりたい事は、

226
00:07:24,987 --> 00:07:26,566
100台の電話機の中から

227
00:07:26,566 --> 00:07:28,447
どの10台の電話機を

228
00:07:28,447 --> 00:07:29,771
ユーザーがこんな検索クエリを行ったら

229
00:07:29,771 --> 00:07:31,791
表示すべきかを

230
00:07:31,791 --> 00:07:34,531
見出す助けとなるような学習アルゴリズムが欲しい。

231
00:07:34,531 --> 00:07:36,695
これがその問題にどう取り組むかだ。

232
00:07:37,218 --> 00:07:39,291
各電話機と特定のユーザーのクエリが

233
00:07:39,291 --> 00:07:41,311
与えられたとして、

234
00:07:41,311 --> 00:07:44,120
フィーチャーベクトルxを構築出来る。

235
00:07:44,120 --> 00:07:45,676
フィーチャーベクトルxは電話機の

236
00:07:45,676 --> 00:07:47,650
様々な性質を捉える事となるだろう。

237
00:07:47,650 --> 00:07:49,972
それは例えば

238
00:07:49,972 --> 00:07:53,107
電話機とユーザーの検索のクエリがどの位近いか、を捕捉した物だろう、

239
00:07:53,107 --> 00:07:54,059
ユーザーの検索のクエリから

240
00:07:54,059 --> 00:07:55,475
どれだけの単語が電話機の名前に

241
00:07:55,475 --> 00:07:56,172
マッチしたのかを捕捉した物だろう。

242
00:07:56,172 --> 00:07:57,356
ユーザーのサーチのクエリの中の単語のうち、

243
00:07:57,356 --> 00:08:01,303
どれだけの単語が電話の詳細情報の項目にマッチしたか、などなども。

244
00:08:01,303 --> 00:08:02,789
つまりフィーチャーxは、

245
00:08:02,789 --> 00:08:03,672
電話の性質を捉えた物で、

246
00:08:03,672 --> 00:08:05,251
そしてまた、ユーザーのクエリに

247
00:08:05,251 --> 00:08:06,412
どれだけ似ているか、あるいはどれだけ良くマッチしたかを

248
00:08:06,412 --> 00:08:10,591
様々な次元から見たような物も捉えた物だろう。

249
00:08:10,591 --> 00:08:11,868
我らがやりたい事は

250
00:08:11,868 --> 00:08:14,330
特定の電話機を

251
00:08:14,330 --> 00:08:15,816
ユーザーがクリックするであろう

252
00:08:15,816 --> 00:08:17,673
確率を推計したい。

253
00:08:17,673 --> 00:08:18,881
何故なら我らはユーザーに

254
00:08:18,881 --> 00:08:20,065
彼らが買いそうな電話機を

255
00:08:20,065 --> 00:08:21,481
見せたいから、

256
00:08:21,481 --> 00:08:22,921
彼らのwebブラウザ内でクリックしてくれそうな

257
00:08:22,921 --> 00:08:24,082
確率が高い電話機を

258
00:08:24,082 --> 00:08:27,240
ユーザーに見せたいからだ。

259
00:08:27,240 --> 00:08:29,562
その為に、y=1を

260
00:08:29,562 --> 00:08:30,676
ユーザーが電話機をクリックした場合、と

261
00:08:30,676 --> 00:08:31,930
定義する。

262
00:08:31,930 --> 00:08:34,136
そしてそれ以外の場合はy=0とする。

263
00:08:34,136 --> 00:08:35,454
そこで私がやりたいのは、

264
00:08:35,454 --> 00:08:36,992
ユーザーが特定の電話機を

265
00:08:36,992 --> 00:08:38,246
クリックする確率だ、

266
00:08:38,246 --> 00:08:39,802
電話機の性質や

267
00:08:39,802 --> 00:08:41,693
クエリがどれだけ電話機にマッチしたかを捉えたような

268
00:08:41,693 --> 00:08:43,819
フィーチャーが与えられた時に。

269
00:08:43,819 --> 00:08:45,700
このようなwebサイトを

270
00:08:45,700 --> 00:08:47,720
運営している人達が

271
00:08:47,720 --> 00:08:49,130
この問題に与えた名前は、

272
00:08:49,130 --> 00:08:51,249
これを学習する問題は実際には

273
00:08:51,249 --> 00:08:53,223
クリックスルー率の予測値、またはCTRの予測値を

274
00:08:53,223 --> 00:08:57,296
学習する問題、と呼ばれている。

275
00:08:57,296 --> 00:08:58,796
それは単に、ユーザーに

276
00:08:58,796 --> 00:09:00,491
リンクをオファーした時に

277
00:09:00,491 --> 00:09:01,698
そのリンクをクリックする確率を

278
00:09:01,698 --> 00:09:03,022
学習するって意味なだけ。

279
00:09:03,022 --> 00:09:06,528
CTRはClick Through Rateの略。

280
00:09:06,528 --> 00:09:07,550
そしてもしクリックスルー率の予測値を

281
00:09:07,550 --> 00:09:09,245
各電話機に対して

282
00:09:09,245 --> 00:09:10,847
推計出来たなら、

283
00:09:10,847 --> 00:09:12,171
これを用いてユーザーに

284
00:09:12,171 --> 00:09:13,819
もっともクリックしてもらえそうな電話機を

285
00:09:13,819 --> 00:09:15,770
見せる、という事が出来る、

286
00:09:15,770 --> 00:09:17,441
何故なら100台の電話機から

287
00:09:17,441 --> 00:09:20,553
100台の電話機それぞれの

288
00:09:20,553 --> 00:09:21,737
これを計算する事が出来て、

289
00:09:21,737 --> 00:09:22,759
ユーザーがもっともクリックしそうな

290
00:09:22,759 --> 00:09:25,754
10台の電話機を選ぶ事が出来る、

291
00:09:25,754 --> 00:09:26,892
そしてこれはユーザーに、どの10台を見せるかを

292
00:09:26,892 --> 00:09:29,818
決定する極めて合理的な方法だと言えよう。

293
00:09:29,818 --> 00:09:32,186
明確にする為、ユーザーが

294
00:09:32,186 --> 00:09:33,440
検索をする都度、

295
00:09:33,440 --> 00:09:35,576
10の結果を返すとしよう。

296
00:09:35,576 --> 00:09:37,225
その場合にそれがする事は

297
00:09:37,225 --> 00:09:38,990
実際は10組のx, yのペアを与えてくれる事で、

298
00:09:38,990 --> 00:09:40,870
これは実際は10のトレーニング手本を

299
00:09:40,870 --> 00:09:43,332
我らに与えてくれる、

300
00:09:43,332 --> 00:09:44,640
ユーザーが我らのwebサイトに来るたび毎に、

301
00:09:44,640 --> 00:09:46,257
何故なら、

302
00:09:46,257 --> 00:09:47,535
我らがユーザーに見せる為に選んだ

303
00:09:47,535 --> 00:09:48,881
10台の電話機は

304
00:09:48,881 --> 00:09:49,896
それらの10台の電話機それぞれに

305
00:09:49,896 --> 00:09:51,389
フィーチャーベクトルxが得られ、

306
00:09:51,389 --> 00:09:52,737
そしてまた10台の電話機それぞれに

307
00:09:52,737 --> 00:09:54,563
yの値も

308
00:09:54,563 --> 00:09:56,172
得られる事になる。

309
00:09:56,172 --> 00:09:57,542
我らはyの値も観測する事になる、

310
00:09:57,542 --> 00:09:59,517
ユーザーがそのリンクを

311
00:09:59,517 --> 00:10:00,925
クリックしたか否かに

312
00:10:00,925 --> 00:10:02,465
応じて。

313
00:10:02,465 --> 00:10:03,696
つまり、こんな類のwebサイトを

314
00:10:03,696 --> 00:10:04,903
運営する方法の一つとして、

315
00:10:04,903 --> 00:10:06,830
ユーザーに継続的に

316
00:10:06,830 --> 00:10:08,363
10個の最もユーザーが好きそうな

317
00:10:08,363 --> 00:10:09,895
電話機を見せる、という事で、

318
00:10:09,895 --> 00:10:11,428
そうする事でユーザーが来る都度、

319
00:10:11,428 --> 00:10:12,728
10個の手本、10組のx, yのペアを

320
00:10:12,728 --> 00:10:14,493
得る事となり、

321
00:10:14,493 --> 00:10:16,304
そして次にオンライン学習アルゴリズムを用いて

322
00:10:16,304 --> 00:10:17,953
本質的にはこれら10個の手本に対する

323
00:10:17,953 --> 00:10:20,182
10ステップの最急降下法で

324
00:10:20,182 --> 00:10:21,691
パラメータをアップデートする。

325
00:10:21,691 --> 00:10:23,386
その後はデータを

326
00:10:23,386 --> 00:10:25,081
捨てて良くて、

327
00:10:25,081 --> 00:10:26,590
そして実際にwebサイトを訪れる

328
00:10:26,590 --> 00:10:27,891
連続的なユーザーのストリームを

329
00:10:27,891 --> 00:10:29,354
保持しているなら、

330
00:10:29,354 --> 00:10:31,095
これはあなたのアルゴリズムの為に

331
00:10:31,095 --> 00:10:32,395
パラメータを学習する、極めて合理的な方法だろう。

332
00:10:32,395 --> 00:10:33,835
あなたのユーザーが、

333
00:10:33,835 --> 00:10:35,669
もっともクリックしそうな10台の

334
00:10:35,669 --> 00:10:39,013
電話を見せる為の。

335
00:10:39,013 --> 00:10:40,151
以上が商品検索の問題、言い換えると

336
00:10:40,151 --> 00:10:41,498
電話のランキングを学習する、

337
00:10:41,498 --> 00:10:44,214
電話の検索を学習する例だ。

338
00:10:44,214 --> 00:10:46,422
その他の例にもちょっとだけ触れておこう。

339
00:10:46,422 --> 00:10:47,372
一つには、もしwebサイトを運営していて、

340
00:10:47,372 --> 00:10:48,231
ユーザーに提示する

341
00:10:48,231 --> 00:10:49,439
スペシャルオファーをどんな物とするかを

342
00:10:49,439 --> 00:10:50,321
決定したいとする。

343
00:10:50,321 --> 00:10:53,154
これはとても電話機と似ているし、

344
00:10:53,154 --> 00:10:54,710
または別々のユーザーに別々のニュース記事を見せるような

345
00:10:54,710 --> 00:10:58,216
webサイトを運営していても、

346
00:10:58,216 --> 00:10:59,911
つまりあたなのサービスがニュースアグリゲーターのwebサイトだとしても、

347
00:10:59,911 --> 00:11:01,374
その場合でもあなたは

348
00:11:01,374 --> 00:11:02,303
同様のシステムを用いて

349
00:11:02,303 --> 00:11:03,882
ユーザーに何の記事を

350
00:11:03,882 --> 00:11:05,554
見せるのかを

351
00:11:05,554 --> 00:11:06,877
選択するのに、

352
00:11:06,877 --> 00:11:08,154
彼らがもっとも興味をもちそうで、

353
00:11:08,154 --> 00:11:11,103
クリックしそうな物を選ぶ事が出来る。

354
00:11:11,103 --> 00:11:13,495
スペシャルオファーに密接に関係している物として、リコメンデーションも有効に活用出来る。

355
00:11:13,495 --> 00:11:15,097
実際、もし協調的フィルタリングの

356
00:11:15,097 --> 00:11:17,953
システムがあるなら、

357
00:11:17,953 --> 00:11:20,693
協調的フィルタリングシステムが

358
00:11:20,693 --> 00:11:22,643
ロジスティック回帰の分類器に

359
00:11:22,643 --> 00:11:23,897
食わせる為の、追加のフィーチャーを

360
00:11:23,897 --> 00:11:25,732
提供してくれて、

361
00:11:25,732 --> 00:11:28,100
その分類器を用いてユーザーにリコメンドする

362
00:11:28,100 --> 00:11:29,981
商品のそれぞれのクリックスルー率を予測する事が出来る。

363
00:11:29,981 --> 00:11:32,280
もちろん、これらの問題はどれも

364
00:11:32,280 --> 00:11:34,207
通常の機会学習の問題として

365
00:11:34,207 --> 00:11:35,600
定式化する事も出来る、という事は指摘しておくべきだろう。

366
00:11:35,600 --> 00:11:39,873
その場合は固定したトレーニングセットを持っているという形になる。

367
00:11:39,873 --> 00:11:40,894
例えば2, 3日webサイトを

368
00:11:40,894 --> 00:11:41,823
運営してみて、

369
00:11:41,823 --> 00:11:43,727
そしてトレーニングセットを保存し分けて

370
00:11:43,727 --> 00:11:44,842
固定されたトレーニングセットとし、

371
00:11:44,842 --> 00:11:45,771
それに対して学習アルゴリズムを走らせる事も出来る。

372
00:11:45,771 --> 00:11:48,696
だがこれらは現実に、

373
00:11:48,696 --> 00:11:49,950
大きな会社が大量にデータを

374
00:11:49,950 --> 00:11:51,901
集めているシーンに遭遇する事が多々あるたぐいの

375
00:11:51,901 --> 00:11:53,712
問題でもある。その場合は、

376
00:11:53,712 --> 00:11:55,221
固定したトレーニングセットを保存し分ける必要は無く、

377
00:11:55,221 --> 00:11:56,963
その代わりにオンライン学習アルゴリズムを用いて、

378
00:11:56,963 --> 00:11:59,563
単純にユーザーがwebサイトにおいて生成するデータを

379
00:11:59,563 --> 00:12:04,091
継続的に学習させてしまう事も出来る。

380
00:12:05,183 --> 00:12:07,249
以上がオンライン学習の

381
00:12:07,249 --> 00:12:08,990
問題設定だ。

382
00:12:08,990 --> 00:12:10,616
ここまで見てきた通り、それに適用する

383
00:12:10,616 --> 00:12:12,357
アルゴリズムは、確率的最急降下法のアルゴリズムと

384
00:12:12,357 --> 00:12:13,867
本当にとっても良く似ている。

385
00:12:13,867 --> 00:12:15,330
唯一違う所は

386
00:12:15,330 --> 00:12:16,871
固定したトレーニングセットを

387
00:12:16,871 --> 00:12:18,000
スキャンしていく代わりに、

388
00:12:18,000 --> 00:12:19,974
ユーザー達から一つの手本だけを取り出して、

389
00:12:19,974 --> 00:12:21,290
その手本から学習し、

390
00:12:21,290 --> 00:12:22,644
その手本を捨てて、次に進む。

391
00:12:22,644 --> 00:12:25,593
そしてもし何らかの応用に際し、

392
00:12:25,593 --> 00:12:26,777
連続的なデータのストリームがある時は、

393
00:12:26,777 --> 00:12:28,356
この種のアルゴリズムはあなたのアプリの為に

394
00:12:28,356 --> 00:12:31,816
検討してみるに値する物だろう。

395
00:12:31,816 --> 00:12:33,952
もちろん、オンライン学習の

396
00:12:33,952 --> 00:12:36,128
利点の一つにはまた、

397
00:12:36,128 --> 00:12:37,458
変わっていくユーザーのプールとか

398
00:12:37,458 --> 00:12:38,967
または予測しようとしている事が

399
00:12:38,967 --> 00:12:40,082
ゆっくりと変わっていくような

400
00:12:40,082 --> 00:12:42,032
事である場合、例えばユーザーの嗜好が

401
00:12:42,032 --> 00:12:43,751
ゆっくり変わっていくとか、そういう場合は、

402
00:12:43,751 --> 00:12:45,492
オンライン学習アルゴリズムは

403
00:12:45,492 --> 00:12:47,211
ユーザーの最新の振る舞いが、それがどんな物であれ

404
00:12:47,211 --> 00:12:49,161
それに学習した仮説を

405
00:12:49,161 --> 99:59:59,000
ゆっくりと適応させていく事が出来る。