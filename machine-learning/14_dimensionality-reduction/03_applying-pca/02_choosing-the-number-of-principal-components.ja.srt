1
00:00:00,090 --> 00:00:01,560
PCAのアルゴリズムにおいては、

2
00:00:01,980 --> 00:00:03,530
n次元のフィーチャーを引数に取り

3
00:00:03,970 --> 00:00:06,260
それをある数kの次元のフィーチャーの表現へと縮小する。

4
00:00:07,620 --> 00:00:09,090
この数kがPCAアルゴリズムの

5
00:00:09,820 --> 00:00:10,800
パラメータとなる。

6
00:00:11,810 --> 00:00:13,240
この数字kはまた、

7
00:00:13,620 --> 00:00:15,080
主成分の数、あるいは保持する主成分の総数

8
00:00:15,830 --> 00:00:17,480
とも呼ばれる物だ。

9
00:00:18,530 --> 00:00:19,640
そしてこのビデオで、

10
00:00:19,810 --> 00:00:20,850
PCAのパラメータkを選ぶのに

11
00:00:21,730 --> 00:00:23,090
人々がどんなやり方で

12
00:00:23,430 --> 00:00:24,490
選ぶ事が多いのかの

13
00:00:24,610 --> 00:00:26,740
ガイドラインを与えたい。

14
00:00:28,650 --> 00:00:29,670
kを選ぶ為に、

15
00:00:30,110 --> 00:00:30,990
それは主成分の数を選ぶという事だが、

16
00:00:31,360 --> 00:00:34,110
その為に有用な幾つかのコンセプトをここに示す。

17
00:00:36,430 --> 00:00:37,520
PCAがやろうとする事は、

18
00:00:37,760 --> 00:00:38,760
二乗射影誤差の平均を

19
00:00:40,070 --> 00:00:41,510
最小化しようとする事だ。

20
00:00:42,030 --> 00:00:43,200
つまりPCAは、

21
00:00:43,430 --> 00:00:45,480
この量を最小化しようと試みる。ここに書きだした奴。

22
00:00:46,410 --> 00:00:47,980
これは元のデータxと

23
00:00:48,150 --> 00:00:50,010
射影したバージョンx-approx-iとの

24
00:00:50,690 --> 00:00:53,470
差分で、

25
00:00:53,620 --> 00:00:54,930
これは前回のビデオで定義した物だ。

26
00:00:55,020 --> 00:00:55,900
PCAはxとそれをより次元の低い表面へと

27
00:00:56,160 --> 00:00:57,360
射影した点との距離の二乗を

28
00:00:58,330 --> 00:00:59,750
最小化しようとする。

29
00:01:01,220 --> 00:01:02,990
これが二乗射影誤差の平均だ。

30
00:01:03,990 --> 00:01:05,320
そしてまた、データ全体の

31
00:01:05,440 --> 00:01:07,020
分散も定義しておこう。

32
00:01:07,100 --> 00:01:08,730
それは

33
00:01:09,020 --> 00:01:11,730
これらの手本xiの

34
00:01:12,140 --> 00:01:14,130
長さの二乗の平均だ。

35
00:01:14,450 --> 00:01:16,010
つまりデータ全体の分散は、

36
00:01:16,260 --> 00:01:17,930
トレーニングセット内の

37
00:01:18,070 --> 00:01:19,250
各トレーニング手本の長さの

38
00:01:19,370 --> 00:01:21,640
平均だ。

39
00:01:22,190 --> 00:01:23,690
そしてこれの意味する所は、

40
00:01:23,940 --> 00:01:24,850
「平均では、我らの手本は

41
00:01:25,690 --> 00:01:27,960
全てがゼロのベクトルから、どれだけ離れているか？

42
00:01:28,770 --> 00:01:30,460
平均では我らのトレーニング手本は

43
00:01:30,820 --> 00:01:32,820
原点からどれだけ離れているだろうか？」

44
00:01:33,510 --> 00:01:34,450
我らがkを選ぼうとする時には、

45
00:01:35,870 --> 00:01:37,210
kを選ぶのに良く使われる

46
00:01:37,400 --> 00:01:38,620
経験則としては、

47
00:01:38,800 --> 00:01:40,290
これらの値の比が、

48
00:01:40,980 --> 00:01:43,810
0.01未満となるように選ぶ、という物がある。

49
00:01:44,550 --> 00:01:45,540
言い換えると、

50
00:01:46,340 --> 00:01:47,370
我らがkを選ぶ

51
00:01:47,510 --> 00:01:48,460
とても良くやるやり方は、

52
00:01:48,800 --> 00:01:51,180
二乗射影誤差の平均を求める、という事。

53
00:01:51,580 --> 00:01:54,700
それはxと射影との

54
00:01:55,240 --> 00:01:56,340
距離の平均を、

55
00:01:57,570 --> 00:02:00,330
データ全体の分散で割った物。

56
00:02:00,800 --> 00:02:01,870
この全体の分散は、データがどれほど変化するかを表す。

57
00:02:02,940 --> 00:02:04,060
我らはこの比率を、

58
00:02:04,240 --> 00:02:06,760
例えば0.01未満にしたい、とする。

59
00:02:06,830 --> 00:02:09,450
言い換えると1%未満、と考えても良い。

60
00:02:10,860 --> 00:02:11,940
そしてほとんどの人々が

61
00:02:12,150 --> 00:02:13,640
kを選ぶという事を考える時には、

62
00:02:13,860 --> 00:02:15,660
kを直接選ぶのではなく、

63
00:02:15,890 --> 00:02:17,110
多くの人の考え方としては、

64
00:02:17,480 --> 00:02:18,940
この値が幾つか、

65
00:02:19,160 --> 00:02:20,630
という事。これが0.01だろうか？

66
00:02:20,740 --> 00:02:23,330
または別の数だろうか？

67
00:02:23,720 --> 00:02:25,320
そしてもしこれが0.01なら、

68
00:02:25,490 --> 00:02:27,020
PCAの用語を用いてこれを

69
00:02:27,270 --> 00:02:30,120
違う言い方で言うと、99%の分散が保持されている、と言う。

70
00:02:32,060 --> 00:02:33,480
私は本当に、、、

71
00:02:33,850 --> 00:02:34,810
技術的にこのフレーズが一体何を意味しているのかについて、

72
00:02:35,140 --> 00:02:36,920
そんなに気にしないで欲しい。

73
00:02:37,830 --> 00:02:39,170
このフレーズ、「99%の分散が保持されている」というのは、単に

74
00:02:39,420 --> 00:02:41,710
この左側の量が0.01未満だと言っているに過ぎない。

75
00:02:42,340 --> 00:02:43,910
だから、もしあなたが

76
00:02:44,930 --> 00:02:46,510
PCAを使っていて、そして他の人に、

77
00:02:46,630 --> 00:02:47,730
どれだけの数の主成分を

78
00:02:48,220 --> 00:02:49,860
残したのか、について伝えたい時は、

79
00:02:49,980 --> 00:02:51,080
私は、kを

80
00:02:51,140 --> 00:02:52,360
99%の分散が保持されるように選んだ、

81
00:02:52,450 --> 00:02:55,360
と言う方が、より一般的だ。

82
00:02:55,990 --> 00:02:56,960
そしてそれは、知っておくと役に立つ事だ。

83
00:02:57,660 --> 00:02:58,530
それの意味する所は、

84
00:02:58,620 --> 00:02:59,820
平均の二乗射影誤差を

85
00:03:00,760 --> 00:03:01,720
全体の分散で割ると、

86
00:03:01,900 --> 00:03:03,260
それがたかだが1%だという事だ。

87
00:03:03,820 --> 00:03:04,770
それは考えてみるになかなか

88
00:03:05,270 --> 00:03:06,790
洞察に富んだ事だ。

89
00:03:06,920 --> 00:03:08,420
一方でもしあなたが誰かに

90
00:03:09,170 --> 00:03:10,710
「100個の主成分を得た」とか、

91
00:03:10,890 --> 00:03:12,030
「kはイコール100で、

92
00:03:12,720 --> 00:03:13,850
元の次元は1000次元のデータだった」

93
00:03:14,220 --> 00:03:15,350
とか言っても、

94
00:03:15,420 --> 00:03:16,600
これを聞いた人にとっては

95
00:03:19,100 --> 00:03:19,100
解釈が難しい。

96
00:03:19,320 --> 00:03:22,220
そこでこの数字、0.01というのを人々は良く使う。

97
00:03:23,070 --> 00:03:25,380
その他良く使われるのは0.05。

98
00:03:26,840 --> 00:03:27,810
こちらは5%。

99
00:03:27,990 --> 00:03:28,870
もしこちらを用いると

100
00:03:29,210 --> 00:03:30,390
人の所に行って、こう言う事が出来る：

101
00:03:30,740 --> 00:03:32,320
分散の95%は

102
00:03:32,480 --> 00:03:34,280
保持されています、と。

103
00:03:34,700 --> 00:03:36,710
他の数字としては、分散の90%が保持されている、とか、

104
00:03:37,980 --> 00:03:40,030
85%くらいまではありうるかもしれない。

105
00:03:40,150 --> 00:03:42,410
90%は0.10に対応した物で、

106
00:03:44,340 --> 00:03:46,950
つまり10%。

107
00:03:47,250 --> 00:03:49,160
つまり、値の範囲として、

108
00:03:49,900 --> 00:03:50,770
90, 95, 99, そして低くても85%くらいまでの中に

109
00:03:50,870 --> 00:03:51,470
含まれる値は、

110
00:03:51,500 --> 00:03:55,100
値としてはかなり典型的な範囲だろう。

111
00:03:55,780 --> 00:03:56,900
95から99の値が

112
00:03:57,690 --> 00:03:58,810
人々が用いる値としては

113
00:03:59,020 --> 00:04:02,080
もっとも一般的な範囲だと思う。

114
00:04:02,130 --> 00:04:02,950
多くのデータセットにおいて、

115
00:04:03,010 --> 00:04:04,320
99%の分散を保持するのに、

116
00:04:04,790 --> 00:04:06,590
凄いデータの次元を削減出来て、

117
00:04:06,790 --> 00:04:08,160
しかもほとんどの分散を保持したままに出来る事に

118
00:04:08,200 --> 00:04:11,810
しばしば驚く事になろう。

119
00:04:12,440 --> 00:04:13,410
何故なら多くの現実世界のデータは、

120
00:04:13,560 --> 00:04:15,210
多くのフィーチャーがお互いに

121
00:04:15,280 --> 00:04:17,060
高い相関を持っているから。

122
00:04:17,310 --> 00:04:17,940
だからデータを

123
00:04:18,490 --> 00:04:19,540
大量に圧縮しつつ、

124
00:04:19,610 --> 00:04:20,990
多くの分散、例えば

125
00:04:21,360 --> 00:04:22,310
99%とか95%の分散を保持する事も

126
00:04:22,530 --> 00:04:26,260
可能となる。
ではこれをどう実装したらいいだろう？

127
00:04:26,810 --> 00:04:28,610
これが一つ、使えそうなアルゴリズムだ。

128
00:04:28,890 --> 00:04:30,360
もしあなたがkの値を

129
00:04:30,540 --> 00:04:31,360
選びたいとすると、

130
00:04:31,470 --> 00:04:33,510
k=1から始める。

131
00:04:33,550 --> 00:04:34,670
そしてPCAを実行する。

132
00:04:35,350 --> 00:04:36,440
つまりUreduceを計算して、

133
00:04:36,570 --> 00:04:38,880
z(1), z(2), ... , z(m)と計算して、

134
00:04:39,520 --> 00:04:40,790
x1 approx, ...とxm approxまでを

135
00:04:41,090 --> 00:04:42,540
全て計算する。

136
00:04:43,200 --> 00:04:45,110
そして分散が99%保持されているかどうかをチェックする。

137
00:04:47,140 --> 00:04:48,890
そしてもし保持されていれば、k=1を使う。

138
00:04:49,020 --> 00:04:51,960
保持されていなければ、次に進み、k=2を試す。

139
00:04:52,620 --> 00:04:53,810
そしてまたこの手続き全体を

140
00:04:54,200 --> 00:04:56,070
繰り返して、そして

141
00:04:56,170 --> 00:04:57,770
この式が満たされているかをチェックする、

142
00:04:58,470 --> 00:05:00,980
これは0.01未満だろうか。そして満たしていなかったら、またこれを繰り返す。

143
00:05:01,220 --> 00:05:03,070
k=3を試そう、

144
00:05:03,310 --> 00:05:04,910
次にk=4を試そう、

145
00:05:04,970 --> 00:05:06,250
そうやって、例えば

146
00:05:06,630 --> 00:05:07,730
k=17まで行った所で、

147
00:05:08,070 --> 00:05:09,040
99%のデータが保持されている、という事を

148
00:05:09,090 --> 00:05:13,060
見出したとする。

149
00:05:14,120 --> 00:05:15,110
その場合はk=17とする訳だ。

150
00:05:15,570 --> 00:05:17,160
これはkの

151
00:05:17,240 --> 00:05:18,790
99%の分散を保持する最小の値を探す

152
00:05:19,130 --> 00:05:20,920
方法の一つだ。

153
00:05:22,380 --> 00:05:23,440
だが想像出来るように、

154
00:05:23,550 --> 00:05:25,140
この手続は恐ろしいほど効率が悪い。

155
00:05:26,210 --> 00:05:28,120
我らはk=1を試し、k=2、とこれらの計算をやり続ける。

156
00:05:29,580 --> 00:05:30,540
幸運な事に、PCAを実装する時には、

157
00:05:31,130 --> 00:05:33,510
この手順の所で、

158
00:05:33,960 --> 00:05:35,530
実際にはこれらの事を

159
00:05:35,910 --> 00:05:37,080
同じように計算する、もっと簡単な方法を可能にする

160
00:05:37,320 --> 00:05:40,160
量を与えてくれる。

161
00:05:41,110 --> 00:05:42,160
具体的には、これらの行列、

162
00:05:42,820 --> 00:05:44,120
U, S, Vを取る為に

163
00:05:44,340 --> 00:05:45,550
svdを呼んだら、

164
00:05:45,610 --> 00:05:46,780
共分散行列 Sigmaに対して

165
00:05:47,040 --> 00:05:48,560
svdをコールしたら、

166
00:05:48,860 --> 00:05:49,780
それはSという行列も返す。

167
00:05:50,300 --> 00:05:52,170
このSが何かというと、

168
00:05:52,360 --> 00:05:53,430
SはN掛けるNの

169
00:05:53,520 --> 00:05:56,790
正方行列であり、

170
00:05:57,640 --> 00:05:58,090
実際は、

171
00:05:58,290 --> 00:05:58,290
対角行列でもある。

172
00:05:58,830 --> 00:06:00,380
そして対角成分であるs11,

173
00:06:00,540 --> 00:06:01,640
s22,

174
00:06:01,980 --> 00:06:03,240
s33、、、とsnnまであるが、

175
00:06:03,590 --> 00:06:05,130
それらだけが

176
00:06:05,260 --> 00:06:07,010
この行列の中の非ゼロ成分で、

177
00:06:07,130 --> 00:06:08,880
対角成分から外れた全ての成分は

178
00:06:09,060 --> 00:06:11,470
0となる。

179
00:06:11,590 --> 00:06:11,590
分かりましたか。

180
00:06:11,670 --> 00:06:12,530
ここに描いたこれらの大きなOは、

181
00:06:13,340 --> 00:06:14,260
これの意味する所は、

182
00:06:14,740 --> 00:06:16,330
この行列の

183
00:06:17,130 --> 00:06:18,220
対角成分から外れた成分は

184
00:06:18,480 --> 00:06:20,310
全てゼロとなる、という事だ。

185
00:06:22,300 --> 00:06:23,790
そして証明出来る事として、

186
00:06:24,190 --> 00:06:25,250
ここでその証明をして見るつもりは無いが、

187
00:06:25,480 --> 00:06:26,380
ある所与の値kに対し、

188
00:06:26,620 --> 00:06:27,880
ここにある値は、

189
00:06:27,980 --> 00:06:29,920
もっとシンプルに計算出来る、

190
00:06:30,590 --> 00:06:37,820
という事が、知られている。

191
00:06:38,800 --> 00:06:40,310
そしてその値は、

192
00:06:41,000 --> 00:06:42,900
1引くことの i=1からkまでの

193
00:06:43,130 --> 00:06:44,400
和をとる事のsii、

194
00:06:44,610 --> 00:06:47,960
割ることの

195
00:06:48,640 --> 00:06:50,050
和を取る事のi=1からnまでの

196
00:06:50,170 --> 00:06:52,010
sii。

197
00:06:53,360 --> 00:06:54,820
これを言葉で説明すると、

198
00:06:55,000 --> 00:06:56,170
あるいはこれを説明する為に

199
00:06:56,450 --> 00:06:57,330
別の見方で見てみると、

200
00:06:57,960 --> 00:06:59,370
例えばk=3だとすると、

201
00:07:00,810 --> 00:07:01,970
分子を計算する為に

202
00:07:02,080 --> 00:07:03,200
我らがやる事は、

203
00:07:03,340 --> 00:07:04,680
和を取る事のi=1から3までの

204
00:07:04,820 --> 00:07:05,830
siiを計算する、

205
00:07:06,240 --> 00:07:08,170
つまり、単にこの最初の三つの要素の和を計算する。

206
00:07:09,280 --> 00:07:09,710
これが分子となる。

207
00:07:10,980 --> 00:07:12,880
そして分母は、

208
00:07:13,090 --> 00:07:14,970
この対角成分全ての和だ。

209
00:07:16,210 --> 00:07:17,470
そして1から引くことのその比、

210
00:07:17,660 --> 00:07:19,080
それがここの量を

211
00:07:19,300 --> 00:07:21,330
与えるのだ。

212
00:07:21,650 --> 00:07:23,440
この青で丸く囲んだこれ。

213
00:07:23,650 --> 00:07:24,380
そこで我らは、

214
00:07:24,650 --> 00:07:26,000
たんにこれが0.01以上かどうかを

215
00:07:26,430 --> 00:07:29,330
テストする事が出来る。

216
00:07:29,370 --> 00:07:30,460
または同じ事だが、

217
00:07:30,830 --> 00:07:31,960
i=1からkまでのsiiの和を

218
00:07:32,180 --> 00:07:33,010
割ることの i=1からnまでのsiiの和

219
00:07:33,970 --> 00:07:35,180
これが0.99以上かどうかを

220
00:07:35,320 --> 00:07:37,090
テストしても

221
00:07:37,650 --> 00:07:38,580
構わない。

222
00:07:38,770 --> 00:07:40,600
もしあなたが分散の99%を

223
00:07:40,720 --> 00:07:42,920
保持したいと思うのなら。

224
00:07:44,770 --> 00:07:45,650
そこであなたが出来る事としては、

225
00:07:45,940 --> 00:07:48,360
単純にちょっとずつkを増加させていって、

226
00:07:48,770 --> 00:07:49,820
k=1をセットし、k=2をセットし、

227
00:07:50,100 --> 00:07:51,290
k=3をセットし、、、と続けていって、

228
00:07:52,140 --> 00:07:53,240
そしてこの量をテストしていって、

229
00:07:54,720 --> 00:07:56,120
99%の分散を保持する事を保証する中で、

230
00:07:56,350 --> 00:07:58,820
最小となるkの値を見てみる。

231
00:08:00,600 --> 00:08:01,810
もしこれをやれば、

232
00:08:02,000 --> 00:08:02,790
svd関数はたったの一回

233
00:08:03,170 --> 00:08:04,660
呼ぶだけで良い。

234
00:08:04,970 --> 00:08:05,830
何故ならそれでS行列が得られるから。

235
00:08:06,010 --> 00:08:07,060
ひとたびS行列を

236
00:08:07,090 --> 00:08:08,350
得てしまえば、

237
00:08:08,490 --> 00:08:09,540
あなたはこの計算を

238
00:08:09,770 --> 00:08:11,370
分子のkの値を増やしていくだけで

239
00:08:11,930 --> 00:08:12,910
計算していく事が出来て、

240
00:08:13,070 --> 00:08:14,450
だからsvdを

241
00:08:14,560 --> 00:08:16,290
異なる値のkを試す都度何度も何度も

242
00:08:16,540 --> 00:08:18,620
呼びつづける必要は無い。

243
00:08:18,910 --> 00:08:20,030
つまりこの手続きは、

244
00:08:20,150 --> 00:08:21,700
もっとずっと効率的だ。

245
00:08:21,910 --> 00:08:24,020
そしてこの方法により、

246
00:08:24,090 --> 00:08:25,890
PCAを最初から、何度も何度も

247
00:08:26,260 --> 00:08:27,620
走らせる必要無く、

248
00:08:28,030 --> 00:08:30,650
kの値を選ぶ事が出来る。単にsvdを一回走らせるだけで、

249
00:08:30,850 --> 00:08:32,350
これらの対角成分の値を与えてくれる、

250
00:08:32,780 --> 00:08:35,090
これらの値全て、s11、s22とsnnまでの値全て。

251
00:08:35,780 --> 00:08:36,820
そしてそこで、単に

252
00:08:36,920 --> 00:08:38,440
この式の

253
00:08:38,730 --> 00:08:40,740
kを変えていくだけで、

254
00:08:41,010 --> 00:08:42,250
99%の分散が保持される最小のkを

255
00:08:43,140 --> 00:08:44,030
見つける事が出来る。

256
00:08:44,850 --> 00:08:45,870
ではまとめよう。

257
00:08:46,050 --> 00:08:47,850
PCAを圧縮の目的で

258
00:08:47,970 --> 00:08:49,050
使う時に、

259
00:08:49,420 --> 00:08:50,790
私がkを選ぶ為に良くやるのは、

260
00:08:51,120 --> 00:08:52,590
svdを共分散行列に対して

261
00:08:52,950 --> 00:08:54,480
一回実行して、

262
00:08:54,540 --> 00:08:55,750
そしてこの式を使って、

263
00:08:56,030 --> 00:08:57,930
この式を満たす最小のkを

264
00:08:58,020 --> 00:09:00,390
選び出す。

265
00:09:01,580 --> 00:09:02,560
ところで、

266
00:09:02,650 --> 00:09:03,850
たとえあなたが違うkの値を選んだとしても、

267
00:09:04,180 --> 00:09:04,960
たとえあなたがkの値を

268
00:09:05,000 --> 00:09:05,920
手動で選んで、

269
00:09:06,090 --> 00:09:07,250
例えば1000次元のデータに対して

270
00:09:07,300 --> 00:09:08,620
k=100を

271
00:09:09,540 --> 00:09:11,590
選びたい、としよう。

272
00:09:12,430 --> 00:09:13,450
その場合でも、あなたがやった事を

273
00:09:13,690 --> 00:09:14,760
他の人に説明したいと思ったら、

274
00:09:15,230 --> 00:09:17,070
あなたのPCAの実装のパフォーマンスを

275
00:09:17,750 --> 00:09:18,910
他の人に伝える良い方法としては、

276
00:09:19,220 --> 00:09:20,300
実際にこの量を

277
00:09:20,540 --> 00:09:21,670
計算してみる事だ。

278
00:09:21,890 --> 00:09:23,000
この値はあなたに、

279
00:09:23,110 --> 00:09:25,770
分散の何％が保持されているかを教えてくれる。

280
00:09:26,300 --> 00:09:28,070
そしてあなたがこの数字を報告すれば、

281
00:09:28,340 --> 00:09:29,720
PCAに慣れている人たちなら、

282
00:09:30,100 --> 00:09:31,610
そういう人たちなら

283
00:09:31,880 --> 00:09:33,020
これを用いる事で、

284
00:09:33,080 --> 00:09:34,560
あなたの100次元の表現が、

285
00:09:34,900 --> 00:09:37,340
元のデータセットをどれくらい良く近似出来ているかを

286
00:09:37,690 --> 00:09:39,270
良く理解する事が出来る。

287
00:09:39,580 --> 00:09:41,300
何故なら99%の分散が保持されているのだから、

288
00:09:41,990 --> 00:09:44,140
それは実際にあなたの

289
00:09:44,360 --> 00:09:45,860
施工誤差の二乗を測る指標だ。

290
00:09:46,240 --> 00:09:47,870
その比が0.01というなら、

291
00:09:48,430 --> 00:09:49,940
人々にあなたのPCAの実装が

292
00:09:50,430 --> 00:09:51,820
オリジナルのデータセットの良い近似を

293
00:09:52,580 --> 00:09:53,840
発見したかについての

294
00:09:54,000 --> 00:09:56,530
良い理解を与える。

295
00:09:58,440 --> 00:09:59,600
以上で、数字のkを選ぶ

296
00:09:59,800 --> 00:10:01,260
効率的な手続きを

297
00:10:01,850 --> 00:10:02,800
提供出来ただろうか。このkを選ぶ事で、

298
00:10:03,260 --> 00:10:04,940
データを何次元まで削減するかを

299
00:10:05,160 --> 00:10:06,630
選ぶ事になる。

300
00:10:06,750 --> 00:10:07,830
そしてもしあなたがPCAを

301
00:10:07,970 --> 00:10:09,740
とても高い次元のデータセットに適用するなら、

302
00:10:09,990 --> 00:10:11,570
1000次元のデータとか、

303
00:10:11,980 --> 00:10:13,340
とてもよく、データセットが

304
00:10:13,530 --> 00:10:14,720
高い相関を持つフィーチャーを含むので、

305
00:10:15,070 --> 00:10:16,140
これは単に、多くのデータにおいて

306
00:10:16,280 --> 00:10:17,190
あなたが目にする事になる性質なので、

307
00:10:18,440 --> 00:10:19,420
あなたは良く、PCAが

308
00:10:20,040 --> 00:10:21,610
分散の99%を保持していながら、とか、

309
00:10:21,840 --> 00:10:22,940
あるいは95とか99とか、

310
00:10:23,110 --> 00:10:24,440
とにかく高い割合の分散を

311
00:10:24,720 --> 00:10:25,910
保持していながら、

312
00:10:26,360 --> 00:10:27,580
とても多くの割合のデータを

313
00:10:28,560 --> 00:10:29,720
圧縮する事が出来る、という状況を目にする事になるだろう。