1
00:00:00,120 --> 00:00:01,020
前の幾つかのビデオで、

2
00:00:01,690 --> 00:00:03,300
圧縮アルゴリズムとしてのPCAについて

3
00:00:03,410 --> 00:00:05,270
言及した、そこでは

4
00:00:05,330 --> 00:00:06,760
例えば1000次元のデータがあって、

5
00:00:07,270 --> 00:00:08,760
それを100次元のフィーチャーベクトルに

6
00:00:09,100 --> 00:00:10,850
圧縮する、とか、

7
00:00:11,010 --> 00:00:12,360
あるいは3次元のデータがあって、

8
00:00:12,810 --> 00:00:14,980
それを二次元の表現に圧縮する、とかだった。

9
00:00:16,360 --> 00:00:17,430
では、これが圧縮の

10
00:00:17,620 --> 00:00:19,040
アルゴリズムだというのなら、

11
00:00:19,360 --> 00:00:20,440
この圧縮した表現から、

12
00:00:20,660 --> 00:00:22,930
元の高次元のデータを近似した値に

13
00:00:23,030 --> 00:00:25,560
戻す方法があるべきだろう。

14
00:00:26,340 --> 00:00:28,070
つまり、あるz(i)が与えられたとして、

15
00:00:28,780 --> 00:00:30,250
これは100次元だったとして、

16
00:00:30,320 --> 00:00:31,710
そこからどうやって元の表現x(i)、これは1000次元とかだが、

17
00:00:32,050 --> 00:00:34,720
そのx(i)に戻したらいいだろうか？

18
00:00:35,760 --> 00:00:36,820
このビデオでは、

19
00:00:36,930 --> 00:00:40,350
そのやり方を説明する。

20
00:00:40,500 --> 00:00:43,620
PCAアルゴリズムでは、こんな感じの手本を持っている。

21
00:00:43,940 --> 00:00:45,670
これが手本x1で、

22
00:00:45,910 --> 00:00:47,810
これが手本x2。

23
00:00:48,110 --> 00:00:49,340
そして我らがやるのは、

24
00:00:49,570 --> 00:00:51,010
これらの手本に対して、

25
00:00:51,120 --> 00:00:54,160
これを一次元平面の上に射影する。

26
00:00:55,150 --> 00:00:56,280
すると、1次元平面に

27
00:00:56,450 --> 00:00:57,750
射影した後なら、

28
00:00:58,350 --> 00:01:00,500
これらの点を示すのに

29
00:01:00,600 --> 00:01:01,950
一つの実数、これをz1と呼ぼう、

30
00:01:02,300 --> 00:01:04,640
このz1だけで示す事が出来る。

31
00:01:04,890 --> 00:01:06,930
このような点が与えられた時、

32
00:01:07,730 --> 00:01:08,730
z1の点が与えられた時、

33
00:01:08,980 --> 00:01:10,840
オリジナルの二次元空間に、

34
00:01:11,000 --> 00:01:12,580
どうやったら戻せるだろうか？

35
00:01:13,290 --> 00:01:15,380
具体的に書くと、

36
00:01:15,510 --> 00:01:16,510
ある点zが与えられた時に、このzはRだが、

37
00:01:16,660 --> 00:01:17,840
これからなんであれ

38
00:01:18,160 --> 00:01:19,660
オリジナルの値の、

39
00:01:20,440 --> 00:01:22,060
何からの近似的なR2の表現xを

40
00:01:22,370 --> 00:01:24,970
取り戻す事が出来るだろうか？

41
00:01:26,520 --> 00:01:28,090
さて、zはイコールの、

42
00:01:28,400 --> 00:01:29,570
U reduceの転置 xだが、

43
00:01:29,680 --> 00:01:30,640
これの逆方向に行きたければ、

44
00:01:30,930 --> 00:01:33,620
その方程式は、

45
00:01:33,780 --> 00:01:35,150
x approx イコールの、

46
00:01:35,290 --> 00:01:38,220
U reduce 掛ける zと

47
00:01:40,470 --> 00:01:43,570
なる。

48
00:01:44,020 --> 00:01:44,880
ここで次元をチェックしておこう。

49
00:01:45,950 --> 00:01:47,760
ここでU reduceは

50
00:01:47,970 --> 00:01:48,990
n掛けるk 次元の

51
00:01:49,680 --> 00:01:51,260
ベクトルで、

52
00:01:51,370 --> 00:01:53,270
zは k掛ける1 次元のベクトル。

53
00:01:54,030 --> 00:01:56,280
だからこれらを掛けあわせれば、その結果は n掛ける1 となるだろう。

54
00:01:56,720 --> 00:01:58,270
つまり x approxは

55
00:01:58,450 --> 00:01:59,990
n次元ベクトルとなる。

56
00:02:00,310 --> 00:02:01,320
そして、PCAが意図する事は、

57
00:02:01,390 --> 00:02:03,320
二乗射影誤差が

58
00:02:03,620 --> 00:02:04,510
大きくなり過ぎない、という事だから、

59
00:02:04,730 --> 00:02:06,050
このx approxは

60
00:02:06,500 --> 00:02:08,640
なんであれオリジナルのxの値に

61
00:02:08,960 --> 00:02:10,090
このxがzを最初に導出するのに使った物だが、

62
00:02:10,270 --> 00:02:13,140
そのxに近い値となる。

63
00:02:14,080 --> 00:02:16,630
これがどんな感じなのかを絵で示そう。こんな感じだ。

64
00:02:16,870 --> 00:02:17,820
この手続きで取り戻せるのは、

65
00:02:17,970 --> 00:02:19,640
この緑の直線の上に乗ってる

66
00:02:19,920 --> 00:02:22,860
点だ。

67
00:02:23,500 --> 00:02:24,580
前の例を用いると、

68
00:02:24,920 --> 00:02:26,400
この値x1から

69
00:02:26,610 --> 00:02:28,570
始めたとして、

70
00:02:28,850 --> 00:02:29,690
このz1を得る。

71
00:02:30,310 --> 00:02:32,760
このz1をこの公式に代入して、

72
00:02:33,440 --> 00:02:35,510
x1 approxを得る。

73
00:02:35,730 --> 00:02:37,040
それはこの、ここの点。

74
00:02:37,590 --> 00:02:40,110
これがx1 approx。

75
00:02:40,260 --> 00:02:41,990
これはR2だ。

76
00:02:42,780 --> 00:02:44,060
同様に、

77
00:02:44,180 --> 00:02:45,640
同じ手続きを繰り返すと、

78
00:02:45,760 --> 00:02:47,840
これがx2 approxとなる。

79
00:02:49,640 --> 00:02:50,630
そしてこれは、元のデータの

80
00:02:50,780 --> 00:02:53,160
かなりまともな近似なのが分かるだろう。

81
00:02:53,670 --> 00:02:54,870
以上が、

82
00:02:55,060 --> 00:02:56,190
低い次元の表現zから

83
00:02:56,630 --> 00:02:58,350
圧縮されてない表現のデータを

84
00:02:58,700 --> 00:03:00,720
取り戻す方法だ。

85
00:03:00,760 --> 00:03:01,990
我らはオリジナルのデータxを

86
00:03:02,240 --> 00:03:03,480
近似した物を取り戻す。

87
00:03:03,690 --> 00:03:05,400
このプロセスの事をまた、

88
00:03:05,500 --> 00:03:07,210
オリジナルデータの再構築とも

89
00:03:08,220 --> 00:03:08,900
呼ぶ。

90
00:03:09,530 --> 00:03:10,950
圧縮した表現から元の値xを

91
00:03:11,310 --> 00:03:13,630
再構築しようとしている、と考える時にはこう呼ぶ。

92
00:03:16,770 --> 00:03:18,370
ラベルづけされてないデータセットがあった時に、

93
00:03:18,610 --> 00:03:19,850
PCAをどうやって適用し、

94
00:03:19,990 --> 00:03:21,710
高次元のフィーチャーxを

95
00:03:21,970 --> 00:03:23,800
より低い次元の表現zに

96
00:03:24,130 --> 00:03:25,440
マップするか、

97
00:03:25,560 --> 00:03:27,200
分かっただろう。

98
00:03:27,400 --> 00:03:28,630
そしてこのビデオから、

99
00:03:28,910 --> 00:03:29,670
これらの低次元の表現zから

100
00:03:30,260 --> 00:03:31,690
オリジナルの高次元のデータを近似した物を

101
00:03:31,860 --> 00:03:32,810
取り戻す方法も

102
00:03:33,700 --> 00:03:35,780
分かっただろう。

103
00:03:37,300 --> 00:03:38,180
いまやあなたは、PCAを

104
00:03:38,460 --> 00:03:40,280
どうやって実装し適用したらいいかを知った訳だ。

105
00:03:40,470 --> 00:03:41,290
そこで我らが次にやろうと思うのは、

106
00:03:41,390 --> 00:03:42,250
PCAを実践で

107
00:03:42,290 --> 00:03:43,460
上手に使っていく方法の

108
00:03:43,990 --> 00:03:45,240
メカニクスについてちょっと話をしたい。

109
00:03:45,530 --> 00:03:46,670
具体的には、次のビデオでは

110
00:03:46,890 --> 00:03:47,610
kをどうやって

111
00:03:48,090 --> 00:03:49,730
選ぶかについて話していきたい。

112
00:03:49,910 --> 00:03:51,140
それはつまり、この圧縮された表現のベクトルzの次元を

113
00:03:51,560 --> 00:03:53,570
どうやって選ぶか、という事だ。