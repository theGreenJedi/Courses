1
00:00:00,090 --> 00:00:01,330
このビデオでは、

2
00:00:01,500 --> 00:00:02,560
二番目の種類の

3
00:00:03,030 --> 00:00:04,620
教師なし学習の問題である、

4
00:00:04,950 --> 00:00:06,320
次元削減について始めたいと思う。

5
00:00:07,600 --> 00:00:08,460
次元を削減したい、と思う

6
00:00:08,660 --> 00:00:09,710
幾つかの異なる理由が

7
00:00:09,890 --> 00:00:11,270
存在する。

8
00:00:12,220 --> 00:00:14,420
一つはデータを圧縮したい時、

9
00:00:14,600 --> 00:00:15,860
そして後で見るように、2, 3後のビデオで見るように、

10
00:00:16,570 --> 00:00:18,200
データ圧縮はデータを圧縮して

11
00:00:18,490 --> 00:00:19,660
より少ない

12
00:00:19,970 --> 00:00:20,940
メモリやディスク容量を

13
00:00:21,330 --> 00:00:22,670
占有するように

14
00:00:23,050 --> 00:00:24,410
なるだけでなく、

15
00:00:24,730 --> 00:00:26,960
また学習アルゴリズムのスピードアップにもなる。

16
00:00:27,980 --> 00:00:29,490
だがまずは、次元削減とは何かを

17
00:00:29,620 --> 00:00:31,840
話す事から始めよう。

18
00:00:33,490 --> 00:00:35,800
動機を理解する例として、

19
00:00:35,990 --> 00:00:37,440
たくさん、たくさん、たーくさんのフィーチャーの

20
00:00:37,680 --> 00:00:38,700
データセットを集めたとしよう。

21
00:00:39,290 --> 00:00:40,600
そしてそれらのうちの二つだけをここにプロットした。

22
00:00:41,600 --> 00:00:42,770
そして例えばそれら二つのフィーチャーは

23
00:00:42,890 --> 00:00:44,000
実際は何かの

24
00:00:44,070 --> 00:00:45,730
センチメートルによる長さと、

25
00:00:45,860 --> 00:00:47,150
それとは別のフィーチャーx2は

26
00:00:47,550 --> 00:00:48,920
インチによる長さだと

27
00:00:49,460 --> 00:00:51,150
しよう。

28
00:00:52,250 --> 00:00:53,030
つまりこれは、極めて冗長な

29
00:00:53,500 --> 00:00:55,910
表現となっていて、

30
00:00:56,170 --> 00:00:57,920
x1とx2の別々のフィーチャーを

31
00:00:58,430 --> 00:00:58,820
保持し続けるよりは、

32
00:00:59,090 --> 00:01:00,240
それら両方が基本的には同じ長さを測っているのだから、

33
00:01:00,370 --> 00:01:01,490
我らはデータを削減して

34
00:01:01,640 --> 00:01:03,340
一次元にしたい、と

35
00:01:03,430 --> 00:01:06,800
思うだろう。

36
00:01:06,920 --> 00:01:08,840
そしてこの長さを測る数字一つだけを保持すれば良い。

37
00:01:09,620 --> 00:01:11,080
この例はちょっとうさんくさいように

38
00:01:11,150 --> 00:01:13,920
思うかもしれない。でも実の所、

39
00:01:14,030 --> 00:01:15,850
このセンチメーターとインチの例は、そんなに非現実的でも無い。

40
00:01:16,220 --> 00:01:17,140
そして私が実際に産業界で見た物と

41
00:01:17,510 --> 00:01:18,870
そんなに違いもしない。

42
00:01:19,970 --> 00:01:21,320
もし何百、何千もの

43
00:01:21,790 --> 00:01:23,160
フィーチャーがあるのなら、

44
00:01:23,240 --> 00:01:24,450
すぐに、簡単に何のフィーチャーを

45
00:01:24,680 --> 00:01:26,580
持っていたのか、トラック出来なくなるものだ。

46
00:01:26,930 --> 00:01:28,190
そして時には、

47
00:01:28,420 --> 00:01:29,650
別々のエンジニアのチームが、

48
00:01:30,110 --> 00:01:31,090
例えばあるエンジニアのチームが200の

49
00:01:31,200 --> 00:01:32,500
フィーチャーをあなたに与え、

50
00:01:32,770 --> 00:01:34,000
二番目のエンジニアチームがまた別の

51
00:01:34,340 --> 00:01:35,420
300フィーチャーを与え、

52
00:01:35,550 --> 00:01:36,640
そして三番目のエンジニアチームが500フィーチャーを

53
00:01:36,940 --> 00:01:38,150
あなたに提供したとする。

54
00:01:38,290 --> 00:01:39,220
すると全部で1000フィーチャーとなる訳だが、

55
00:01:39,940 --> 00:01:40,910
それは実際にどのフィーチャーが

56
00:01:41,040 --> 00:01:42,820
どこのチームから来た物かなどを

57
00:01:43,200 --> 00:01:44,540
正確にトラックするのは難しくなる。

58
00:01:44,860 --> 00:01:47,310
しかも現実には、こんなに冗長なフィーチャーを保持したくは無い。

59
00:01:47,530 --> 00:01:49,440
だからもしセンチメーターの

60
00:01:50,090 --> 00:01:51,520
長さが近傍のセンチメーターに

61
00:01:51,940 --> 00:01:53,920
丸めてしまって、

62
00:01:54,060 --> 00:01:56,480
インチの長さは近傍のインチに丸めてしまえば、

63
00:01:57,070 --> 00:01:58,050
それが理由でこの手本は

64
00:01:58,720 --> 00:01:59,900
直線に完全には乗らない事になる、

65
00:02:00,100 --> 00:02:01,270
何故なら、近傍のセンチメーターなり近傍のインチなりへの

66
00:02:01,740 --> 00:02:03,420
丸め誤差の為に。

67
00:02:04,260 --> 00:02:05,160
もしデータを2次元の代わりに

68
00:02:05,610 --> 00:02:06,680
1次元に削減出来たら、

69
00:02:07,130 --> 00:02:10,320
冗長性も削減出来る。

70
00:02:11,590 --> 00:02:14,030
別の例としては、これもまた嘘っぽいかもしれないが、

71
00:02:14,590 --> 00:02:16,560
自律的なヘリコプターパイロットと

72
00:02:16,920 --> 00:02:19,920
何年も仕事をしてきた。

73
00:02:20,990 --> 00:02:22,610
言い換えると私はヘリコプターを飛ばすパイロットと仕事をしてきた。

74
00:02:23,950 --> 00:02:24,040
そして、だ。

75
00:02:25,080 --> 00:02:28,090
もし仮に、、、

76
00:02:28,250 --> 00:02:29,100
もし仮に調査なり試験なりを

77
00:02:29,590 --> 00:02:30,500
これらの別々のパイロットに実施したとして、

78
00:02:30,770 --> 00:02:32,200
そこでは一つのフィーチャーx1として

79
00:02:32,440 --> 00:02:33,780
例えばこれらのヘリコプターパイロットの

80
00:02:34,050 --> 00:02:35,600
スキルだとして、

81
00:02:35,820 --> 00:02:38,190
そしてx2は例えば

82
00:02:38,460 --> 00:02:41,810
パイロットの楽しみ度合いだとする。

83
00:02:42,700 --> 00:02:43,770
つまり、彼らが

84
00:02:43,870 --> 00:02:45,050
どれだけ飛行を楽しんだのか、だ。

85
00:02:45,280 --> 00:02:46,810
これら二つのフィーチャーは高く相関しているだろう。

86
00:02:48,310 --> 00:02:49,730
そして本当に気になっているのは、

87
00:02:49,940 --> 00:02:52,530
この種の、この種の、

88
00:02:53,610 --> 00:02:55,120
この方向、本当にパイロットの適性を測っている、

89
00:02:55,370 --> 00:02:57,190
別のフィーチャーかもしれない。

90
00:03:00,450 --> 00:03:01,240
私は適性、という名前を

91
00:03:01,590 --> 00:03:03,220
創り上げた。だがふたたび、

92
00:03:03,320 --> 00:03:04,780
もし高く相関したフィーチャーがあれば、

93
00:03:04,990 --> 00:03:06,500
実際に次元を削減したくなるだろう。

94
00:03:07,570 --> 00:03:08,760
だから、もうちょっと詳しく、

95
00:03:09,040 --> 00:03:09,950
データの次元を

96
00:03:10,060 --> 00:03:11,390
2次元から、2Dから

97
00:03:11,520 --> 00:03:12,950
1次元、1Dへと

98
00:03:13,150 --> 00:03:14,400
削減する、という事が

99
00:03:14,600 --> 00:03:16,300
本当は何を意味しているかを説明しよう。

100
00:03:16,840 --> 00:03:18,660
これらの手本を

101
00:03:18,830 --> 00:03:19,940
別々の色で、

102
00:03:21,600 --> 00:03:21,600
色付けしよう。

103
00:03:21,730 --> 00:03:22,890
そしてこのケースでは、

104
00:03:23,370 --> 00:03:24,740
次元を削減する、という時に

105
00:03:25,010 --> 00:03:26,320
意味している事は、

106
00:03:26,540 --> 00:03:28,400
例えばこの直線を探して、

107
00:03:28,660 --> 00:03:30,560
もっとも多くのデータが載るような

108
00:03:30,710 --> 00:03:31,700
直線の方向を探して、

109
00:03:31,910 --> 00:03:33,150
そこに全てのデータを

110
00:03:33,380 --> 00:03:34,740
射影する、

111
00:03:34,910 --> 00:03:36,230
そうする事で、

112
00:03:36,510 --> 00:03:37,430
この直線上の

113
00:03:37,970 --> 00:03:39,420
各手本の位置を

114
00:03:39,580 --> 00:03:41,480
測る事が出来る。

115
00:03:42,010 --> 00:03:42,820
そして新しい一つのフィーチャーz1という考えに行き着く。

116
00:03:43,100 --> 00:03:45,080
直線上の位置を

117
00:03:46,830 --> 00:03:48,200
示すのに

118
00:03:48,730 --> 00:03:49,530
一つの数だけしか

119
00:03:49,890 --> 00:03:50,940
必要としなくなったので、

120
00:03:51,200 --> 00:03:51,980
つまりz1はこれらの点の

121
00:03:52,750 --> 00:03:54,630
この緑の直線上の位置を

122
00:03:54,830 --> 00:03:57,610
示す、新しいフィーチャーなのだ。

123
00:03:58,060 --> 00:03:59,300
これの意味する所は、

124
00:03:59,400 --> 00:04:00,680
前と同じに手本x1が

125
00:04:00,930 --> 00:04:02,540
あったとすると、

126
00:04:03,430 --> 00:04:04,740
例えばこれは最初の手本x1だとする。

127
00:04:05,040 --> 00:04:06,480
そして、x1を表す為には

128
00:04:06,820 --> 00:04:08,550
もともとのx1には

129
00:04:09,620 --> 00:04:10,760
二次元の数が必要だった、

130
00:04:11,570 --> 00:04:12,800
または二次元のフィーチャーベクトルが必要だった。

131
00:04:13,700 --> 00:04:14,920
その代わりにここでは、z1で表す事が出来る。

132
00:04:18,120 --> 00:04:20,330
私は最初の手本を

133
00:04:20,520 --> 00:04:22,170
表すのに、z1だけで表す事が出来る、

134
00:04:23,270 --> 00:04:25,380
ここでz1は実数。

135
00:04:25,940 --> 00:04:29,260
同様にx2は、x2をここの

136
00:04:29,590 --> 00:04:31,400
二番目の手本とすると、

137
00:04:32,690 --> 00:04:35,110
以前はこれを表すのに

138
00:04:35,830 --> 00:04:37,520
二つの数が必要だったが、

139
00:04:37,720 --> 00:04:39,930
もし代わりに直線上の黒い線に

140
00:04:40,930 --> 00:04:42,730
射影した物を

141
00:04:43,130 --> 00:04:44,250
計算すれば、

142
00:04:44,700 --> 00:04:45,980
そうすれば今や、私は

143
00:04:46,210 --> 00:04:47,350
このz2の線上の位置を

144
00:04:47,550 --> 00:04:49,580
示すには、

145
00:04:49,620 --> 00:04:51,230
たった一つの実数しか

146
00:04:51,790 --> 00:04:53,070
必要としない。

147
00:04:54,300 --> 00:04:56,730
などなどという事が、m個の手本を通して言える。

148
00:04:57,790 --> 00:04:59,560
さて、まとめよう。

149
00:04:59,810 --> 00:05:01,310
もし元のデータセットを、

150
00:05:02,340 --> 00:05:03,800
全ての手本を緑の直線に

151
00:05:04,000 --> 00:05:05,270
射影する、という近似を

152
00:05:05,590 --> 00:05:07,690
許容するなら、

153
00:05:07,880 --> 00:05:10,260
その時は一つの

154
00:05:10,360 --> 00:05:12,090
数しか必要としない、

155
00:05:12,170 --> 00:05:13,700
直線の上の点の場所を

156
00:05:13,820 --> 00:05:15,270
示すのに、

157
00:05:15,370 --> 00:05:16,710
たった一つの実数しか必要としない。

158
00:05:17,080 --> 00:05:18,220
つまり、ただ一つの

159
00:05:18,300 --> 00:05:19,730
数を使って、各手本の位置を

160
00:05:20,070 --> 00:05:21,850
表す事が出来る、

161
00:05:21,930 --> 00:05:23,170
各手本を、緑の直線に

162
00:05:23,280 --> 00:05:26,520
射影した後では。

163
00:05:27,570 --> 00:05:29,060
つまりこれは、元のトレーニングセットを

164
00:05:29,210 --> 00:05:30,300
近似した物となっている、

165
00:05:30,570 --> 00:05:32,770
何故ならトレーニング手本を直線に射影しているから。

166
00:05:33,630 --> 00:05:34,790
だが、

167
00:05:35,130 --> 00:05:36,140
いまや私は各手本に対して

168
00:05:36,530 --> 00:05:39,800
たった一つの数を保持するだけで良くなっている。

169
00:05:41,220 --> 00:05:42,960
だからこれは必要なメモリ量、または必要なスペース、

170
00:05:43,340 --> 00:05:44,640
またはデータを保存する方法がなんであれ、

171
00:05:45,090 --> 00:05:47,760
それを半減させる。

172
00:05:49,100 --> 00:05:50,530
そしてもっと興味深い事には、

173
00:05:50,700 --> 00:05:51,940
もっと重要な事としては、後で観る事になるが、

174
00:05:52,200 --> 00:05:53,520
あとのビデオで、

175
00:05:53,780 --> 00:05:55,730
それは、これが

176
00:05:55,930 --> 00:05:56,940
我らの学習アルゴリズムを

177
00:05:57,200 --> 00:05:59,170
もっと早く走らせてくれる、という事だ。

178
00:05:59,480 --> 00:06:00,600
そしてそれは実際、たぶん、

179
00:06:00,920 --> 00:06:02,060
データを保持するディスクスペース要件や

180
00:06:02,140 --> 00:06:03,800
メモリ要件を減らす、という事よりも、

181
00:06:04,580 --> 00:06:06,220
より興味深いデータ圧縮の

182
00:06:06,680 --> 00:06:08,620
適用例と言えるだろう。

183
00:06:10,250 --> 00:06:11,490
前のスライドでは、

184
00:06:11,580 --> 00:06:13,140
データを2Dから1Dへと削減する

185
00:06:13,620 --> 00:06:15,060
例を見た。

186
00:06:15,210 --> 00:06:16,290
このスライドでは、

187
00:06:16,660 --> 00:06:18,010
別のデータ削減の例である、

188
00:06:18,450 --> 00:06:21,080
3次元の3Dから二次元の2Dへの削減をお見せする。

189
00:06:22,590 --> 00:06:23,360
ところで、より典型的な

190
00:06:23,750 --> 00:06:25,570
次元削減の例としては、

191
00:06:26,390 --> 00:06:27,790
1000次元、つまり1000Dとかの

192
00:06:28,230 --> 00:06:30,330
データとかもあり、

193
00:06:30,720 --> 00:06:31,880
それを例えば

194
00:06:32,150 --> 00:06:34,080
100次元または100Dに削減したい、とかいう事がある。

195
00:06:34,110 --> 00:06:35,590
だがスライドにプロット可能な限界という

196
00:06:35,700 --> 00:06:37,760
制限の為に、

197
00:06:38,460 --> 00:06:41,520
3Dから2Dと、2Dから1Dの例を使っていく。

198
00:06:43,160 --> 00:06:45,830
さて、ここに見せたようなデータセットがあるとする。

199
00:06:46,050 --> 00:06:47,420
つまり、手本の集合x(i)があり、

200
00:06:48,110 --> 00:06:49,430
それはR 3の点の集まりだ。

201
00:06:49,800 --> 00:06:51,790
つまり、三次元の手本がある。

202
00:06:52,740 --> 00:06:53,300
これはスライド上では

203
00:06:53,690 --> 00:06:54,610
見づらいとは思うが、

204
00:06:54,920 --> 00:06:55,980
3次元プロットの雲を

205
00:06:56,310 --> 00:06:58,190
一応見せておく。

206
00:06:59,050 --> 00:07:00,280
ちょっと見づらいけど、

207
00:07:00,380 --> 00:07:01,970
このデータはだいたい全部

208
00:07:02,230 --> 00:07:04,020
平面に乗っている。

209
00:07:04,130 --> 00:07:05,700
こんな感じ。

210
00:07:07,110 --> 00:07:08,130
そこで次元削減で

211
00:07:08,380 --> 00:07:09,970
やる事としては、

212
00:07:10,210 --> 00:07:11,960
このデータを全部持ってきて

213
00:07:12,110 --> 00:07:13,800
二次元平面に

214
00:07:14,630 --> 00:07:15,350
射影する事。

215
00:07:15,700 --> 00:07:16,670
ここで私がやった事は、

216
00:07:16,730 --> 00:07:18,060
データを全部持ってきて、

217
00:07:18,300 --> 00:07:19,250
全てのデータを平面上に乗るように

218
00:07:19,770 --> 00:07:21,390
射影した、という事。

219
00:07:22,590 --> 00:07:23,910
さて、最終的に、

220
00:07:24,040 --> 00:07:25,580
平面上の位置を示す為に、

221
00:07:25,750 --> 00:07:27,810
二つの数字が必要だ。でしょ？

222
00:07:28,000 --> 00:07:29,150
この軸に沿った点の位置を、

223
00:07:29,290 --> 00:07:30,660
示す必要があり、

224
00:07:30,970 --> 00:07:32,370
そしてまたこの軸に沿った

225
00:07:32,650 --> 00:07:35,090
場所も示す必要がある。

226
00:07:35,730 --> 00:07:37,470
つまり我らは二つの数字が要る。

227
00:07:37,850 --> 00:07:39,900
z1とz2と呼ぼうか。

228
00:07:40,600 --> 00:07:42,450
平面上の点の場所を示す為に。

229
00:07:43,290 --> 00:07:44,730
つまりそれの意味する所は、

230
00:07:44,890 --> 00:07:45,910
今や我らは各手本を

231
00:07:46,690 --> 00:07:48,310
各トレーニング手本を、

232
00:07:48,740 --> 00:07:50,310
ここに書いた二つの数

233
00:07:50,630 --> 00:07:52,950
z1とz2で、表す事が出来る。

234
00:07:53,990 --> 00:07:55,890
つまり我らはデータを、R 2のベクトルzを用いて

235
00:07:56,610 --> 00:07:59,130
表す事が出来る、という事だ。

236
00:08:00,580 --> 00:08:02,110
そしてこれらの下付き添字、z下付き添字1、

237
00:08:02,350 --> 00:08:03,990
z下付き添字2は、

238
00:08:04,560 --> 00:08:05,440
それが意味するのは、

239
00:08:05,500 --> 00:08:07,520
このベクトルzは、

240
00:08:07,750 --> 00:08:09,680
二次元のベクトルz1とz2だ、という事だ。

241
00:08:10,600 --> 00:08:11,580
そしてもし私はある特定の手本、

242
00:08:11,790 --> 00:08:13,690
z(i)があるとする、

243
00:08:13,760 --> 00:08:15,700
またはそれは二次元ベクトル z(i) 1と

244
00:08:16,350 --> 00:08:19,110
z(i) 2だ。

245
00:08:20,580 --> 00:08:21,990
そして前のスライドで、

246
00:08:22,230 --> 00:08:23,750
データを一次元に

247
00:08:23,950 --> 00:08:25,270
削減した時、

248
00:08:25,360 --> 00:08:27,500
z1しか無かった。よね？

249
00:08:27,760 --> 00:08:28,610
そしてそれこそが前のスライドでの

250
00:08:28,700 --> 00:08:29,830
z(1) 下付き添字1 だった。

251
00:08:30,550 --> 00:08:31,720
だがここでは二次元のデータなので、

252
00:08:32,100 --> 00:08:32,730
z1とz2を持ってる。

253
00:08:33,040 --> 00:08:34,940
データの二つの構成要素として。

254
00:08:36,690 --> 00:08:37,830
さてこれらの図の意味を

255
00:08:38,020 --> 00:08:39,200
確認しよう。

256
00:08:39,290 --> 00:08:40,790
その為に、これらの三つの図を

257
00:08:41,600 --> 00:08:45,080
全く同じ物を、けど3Dプロットで再掲する。

258
00:08:45,540 --> 00:08:46,570
我らがやってきたプロセスは、

259
00:08:47,040 --> 00:08:48,110
まず左にあるのがもともとのデータセットで、

260
00:08:48,480 --> 00:08:49,520
真ん中が2Dに投影したデータセット。

261
00:08:49,590 --> 00:08:50,540
そして右側が、

262
00:08:51,040 --> 00:08:52,140
z1とz2としての、

263
00:08:52,820 --> 00:08:54,900
2Dのデータセット。

264
00:08:55,780 --> 00:08:56,610
それらをもうちょっと詳しく見てみよう。

265
00:08:56,820 --> 00:08:57,960
これが私のオリジナルのデータセットで、

266
00:08:58,270 --> 00:08:59,210
左に示した。

267
00:08:59,410 --> 00:09:00,680
つまり私は、

268
00:09:01,380 --> 00:09:02,420
3Dの点の雲から

269
00:09:02,660 --> 00:09:04,000
始めた。そこでは、

270
00:09:04,360 --> 00:09:05,390
軸はx1, x2, x3などと

271
00:09:05,570 --> 00:09:07,410
ラベルづけされていた。だから3Dの点があった訳だ。

272
00:09:07,960 --> 00:09:08,970
だがほとんどのデータは

273
00:09:09,500 --> 00:09:10,750
だいたいはある2D平面に

274
00:09:10,850 --> 00:09:12,800
そんなに離れずに乗っていた。

275
00:09:13,930 --> 00:09:14,950
そこでこんな事が出来る、

276
00:09:15,040 --> 00:09:17,460
このデータを持ってきて、これが真ん中の図だ。

277
00:09:17,800 --> 00:09:19,110
それを2Dに射影する。

278
00:09:19,370 --> 00:09:20,790
つまり、これら全てのデータが

279
00:09:20,900 --> 00:09:23,220
2Dの表面に乗るように射影した。

280
00:09:23,750 --> 00:09:25,330
見ての通り、全てのデータは

281
00:09:26,190 --> 00:09:27,470
平面上にある。何故なら、

282
00:09:27,700 --> 00:09:30,520
全てを平面に射影したから。

283
00:09:30,570 --> 00:09:31,490
つまりこれが意味する事は、

284
00:09:31,800 --> 00:09:33,190
今や平面上の点の位置を

285
00:09:33,820 --> 00:09:35,090
表すには、たった二つの数、

286
00:09:35,620 --> 00:09:37,470
z1とz2しか、必要としない。

287
00:09:40,530 --> 00:09:41,480
以上が、データを

288
00:09:41,810 --> 00:09:42,990
3次元から2次元に削減する時に行う

289
00:09:43,500 --> 00:09:45,180
手続きとなる。

290
00:09:45,340 --> 00:09:48,520
以上が次元削減で、

291
00:09:49,230 --> 00:09:50,850
そしてそれを用いてデータを圧縮する

292
00:09:51,070 --> 00:09:52,740
方法だ。

293
00:09:54,010 --> 00:09:55,400
そして後で見るように、

294
00:09:55,580 --> 00:09:56,970
これは我らの学習アルゴリズムを

295
00:09:57,110 --> 00:09:58,020
もっと早く走らせる時にも

296
00:09:58,580 --> 00:09:59,670
また用いる事が出来るが、

297
00:09:59,740 --> 00:10:01,210
それはあとのビデオでやろう。