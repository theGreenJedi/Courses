このビデオでは、 新しいバージョンの線形回帰、 もっとパワフルな奴について話していく。 複数の変数、または複数のフィーチャーについて 機能する奴だ。 自分でコードを書く代わりに、 ここまでに作り上げた もともとの線形回帰では 一つのフィーチャーxと つまり家のサイズと、 それを使って 家の価格を 予測したい。これが、 我らの仮説の形だった。 だが、ここで想像してみてくれ。 フィーチャー、または変数として、 家のサイズだけを 価格の予測に 使うのでは無く、 ベッドルームの数も 何階建てかも 築年数も知っている。 これは家の価格を予想するのに もっと多くの情報を与えてくれる。 ちょっとした記法を 導入する。 前にもちょっと触れたが 変数x1、x2、、、を この場合は 4つのフィーチャーを 表すのに 使う。 そして結果の変数には これまで同様、 yを使う。予測しようとしている価格を表すのに。 もう少しノーテーションを追加しよう。 今となってはフィーチャーは4つあるのだから 小文字のnを フィーチャーの数を表すのに使う。 つまりこの例では、 n=4だ。何故なら、ここには 1、2、3、4フィーチャーあるから。 そしてこのnは、以前の例とは 異なるノーテーションなのに注意。 以前はnで、手本データの数を表していた。 だからもし 47行のデータがあったら mはこのテーブルの行の数で、それはつまりトレーニング手本の数だ。 また、xの 上付き添字の iをトレーニング手本iの 入力フィーチャーを表すのに用いる。 具体的には、 例えばx2は、 二番目のトレーニング手本の フィーチャーのベクトルとなる。 だからx2は このベクトル、 1416、3、2、40となる、 何故ならそれらが4つのフィーチャーだ、 2つ目の家の 価格を予測するのに使う。 だから、このノーテーションにおいては、 ここにある上添字の2は トレーニングセットのインデックスだ。 これはXの2乗という意味じゃない。 そうではなく、これは このテーブルの二行目を見ろ、という意味のインデックスだ。 これは私の二番目のトレーニングの手本を参照している。 このノーテーションではX2は、 4次元のベクトルだ。 実の所、より一般的に n次元ベクトルだ。 このノーテーションでは X2は今やベクトルで Xiの添字jを、 jの値、j番目のフィーチャーの値、 そしてそのトレーニングの手本を 示すのに 用いる。 具体的に見よう。x2の下添字3は このベクトルの フィーチャー番号3を参照することになるから、 イコール2だ。 おっと、これは3だ。ちょっと書き間違いを修正。 だからx2の下添字3はイコール2。 今や複数のフィーチャーがあるのだから その時仮説の形はどうであるべきか 議論しよう。 これまでは、これが 仮説の形式だった。 xはたった一つのフィーチャーだった。 だが今やフィーチャーは複数あるので、 このシンプルな式はもう使えない。 代わりに、線形回帰の 仮説の形式は こんな形になる。 シータ0足す、 シータ1 x1 足す、 シータ2 x2 足す シータ3 x3 足す事のシータ4 x4。 もしフィーチャーがN個なら、 4つ足し合わせる代わりに N個に渡って 足し合わせる。 具体的に話そう。 パラメータとして 以下のようなhのxになるようなパラメータ、 80 + 0.1 x1 +  0.01 x2 + 3 x3 - 2 x4. これは考えられる仮説の 一例だ。 そして前に言った通り 仮説とは 家の価格を 1000ドル単位で予想する事。 つまり、 家の基本価格は 80000足す事の、 0.1掛ける事の、、、つまり1平方フィートあたり100ドルの 追加分、 さらにそこに、 家の階数が増えると その分ちょっとだけ価格が上乗せされる。 x2が何階建てかを 表していて、 さらにベッドルームが一つ増える都度、 さらに価格が上がる。 何故ならx3が、 ベッドルームの数だから。 そして築年数が増えると、 それに応じて、ちょっとだけ価格が落ちていく。 築年数が増えていくに従って。 ここでこのスライドに仮説を再掲した。 ここでやりたいのは ちょっとした記法を導入して、 この式をシンプルにしたい。 簡単にする為の記法として、 xの添字0を、1と定義したい。 具体的には、ようするに 各手本iごとに フィーチャーのベクトルとして、x上添字のiが 存在する。 そしてxの上添字iの下添字0は=0となる。 この事は追加の0番目の フィーチャーを追加した、と考える事が出来る。 つまりこれまではnフィーチャーだったが、 何故ならx1、x2、、、と xnまでだったから。 でもこれからは、0番目の 追加のフィーチャーでいつも1なのを 定義してるというワケ。 だから今やフィーチャーベクトルのxは この、0インデックスの n+1次元ベクトルとなった！ だからこれは今や、 n+1次元のフィーチャーベクトルだが、 インデックスは0から振る。 また、さらにパラメータも ベクトルと 考える。 ここでの我らのパラメータは シータ0、シータ1、 などなどだ。 それがシータnまで続く。 我らはそれらを シータ0, シータ1、、、とシータnまで続く パラメータベクトルに 集めたい。 それは もう一つの0インデックスのベクトルだ。 それはインデックスが0から割り振られている。 それはもう一つのn+1次元ベクトルだ。 つまり、私の仮説は今や、 シータ0 x0 足すことの シータ1 x1足すことの、、、と シータn xnまで足した物と書ける。 そしてこの方程式は この上にあるのと同じだ。 何故なら x0は1だから。 そしてここでちょっとイイのは、 この形の仮説を 次のように、 シータの転置にx、とも書けるって事。 どれくらい ベクトルの内積に 慣れているかという話になるが、 シータの転置にxとはどんなか、 シータの転置はどうなるかまず書くと、 これがシータ0 シータ1、、、とシータnまで。 つまりこれが シータの転置で そしてこれは実際 n+1掛ける1 行列だ。 それは行ベクトルとも呼ばれる。 そして今度はそれを取って、 ベクトルxに掛けると xベクトルはx0、 x1、、、と xnまで続けた物。 つまり、シータの転置の xとの内積は これと一致する。 これは仮説を書く為の 便利な方法だ。 パラメータのベクトルであるシータと フィーチャーベクトルである所のxとの 内積で 書ける。 そしてこのちょっとした記法の追加、 ここにちょこっと抜粋した この記法の慣習に従えば、 これをこのコンパクトな形式で書ける。 以上がフィーチャーが複数あった時の仮説の形式だ。 また、これには別の名前もついていて、 多変量の線形回帰とも 呼ばれている。 多変量という言葉は ちょっとファンシーな言葉かもしれないが 複数のフィーチャーがあると言っているだけ。 または複数の変数がある、と。Yの値を予測するのに使う。