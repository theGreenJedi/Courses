1
00:00:00,190 --> 00:00:01,270
このビデオと、

2
00:00:01,440 --> 00:00:02,720
この次のビデオで、

3
00:00:02,850 --> 00:00:04,040
最急降下法を上手に使う為の

4
00:00:04,180 --> 00:00:06,940
実践的なトリックを幾つか紹介していきます。

5
00:00:07,680 --> 00:00:10,250
このビデオでは、フィーチャースケーリングと呼ばれるアイデアを紹介します。

6
00:00:11,770 --> 00:00:12,210
n 要素の合計を行うのに

7
00:00:13,030 --> 00:00:14,080
複数のフィーチャーの問題を

8
00:00:14,180 --> 00:00:15,880
扱ってるとします。

9
00:00:16,320 --> 00:00:17,410
もしフィーチャー同士がだいたい

10
00:00:18,050 --> 00:00:19,440
似たスケールである事を保証しておくと、

11
00:00:19,570 --> 00:00:20,480
つまり異なるフィーチャーが

12
00:00:20,650 --> 00:00:22,130
似たような範囲の値となるように

13
00:00:22,300 --> 00:00:23,390
保証しておくという事だが、そうすると、

14
00:00:24,420 --> 00:00:26,490
最急降下法はより早く収束する。

15
00:00:27,510 --> 00:00:28,680
具体的には、例えば

16
00:00:28,820 --> 00:00:29,860
2つのフィーチャーの問題があるとしよう。

17
00:00:30,380 --> 00:00:31,680
x1が家のサイズで、

18
00:00:31,950 --> 00:00:32,860
0から2000の値を

19
00:00:33,530 --> 00:00:34,540
とるとする。

20
00:00:35,490 --> 00:00:36,270
そしてx2はベッドルームの数とする。

21
00:00:36,520 --> 00:00:37,570
その範囲はたぶん、

22
00:00:37,820 --> 00:00:39,250
1から5って所だろう。

23
00:00:40,100 --> 00:00:41,690
コスト関数Jのシータの

24
00:00:41,800 --> 00:00:43,000
等高線を描けば、

25
00:00:44,810 --> 00:00:46,540
その等高線はこんな感じになるだろう。

26
00:00:46,750 --> 00:00:49,010
ここで

27
00:00:49,230 --> 00:00:50,570
Jのシータは

28
00:00:50,910 --> 00:00:53,590
パラメータ シータ0、シータ1、そしてシータ2の関数だ。

29
00:00:54,300 --> 00:00:55,400
シータ0は無視する事にする。

30
00:00:56,020 --> 00:00:57,230
つまりシータ0を捨てて、

31
00:00:57,480 --> 00:00:58,730
シータ1とシータ2だけの

32
00:00:58,840 --> 00:01:01,080
関数のフリをしよう。

33
00:01:01,510 --> 00:01:02,810
そしてx1はx2よりも

34
00:01:02,940 --> 00:01:04,110
ずっと大きい範囲の値を

35
00:01:04,370 --> 00:01:05,790
取りうるので、

36
00:01:06,120 --> 00:01:07,270
コスト関数の等高線は

37
00:01:07,340 --> 00:01:08,320
このような、

38
00:01:09,420 --> 00:01:11,400
とても歪んだ

39
00:01:11,690 --> 00:01:14,720
楕円型になる事が分かる。

40
00:01:15,070 --> 00:01:16,620
いわば、2000対5の比となるのだから

41
00:01:16,770 --> 00:01:18,470
これよりもっと歪んだ形だろう。

42
00:01:18,800 --> 00:01:20,190
これはとても縦長で

43
00:01:20,560 --> 00:01:23,070
薄っぺらい楕円だ。

44
00:01:23,320 --> 00:01:24,950
これらとても背が高くてガリガリの楕円が

45
00:01:25,310 --> 00:01:27,940
コスト関数、Jのシータの等高線を形成する。

46
00:01:29,420 --> 00:01:30,860
そしてこのコスト関数に対して

47
00:01:30,930 --> 00:01:34,290
最急降下法を適用すると、

48
00:01:34,830 --> 00:01:36,480
その歩みは結果として

49
00:01:36,970 --> 00:01:38,660
とても長い時間がかかる。

50
00:01:39,080 --> 00:01:40,360
前にいったり後ろに行ったり振動して、

51
00:01:41,100 --> 00:01:43,130
大域的な最小値に辿り着くまで

52
00:01:43,190 --> 00:01:46,120
長い時間がかかりうる。

53
00:01:47,470 --> 00:01:48,720
実際、これらの等高線を

54
00:01:48,890 --> 00:01:50,400
もっと極端にした物を想像してみれば、

55
00:01:50,580 --> 00:01:51,970
つまり信じられないほどガリガリのやせぼっちの楕円にしてみれば、

56
00:01:52,480 --> 00:01:54,300
のっぽでガリガリの等高線にしてみたら、

57
00:01:56,230 --> 00:01:57,030
もっともっと極端にしてみたら、

58
00:01:57,380 --> 00:01:59,060
最急降下は

59
00:01:59,790 --> 00:02:02,310
さらに長い時間を

60
00:02:02,630 --> 00:02:04,280
その道中に費やす、

61
00:02:04,690 --> 00:02:06,030
ふらふらと

62
00:02:06,120 --> 00:02:08,270
この全体最小への道を見つけるのに、長い時間がかかる。

63
00:02:12,130 --> 00:02:14,370
こういう場合に便利な技としては、

64
00:02:14,780 --> 00:02:16,280
フィーチャーをスケールする、というのがある。

65
00:02:17,380 --> 00:02:18,760
具体的には、

66
00:02:19,200 --> 00:02:20,370
フィーチャーx1を、

67
00:02:20,570 --> 00:02:21,770
家のサイズの代わりに、

68
00:02:21,870 --> 00:02:23,070
それを2000で割った物で定義し、

69
00:02:24,040 --> 00:02:25,140
x2を

70
00:02:25,270 --> 00:02:26,520
寝室の数 割る 5 で定義する。

71
00:02:26,940 --> 00:02:29,010
すると、

72
00:02:29,170 --> 00:02:30,020
コスト関数Jに関する

73
00:02:30,090 --> 00:02:31,840
等高線は、

74
00:02:32,900 --> 00:02:34,430
もっと歪まなくなる、

75
00:02:34,840 --> 00:02:36,990
つまり等高線はもっと円っぽくなる。

76
00:02:38,210 --> 00:02:39,180
そして最急降下法を

77
00:02:39,520 --> 00:02:40,540
このコスト関数に適用すると、

78
00:02:40,750 --> 00:02:42,120
最急降下は

79
00:02:44,110 --> 00:02:45,630
数学的にも示せるが、

80
00:02:45,860 --> 00:02:47,430
全体最小に向かう、

81
00:02:47,540 --> 00:02:48,830
もっと直接的なパスを見つけられる、

82
00:02:49,390 --> 00:02:51,200
全体最小に向かう

83
00:02:51,530 --> 00:02:52,530
もっと複雑で

84
00:02:52,620 --> 00:02:53,520
からみあった経路を辿る

85
00:02:54,310 --> 00:02:55,910
パスでは無く。

86
00:02:57,300 --> 00:02:58,710
つまり、フィーチャーを

87
00:02:58,950 --> 00:03:01,000
同じ範囲になるようにスケールする事で、

88
00:03:01,620 --> 00:03:02,810
この例の場合は結局

89
00:03:02,970 --> 00:03:04,150
x1とx2を

90
00:03:04,300 --> 00:03:06,960
0と1の間にした訳だが、

91
00:03:09,580 --> 00:03:12,290
そうする事で、より早く収束する最急降下法を

92
00:03:12,690 --> 00:03:13,810
実装する事が出来る。

93
00:03:18,120 --> 00:03:19,640
より一般的に、フィーチャースケーリングを実施する時は、

94
00:03:20,160 --> 00:03:21,240
多くの場合、

95
00:03:21,530 --> 00:03:22,480
各フィーチャーを

96
00:03:22,750 --> 00:03:25,670
だいたい-1から1の範囲に

97
00:03:25,780 --> 00:03:28,170
スケールする。

98
00:03:28,960 --> 00:03:31,710
具体的に。
x0はいつも1だから

99
00:03:31,760 --> 00:03:32,810
既にそのレンジにある。

100
00:03:34,110 --> 00:03:35,150
だが他のフィーチャーは

101
00:03:35,630 --> 00:03:36,950
このレンジに収まるように

102
00:03:37,330 --> 00:03:39,150
割る事が出来る。

103
00:03:39,510 --> 00:03:41,520
-1と1という数字自体はどうでも良い。

104
00:03:42,270 --> 00:03:42,900
だからもし、x1というフィーチャーがあって

105
00:03:44,150 --> 00:03:45,340
その範囲が

106
00:03:45,510 --> 00:03:48,000
0と3の間なら、まぁ問題は無いでしょう。

107
00:03:48,400 --> 00:03:49,410
もし別のフィーチャーがあって

108
00:03:49,600 --> 00:03:51,190
その範囲が-2から0.5の間

109
00:03:52,140 --> 00:03:54,020
だったとする、

110
00:03:54,300 --> 00:03:55,710
これも-1から1の間に

111
00:03:56,070 --> 00:03:57,070
十分近い、つまり

112
00:03:57,320 --> 00:03:59,160
問題無し。

113
00:04:00,310 --> 00:04:01,260
ところがもし、

114
00:04:01,340 --> 00:04:02,580
別のフィーチャー、例えばx3 としよう、

115
00:04:02,820 --> 00:04:04,780
それが-100から100までの

116
00:04:05,840 --> 00:04:09,070
レンジだったとしたら、

117
00:04:09,330 --> 00:04:10,850
その時はこれは

118
00:04:11,090 --> 00:04:13,570
-1から1までとは大きく異なった値である。

119
00:04:13,860 --> 00:04:15,020
だからこれは、

120
00:04:15,230 --> 00:04:17,480
あまりよくないスケールのフィーチャーと言えて、

121
00:04:17,970 --> 00:04:19,340
同様にもし、とてもとても小さいレンジの

122
00:04:19,420 --> 00:04:20,680
フィーチャー、例えばx4が

123
00:04:20,950 --> 00:04:22,060
-0.0001から0.0001までの値を

124
00:04:22,340 --> 00:04:25,530
取るとすると、

125
00:04:25,740 --> 00:04:28,290
その時もまた、

126
00:04:29,720 --> 00:04:30,780
-1から1までのレンジより

127
00:04:30,910 --> 00:04:31,960
ずっと小さい

128
00:04:32,460 --> 00:04:33,760
範囲をとっている。

129
00:04:34,040 --> 00:04:36,630
だからこの場合も、このフィーチャーはあまり良くスケールされてない、と言える。

130
00:04:37,850 --> 00:04:39,150
つまり、値のレンジは

131
00:04:39,430 --> 00:04:40,350
1よりも

132
00:04:41,070 --> 00:04:42,010
大きくても小さくてもいいんだが

133
00:04:42,370 --> 00:04:43,840
だが、大きすぎたり、

134
00:04:44,040 --> 00:04:45,170
たとえば100とか

135
00:04:45,610 --> 00:04:47,470
または小さすぎたり、

136
00:04:47,650 --> 00:04:49,990
たとえば0.001とか、そういうのは良くない。

137
00:04:50,770 --> 00:04:52,530
人によってちょっとずつ異なる経験則を持ってるものだが、

138
00:04:52,870 --> 00:04:53,910
私が使ってる経験則は

139
00:04:54,070 --> 00:04:55,440
フィーチャーの範囲が

140
00:04:55,670 --> 00:04:56,750
-3から3までの範囲の値なら、

141
00:04:56,980 --> 00:04:58,590
どう思うかといえば、

142
00:04:58,840 --> 00:05:00,120
これはセーフ。

143
00:05:00,170 --> 00:05:01,690
だが

144
00:05:02,000 --> 00:05:03,050
3とか-3より先の

145
00:05:03,440 --> 00:05:04,360
値をとる場合は

146
00:05:04,530 --> 00:05:06,400
心配しはじめる。そして

147
00:05:06,700 --> 00:05:09,660
値の範囲が、-1/3から1/3なら

148
00:05:10,920 --> 00:05:12,020
これもオーケー。

149
00:05:12,270 --> 00:05:14,880
また、0から1/3とか-1/3から0も

150
00:05:14,910 --> 00:05:17,890
よくある範囲なので多分オーケー。

151
00:05:18,560 --> 00:05:19,310
だが、それが

152
00:05:19,450 --> 00:05:20,640
もっと小さな範囲の値、

153
00:05:20,900 --> 00:05:23,220
例えばこのx4とか、その場合は心配しはじめる。

154
00:05:23,790 --> 00:05:25,060
では、覚えて帰って欲しいメッセージとしては、

155
00:05:25,500 --> 00:05:26,780
フィーチャー同士が

156
00:05:27,000 --> 00:05:28,550
完全に同じスケール、レンジの値を取らなくても、

157
00:05:28,700 --> 00:05:30,920
気にしない！

158
00:05:31,170 --> 00:05:31,930
この範囲に十分近ければ

159
00:05:32,090 --> 00:05:35,060
最急降下法は正しく機能するはずだから。

160
00:05:35,930 --> 00:05:37,530
フィーチャースケールを実施する時に

161
00:05:37,930 --> 00:05:39,960
最大値で割る他に

162
00:05:40,220 --> 00:05:42,080
さらに時々

163
00:05:42,730 --> 00:05:45,070
行われる事としては、平均ノーマライゼーションと言う物がある。

164
00:05:45,330 --> 00:05:47,150
それの意味する所は

165
00:05:47,320 --> 00:05:48,130
xiをとってきて、

166
00:05:48,350 --> 00:05:49,810
それをxi マイナス ミューiに

167
00:05:50,230 --> 00:05:51,850
置き換えたい、

168
00:05:52,870 --> 00:05:55,260
フィーチャーの平均が、だいたい0になるように。

169
00:05:56,530 --> 00:05:57,730
明らかに、

170
00:05:57,890 --> 00:05:59,260
これはフィーチャーx0には適用すべきでない。

171
00:05:59,650 --> 00:06:00,750
何故ならフィーチャーx0は

172
00:06:00,940 --> 00:06:02,260
いつでも1だから。

173
00:06:02,360 --> 00:06:03,600
だから平均が0には

174
00:06:03,810 --> 00:06:05,100
なりえない。

175
00:06:06,370 --> 00:06:07,760
だが、具体的に話をすると、

176
00:06:07,950 --> 00:06:09,320
その他のフィーチャー、

177
00:06:09,600 --> 00:06:10,320
例えば家のサイズのレンジが

178
00:06:10,960 --> 00:06:14,170
0から2000の値の範囲を

179
00:06:14,310 --> 00:06:15,080
取るとすると、

180
00:06:15,230 --> 00:06:16,230
そして家のサイズの平均は

181
00:06:16,470 --> 00:06:18,340
1000くらいだとすると、

182
00:06:18,500 --> 00:06:20,080
その時はこの式を

183
00:06:21,470 --> 00:06:21,950
使った方が良いかもしれない。

184
00:06:23,940 --> 00:06:24,970
フィーチャーx1には

185
00:06:25,250 --> 00:06:26,270
サイズから平均の値を引いて

186
00:06:26,590 --> 00:06:28,010
2000で割った物とする。

187
00:06:28,630 --> 00:06:31,820
同様に、

188
00:06:32,530 --> 00:06:34,010
もし家の寝室の数が

189
00:06:34,520 --> 00:06:37,630
1から5部屋だとして

190
00:06:39,240 --> 00:06:40,460
平均的な家には

191
00:06:40,890 --> 00:06:41,920
寝室が二部屋だったすると、

192
00:06:42,110 --> 00:06:44,750
二番目のフィーチャーx2を平均ノーマライズする為に

193
00:06:45,080 --> 00:06:47,460
この式を使う方が良いかも。

194
00:06:49,340 --> 00:06:50,720
これら両方のケースで

195
00:06:50,840 --> 00:06:52,730
フィーチャーx1とx2はどちらも、

196
00:06:52,930 --> 00:06:54,490
だいたい-0.5から0.5の間の値を

197
00:06:54,880 --> 00:06:56,580
取る結果となる。

198
00:06:57,130 --> 00:06:57,880
厳密に成立する訳ではないーー

199
00:06:58,210 --> 00:07:00,920
x2は実際、0.5よりも少し大きくなりうる。
でも十分近い。

200
00:07:01,800 --> 00:07:03,140
このルールを一般化すると、

201
00:07:03,530 --> 00:07:04,860
フィーチャーx1を持ってきて

202
00:07:04,900 --> 00:07:06,390
それを、x1 - ミュー1 割ることの s1で

203
00:07:08,060 --> 00:07:10,110
置き換える。

204
00:07:10,940 --> 00:07:13,410
ミュー1は

205
00:07:13,550 --> 00:07:15,890
トレーニングセット内の

206
00:07:16,200 --> 00:07:18,290
x1の平均と

207
00:07:19,960 --> 00:07:21,310
定義し、

208
00:07:22,320 --> 00:07:24,190
s1は

209
00:07:24,350 --> 00:07:27,420
そのフィーチャーの

210
00:07:27,820 --> 00:07:28,940
値のレンジで、

211
00:07:29,040 --> 00:07:30,110
それはつまり、

212
00:07:30,630 --> 00:07:31,900
最大値-最小値と言う事。

213
00:07:32,290 --> 00:07:33,350
変数の偏差という物を

214
00:07:33,590 --> 00:07:35,360
知ってるなら、

215
00:07:35,850 --> 00:07:37,390
s1に標準偏差を

216
00:07:37,760 --> 00:07:40,790
設定しても構わない。

217
00:07:41,020 --> 00:07:43,240
でも、このmax-minでもいいよ。

218
00:07:44,330 --> 00:07:45,170
同様に、二番目のフィーチャー

219
00:07:45,610 --> 00:07:47,380
x2についても、

220
00:07:47,840 --> 00:07:49,740
x2を平均を引いて

221
00:07:51,040 --> 00:07:52,220
値のレンジ、つまり

222
00:07:52,800 --> 00:07:54,110
maxからminを引いた物で割った物に

223
00:07:54,380 --> 00:07:55,980
置き換える。

224
00:07:56,880 --> 00:07:57,910
この種の式は知っての通り、

225
00:07:58,370 --> 00:07:59,630
完全に、という訳では無いが

226
00:07:59,850 --> 00:08:01,020
だいたいは

227
00:08:01,920 --> 00:08:03,320
この種のレンジにフィーチャーを押し込む。

228
00:08:03,490 --> 00:08:04,820
ところで、

229
00:08:04,890 --> 00:08:05,700
とても注意深い

230
00:08:05,940 --> 00:08:07,570
視聴者の皆さんの中には、

231
00:08:07,710 --> 00:08:09,300
レンジをmax-minとすると、

232
00:08:09,610 --> 00:08:12,410
この5は、本当は4になる、と思ったかもしれない。

233
00:08:13,140 --> 00:08:14,390
つまりmaxの5から

234
00:08:14,600 --> 00:08:15,830
1を引くと、

235
00:08:16,320 --> 00:08:17,160
その値のレンジは実際には

236
00:08:17,860 --> 00:08:18,530
4となる。
だがこれらは全て

237
00:08:18,690 --> 00:08:20,380
近似であって、

238
00:08:20,830 --> 00:08:22,010
このあたりのレンジにフィーチャーを持ってくるなら

239
00:08:22,450 --> 00:08:24,750
どんな値でも構わない。

240
00:08:25,200 --> 00:08:27,220
そしてフィーチャースケーリングは

241
00:08:27,660 --> 00:08:28,520
そんなに厳密である必要は無い。

242
00:08:29,050 --> 00:08:30,390
最急降下が

243
00:08:30,790 --> 00:08:32,290
大幅に短縮される為には。

244
00:08:34,610 --> 00:08:35,840
これで君も、

245
00:08:36,020 --> 00:08:37,420
フィーチャースケーリングとは何かを知った訳だ。

246
00:08:37,530 --> 00:08:39,040
このシンプルなトリックを適用すれば、

247
00:08:39,250 --> 00:08:40,650
最急降下はより早く走り

248
00:08:40,870 --> 00:08:43,680
より少ない繰り返しで収束する。

249
00:08:44,990 --> 00:08:45,540
以上がフィーチャースケーリングだ。

250
00:08:46,080 --> 00:08:47,190
次のビデオでは、

251
00:08:47,350 --> 00:08:49,410
最急降下法をより良く機能させる

252
00:08:49,710 --> 00:08:50,970
もう一つのトリックを紹介する。