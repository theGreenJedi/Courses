このビデオと、 この次のビデオで、 最急降下法を上手に使う為の 実践的なトリックを幾つか紹介していきます。 このビデオでは、フィーチャースケーリングと呼ばれるアイデアを紹介します。 n 要素の合計を行うのに 複数のフィーチャーの問題を 扱ってるとします。 もしフィーチャー同士がだいたい 似たスケールである事を保証しておくと、 つまり異なるフィーチャーが 似たような範囲の値となるように 保証しておくという事だが、そうすると、 最急降下法はより早く収束する。 具体的には、例えば 2つのフィーチャーの問題があるとしよう。 x1が家のサイズで、 0から2000の値を とるとする。 そしてx2はベッドルームの数とする。 その範囲はたぶん、 1から5って所だろう。 コスト関数Jのシータの 等高線を描けば、 その等高線はこんな感じになるだろう。 ここで Jのシータは パラメータ シータ0、シータ1、そしてシータ2の関数だ。 シータ0は無視する事にする。 つまりシータ0を捨てて、 シータ1とシータ2だけの 関数のフリをしよう。 そしてx1はx2よりも ずっと大きい範囲の値を 取りうるので、 コスト関数の等高線は このような、 とても歪んだ 楕円型になる事が分かる。 いわば、2000対5の比となるのだから これよりもっと歪んだ形だろう。 これはとても縦長で 薄っぺらい楕円だ。 これらとても背が高くてガリガリの楕円が コスト関数、Jのシータの等高線を形成する。 そしてこのコスト関数に対して 最急降下法を適用すると、 その歩みは結果として とても長い時間がかかる。 前にいったり後ろに行ったり振動して、 大域的な最小値に辿り着くまで 長い時間がかかりうる。 実際、これらの等高線を もっと極端にした物を想像してみれば、 つまり信じられないほどガリガリのやせぼっちの楕円にしてみれば、 のっぽでガリガリの等高線にしてみたら、 もっともっと極端にしてみたら、 最急降下は さらに長い時間を その道中に費やす、 ふらふらと この全体最小への道を見つけるのに、長い時間がかかる。 こういう場合に便利な技としては、 フィーチャーをスケールする、というのがある。 具体的には、 フィーチャーx1を、 家のサイズの代わりに、 それを2000で割った物で定義し、 x2を 寝室の数 割る 5 で定義する。 すると、 コスト関数Jに関する 等高線は、 もっと歪まなくなる、 つまり等高線はもっと円っぽくなる。 そして最急降下法を このコスト関数に適用すると、 最急降下は 数学的にも示せるが、 全体最小に向かう、 もっと直接的なパスを見つけられる、 全体最小に向かう もっと複雑で からみあった経路を辿る パスでは無く。 つまり、フィーチャーを 同じ範囲になるようにスケールする事で、 この例の場合は結局 x1とx2を 0と1の間にした訳だが、 そうする事で、より早く収束する最急降下法を 実装する事が出来る。 より一般的に、フィーチャースケーリングを実施する時は、 多くの場合、 各フィーチャーを だいたい-1から1の範囲に スケールする。 具体的に。
x0はいつも1だから 既にそのレンジにある。 だが他のフィーチャーは このレンジに収まるように 割る事が出来る。 -1と1という数字自体はどうでも良い。 だからもし、x1というフィーチャーがあって その範囲が 0と3の間なら、まぁ問題は無いでしょう。 もし別のフィーチャーがあって その範囲が-2から0.5の間 だったとする、 これも-1から1の間に 十分近い、つまり 問題無し。 ところがもし、 別のフィーチャー、例えばx3 としよう、 それが-100から100までの レンジだったとしたら、 その時はこれは -1から1までとは大きく異なった値である。 だからこれは、 あまりよくないスケールのフィーチャーと言えて、 同様にもし、とてもとても小さいレンジの フィーチャー、例えばx4が -0.0001から0.0001までの値を 取るとすると、 その時もまた、 -1から1までのレンジより ずっと小さい 範囲をとっている。 だからこの場合も、このフィーチャーはあまり良くスケールされてない、と言える。 つまり、値のレンジは 1よりも 大きくても小さくてもいいんだが だが、大きすぎたり、 たとえば100とか または小さすぎたり、 たとえば0.001とか、そういうのは良くない。 人によってちょっとずつ異なる経験則を持ってるものだが、 私が使ってる経験則は フィーチャーの範囲が -3から3までの範囲の値なら、 どう思うかといえば、 これはセーフ。 だが 3とか-3より先の 値をとる場合は 心配しはじめる。そして 値の範囲が、-1/3から1/3なら これもオーケー。 また、0から1/3とか-1/3から0も よくある範囲なので多分オーケー。 だが、それが もっと小さな範囲の値、 例えばこのx4とか、その場合は心配しはじめる。 では、覚えて帰って欲しいメッセージとしては、 フィーチャー同士が 完全に同じスケール、レンジの値を取らなくても、 気にしない！ この範囲に十分近ければ 最急降下法は正しく機能するはずだから。 フィーチャースケールを実施する時に 最大値で割る他に さらに時々 行われる事としては、平均ノーマライゼーションと言う物がある。 それの意味する所は xiをとってきて、 それをxi マイナス ミューiに 置き換えたい、 フィーチャーの平均が、だいたい0になるように。 明らかに、 これはフィーチャーx0には適用すべきでない。 何故ならフィーチャーx0は いつでも1だから。 だから平均が0には なりえない。 だが、具体的に話をすると、 その他のフィーチャー、 例えば家のサイズのレンジが 0から2000の値の範囲を 取るとすると、 そして家のサイズの平均は 1000くらいだとすると、 その時はこの式を 使った方が良いかもしれない。 フィーチャーx1には サイズから平均の値を引いて 2000で割った物とする。 同様に、 もし家の寝室の数が 1から5部屋だとして 平均的な家には 寝室が二部屋だったすると、 二番目のフィーチャーx2を平均ノーマライズする為に この式を使う方が良いかも。 これら両方のケースで フィーチャーx1とx2はどちらも、 だいたい-0.5から0.5の間の値を 取る結果となる。 厳密に成立する訳ではないーー x2は実際、0.5よりも少し大きくなりうる。
でも十分近い。 このルールを一般化すると、 フィーチャーx1を持ってきて それを、x1 - ミュー1 割ることの s1で 置き換える。 ミュー1は トレーニングセット内の x1の平均と 定義し、 s1は そのフィーチャーの 値のレンジで、 それはつまり、 最大値-最小値と言う事。 変数の偏差という物を 知ってるなら、 s1に標準偏差を 設定しても構わない。 でも、このmax-minでもいいよ。 同様に、二番目のフィーチャー x2についても、 x2を平均を引いて 値のレンジ、つまり maxからminを引いた物で割った物に 置き換える。 この種の式は知っての通り、 完全に、という訳では無いが だいたいは この種のレンジにフィーチャーを押し込む。 ところで、 とても注意深い 視聴者の皆さんの中には、 レンジをmax-minとすると、 この5は、本当は4になる、と思ったかもしれない。 つまりmaxの5から 1を引くと、 その値のレンジは実際には 4となる。
だがこれらは全て 近似であって、 このあたりのレンジにフィーチャーを持ってくるなら どんな値でも構わない。 そしてフィーチャースケーリングは そんなに厳密である必要は無い。 最急降下が 大幅に短縮される為には。 これで君も、 フィーチャースケーリングとは何かを知った訳だ。 このシンプルなトリックを適用すれば、 最急降下はより早く走り より少ない繰り返しで収束する。 以上がフィーチャースケーリングだ。 次のビデオでは、 最急降下法をより良く機能させる もう一つのトリックを紹介する。