इस वीडियो में, मैं आपको देना चाहता हूँ कुछ उपयोगी सलाह ग्रेडीयंट डिसेंट को काम करवाने के लिए. सुझाव इस विडीओ में केंद्रित होंगे लर्निंग रेट अल्फ़ा पर. वास्तव में, यहाँ है ग्रेडीयंट डिसेंट अप्डेट रूल. और इस विडीओ में मैं क्या करना चाहता हूँ कि बताऊँ आपको कि मैं क्या सोचता हूँ डीबगिंग की तरह, और कुछ सलाह यह तय करने के लिए कि ग्रेडीयंट डिसेंट सही काम कर रहा है. और दूसरा, मैं आपको बताना चाहता हूँ कि कैसे चुने लर्निंग रेट अल्फ़ा या कम से कम कैसे मैं कोशिश करता हूँ इसे चुनने की. यहाँ है कुछ जो मैं अक्सर करता हूँ यह तय करने के लिए कि ग्रेडीयंट डिसेंट काम कर रहा है सही ढंग से. ग्रेडीयंट डिसेंट का काम है ढूँढना थीटा की वैल्यू आपके लिए जो आशापूर्वक न्यूनतम करेगी कॉस्ट फ़ंक्शन जे(थीटा) को. मैं अक्सर क्या करता हूँ इसलिए प्लॉट करता हूँ कॉस्ट फ़ंक्शन जे (थीटा) जब ग्रेडीयंट डिसेंट रन करता है. अत: एक्स ऐक्सिस पर यहाँ है एक संख्या इटरेशन्स की ग्रेडीयंट डिसेंट की और जब ग्रेडीयंट डिसेंट रन करता है आपको आशापूर्वक मिलता है एक प्लॉट जो शायद ऐसा दिखता है. ध्यान दें कि एक्स ऐक्सिस है संख्या इटरेशन्स की. पहले हम देख रहे थे जे(थीटा) के प्लॉट्स पर जहाँ एक्स ऐक्सिस, जहाँ हॉरिज़ॉंटल ऐक्सिस थी पेरामिटर वेक्टर थीटा. लेकिन यह वह नहीं हैं. वस्तुत:, यह पोईँट क्या है, कि मैं रन करूँगा ग्रेडीयंट डिसेंट 100 इटरेशन्स के लिए. और जो भी वैल्यू मुझे मिलती है थीटा के लिए 100 इटरेशन्स के बाद, मुझे मिलेगी कुछ वैल्यू थीटा की 100 इटरेशन्स के बाद. और मैं करूंगा इवैल्यूएट कॉस्ट फ़ंक्शन जे(थीटा). जो वैल्यू मुझे मिली थीटा की 100 इटरेशन्स के बाद, और यह वर्टिकल हाइट है वैल्यू जे(थीटा) की. वैल्यू जो मुझे मिली थीटा की 100 इटरेशन्स के बाद ग्रेडीयंट डिसेंट की. और यह पोईँट यहाँ कॉरेस्पॉंड करता हैं वैल्यू जे(थीटा) से जो थीटा जो मुझे मिला जब मैंने रन कर लिया है ग्रेडीयंट डिसेंट 200 इटरेशन्स के लिए. तो यह प्लॉट क्या दिखा रहा है, यह दिखा रहा है वैल्यू आपके कॉस्ट फ़ंक्शन की ग्रेडीयंट डिसेंट की प्रत्येक इटरेशन के बाद. और यदि ग्रेडीयंट डिसेंट सही ढंग से काम कर रहा है तब जे(थीटा) कम होना चाहिए प्रत्येक इटरेशन के बाद. और एक उपयोगी चीज़ जो इस प्रकार का प्लॉट आपको बता सकता है वह है कि याद आप देखें विशेष चित्र पर जो मैंने बनाया है, यह दिखता है जब आपको मिल गए है शायद 300 इटरेशन्स, 300 और 400 इटरेशन्स के बीच, इस सेगमेंट में यह दिखता है कि जे(थीटा) और ज़्यादा कम नहीं हुआ है. तो जब तक आप पहुँचते हैं 400 इटरेशन्स पर, ऐसा लगता है कि यह कर्व यहाँ फ़्लैट हो गया है. और इसलिए यहाँ 400 इटरेशन्स पर, ऐसा लगता है ग्रेडीयंट डिसेंट लगभग कन्वर्ज हो गया है क्योंकि आपका कॉस्ट फ़ंक्शन और कम नहीं हो रहा है. अत: इस चित्र को देखने से आपको समझ आ सकती है क्या ग्रेडीयंट डिसेंट कन्वर्ज हुआ है या नहीं. वैसे तो, संख्या इटरेशन्स की जो ग्रेडीयंट डिसेंट लेता है कन्वर्ज होने के लिए ऐप्लिकेशन में हो सकती है भिन्न एक ऐप्लिकेशन में, ग्रेडीयंट डिसेंट शायद कन्वर्ज हो जाए तीस इटरेशन्स के बाद. एक भिन्न ऐप्लिकेशन के लिए, ग्रेडीयंट डिसेंट शायद ले 3,000 इटरेशन्स. किसी और लर्निंग अल्गोरिद्म के लिए, यह शायद ले सकता है 3 मिल्यन इटरेशन्स. यह बहित कठिन हो जाता है बता पाना पहले से कि कितनी इटरेशन्स ग्रेडीयंट डिसेंट को चाहिए कन्वर्ज होने के लिए. और प्रायः प्लॉट करने से इस प्रकार के प्लॉट, प्लॉट करने से कॉस्ट फ़ंक्शन जैसे हम बढ़ाते हैं संख्या इटरेशन्स की, है अक्सर देख कर इन प्लॉट्स पर. लेकिन मैं कोशिश करता हूँ बताने की यदि ग्रेडीयंट डिसेंट कन्वर्ज हो गया है. यह भी सम्भव है बना पाना स्वचालित कन्वर्जेन्स टेस्ट, मतलब कि होना एक अल्गोरिद्म का जो बता पाए यदि ग्रेडीयंट डिसेंट कन्वर्ज हो गया है. और यहाँ है एक काफ़ी आम उदाहरण एक स्वचालित कन्वर्जेन्स टेस्ट का. और इस तरह का टेस्ट शायद घोषित कर दे कनवरजेन्स यदि आपका कॉस्ट फ़ंक्शन जे(थीटा) कम होता है एक छोटी एप्सिलोन वैल्यू से कम. कोई छोटी वैल्यू 10 से माइनस 3 तक एक इटरेशन में. लेकिन मुझे पता लगा कि यह थ्रेशोल्ड / सीमारेखा ढूँढ पाना काफ़ी कठिन है. और इसलिए जाँचने के लिए आपकी ग्रेडीयंट डिसेंट का कन्वर्जेन्स मैं वास्तव में देखता हूँ इस तरह के प्लॉट्स पर, जैसे यह चित्र बाईं तरफ़, बजाय भरोसा करने के एक स्वचालित कन्वर्जेन्स टेस्ट पर. इस तरह के चित्र पर देखने से आपको यह भी पता चलता है, या एक अग्रिम चेतावनी मिल जाती है, यदि शायद ग्रेडीयंट डिसेंट सही काम नहीं कर रहा है. वस्तुत:,यदि आप प्लॉट करते हैं जे(थीटा) को इटरेशन संख्या के फ़ंक्शन की तरह. तब आप देखते हैं एक चित्र इस तरह का जहाँ जे(थीटा) वास्तव में बढ़ रहा है, तब वह भी आपको देता है एक स्पष्ट इशारा कि ग्रेडीयंट डिसेंट काम नहीं कर रहा है. और एक इस तरह के थीटा  का अक्सर मतलब होता है कि आपको इस्तेमाल करनी चाहिए लर्निंग रेट अल्फ़ा. यदि जे(थीटा) वाक़ई में बढ़ रहा है, सबसे ज़्यादा आम कारण उसके लिए है कि यदि आप न्यूनतम करने की कोशिश कर रहे हो एक फ़ंक्शन को, वह शायद ऐसा दिखता है. लेकिन यदि आपकी लर्निंग रेट काफ़ी बड़ी है तब यदि आप यहाँ से शुरू करते है, ग्रेडीयंट डिसेंट शायद पार कर जाए मिनिमम और भेज दे आपको वहाँ. और यदि लर्निंग रेट बहुत बड़ी है, आप शायद पार कर जाएँगे फिर से और यह भेज दे आपको वहाँ और इसी प्रकार आगे. तो वह, आप वास्तव में क्या चाहते थे कि शुरू करें यहाँ और वह धीरे-धीरे नीचे जाए, सही? लेकिन यदि लर्निंग रेट बहुत बड़ी है, तब ग्रेडीयंट डिसेंट इसके स्थान पर पार करता रहेगा मिनिमम. ताकि आपकी स्थिति होती जाएगी और ख़राब  और ख़राब बजाय जाने के ऊपर की वैल्यूज़ पर कोस्ट फ़ंक्शन जे(थीटा) की. तो आपको मिलता है एक प्लॉट इस तरह का, और यदि आप देखें  प्लॉट इस तरह का, इसका हल अक्सर है लेना एक छोटी वैल्यू अल्फ़ा की. ओह, और वैसे भी, सुनिश्चित कर लें कि आपके कोड में कोई बग नहीं है. लेकिन अक्सर एक बहुत बड़ी वैल्यू अल्फ़ा की हो सकती है एक आम समस्या. इसी प्रकार कभी-कभी आप शायद देखें जे(थीटा) करते हुए कुछ ऐसा भी, यह शायद कम हो  थोड़ी देर के लिए फिर ज़्यादा हो थोड़ी देर के लिए फिर कम हो थोड़ी देर के लिए फिर ज़्यादा हो फिर कम हो थोड़ी देर के लिए फिर ज़्यादा हो और ऐसा चलता रहे. और हल इस तरह की कुछ चीज़ के लिए भी है लेना एक छोटी वैल्यू अल्फ़ा की. मैं नहीं करूँगा उसे प्रूव / प्रमाणित यहाँ, लेकिन दूसरी असम्प्शंज़ / पूर्वधारणा  के तहत कॉस्ट फ़ंक्शन के बारे में, यह सत्य नहीं हैं लिनीअर रेग्रेशन के लिए, गणित ने दिखाया है कि यदि आपकी लर्निंग रेट पर्याप्त रूप से कम है, तब जे (थीटा) कम होना चाहिए प्रत्येक इटरेशन के साथ. अत: यदि यह नहीं होता है सम्भवत: अल्फ़ा ज़्यादा बड़ा है, आपको उसे कम पर सेट करना चाहिए. लेकिन निस्संदेह, आप नहीं चाहते आपकी लर्निंग रेट ज़्यादा कम भी क्योंकि यदि आप वह करते हैं तब ग्रेडीयंट डिसेंट धीरे कन्वर्ज हो सकता है. और यदि अल्फ़ा बहुत छोटा होगा, आप शायद यहाँ से शुरू करें, मान लो, और ले पाएँगे छोटे छोटे स्टेप्स. और केवल लेंगे बहुत अधिक इटरेशन्स इससे पहले कि आप मिनिमम पर पहुँच पाए, और इसलिए यदि अल्फ़ा बहुत छोटा है, ग्रेडीयंट डिसेंट कर सकता है धीमी प्राग्रेस और कन्वर्ज हो सकता है धीरे-धीरे. सारांश में, यदि लर्निंग रेट बहुत छोटी है, आपके पास है धीरे कन्वर्जेन्स की समस्या, और यदि लर्निंग रेट बहुत बड़ी है, जे (थीटा) शायद कम न हो प्रत्येक इटरेशन में, और शायद यह कन्वर्ज भी न हो. कुछ केसीज़ में यदि लर्निंग रेट बहुत बड़ी है, धीरे कन्वर्जेन्स भी सम्भव है. लेकिन ज़्यादा आम समस्या जो आप देखते हैं वह है केवल कि जे (थीटा) शायद कम न हो प्रत्येक इटरेशन में. और डीबग करने के लिए इन सब चीज़ों को, अक्सर प्लॉट कर लेने से वह जे(थीटा) इटरेशन की संख्या के फ़ंक्शन की तरह सहायता करता है आपको समझने में कि क्या हो रहा है. वास्तव में, मैं वास्तव में क्या करता हूँ जब मैं रन करता हूँ ग्रेडीयंट डिसेंट कि मैं परखता हूँ एक रेंज वैल्यूज़ की. अत: कोशिश करें रन करने की ग्रेडीयंट डिसेंट को एक रेंज के साथ अल्फ़ा की, जैसे 0.001 और 0.01. तो वे हैं भिन्न एक दस फ़ैक्टर के अंतर से. और इन भिन्न अल्फ़ा की वैल्यूज़ के लिए प्लॉट करें जे(थीटा) एक फ़ंक्शन के तरह इटरेशन की संख्या के, और तब चुन लें अल्फ़ा की वैल्यू जो प्रतीत होती है कम करती हुई जे(थीटा) को तीव्रता से. वैसे तो, मैं वास्तव में क्या करता हूँ वे ये दस के स्टेप्स नहीं हैं. तो यह है एक स्केल दस के फ़ैक्टर से बढ़ाना प्रत्येक स्टेप में. मैं वास्तव में क्या करता हूँ कि मैं परखता हूँ एक रेंज वैल्यूज़ की. और इसी प्रकार, जहाँ यह है 0.001. मैं तब बढ़ाऊँगा रेट को तीन गुणा लेने के लिए 0.003. और अब इसे बढ़ाऊँगा 0.01 पर, यह एक और लगभग तीन गुणा बढ़त है 0.003 से 0.01 तक. और इसलिए ये हैं, क़रीब, परखना ग्रेडीयंट डिसेंट प्रत्येक वैल्यू से जो लगभग 3x बड़ी है पिछली वैल्यू से. तो मैं क्या करता हूँ कि परखता हूँ एक रेंज वैल्यूज़ की तब तक जब मुझे मिल जाती है वह वैल्यू जो काफ़ी छोटी है और मुझे मिल जाती है एक वैल्यू जो काफ़ी बड़ी है. तब मैं कोशिश करता हूँ लेने की अधिकतम सम्भव वैल्यू, या केवल थोड़ी छोटी अधिकतम उचित रूप से बड़ी वैल्यू से जो मुझे मिली थी. और जब मैं वह करता हूँ अक्सर यह मझे देता है एक अच्छी लर्निंग रेट मेरी प्रॉब्लम के लिए. और यदि आप भी यह करते हैं शायद आप भी चुन पाएँगे एक अच्छी लर्निंग रेट आपकी इम्प्लमेंटेशन के लिए ग्रेडीयंट डिसेंट की.