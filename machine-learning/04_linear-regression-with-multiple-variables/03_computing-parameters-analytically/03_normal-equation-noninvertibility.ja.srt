1
00:00:00,220 --> 00:00:05,060
このビデオでは、正規方程式と非可逆性について

2
00:00:05,060 --> 00:00:07,640
お話する。

3
00:00:07,640 --> 00:00:09,890
これはいくらかアドバンスドな概念だが、

4
00:00:09,890 --> 00:00:12,490
ちょくちょく質問される。

5
00:00:12,490 --> 00:00:14,400
だからここで喋っておこうと思う。

6
00:00:14,400 --> 00:00:17,550
だがこれはいくらかアドバンスドな概念なので、

7
00:00:18,600 --> 00:00:23,210
だからおまけの題材と思ってもらって構わない。

8
00:00:23,210 --> 00:00:26,890
あなたがたの内の何人かは、理解しておいたら便利、と思うような

9
00:00:26,890 --> 00:00:29,610
現象が存在し、遭遇しうる事はしうる。

10
00:00:31,340 --> 00:00:32,030
だがそれを理解していなかったからと言って、

11
00:00:33,470 --> 00:00:37,450
正規方程式も線形回帰も

12
00:00:37,450 --> 00:00:39,520
現実に実行出来るしちゃんと機能させられる。

13
00:00:39,520 --> 00:00:45,610
問題はこんなだ：

14
00:00:45,610 --> 00:00:49,580
あなたがたの内の何人かは

15
00:00:49,580 --> 00:00:52,400
線形代数により詳しいだろうが、そのような人達が

16
00:00:52,400 --> 00:00:56,060
私に尋ねてくる事は、

17
00:00:56,060 --> 00:01:00,680
この シータ = (X転置 X)^-1 X転置 Y という式で、

18
00:01:00,680 --> 00:01:04,220
これを計算する時に、

19
00:01:04,220 --> 00:01:05,120
(X転置 X)が非可逆だったらどうしたらいいのか？という事だ。

20
00:01:05,120 --> 00:01:10,978
つまり線形代数に詳しい人達なら、

21
00:01:10,978 --> 00:01:15,720
逆行列を求める事が出来る行列は限られていて、

22
00:01:15,720 --> 00:01:20,260
それ以外の行列は逆行列を持たず、

23
00:01:20,260 --> 00:01:23,910
非正則行列とか非可逆行列とか特異行列とか

24
00:01:23,910 --> 00:01:27,850
縮退した行列（注：日本語ではあまり言われない）などと呼ばれる事がある事を知っているだろう。

25
00:01:27,850 --> 00:01:31,370
(X転置 X)が非正則行列となる問題は

26
00:01:31,370 --> 00:01:35,090
本当に稀にしか起こらないはずだ。

27
00:01:35,090 --> 00:01:37,930
そしてOctaveでは、シータを求める為にこう実装すれば、

28
00:01:37,930 --> 00:01:40,490
これは実は、正しく振舞ってくれる。

29
00:01:40,490 --> 00:01:45,430
ちょっと技術的になり過ぎてると思うので、これ以上詳細には踏み込みたくない。

30
00:01:45,430 --> 00:01:51,000
だけどOctaveには行列の逆行列を計算する二つの関数がある。

31
00:01:51,000 --> 00:01:52,720
一つはpinv()と呼ばれる物で、もう一つはinv()と呼ばれる物。

32
00:01:52,720 --> 00:01:54,450
これら二つの違いは幾らか技術的だ。

33
00:01:54,450 --> 00:01:55,690
一方は擬似逆行列 (pseudo inverse)と呼ばれていて、一方は逆行列(inverse)と呼ばれている。

34
00:01:55,690 --> 00:01:59,090
数学的には以下の事が示せる：pinv()関数を使っている限りは

35
00:01:59,090 --> 00:02:00,740
(X転置 X)が非正則行列でも

36
00:02:00,740 --> 00:02:05,220
望んでいるシータの値を実際に計算してくれる、という事を。

37
00:02:05,220 --> 00:02:08,982
pinv()とinv()の

38
00:02:08,982 --> 00:02:13,140
詳細な違いについては

39
00:02:13,140 --> 00:02:18,400
いくらかアドバンスドな数値計算の概念なので、

40
00:02:18,400 --> 00:02:22,160
ここでは踏み込まない事にする。

41
00:02:22,160 --> 00:02:26,560
だがこのおまけのビデオでは、

42
00:02:26,560 --> 00:02:27,710
X転置 Xが非可逆とはどういう意味かの

43
00:02:27,710 --> 00:02:32,140
ちょっとした感覚的な話をしたい。

44
00:02:32,140 --> 00:02:37,940
線形代数が得意で、こんな話題が

45
00:02:37,940 --> 00:02:46,060
面白い、と思う人達の為に。

46
00:02:46,060 --> 00:02:49,720
数学的に証明はしないが、

47
00:02:49,720 --> 00:02:54,650
X転置 Xが非可逆なのは、

48
00:02:54,650 --> 00:02:58,730
だいたい原因は二つに分けられる：

49
00:02:58,730 --> 00:03:02,753
最初の原因は、学習の問題に関して、なんらかの

50
00:03:02,753 --> 00:03:05,470
冗長なフィーチャーがある、という場合。

51
00:03:05,470 --> 00:03:08,770
具体的には、住居の価格を予測したいとすると、

52
00:03:08,770 --> 00:03:13,430
x1が家の面積を平方フィートで表しているとして、

53
00:03:13,430 --> 00:03:18,350
x2を家のサイズを平方メートルで表しているとする。

54
00:03:18,350 --> 00:03:22,520
こういう場合は、１メートルは少数第2位までで丸めると3.28フィートなのだから、

55
00:03:22,520 --> 00:03:27,850
この二つのフィーチャーはいつも以下の制約を満たす：

56
00:03:27,850 --> 00:03:32,770
x1 = (3.28)^2 * x2 。

57
00:03:32,770 --> 00:03:37,280
そして、これはちょっとアドバンスドな線形代数の話だが、

58
00:03:37,280 --> 00:03:38,350
もしあなたが線形代数のエキスパートなら、

59
00:03:38,350 --> 00:03:42,550
二つのフィーチャーがこのような線形の式の関係を持っていたら、行列 X転置 Xが非可逆となる事が

60
00:03:44,100 --> 00:03:48,490
証明出来るのだ。

61
00:03:48,490 --> 00:03:53,210
二番目に (X転置 X) が非正則行列になる状況は、

62
00:03:53,210 --> 00:03:58,060
大量のフィーチャーに対して

63
00:03:58,060 --> 00:04:02,300
学習アルゴリズムを走らせようとしている時だ。

64
00:04:02,300 --> 00:04:03,990
具体的には、mがn以下の時。

65
00:04:03,990 --> 00:04:07,780
例えば、m=10個のトレーニング手本があって、

66
00:04:07,780 --> 00:04:11,260
n=100個のフィーチャーがあるとしてみよう。

67
00:04:11,260 --> 00:04:15,450
その時はフィッティングしようとしているパラメーターベクトルシータはn+1次元だから

68
00:04:15,450 --> 00:04:20,420
101次元となる。

69
00:04:20,420 --> 00:04:23,660
だからあなたは101個のパラメータを、たった10個のトレーニング手本でフィッティングしようとしている訳だ。

70
00:04:23,660 --> 00:04:27,380
これはうまく行く事も無い訳では無いが、

71
00:04:27,380 --> 00:04:32,625
いつもいいアイデアという訳では無い。

72
00:04:32,625 --> 00:04:37,930
何故なら後で見るように、データが十分に無いから。

73
00:04:37,930 --> 00:04:43,400
100とか101個のパラメータにフィッティングしたいという時に10個の手本しか無いとすると。

74
00:04:43,400 --> 00:04:47,300
このコースで後ほど、何故これがたくさんのパラメータをフィッティングする時に

75
00:04:47,300 --> 00:04:51,290
データとして少なすぎるのかを見ていく事になる。

76
00:04:51,290 --> 00:04:53,050
だが一般的には、その場合に我らがやるのは、もしmがn以下なら、

77
00:04:53,050 --> 00:04:55,330
フィーチャーを幾つか削除するか、正規化と呼ばれるテクニックを

78
00:04:55,330 --> 00:04:58,790
使う事だ。

79
00:04:58,790 --> 00:05:02,430
正規化もこのコースで後でちょっと扱うが、

80
00:05:02,430 --> 00:05:05,770
それもたくさんのフィーチャーを使ってたくさんのパラメータをフィッティングするのを、

81
00:05:05,770 --> 00:05:07,190
相対的に少ないトレーニングセットでも可能にしてくれる手法だ。

82
00:05:07,190 --> 00:05:09,220
だがこの正規化はこのコースの後半のトピックだ。

83
00:05:09,220 --> 00:05:11,640
要約すると、X転置 Xが非正則行列だと、

84
00:05:11,640 --> 00:05:16,050
あるいは非可逆だと分かったら、

85
00:05:16,050 --> 00:05:20,390
あなたにオススメする方法は、

86
00:05:20,390 --> 00:05:22,570
はじめに： フィーチャーを調べて、このx1とx2のように線形に依存しているような

87
00:05:24,050 --> 00:05:26,690
冗長なフィーチャーが無いかを調べる。

88
00:05:26,690 --> 00:05:31,640
線形に依存しているというのは、お互いがお互いの線形関数になってる、と言ってもいい。

89
00:05:31,640 --> 00:05:35,700
そして冗長なフィーチャーがあったら、

90
00:05:35,700 --> 00:05:38,490
これらのフィーチャーのうちの一方を単純に削除してしまえば良い。

91
00:05:38,490 --> 00:05:42,410
これらのフィーチャーは二つは要らない。

92
00:05:42,410 --> 00:05:46,100
だからこれら二つのフィーチャーの一つを単に削除するだけで

93
00:05:46,100 --> 00:05:49,180
非可逆の問題は解決するはずだ。

94
00:05:49,180 --> 00:05:52,420
つまり、まず手始めに、各フィーチャーを見ていって、冗長なフィーチャーが無いかチェックしていって、

95
00:05:52,420 --> 00:05:58,450
もし見つかったら、冗長なフィーチャーを削除していき、