このビデオでは、正規方程式と非可逆性について お話する。 これはいくらかアドバンスドな概念だが、 ちょくちょく質問される。 だからここで喋っておこうと思う。 だがこれはいくらかアドバンスドな概念なので、 だからおまけの題材と思ってもらって構わない。 あなたがたの内の何人かは、理解しておいたら便利、と思うような 現象が存在し、遭遇しうる事はしうる。 だがそれを理解していなかったからと言って、 正規方程式も線形回帰も 現実に実行出来るしちゃんと機能させられる。 問題はこんなだ： あなたがたの内の何人かは 線形代数により詳しいだろうが、そのような人達が 私に尋ねてくる事は、 この シータ = (X転置 X)^-1 X転置 Y という式で、 これを計算する時に、 (X転置 X)が非可逆だったらどうしたらいいのか？という事だ。 つまり線形代数に詳しい人達なら、 逆行列を求める事が出来る行列は限られていて、 それ以外の行列は逆行列を持たず、 非正則行列とか非可逆行列とか特異行列とか 縮退した行列（注：日本語ではあまり言われない）などと呼ばれる事がある事を知っているだろう。 (X転置 X)が非正則行列となる問題は 本当に稀にしか起こらないはずだ。 そしてOctaveでは、シータを求める為にこう実装すれば、 これは実は、正しく振舞ってくれる。 ちょっと技術的になり過ぎてると思うので、これ以上詳細には踏み込みたくない。 だけどOctaveには行列の逆行列を計算する二つの関数がある。 一つはpinv()と呼ばれる物で、もう一つはinv()と呼ばれる物。 これら二つの違いは幾らか技術的だ。 一方は擬似逆行列 (pseudo inverse)と呼ばれていて、一方は逆行列(inverse)と呼ばれている。 数学的には以下の事が示せる：pinv()関数を使っている限りは (X転置 X)が非正則行列でも 望んでいるシータの値を実際に計算してくれる、という事を。 pinv()とinv()の 詳細な違いについては いくらかアドバンスドな数値計算の概念なので、 ここでは踏み込まない事にする。 だがこのおまけのビデオでは、 X転置 Xが非可逆とはどういう意味かの ちょっとした感覚的な話をしたい。 線形代数が得意で、こんな話題が 面白い、と思う人達の為に。 数学的に証明はしないが、 X転置 Xが非可逆なのは、 だいたい原因は二つに分けられる： 最初の原因は、学習の問題に関して、なんらかの 冗長なフィーチャーがある、という場合。 具体的には、住居の価格を予測したいとすると、 x1が家の面積を平方フィートで表しているとして、 x2を家のサイズを平方メートルで表しているとする。 こういう場合は、１メートルは少数第2位までで丸めると3.28フィートなのだから、 この二つのフィーチャーはいつも以下の制約を満たす： x1 = (3.28)^2 * x2 。 そして、これはちょっとアドバンスドな線形代数の話だが、 もしあなたが線形代数のエキスパートなら、 二つのフィーチャーがこのような線形の式の関係を持っていたら、行列 X転置 Xが非可逆となる事が 証明出来るのだ。 二番目に (X転置 X) が非正則行列になる状況は、 大量のフィーチャーに対して 学習アルゴリズムを走らせようとしている時だ。 具体的には、mがn以下の時。 例えば、m=10個のトレーニング手本があって、 n=100個のフィーチャーがあるとしてみよう。 その時はフィッティングしようとしているパラメーターベクトルシータはn+1次元だから 101次元となる。 だからあなたは101個のパラメータを、たった10個のトレーニング手本でフィッティングしようとしている訳だ。 これはうまく行く事も無い訳では無いが、 いつもいいアイデアという訳では無い。 何故なら後で見るように、データが十分に無いから。 100とか101個のパラメータにフィッティングしたいという時に10個の手本しか無いとすると。 このコースで後ほど、何故これがたくさんのパラメータをフィッティングする時に データとして少なすぎるのかを見ていく事になる。 だが一般的には、その場合に我らがやるのは、もしmがn以下なら、 フィーチャーを幾つか削除するか、正規化と呼ばれるテクニックを 使う事だ。 正規化もこのコースで後でちょっと扱うが、 それもたくさんのフィーチャーを使ってたくさんのパラメータをフィッティングするのを、 相対的に少ないトレーニングセットでも可能にしてくれる手法だ。 だがこの正規化はこのコースの後半のトピックだ。 要約すると、X転置 Xが非正則行列だと、 あるいは非可逆だと分かったら、 あなたにオススメする方法は、 はじめに： フィーチャーを調べて、このx1とx2のように線形に依存しているような 冗長なフィーチャーが無いかを調べる。 線形に依存しているというのは、お互いがお互いの線形関数になってる、と言ってもいい。 そして冗長なフィーチャーがあったら、 これらのフィーチャーのうちの一方を単純に削除してしまえば良い。 これらのフィーチャーは二つは要らない。 だからこれら二つのフィーチャーの一つを単に削除するだけで 非可逆の問題は解決するはずだ。 つまり、まず手始めに、各フィーチャーを見ていって、冗長なフィーチャーが無いかチェックしていって、 もし見つかったら、冗長なフィーチャーを削除していき、