इस विडियो में, हम बात करेंगे नोर्मल इक्वेज़न की, जो कुछ लिनीअर रेग्रेशन प्राब्लम्ज़ के लिए, देगी हमें एक बेहतर तरीक़ा हल करने का ऑप्टिमल वैल्यू के लिए पेरमिटर्स थीटा की. वस्तुतः, अब तक अल्गोरिद्म जो हम प्रयोग करते रहे हैं लिनीअर रेग्रेशन के लिए है ग्रेडीयंट डिसेंट जहाँ करने के लिए मिनमायज़ कोस्ट फ़ंक्शन जे ऑफ़ थीटा को, हम लेंगे यह इटरेटिव अल्गोरिद्म जो लेता है बहुत से स्टेप्स, कई इटरेशन्स ग्रेडीयंट डिसेंट की कन्वर्ज होने के लिए ग्लोबल मिनिमम पर. इसके विपरीत, नोर्मल इक्वेज़न देगी हमें एक विधि हल करने के लिए थीटा को ऐनलिटिक्ली, ताकि बजाय चलाने की जरूरत से यह इटरेटिव अल्गोरिद्म, हम कर सकते हैं इसके स्थान पर सिर्फ़ हल थीटा की ऑप्टिमल वैल्यूज़ के लिए एक बार में सब, ताकि मूल रूप से एक ही स्टेप में आपको मिलती हैं ऑप्टिमल वैल्यूज़ वहीं पर. ऐसा होता है कि नॉर्मल इक्वेज़न के हैं कुछ लाभ और कुछ नुकसान, लेकिन पहले हम पहुँचे वहाँ और बात करें कि कब आपको इस्तेमाल करना चाहिए इसे, चलो लेते हैं कुछ अनुभव कि क्या यह विधि करती है. इस सप्ताह के शुरू के उदाहरण के लिए, चलो कल्पना करते हैं, लेते हैं बहुत सरल कॉस्ट फ़ंक्शन जे ऑफ़ थीटा, वह है सिर्फ़ फ़ंक्शन एक रियल नम्बर थीटा का. तो, अब के लिए, कल्पना करें कि थीटा है सिर्फ़ एक स्केलर वैल्यू या कि थीटा है सिर्फ़ एक रो वैल्यू. यह है सिर्फ़ एक नम्बर बजाय एक वेक्टर के. कल्पना कीजिए कि हमारे पास है एक कॉस्ट फ़ंक्शन जे जो है एक क्वाड्रैटिक फ़ंक्शन इस रियल वैल्यू पेरामिटर थीटा का, तो जे ऑफ़ थीटा वैसा दिखता है. ठीक है, कैसे करते हैं आप मिनमायज़ एक क्वाड्रैटिक फ़ंक्शन को? आप में से वे जो जानते हैं थोड़ा बहुत कैल्क्युलस, आप शायद जानते होंगे तरीक़ा एक फ़ंक्शन को न्यूनतम / मिनमायज़ करने का है लें डेरिवेटिव और सेट करें डेरिवेटिव को बराबर ज़ीरो के. तो, आप लेते हैं डेरिवेटिव जे का विद रिस्पेक्ट टु पेरामिटर थीटा. आपको मिलता है कुछ फ़ॉर्म्युला जो मैं डिराइव नहीं करूँगा, आप सेट करते हैं उस डेरिवेटिव को बराबर ज़ीरो के, और यह आपको करने देता है हल थीटा की वैल्यू के लिए जो मिनमायज़ करती है जे ऑफ़ थीटा को. वह था एक आसान केस जब थीटा था सिर्फ़ एक रियल नम्बर. प्रॉब्लम जिसमें हम रुचि रखते हैं, थीटा नहीं है सिर्फ़ एक रियल नम्बर, लेकिन, इसके बजाय, यह है n+1-डिमेन्शनल पेरामिटर वेक्टर, और, एक कॉस्ट फ़ंक्शन जे, एक फ़ंक्शन इस वेक्टर वैल्यू का या थीटा n तक का. और एक कॉस्ट फ़ंक्शन ऐसा दिखता हैं, कुछ स्क्वेर कॉस्ट फ़ंक्शन दाईं तरफ़. कैसे करें हम न्यूनतम / मिनमायज़ इस कॉस्ट फ़ंक्शन जे को? कैल्क्युलस वास्तव में हमें बताता है कि, यदि आप, वह एक ढंग उसे करने का है लें पर्शियल डेरिवेटिव जे का विद रिस्पेक्ट टु प्रत्येक पेरामिटर थीटा जे के बारी बारी से, और तब, सेट करें इन सबको बराबर 0. यदि आप वह करते हैं, और आप हल करते हैं वैल्यूज़ थीटा 0, थीटा 1, आगे थीटा n तक के लिए, तब, यह देगा आपको वे वैल्यूज़ थीटा की जो मिनमायज़ करती हैं कॉस्ट फ़ंक्शन जे को. जहाँ, यदि आप वास्तव में करते हैं कैल्क्युलस और निकलता हैं हल पेरामिटर्स थीटा 0 से थीटा n तक के लिए, डेरिवेशन थोड़ा कठिन हो जाता है. और, मैं करूँगा इस वीडियो में, वास्तव में नहीं करूँगा डेरिवेशन, जो है एक तरह से लम्बा और थोड़ा कठिन, लेकिन मैं क्या करना चाहता हूँ कि सिर्फ़ बताऊँ आपको जो आपको जानने की आवश्यकता है करने के लिए इम्प्लमेंट इस प्रक्रिया को ताकि आप हल कर सकें वैल्यूज़ के लिए थीटा की जो कॉरेस्पॉंड करती हैं जहाँ पार्शियल डेरिवेटिव बराबर है ज़ीरो के. या वैकल्पिक रूप से, या समान रूप से, थीटा की वैल्यूज़ हैं जो न्यूनतम / मिनमायज़ करती हैं कॉस्ट फ़ंक्शन जे ऑफ़ थीटा को. मुझे पता है कि कुछ टिप्पणी जो मैंने की हैं वे समझ आती हैं केवल उन्हें आपमें से जो हैं परिचित कैल्क्युलस से. अत:, लेकिन यदि आप नहीं जानते, यदि आप कम परिचित हैं कैल्क्युलस से, चिंता मत कीजिए इसकी. मैं सिर्फ तुम्हें बताऊँगा जो आपको जानने की आवश्यकता है करने के लिए इम्प्लमेंट इस अल्गोरिद्म को और उससे काम करवाने के लिए. उदाहरण के लिए जो मैं इस्तेमाल करना चाहता हूँ एक लगातार उदाहरण की तरह मान लो कि मेरे पास है m = 4 ट्रेनिंग इग्ज़ाम्पल्ज़. इम्प्लमेंट करने के लिए इस नॉर्मल इक्वेज़न को, मैं क्या करूँगा वह है निम्न. मैं लूँगा मेरा डेटा सेट, तो यहाँ है मेरे चार ट्रेनिंग इग्ज़ाम्पल्ज़. इस केस में मान लो कि, आप जानते हैं, ये चार इग्ज़ाम्पल्ज़ ही हैं मेरे पास. मैं क्या करूँगा कि लूँगा मेरा डेटा सेट और जोड़ूँगा एक अतिरिक्त कॉलम जो कॉरेस्पॉंड करता है मेरे अतिरिक्त फ़ीचर, x0 से, जो हमेशा लेता है यह वैल्यू 1. क्या करुंगा मैं कि मैं तब बनाऊँगा एक मेट्रिक्स जिसे कहूँगा X जो है एक मेट्रिक्स जिसमें मूल रूप से मेरे सारे फ़ीचर्ज़ हैं मेरे ट्रेनिंग डेटा के, अत: पूर्णत: यहाँ है मेरे सारे मेरे फ़ीचर्ज़ और हम लेंगे वे सब नम्बर्ज़ और रखेंगे उन्हें इस मेट्रिक्स "X" में, ठीक है? तो बस, आप जानते हैं, कॉपी करें डेटा एक कॉलम एक समय में और तब मैं करूँगा कुछ समान y's के लिए. मैं लूँगा वैल्यूज़ जो मैं कोशिश कर रहा हूँ प्रिडिक्ट करने की और बनाऊँगा अब एक वेक्टर, ऐसे और कहूँगा उसे एक वेक्टर y. तो X होगी एक m बाई (n+1) - डिमेन्शनल मेट्रिक्स, और y होगा एक m-डिमेन्शनल वेक्टर जहाँ m है संख्या मेरे ट्रेनिंग इग्ज़ाम्पल्ज़ की और n है, n है एक संख्या फ़ीचर्ज़ की, n+1, क्योंकि यह अतिरिक्त फ़ीचर x0 जो मैंने जोड़ा था. अंत में यदि आप लेते हैं आपकी मेट्रिक्स X और आप लेते हैं आपका वेक्टर y, और यदि आप सिर्फ़ कम्प्यूट करते हैं इसे, और सेट करते हैं थीटा बराबर X ट्रान्स्पोज़ X इन्वर्स गुणा X ट्रान्स्पोज़ Y, यह देगा आपको वैल्यू थीटा की जो मिनमायज़ करता हैं आपका कॉस्ट फ़ंक्शन. बहुत कुछ था जो हुआ स्लाइड्स पर और मैं कर के दिखाता हूँ इसे इस्तेमाल करते हुए एक विशेष उदाहरण से एक डेटा सेट के. मुझे सिर्फ़ लिखने दो इसे थोड़ी और जनरल फ़ॉर्म में और फिर मुझे बस, और बाद में इस वीडियो में मैं समझाऊँगा इसे थोड़ा और. यह अभी तक पूरी तरह से स्पष्ट नहीं है कि इसे कैसे करना है. एक जनरल केस में, मान लो हमारे पास है m ट्रेनिंग इग्ज़ाम्पल्ज़ इसलिए X1, Y1 से Xn, Yn और n फ़ीचर्ज़. अत: प्रत्येक ट्रेनिंग इग्ज़ाम्पल x(i) दिख सकता है एक वेक्टर जैसे इस तरह, वह है एक n+1 डिमेन्शनल फ़ीचर वेक्टर. जिस तरह मैं बनाऊँगा मेट्रिक्स "X", यह कहलाती है डिज़ाइन मेट्रिक्स भी है निम्न. प्रत्येक ट्रेनिंग इग्ज़ाम्पल देता है मुझे एक फ़ीचर वेक्टर इस तरह. मान लो, एक प्रकार से n + 1 डिमेन्शनल वेक्टर. जिस तरह मैं बनाऊँगा मेरी डिज़ाइन मेट्रिक्स X है सिर्फ़ बनाना मेट्रिक्स इस तरह. और मैं क्या करूँगा कि लूँगा पहला ट्रेनिंग इग्ज़ाम्पल, तो वह है एक वेक्टर, लें इसका ट्रान्स्पोज़ तो वह बन जाता है ऐसा, आप जानते हैं, लंबा पतला सी चीज़ और बनाता है x1 ट्रान्स्पोज़ पहली रो मेरी डिज़ाइन मेट्रिक्स की. फिर मैं लूँगा मेरा दूसरा ट्रेनिंग इग्ज़ाम्पल, x2, लूँगा उसका ट्रैन्स्पोज़ और रखूँगा उसे दूसरी रो के लिए, X की और इसी तरह आगे, मेरे अंतिम ट्रेनिंग इग्ज़ाम्पल तक. लें उसका ट्रैन्स्पोज, और वह है मेरी अंतिम रो मेरी मेट्रिक्स X की. और, इसलिए, वह बनाता है मेरी मेट्रिक्स X, एक m बाई n + 1 डिमेन्शनल मेट्रिक्स. एक ठोस उदाहरण के जैसे, मान लो मेरे पास है फ़ीचर, वास्तव में फ़ीचर x ज़ीरो के अलावा, जो है हमेशा बराबर 1. तो यदि मेरे फ़ीचर वेक्टर्स x(i) है बराबर 1 के, जो है x0, तब कुछ असली फ़ीचर्ज़, जैसे घर का साइज़, तब मेरी डिज़ाइन मेट्रिक्स, X, होगी बराबर इसके. पहली रो के लिए, मैं मूलत: लूँगा इसे और लूँगा इसका ट्रान्स्पोज़. तो, मुझे मिलेगा 1, और फिर X-1-1. दूसरी रो के लिए, हमें मिलेगा 1 और फिर X-1-2 और तब नीचे 1, और फिर X-1-M. और इसलिए, यह होगी एक m बाई 2-डिमेन्शनल मेट्रिक्स. तो, वह है कि कैसे बनानी है मेट्रिक्स X. और वेक्टर y -- कभी-कभी मैं शायद लिखूँ एक तीर ऊपर डिनोट करने के लिए कि यह एक वेक्टर है, लेकिन बहुधा मैं लिखूँगा इसे सिर्फ़ y, कैसे भी. वेक्टर y मिलता है लेने से सारे लेबल्स, सारी सही क़ीमतें घरों की मेरे ट्रेनिंग सेट में, और सिर्फ़ रखना है उन्हें एक m-डिमेन्शनल वेक्टर में, और वह है y. अंत में, बना लेने पर मेट्रिक्स X और वेक्टर y, हम तब सिर्फ़ कम्प्यूट करते हैं थीटा X'(1/X) x X'Y. मैं सिर्फ़ चाहता हूँ करना मैं सिर्फ़ सुनिश्चित करना चाहता हूँ कि यह इक्वेज़न आपको समझ आयी है और यह कि आप जानते हैं कैसे इसे इम्प्लमेंट करना है. तो, आप जानते हैं, वस्तुत:, क्या है यह X'(1/X)? ठीक है, X'(1/X) है इन्वर्स मेट्रिक्स X'X का. वास्तव में यदि आपको कहना होता कि सेट करें A को बराबर X' x X, तो X' है एक मेट्रिक्स, X' x X देता है आपको एक और मेट्रिक्स, और हम कहते हैं उसे मेट्रिक्स A. तब, आप जानते हैं, X'(1/X) है सिर्फ़ आप लें इस मेट्रिक्स A को और आप इन्वर्ट करें इसे, ठीक है! यह देता है, मान लो 1/A. और तो वह है कि आप कैसे करते हैं इस चीज़ को. आप कम्प्यूट करते हैं X'X और तब आप कम्प्यूट करते हैं इसका इन्वर्स. हमने अभी तक ऑक्टेव के बारे में बात नहीं की है. हम करेंगे वह बाद के वीडियोस के सेट में, लेकिन ओकटेव प्रोग्रैमिंग लैंग्विज में या एक समान व्यू में, और मैट लैब प्रोग्रामिंग लैंग्विज भी समान है. कमांड कम्प्यूट करने के लिए यह मात्रा, X ट्रान्स्पोज़ X इन्वर्स गुणा X ट्रान्स्पोज़ Y, है निम्न तरह से. ओकटेव में X प्राइम है नोटेशन जो आप इस्तेमाल करते हो डिनोट करने के लिए X ट्रान्स्पोज़. और इसलिए, यह इक्स्प्रेशन जो है लाल रंग में बॉक्स, वह है कम्प्यूट करना X ट्रान्स्पोज़ गुणा X. pinv है एक फ़ंक्शन कम्प्यूट करने के लिए इन्वर्स एक मेट्रिक्स का, तो यह कम्प्यूट करता है X ट्रान्स्पोज़ X इन्वर्स, और फिर आप गुणा करते हैं उसे X ट्रान्स्पोज़ से, और आप गुणा करते हैं उसे y से. तो आप समाप्त करते हैं कम्प्यूट करना वह फ़ॉर्म्युला जो मैंने साबित नहीं किया था, लेकिन यह संभव है दिखाना गणितीय रूप से यद्यपि मैं नहीं करूँगा वह यहाँ, कि यह फ़ॉर्म्युला देता है आपको ओप्टिमल वैल्यू थीटा की इस अर्थ में कि यदि आप सेट करते हैं थीटा बराबर इसके, वह है वैल्यू थीटा की जो मिनमायज़ करती है कॉस्ट फ़ंक्शन जे ऑफ़ थीटा लिनीअर रेग्रेशन के लिए. एक आख़िरी जानकारी पहले के वीडियो में. मैंने बात की थी फ़ीचर स्केलिंग की और सुझाव दिया था करने के फ़ीचर को समान रेंज में समान रेंज में स्केल्ज़ की प्रत्येक वैल्यू की. यदि आप इस्तेमाल करते हैं यह नॉर्मल इक्वेज़न विधि तब फ़ीचर स्केलिंग वास्तव में आवश्यक नहीं है और, वास्तव में ठीक है यदि, मान लो, कुछ फ़ीचर X वन है ज़ीरो और एक के बीच में, मान लो, कुछ फ़ीचर X टू है रेंज ज़ीरो से एक हज़ार और कुछ फ़ीचर X थ्री है रेंज ज़ीरो से दस की पॉवर माइनस पाँच और यदि आप इस्तेमाल कर रहे हैं नोर्मल इक्वेज़नज़ विधि यह ठीक है और वहाँ कोई आवश्यकता नहीं है करने की फ़ीचर स्केलिंग, ज़ाहिर है, हालांकि यदि आप इस्तेमाल कर रहे हैं ग्रेडीयंट डिसेंट, तब, फ़ीचर स्केलिंग अभी भी महत्वपूर्ण है. अंत में, कहाँ इस्तेमाल करना चाहिए आपको ग्रेडीयंट डिसेंट और कब आपको इस्तेमाल करनी चाहिए नॉर्मल इक्वेज़न विधि. यहाँ हैं कुछ उनके फायदे और नुकसान. मान लो आपके पास हैं m ट्रेनिंग इग्ज़ाम्पल्ज़ और n फ़ीचर्ज़. एक अलाभ ग्रेडीयंट डिसेंट का है कि, आपको चुननी पड़ती हैं लर्निंग रेट अल्फ़ा. और, अक्सर, इसका मतलब चलाना इसे कुछ समय भिन्न-भिन्न लर्निंग रेट अल्फ़ा के साथ और फिर देखना कि क्या सबसे अच्छा काम करती है. और वह है एक प्रकार से अतिरिक्त काम तथा अतिरिक्त परेशानी. एक अन्य अलाभ ग्रेडीयंट डिसेंट का है कि इसे चाहिए बहुत अधिक इटरेशन्स. अत:, निर्भर करते हुए विस्तृत जानकारी पर, जो इसे धीमी गति का कर सकता है, हालांकि और बहुत सी चीज़ें हैं जैसे कि हम देखेंगे कुछ ही देर में. नॉर्मल इक्वेज़न के लिए, आपको नहीं चुननी पड़ती कोई लर्निंग रेट अल्फ़ा. तो वह, आप जानते हैं, बनाता है इसे वास्तव में सुविधाजनक, बनाता है इसे सरल इम्प्लमेंट करने के लिए. आप सिर्फ़ इसे चलाएँ और अक्सर सिर्फ़ वह काम कर जाता है. और आप को जरूरत नहीं है इटरेट करने की, तो, आपको ज़रूरत नहीं है प्लॉट करने की जे ऑफ़ थीटा या चेक करने की कन्वर्जेन्स या लेने की वे सब अतिरिक्त क़दम. अब तक, संतुलन प्रतीत होता है नॉर्मल इक्वेज़न के पक्ष में. यहाँ हैं कुछ अलाभ नॉर्मल इक्वेज़न के, और कुछ लाभ ग्रेडीयंट डिसेंट के. ग्रेडीयंट डिसेंट को बेहतर काम करता है, तब भी जब आपके पास होते हैं एक बहुत बड़ी संख्या में फ़ीचर्ज़. तो, भले ही आपके पास हों लाखों में फ़ीचर्ज़ आप चला सकते हैं ग्रेडीयंट डिसेंट और यह होगा यथोचित कुशल. यह करेगा कुछ उचित. इसके विपरीत, नोर्मल इक्वेज़न, करने के लिए हल पेरमिटर्स डेटा, हमें आवश्यकता है हल करने की यह टर्म. हमें कम्प्यूट करनी पड़ती है यह टर्म, X ट्रान्स्पोज़, X इन्वर्स. यह मेट्रिक्स X ट्रान्स्पोज़ X. यह है एक n बाई n मेट्रिक्स, यदि आपके पास हैं n फ़ीचर्ज़. क्योंकि, अगर आप देखें डिमेन्शंज़ पर X ट्रान्स्पोज़ की, डिमेन्शंज़ X, आप गुणा करते हैं, जानें कि क्या हैं डिमेन्शंज़ गुणन की मेट्रिक्स X ट्रान्स्पोज़ X है एक n बाई n मेट्रिक्स जहाँ n है संख्या फ़ीचर्ज़ की, और सभी कम्प्यूट करने वाली इम्प्लमेंटेशन्स में कॉस्ट इन्वर्ट करने की मेट्रिक्स को, बढ़ जाती हैं लगभग मेट्रिक्स की डिमेन्शन्स की क्यूब से. अत:, इस इन्वर्स को कम्प्यूट करने की कॉस्ट होती है, लगभग क्यूबिक टाइम. कभी-कभी यह थोड़ा तेज़ होता है तुलना में n क्यूब के, यह है, आप जानते हैं, हमारे उद्देश्य के लिए उसके काफ़ी क़रीब. तो यदि n, फ़ीचर्ज़ की संख्या है बहुत बड़ी, तब कम्प्यूट करना इस मात्रा को धीमी गति से हो सकता है और नॉर्मल इक्वेज़न विधि हो सकती है वास्तव में थोड़ा धीमा. तो यदि n है बड़ा तब मैं शायद अक्सर इस्तेमाल करता हूँ ग्रेडीयंट डिसेंट क्योंकि हम यह नहीं करना चाहते क्यूबिक टाइम में. लेकिन, यदि n अपेक्षाकृत छोटा है, तब नॉर्मल इक्वेज़न शायद दें आपको एक बेहतर ढंग हल करने का पेरामिटर्स के लिए. क्या मतलब है छोटे और बड़े का? ठीक है, यदि n है सौ के लगभग, तब इन्वर्ट करना एक सौ-बाई-सौ मेट्रिक्स है बिना परेशानी के, आधुनिक कम्प्यूटिंग माप दंड से. यदि n एक हजार है, मैं अभी भी नॉर्मल इक्वेज़न विधि का प्रयोग करुँगा. इन्वर्ट करना एक हज़ार-बाई-हज़ार मेट्रिक्स है वास्तव में काफ़ी तीव्र एक आधुनिक कंप्यूटर पर. यदि n दस हजार है, तो मैं सोचना शुरू कर सकता हूँ. इन्वर्ट करना एक दस हज़ार-बाई- दस हज़ार मेट्रिक्स थोड़ा धीरे होने लगता है, और मैं तब शुरू करता हूँ शायद झुकना ग्रेडीयंट डिसेंट की दिशा में, लेकिन शायद पूरा नहीं. n बराबर है दस हज़ार, आप कर सकते हैं एक प्रकार से इन्वर्ट एक दस हज़ार-बाई- दस हज़ार मेट्रिक्स को. लेकिन यदि यह हो जाता है इससे भी काफ़ी बड़ा, तब, मैं शायद इस्तेमाल करूँगा ग्रेडीयंट डिसेंट. तो, यदि n बराबर है दस की पॉवर छः, एक दस लाख फ़ीचर्ज़, तब इन्वर्ट करना एक दस लाख बाई दस लाख मैट्रिक्स होगा बहुत महँगा, और मैं निश्चित रूप से पक्ष में हूँ ग्रेडीयंट डिसेंट के यदि आपके पास हैं उतने फ़ीचर्ज़. तो यथार्थत: कितना बड़ा फ़ीचर्ज़ का सेट होना इससे पहले आप इस्तेमाल करें ग्रेडीयंट डिसेंट, कठिन है कोई एक पक्का नम्बर बताना. लेकिन, मेरे लिए यह है अक्सर क़रीब दस हज़ार जो मैं शायद सोचूँ कि बदलना है ग्रेडीयंट डिसेंट पर या शायद, कोई और अल्गोरिद्म पर जिसके बारे में हम बात करेंगे बाद में इस क्लास में. संक्षेप में, जब तक संख्या फ़ीचर्ज़ की है बहुत बड़ी नहीं, नॉर्मल इक्वेज़न देता है हमें एक बेहतर वैकल्पिक विधि हल करने के लिए पेरामिटर थीटा को. वस्तुतः, जब तक संख्या फ़ीचर्ज़ की है कम 1000 से, आप जानते हैं, मैं करूँगा इस्तेमाल, मैं अक्सर इस्तेमाल करूँगा नॉर्मल इक्वेज़न विधि बजाय, ग्रेडीयंट डिसेंट के. कुछ विचारों का पूर्वावलोकन करने के लिए जिनकी हम बात करेंगे बाद में इस कोर्स में, जैसे हम पहुँचेंगे और अधिक जटिल लर्निंग अल्गोरिद्म्स पर. उदाहरण के लिए, जब हम बात करेंगे क्लैसिफ़िकेशन अल्गोरिद्म की, एक लजिस्टिक रेग्रेशन अल्गोरिद्म जैसे, हम देखेंगे कि वे अल्गोरिद्म वास्तव में... नॉर्मल इक्वेज़न विधि वास्तव में काम नहीं करती उन अधिक परिष्कृत लर्निंग अल्गोरिद्म्स के लिए, और हमें सहारा लेना पड़ेगा ग्रेडीयंट डिसेंट का उन अल्गोरिद्म्स के लिए. तो, ग्रेडीयंट डिसेंट है एक अधिक उपयोगी अल्गोरिद्म जानने के लिए. लिनीअर रेग्रेशन में होंगे एक बड़ी में संख्या फ़ीचर्ज़ और किसी अन्य अल्गोरिद्म में जो हम देखेंगे इस कोर्स में, क्योंकि, उनके लिए, नॉर्मल इक्वेज़न विधि लागू नहीं होती और काम नहीं करती. लेकिन इस विशेष मॉडल लिनीअर रेग्रेशन के लिए नॉर्मल इक्वेज़न दे सकता है आपको एक विकल्प जो हो सकता है अधिक तीव्र, ग्रेडीयंट डिसेंट से. अत:, निर्भर करते हुए विस्तृत जानकारी पर आपके अल्गोरिद्म की, निर्भर करते हुए विस्तृत जानकारी पर आपकी प्रॉब्लम की और कितने फ़ीचर्ज़ हैं जो आपके पास है, दोनों अल्गोरिद्म अच्छी तरह से जानने के लायक हैं.