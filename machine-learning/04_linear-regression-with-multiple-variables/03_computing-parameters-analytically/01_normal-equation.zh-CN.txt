在这段视频中 我们要讲 正规方程 (Normal Equation) 对于某些线性回归问题 用正规方程法求解参数 θ 的最优值更好 用正规方程法求解参数 θ 的最优值更好 用正规方程法求解参数 θ 的最优值更好 具体而言 到目前为止 我们一直在使用的线性回归的算法 是梯度下降法 就是说 为了最小化代价函数 J(θ) 来最小化这个 我们使用的迭代算法 需要经过很多步 也就是说通过多次迭代来计算梯度下降 也就是说通过多次迭代来计算梯度下降 来收敛到全局最小值 相反地 正规方程法提供了一种求 θ 的解析解法 正规方程法提供了一种求 θ 的解析解法 所以与其使用迭代算法 我们可以直接一次性求解θ的最优值 我们可以直接一次性求解θ的最优值 我们可以直接一次性求解θ的最优值 所以说基本上 一步就可以得到优化值 一步就可以得到优化值 正规方程法有一些优点 也有一些缺点 但是在我们讲解这个 和何时使用标准方程之前 让我们先对这个算法有一个直观的理解 让我们先对这个算法有一个直观的理解 我们举一个例子来解释这个问题 我们假设 有一个非常简单的代价函数 J(θ) 我们假设 有一个非常简单的代价函数 J(θ) 它就是一个实数 θ 的函数 它就是一个实数 θ 的函数 所以现在 假设 θ 只是一个标量 或者说 θ 只有一行 它是一个数字 不是向量 假设我们的代价函数 J 是这个实参数 θ 的二次函数 所以 J(θ) 看起来是这样的 那么如何最小化一个二次函数呢? 对于那些了解一点微积分的同学来说 你可能知道 最小化的一个函数的方法是 对它求导 并且将导数置零 对它求导 并且将导数置零 所以对 J 求关于 θ 的导数 我不打算推导那些公式 你把那个导数置零 这样你就可以求得 使得 J(θ) 最小的 θ 值 使得 J(θ) 最小的 θ 值 这是数据为实数的 一个比较简单的例子 在这个问题中 我们感兴趣的是 θ不是一个实数的情况 它是一个n+1维的参数向量 它是一个n+1维的参数向量 并且 代价函数 J 是这个向量的函数 并且 代价函数 J 是这个向量的函数 也就是 θ0 到 θm 的函数 一个代价函数看起来是这样 像右边的这个平方代价函数 我们如何最小化这个代价函数J? 实际上 微积分告诉我们一种方法 实际上 微积分告诉我们一种方法 对每个参数 θ 求 J 的偏导数 对每个参数 θ 求 J 的偏导数 然后把它们全部置零 如果你这样做 并且求出θ0 θ1 一直到θn的值 并且求出θ0 θ1 一直到θn的值 并且求出θ0 θ1 一直到θn的值 这样就能得到能够最小化代价函数 J 的 θ 值 这样就能得到能够最小化代价函数 J 的 θ 值 这样就能得到能够最小化代价函数 J 的 θ 值 如果你真的做完微积分和求解参数 θ0 到 θn 如果你真的做完微积分和求解参数 θ0 到 θn 如果你真的做完微积分和求解参数 θ0 到 θn 如果你真的做完微积分和求解参数 θ0 到 θn 你会发现这个偏微分最终可能很复杂 接下来我在视频中要做的 接下来我在视频中要做的 实际上不是遍历所有的偏微分 实际上不是遍历所有的偏微分 因为这样太久太费事 我只是想告诉你们 你们想要实现这个过程所需要知道内容 你们想要实现这个过程所需要知道内容 这样你就可以解出 偏导数为0时 θ的值 偏导数为0时 θ的值 偏导数为0时 θ的值 换个方式说 或者等价地 这个 θ 能够使得代价函数 J(θ) 最小化 这个 θ 能够使得代价函数 J(θ) 最小化 我发现可能只有熟悉微积分的同学 我发现可能只有熟悉微积分的同学 比较容易理解我的话 比较容易理解我的话 所以 如果你不了解 或者不那么了解微积分 也不必担心 我会告诉你 要实现这个算法并且使其正常运行 你所需的必要知识 举个例子 我想运行这样一个例子 假如说我有 m=4 个训练样本 假如说我有 m=4 个训练样本 为了实现正规方程法 我要这样做 看我的训练集 在这里就是这四个训练样本 在这种情况下 我们假设 这四个训练样本就是我的所有数据 我所要做的是 在我的训练集中加上一列对应额外特征变量的x0 在我的训练集中加上一列对应额外特征变量的x0 在我的训练集中加上一列对应额外特征变量的x0 就是那个取值永远是1的 就是那个取值永远是1的 接下来我要做的是 构建一个矩阵 X 这个矩阵基本包含了训练样本的所有特征变量 这个矩阵基本包含了训练样本的所有特征变量 这个矩阵基本包含了训练样本的所有特征变量 所以具体地说 这里有我所有的特征变量 这里有我所有的特征变量 我们要把这些数字 全部放到矩阵中 X 中 好吧？ 所以只是 每次复制一列的数据 我要对 y 做类似的事情 我要对我们将要预测的值 我要对我们将要预测的值 构建一个向量 像这样的 并且称之为向量 y 所以 X 会是一个 m*(n+1) 维矩阵 所以 X 会是一个 m*(n+1) 维矩阵 y 会是一个 m 维向量 y 会是一个 m 维向量 其中 m 是训练样本数量 n 是特征变量数 n+1 是因为我加的这个额外的特征变量 x0 n+1 是因为我加的这个额外的特征变量 x0 最后 如​​果你用矩阵 X 和向量 y 来计算这个 最后 如​​果你用矩阵 X 和向量 y 来计算这个 最后 如​​果你用矩阵 X 和向量 y 来计算这个 θ 等于 X 转置乘以 X 的逆 乘以 X 转置 乘以 y θ 等于 X 转置乘以 X 的逆 乘以 X 转置 乘以 y X转置 乘以X的逆 乘以X转置 乘以y θ 等于 X 转置乘以 X 的逆 乘以 X 转置 乘以 y 这样就得到能够使得代价函数最小化的 θ 这样就得到能够使得代价函数最小化的 θ 幻灯片上的内容比较多 幻灯片上的内容比较多 我讲解了这样一个数据组的一个例子 让我把这个写成更加通用的形式 让我把这个写成更加通用的形式 在之后的视频中 我会仔细介绍这个方程 以防你不完全清楚要如何做 在一般情况下 假如我们有 m 个训练样本 x(1) y(1) 直到 x(m) y(m) n 个特征变量 所以每一个训练样本 xi 可能看起来像一个向量 像这样一个 n+1 维特征向量 我要构建矩阵 X 的方法 我要构建矩阵 X 的方法 也被称为设计矩阵 如下所示 每个训练样本给出一个这样的特征向量 每个训练样本给出一个这样的特征向量 也就是说 这样的 n+1 维向量 我构建我的设计矩阵 X 的方法 就是构建这样的矩阵 接下来我要做的是将 取第一个训练样本 取第一个训练样本 也就是一个向量 取它的转置 它最后是这样 扁长的样子 让 x1 转置作为我设计矩阵的第一行 然后我要把我的 第二个训练样本 x2 进行转置 让它作为 X 的第二行 进行转置 让它作为 X 的第二行 以此类推 直到最后一个训练样本 取它的转置作为矩阵 X 的最后一行 取它的转置作为矩阵 X 的最后一行 取它的转置作为矩阵 X 的最后一行 这样矩阵 X 就是一个 m*(n+1) 维矩阵 这样矩阵 X 就是一个 m*(n+1) 维矩阵 这样矩阵 X 就是一个 m*(n+1) 维矩阵 举个具体的例子 假如我只有一个特征变量 就是说除了 x0 之外只有一个特征变量 就是说除了 x0 之外只有一个特征变量 而 x0 始终为1 所以如果我的特征向量 xi等于1 也就是x0 和某个实际的特征变量 xi等于1 也就是x0 和某个实际的特征变量 xi等于1 也就是x0 和某个实际的特征变量 比如说房屋大小 那么我的设计矩阵 X 会是这样 第一行 就是这个的转置 第一行 就是这个的转置 所以最后得到1 然后 x(1)1 对于第二行 我们得到1 然后 x(1)2 对于第二行 我们得到1 然后 x(1)2 对于第二行 我们得到1 然后 x(1)2 这样直到1 然后 x(1)m 这样直到1 然后 x(1)m 这样 这就会是一个 m*2 维矩阵 这样 这就会是一个 m*2 维矩阵 所以 这就是如何构建矩阵X 和向量y 所以 这就是如何构建矩阵X 和向量y 有时我可能会在上面画一个箭头 有时我可能会在上面画一个箭头 来表示这是一个向量 但很多时候 我就只写y 是一样的 向量y 是这样求得的 把所有标签 所有训练集中正确的房子价格 所有训练集中正确的房子价格 放在一起 得到一个 m 维向量 y 放在一起 得到一个 m 维向量 y 最后 构建完矩阵 X 和向量 y 最后 构建完矩阵 X 和向量 y 我们就可以通过计算 X转置 乘以X的逆 乘以X转置 乘以y 来得到 θ 我们就可以通过计算 X转置 乘以X的逆 乘以X转置 乘以y 来得到 θ 我们就可以通过计算 X转置 乘以X的逆 乘以X转置 乘以y 来得到 θ 我现在就想确保你明白这个等式 我现在就想确保你明白这个等式 并且知道如何实现它 所以具体来说 什么是 X 的转置乘以 X 的逆？ X的转置 乘以X的逆 是 X转置 乘以X的逆矩阵 X的转置 乘以X的逆 是 X转置 乘以X的逆矩阵 具体来说 如果你令A等于 X转置乘以X 如果你令A等于 X转置乘以X X的转置是一个矩阵 X的转置乘以X 是另一个矩阵 X的转置乘以X 是另一个矩阵 我们把这个矩阵称为 A 那么 X转置乘以X的逆 就是矩阵 A 的逆 那么 X转置乘以X的逆 就是矩阵 A 的逆 也就是 1/A 这就是计算过程 先计算 X转置乘以X 然后计算它的逆 我们还没有谈到Octave 我们将在之后的视频中谈到这个 但是在 Octave 编程语言 但是在 Octave 编程语言 或者类似的 MATLAB 编程语言里 或者类似的 MATLAB编程语言里 计算这个量的命令是基本相同的 X转置 乘以X的逆 乘以X转置 乘以y 的代码命令如下所示 在 Octave 中 X’ 表示 X 转置 在 Octave 中 X’ 表示 X 转置 这个用红色框起来的表达式 计算的是 X 转置乘以 X 计算的是 X 转置乘以 X pinv 是用来计算逆矩阵的函数 pinv 是用来计算逆矩阵的函数 所以这个计算 X转置 乘以X的逆 所以这个计算 X转置 乘以X的逆 然后乘以X转置 再乘以y 然后乘以X转置 再乘以y 然后乘以X转置 再乘以y 这样就算完了这个式子 我没有证明这个式子 尽管我并不打算这么做 但是数学上是可以证明的 这个式子会给出最优的 θ 值 这个式子会给出最优的 θ 值 这个式子会给出最优的 θ 值 就是说如果你令 θ 等于这个 就是说如果你令 θ 等于这个 这个 θ 值会最小化这个线性回归的代价函数 J(θ) 这个 θ 值会最小化这个线性回归的代价函数 J(θ) 这个 θ 值会最小化这个线性回归的代价函数 J(θ) 最后一点 在之前视频中我提到特征变量归一化 在之前视频中我提到特征变量归一化 和让特征变量在相似的范围内的想法 和让特征变量在相似的范围内的想法 将所有的值归一化在类似范围内 如果你使用正规方程法 那么就不需要归一化特征变量 那么就不需要归一化特征变量 实际上这是没问题的 如果某个特征变量 x1 在 0到1的区间 如果某个特征变量 x1 在 0到1的区间 某个特征变量 x2 在0到1000的区间 某个特征变量 x2 在0到1000的区间 某个特征变量 x2 在0到1000的区间 某个特征变量x3 在0到10^-5的区间 某个特征变量x3 在0到10^-5的区间 某个特征变量x3 在0到10^-5的区间 然后如果使用正规方程法 这样就没有问题 不需要做特征变量归一化 但如果你使用梯度下降法 但如果你使用梯度下降法 特征变量归一化就很重要 最后 你何时应该使用梯度下降法 而何时应该使用正规方程法呢？ 这里列举了一些它们的优点和缺点 假如你有 m 个训练样本和 n 个特征变量 假如你有 m 个训练样本和 n 个特征变量 梯度下降法的缺点之一就是 你需要选择学习速率 α 这通常表示需要运行多次 尝试不同的学习速率 α 这通常表示需要运行多次 尝试不同的学习速率 α 然后找到运行效果最好的那个 所以这是一种额外的工作和麻烦 梯度下降法的另一个缺点是 它需要更多次的迭代 因为一些细节 计算可能会更慢 因为一些细节 计算可能会更慢 我们一会儿会看到更多的东西 至于正规方程 你不需要选择学习速率 α 所以就非常方便 也容易实现 你只要运行一下 通常这就够了 并且你也不需要迭代 所以不需要画出 J(θ) 的曲线 所以不需要画出 J(θ 的曲线 来检查收敛性或者采取所有的额外步骤 到目前为止 天平似乎倾向于正规方程法 这里列举一些正规方程法的缺点 和梯度下降法的优点 梯度下降法在有很多特征变量的情况下也能运行地相当好 梯度下降法在有很多特征变量的情况下也能运行地相当好 所以即使你有上百万的特征变量 所以即使你有上百万的特征变量 你可以运行梯度下降法 并且通常很有效 它会正常的运行 相对地 正规方程法 为了求解参数θ 需要求解这一项 为了求解参数θ 需要求解这一项 我们需要计算这项 X转置乘以X的逆 这个 X转置乘以X矩阵 是一个 n*n 的矩阵 如果你有 n 个特征变量的话 因为如果你看一下 X转置乘以X 的维度 因为如果你看一下 X转置乘以X 的维度 因为如果你看一下 X转置乘以X 的维度 你可以发现他们的积的维度 你可以发现他们的积的维度 X转置乘以X 是一个 n*n 的矩阵 X转置乘以X 是一个 n*n 的矩阵 其中 n是特征变量的数量 实现逆矩阵计算所需要的计算量 实现逆矩阵计算所需要的计算量 大致是矩阵维度的三次方 大致是矩阵维度的三次方 因此计算这个逆矩阵需要计算大致 n 的三次方 因此计算这个逆矩阵需要计算大致 n 的三次方 有时稍微比计算 n 的三次方快一些 但是对我们来说很接近 所以如果特征变量的数量 n 很大的话 那么计算这个量会很慢 那么计算这个量会很慢 实际上标准方程法会慢很多 因此如果 n 很大 因此如果 n 很大 我可能还是会使用梯度下降法 因为我们不想花费 n 的三次方的时间 但如果 n 比较小 那么标准方程法可能更好地求解参数 θ 那么怎么叫大或者小呢？ 那么 如果 n 是上百的 那么 如果 n 是上百的 计算百位数乘百位数的矩阵 对于现代计算机来说没有问题 如果 n 是上千的 我还是会使用正规方程法 千位数乘千位数的矩阵做逆变换 对于现代计算机来说实际上是非常快的 但如果 n 上万 那么我可能会开始犹豫 上万乘上万维的矩阵作逆变换 会开始有点慢 此时我可能开始倾向于 此时我可能开始倾向于 梯度下降法 但也不绝对 n 等于一万 你可以 逆变换一个一万乘一万的矩阵 但如果 n 远大于此 我可能就会使用梯度下降法了 所以如果 n 等于10^6 有一百万个特征变量 那么做百万乘百万的矩阵的逆变换 那么做百万乘百万的矩阵的逆变换 就会变得非常费时间 在这种情况下我一定会使用梯度下降法 所以很难给出一个确定的值 来决定何时该换成梯度下降法 来决定何时该换成梯度下降法 但是 对我来说通常是 在一万左右 我会开始考虑换成梯度下降法 在一万左右 我会开始考虑换成梯度下降法 在一万左右 我会开始考虑换成梯度下降法 或者我们将在以后讨论到的其他算法 总结一下 只要特征变量的数目并不大 正规方程是一个很好的 计算参数 θ 的替代方法 具体地说 只要特征变量数量小于一万 具体地说 只要特征变量数量小于一万 我通常使用正规方程法 我通常使用正规方程法 而不使用梯度下降法 预告一下在之后的课程中我们要讲的 预告一下在之后的课程中我们要讲的 随着我们要讲的学习算法越来越复杂 随着我们要讲的学习算法越来越复杂 例如 当我们讲到分类算法 像逻辑回归算法 我们会看到 实际上对于那些算法 并不能使用正规方程法 对于那些更复杂的学习算法 我们将不得不仍然使用梯度下降法 我们将不得不仍然使用梯度下降法 因此 梯度下降法是一个非常有用的算法 可以用在有大量特征变量的线性回归问题 可以用在有大量特征变量的线性回归问题 或者我们以后在课程中 会讲到的一些其他的算法 因为 标准方程法不适合或者不能用在它们上 因为 标准方程法不适合或者不能用在它们上 但对于这个特定的线性回归模型 但对于这个特定的线性回归模型 正规方程法是一个 比梯度下降法更快的替代算法 所以 根据具体的问题 所以 根据具体的问题 以及你的特征变量的数量 这两算法都是值得学习的 【果壳教育无边界字幕组】翻译：竹二个 校对：所罗门捷列夫 审核：Naplesssss