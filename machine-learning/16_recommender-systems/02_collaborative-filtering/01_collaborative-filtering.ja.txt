このビデオでは、 協調フィルタリングと呼ばれる リコメンダーシステム構築のアプローチを議論する。 これから議論するアルゴリズムは とても興味深い性質を 持っていて、それは フィーチャーラーニングと呼ばれている。 それの意味する所は、 これはアルゴリズムが、 なんのフィーチャーを使うかを自分自身で学習しはじめる事を意味する。 こんなデータセットが あるとしよう。 そして各映画ごとに、 誰かがやってきてその映画が どのくらいロマンティックか、 どれだけのアクションが入っているかを教えてくれるとしよう。 でも、想像出来るように、 実際に誰かが 個々の映画を見ていって、 それらがどれくらいロマンティックか、 どれだけのアクションが詰め込まれているかを いちいち教えてもらうのは とても難しく、とても時間がかかり、とても高く付く場合がありうる。 しかもしばしば、フィーチャーは たった2つよりもずっと多く必要となる。 ではこれらのフィーチャーはどこから得たらいいか？ そこでちょっと問題を変更して これらのフィーチャーを知らない データセットを 持っていたとしよう。 つまり我らは、映画の集合と それらをユーザーがどうレートしたのかのデータを 与えられたとする。 だが個々の映画がどのくらいロマンティックか 個々の映画にどのくらいアクションが詰まってるのかは まったく分からないとする、 つまりこれらをはてなマークで置き換えた。 だがここで、ちょっとだけ別の仮定をおこう。 ユーザー一人一人の所におもむく事が出来て、各ユーザーが我らに、 彼らがどれくらいロマンティックな映画が好きか、 どれくらいアクションの映画が好きか、 教えてくれるとしよう。 Aliceはシータ1に関連付けられているとしよう。 Bobはシータ2に。 Carolはシータ3に。 Daveはシータ4に。 そしてこれを使う事としよう、 Aliceは我らに 彼女はロマンティック映画を とても好きだ、と教えてくれて、 だからそこには5を、 そこはx1の係数に対応する、 そしてまたAliceはアクション映画を まったく好きでは無い、とも教えてくれた。だからそこは0とする。 そしてBobも同じような事を言ったとする、 だからシータ2はこんな風になる。 一方Carolは、彼女は アクション映画が大好きだと教えてくれたとする、 だからここが5となっている。 ここはx2の係数に対応する所だ。 そしてまたx0も存在してて それはイコール1なのも思い出そう。 そしてCarolは我らに ロマンティックな映画は嫌いだ、とも、 教えてくれたとしよう。Daveも同様だ。 つまり、どうにかして我らが各ユーザーの元におもむき、 各ユーザーjは我らに シータjの値を 教えてくれたと 想定してみよう。 つまり、基本的には彼らが別々の種類の映画をどのくらい好きかを表明してくれるという事だ。 もし我らはこれらのパラメータ、シータを ユーザーから得る事が出来れば、 各映画のx1とx2の値が幾つかを 推測出来る、という事が 判明する。 例を見てみよう。 映画1を見てみよう。 映画1はフィーチャーベクトルx1に 関連づけられているのだった。 そしてこの映画がLove at lastと呼ばれていたのも知ってるだろうが、ここではそれは無視しよう。 この映画がなんなのか、知らないフリをしよう、 だからこの映画のタイトルを無視しよう。 Aliceがこの映画を好きだ、というのが我らの知っている全てだ。 Bobはこの映画が好きだ。 CarolとDaveはこの映画を嫌ってる。 ではそこから、何が推測出来るだろうか？ フィーチャーベクトルから我らは AliceとBobはロマンティックな映画が 好きだという事を知っている。 だって彼らはここは5だと告げてたのだから。 他方、CarolとDaveは 彼らはロマンティックな映画を 嫌ってる事を我らは知っている。 そして彼らはアクション映画を好んでいる。 つまりそれらがユーザー3と4、つまりCarolとDaveが 我らにくれたパラメーターベクトルなので、 そして映画1はAliceとBobに 好まれていて、 CarolとDaveに嫌われているという事実に基づくと、 我らはこれがロマンティックな映画だと 合理的に結論出来る。 それはたぶん、そんなにアクション映画では無かろう。 この例はちょっと 計算的に単純化してあるが、 我らが真に問うている事は シータ1転置 x1が だいたい5となるような x1とはなんだろう？という事だ。 この5とはAliceのレーティング。 シータ2の転置 x1も だいたいイコール5だ。 そしてシータ3転置 x1は だいたい0に。 これはCarolのレーティングだ。 そしてシータ4転置 x1は だいたいイコール0。 そしてこの事から x1はイコール、 まず切片項の1に 続いて1.0 0.0みたいになる。 それは既知のAlice、Bob、 Carol、Daveの映画に関する 嗜好から、そして彼らがこの映画をどう評価するかの知識から、筋が通ってるように思う。 より一般的には このリストを降りていって、 これらの他の映画のフィーチャーも どんなだったらリーズナブルか見つけようと試みる事が出来る。 このxiを学習するという問題を定式化しよう。 ユーザーが我らに 自分の嗜好を教えてくれるとする。 つまり我らのユーザーが来てくれて、 シータ1からシータnuまでの値を 教えてくれると しよう。 そして映画iに関する フィーチャーベクトルxiを学習したい。 だから我らがやる事は 以下のような最適化問題を解く事だ。 その為、映画iを レーティングしたユーザー全員にわたって インデックスjに関する 和を取りたい。 何故なら我らが学習したいのは 映画iのフィーチャーだからで、それはフィーチャーベクトルxiだ。 だから、そこでやりたい事は この二乗誤差を最小化したい、 つまりフィーチャーxiを ユーザーjが映画iを どうレーティングするかの予測値が 二乗誤差の意味で 実際の値y ij、つまりユーザーjの映画iに対する 実際のレーティングの観測値に近い、 そんなに離れていないように、 フィーチャーxiを 選びたい。 ではまとめの為に、 この項がしている事は、 フィーチャーxiを 以下の条件を満たすように選ぶ。 その条件とは、その映画をレーティングしている 全てのユーザーjに対して、 アルゴリズムが予測するそのユーザーの その映画のレーティングが、実際の値とそんなに離れていないように という条件だ。 離れていないとはユーザーが実際にその映画に対して行ったレーティングからの 二乗誤差の意味でだ。 これが二乗誤差の項だ。 いつも通り、この種の 正規化項を足して、 フィーチャーが大きくなりすぎるのを 防止する事も出来る。 さて、以上が一つの特定の映画の フィーチャーを 学習する方法だが、 我らがやりたいのは、 全ての映画の全てのフィーチャーを 学習する事だ。 だからやるべき事は、この追加の シグマをここに追加して、 n m個の映画全てに渡って和を取る、 n下付き添字m 個の映画について、そしてこの 目的関数を最小化する、 全ての映画についての和の。 それを行うと、結局以下のような最適化の問題となる。 これを最小化すると、 全ての映画についての、 リーズナブルなフィーチャーの集合が得られる事が期待出来る。 全てをあわせると、 我らが前のビデオで議論してきた アルゴリズムと、 このビデオで今議論してきたアルゴリズムは 前のビデオで見てきたのは えーと、 映画のレーティングの集合が あったとすると、 つまりデータr ijとy ij、 それは映画のレーティングだが、それがあったとすると、 別々の映画に対してのフィーチャーが所与であれば、 これらのパラメータ、シータが学習出来る、という事だった。 つまり、もしフィーチャーを知ってたら、 別々のユーザーのパラメータ、シータを 学習する事が出来る。 そしてこのビデオの前半で 見てきたように、 もしユーザーがあなたに 喜んでパラメータを提供してくれれば、 別々の映画のフィーチャーを推計する事が出来る。 つまりこれは、鶏と卵の問題だ。 どっちが先に来る？ シータが得られれば、xを知る事が出来る。 xが分かっていれば、シータを学習出来る。 そこでとりうる手段としては、 そしてこれは実際に うまく行くのだが、それは、 出来る事は、実際にランダムに シータの何らかの値を推測してしまう、という事だ。 この最初のランダムなシータの 推測に基づいて、 前進する事が出来て、 別々の映画のフィーチャーを学習する為に ここまで話してきた手順が 使える事になる。 今、何らかのフィーチャーの初期の値が 映画に対して与えられたとき、 この前回のビデオで話した 最初の手法を用いて パラメータシータの推計を 改善する事が出来る。 いまやユーザーのシータの改善された値を得たので、 それを用いてさらにフィーチャーを 改善した物が得られるかもしれない、 などなど。 ある種の繰り返しを 続ける事で、行ったり来たりする事で、 シータ、x、シータ、x、シータ、xと 最適化をしていく事が出来る。 これは実際に機能する。 これを行うと、これは実際に 映画のフィーチャーと ユーザーごとに異なったパラメータの リーズナブルな組に 収束する。 以上が基本的な協調的フィルタリングのアルゴリズムだ。 これは実際に使う、最終的なアルゴリズムでは 無い。次のビデオで、 このアルゴリズムを 改善する事が出来る。 それでもっとずっと計算量的に効率的になる。 でもこれで、別々の映画から、 パラメータとフィーチャーを 同時に学習する、という問題を どう定式化するかが なんとなく分かったんじゃないかな。 そしてこの問題に関して言うと、 リコメンダーシステムの問題に関して言うと、 これが可能なのは、各ユーザーが 複数の映画をレーティングしていて、 さらに出来たら全ての映画が 複数のユーザーにレーティングされてて初めて可能となる。 つまり、この行ったり来たりして シータとxを推計する手順が使用出来る。 ではまとめよう。 このビデオでは、 最初の協調的フィルタリングのアルゴリズムを見てきた。 協調的フィルタリングという用語は たくさんのユーザーに対して このアルゴリズムを実行した時を観察すると、 全てのユーザーが 事実上、ある種の協調 --またはコラボレーション-- をして、 皆にとってより良い映画のレーティングを得ている事が 観察される事による。何故なら各ユーザーが 映画のサブセットをレーティングする、という行動でもって アルゴリズムがちょっとだけ改善されたフィーチャーを得るのを 各ユーザーが助けているからだ。 そして助ける事で -- 2, 3の映画を自分でレーティングする事で、 私はシステムがより良いフィーチャーを学習するのを助けている事になり、 そしてこれらのフィーチャーを システムがその他全員に対して 映画のよりよい予測を行う為に使う事が出来る。 つまりある種の協調作業が ある訳だ：各ユーザーが、 公共の利益の為に、システムがより良いフィーチャーを 学習するのを手助けする。 これが協調的フィルタリングだ。 そして次のビデオでやる事は、 ここまでやってきたアイデアを 用いて、より良いアルゴリズムの 構築を試みる。 協調フィルタリングにとって もうちょっとだけ良い方法を。