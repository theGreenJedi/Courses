1
00:00:01,060 --> 00:00:02,420
このビデオでは、

2
00:00:02,620 --> 00:00:03,900
協調フィルタリングと呼ばれる

3
00:00:03,970 --> 00:00:06,390
リコメンダーシステム構築のアプローチを議論する。

4
00:00:07,540 --> 00:00:08,880
これから議論するアルゴリズムは

5
00:00:09,180 --> 00:00:10,400
とても興味深い性質を

6
00:00:10,680 --> 00:00:11,830
持っていて、それは

7
00:00:12,120 --> 00:00:13,290
フィーチャーラーニングと呼ばれている。

8
00:00:13,790 --> 00:00:14,800
それの意味する所は、

9
00:00:14,960 --> 00:00:16,270
これはアルゴリズムが、

10
00:00:16,450 --> 00:00:19,010
なんのフィーチャーを使うかを自分自身で学習しはじめる事を意味する。

11
00:00:21,130 --> 00:00:22,100
こんなデータセットが

12
00:00:22,220 --> 00:00:23,440
あるとしよう。

13
00:00:23,720 --> 00:00:25,030
そして各映画ごとに、

14
00:00:25,690 --> 00:00:27,000
誰かがやってきてその映画が

15
00:00:27,320 --> 00:00:28,640
どのくらいロマンティックか、

16
00:00:28,840 --> 00:00:30,550
どれだけのアクションが入っているかを教えてくれるとしよう。

17
00:00:31,680 --> 00:00:32,880
でも、想像出来るように、

18
00:00:33,020 --> 00:00:34,320
実際に誰かが

19
00:00:34,500 --> 00:00:36,390
個々の映画を見ていって、

20
00:00:36,490 --> 00:00:37,860
それらがどれくらいロマンティックか、

21
00:00:38,050 --> 00:00:39,440
どれだけのアクションが詰め込まれているかを

22
00:00:39,700 --> 00:00:40,880
いちいち教えてもらうのは

23
00:00:41,410 --> 00:00:42,570
とても難しく、とても時間がかかり、とても高く付く場合がありうる。

24
00:00:42,660 --> 00:00:44,270
しかもしばしば、フィーチャーは

25
00:00:44,390 --> 00:00:46,760
たった2つよりもずっと多く必要となる。

26
00:00:46,980 --> 00:00:48,130
ではこれらのフィーチャーはどこから得たらいいか？

27
00:00:49,890 --> 00:00:50,920
そこでちょっと問題を変更して

28
00:00:51,500 --> 00:00:53,220
これらのフィーチャーを知らない

29
00:00:53,980 --> 00:00:55,160
データセットを

30
00:00:55,410 --> 00:00:57,980
持っていたとしよう。

31
00:00:58,380 --> 00:00:59,280
つまり我らは、映画の集合と

32
00:00:59,640 --> 00:01:01,140
それらをユーザーがどうレートしたのかのデータを

33
00:01:01,270 --> 00:01:03,550
与えられたとする。

34
00:01:03,760 --> 00:01:05,190
だが個々の映画がどのくらいロマンティックか

35
00:01:05,370 --> 00:01:06,140
個々の映画にどのくらいアクションが詰まってるのかは

36
00:01:06,310 --> 00:01:07,660
まったく分からないとする、

37
00:01:07,820 --> 00:01:09,940
つまりこれらをはてなマークで置き換えた。

38
00:01:11,310 --> 00:01:12,330
だがここで、ちょっとだけ別の仮定をおこう。

39
00:01:13,870 --> 00:01:15,570
ユーザー一人一人の所におもむく事が出来て、各ユーザーが我らに、

40
00:01:15,980 --> 00:01:18,510
彼らがどれくらいロマンティックな映画が好きか、

41
00:01:18,820 --> 00:01:20,040
どれくらいアクションの映画が好きか、

42
00:01:20,220 --> 00:01:22,320
教えてくれるとしよう。

43
00:01:22,830 --> 00:01:26,090
Aliceはシータ1に関連付けられているとしよう。

44
00:01:26,820 --> 00:01:27,470
Bobはシータ2に。

45
00:01:27,910 --> 00:01:28,440
Carolはシータ3に。

46
00:01:28,970 --> 00:01:30,330
Daveはシータ4に。

47
00:01:30,500 --> 00:01:31,530
そしてこれを使う事としよう、

48
00:01:31,780 --> 00:01:33,040
Aliceは我らに

49
00:01:33,380 --> 00:01:35,340
彼女はロマンティック映画を

50
00:01:35,610 --> 00:01:36,960
とても好きだ、と教えてくれて、

51
00:01:37,140 --> 00:01:38,780
だからそこには5を、

52
00:01:39,280 --> 00:01:41,210
そこはx1の係数に対応する、

53
00:01:41,570 --> 00:01:42,680
そしてまたAliceはアクション映画を

54
00:01:42,840 --> 00:01:45,030
まったく好きでは無い、とも教えてくれた。だからそこは0とする。

55
00:01:46,060 --> 00:01:47,190
そしてBobも同じような事を言ったとする、

56
00:01:48,660 --> 00:01:49,770
だからシータ2はこんな風になる。

57
00:01:50,630 --> 00:01:52,460
一方Carolは、彼女は

58
00:01:53,570 --> 00:01:54,720
アクション映画が大好きだと教えてくれたとする、

59
00:01:55,240 --> 00:01:56,450
だからここが5となっている。

60
00:01:56,900 --> 00:01:58,600
ここはx2の係数に対応する所だ。

61
00:01:58,980 --> 00:02:00,160
そしてまたx0も存在してて

62
00:02:01,210 --> 00:02:03,490
それはイコール1なのも思い出そう。

63
00:02:03,770 --> 00:02:05,390
そしてCarolは我らに

64
00:02:05,610 --> 00:02:07,000
ロマンティックな映画は嫌いだ、とも、

65
00:02:07,390 --> 00:02:09,640
教えてくれたとしよう。Daveも同様だ。

66
00:02:09,840 --> 00:02:11,030
つまり、どうにかして我らが各ユーザーの元におもむき、

67
00:02:11,440 --> 00:02:12,830
各ユーザーjは我らに

68
00:02:13,290 --> 00:02:14,600
シータjの値を

69
00:02:15,020 --> 00:02:16,160
教えてくれたと

70
00:02:17,090 --> 00:02:18,870
想定してみよう。

71
00:02:19,450 --> 00:02:22,190
つまり、基本的には彼らが別々の種類の映画をどのくらい好きかを表明してくれるという事だ。

72
00:02:24,060 --> 00:02:25,280
もし我らはこれらのパラメータ、シータを

73
00:02:25,990 --> 00:02:27,890
ユーザーから得る事が出来れば、

74
00:02:28,050 --> 00:02:29,820
各映画のx1とx2の値が幾つかを

75
00:02:29,960 --> 00:02:31,210
推測出来る、という事が

76
00:02:31,310 --> 00:02:33,710
判明する。

77
00:02:34,800 --> 00:02:35,140
例を見てみよう。

78
00:02:35,730 --> 00:02:36,560
映画1を見てみよう。

79
00:02:38,690 --> 00:02:39,790
映画1はフィーチャーベクトルx1に

80
00:02:40,580 --> 00:02:42,050
関連づけられているのだった。

81
00:02:42,890 --> 00:02:45,420
そしてこの映画がLove at lastと呼ばれていたのも知ってるだろうが、ここではそれは無視しよう。

82
00:02:45,770 --> 00:02:46,750
この映画がなんなのか、知らないフリをしよう、

83
00:02:46,870 --> 00:02:49,060
だからこの映画のタイトルを無視しよう。

84
00:02:50,180 --> 00:02:52,270
Aliceがこの映画を好きだ、というのが我らの知っている全てだ。

85
00:02:52,450 --> 00:02:53,110
Bobはこの映画が好きだ。

86
00:02:53,750 --> 00:02:55,370
CarolとDaveはこの映画を嫌ってる。

87
00:02:56,450 --> 00:02:57,450
ではそこから、何が推測出来るだろうか？

88
00:02:57,830 --> 00:02:58,900
フィーチャーベクトルから我らは

89
00:02:58,990 --> 00:03:00,510
AliceとBobはロマンティックな映画が

90
00:03:00,780 --> 00:03:03,190
好きだという事を知っている。

91
00:03:03,700 --> 00:03:05,660
だって彼らはここは5だと告げてたのだから。

92
00:03:06,290 --> 00:03:07,480
他方、CarolとDaveは

93
00:03:08,380 --> 00:03:10,150
彼らはロマンティックな映画を

94
00:03:10,510 --> 00:03:11,920
嫌ってる事を我らは知っている。

95
00:03:12,300 --> 00:03:13,990
そして彼らはアクション映画を好んでいる。

96
00:03:14,730 --> 00:03:16,050
つまりそれらがユーザー3と4、つまりCarolとDaveが

97
00:03:16,340 --> 00:03:18,830
我らにくれたパラメーターベクトルなので、

98
00:03:20,110 --> 00:03:20,950
そして映画1はAliceとBobに

99
00:03:21,390 --> 00:03:22,340
好まれていて、

100
00:03:22,880 --> 00:03:24,120
CarolとDaveに嫌われているという事実に基づくと、

101
00:03:24,340 --> 00:03:26,460
我らはこれがロマンティックな映画だと

102
00:03:26,910 --> 00:03:30,810
合理的に結論出来る。

103
00:03:31,180 --> 00:03:34,240
それはたぶん、そんなにアクション映画では無かろう。

104
00:03:35,290 --> 00:03:36,360
この例はちょっと

105
00:03:36,520 --> 00:03:38,090
計算的に単純化してあるが、

106
00:03:38,260 --> 00:03:40,330
我らが真に問うている事は

107
00:03:40,590 --> 00:03:42,010
シータ1転置 x1が

108
00:03:42,840 --> 00:03:45,370
だいたい5となるような

109
00:03:46,030 --> 00:03:48,940
x1とはなんだろう？という事だ。

110
00:03:49,660 --> 00:03:51,700
この5とはAliceのレーティング。

111
00:03:51,920 --> 00:03:55,360
シータ2の転置 x1も

112
00:03:55,510 --> 00:03:56,660
だいたいイコール5だ。

113
00:03:57,670 --> 00:03:59,100
そしてシータ3転置 x1は

114
00:03:59,310 --> 00:04:02,180
だいたい0に。

115
00:04:03,020 --> 00:04:05,250
これはCarolのレーティングだ。

116
00:04:06,970 --> 00:04:09,780
そしてシータ4転置 x1は

117
00:04:10,740 --> 00:04:11,630
だいたいイコール0。

118
00:04:12,590 --> 00:04:13,520
そしてこの事から

119
00:04:13,770 --> 00:04:16,000
x1はイコール、

120
00:04:16,870 --> 00:04:18,770
まず切片項の1に

121
00:04:19,080 --> 00:04:20,960
続いて1.0 0.0みたいになる。

122
00:04:21,310 --> 00:04:22,390
それは既知のAlice、Bob、

123
00:04:22,790 --> 00:04:24,110
Carol、Daveの映画に関する

124
00:04:24,770 --> 00:04:25,940
嗜好から、そして彼らがこの映画をどう評価するかの知識から、筋が通ってるように思う。

125
00:04:27,700 --> 00:04:29,080
より一般的には

126
00:04:29,220 --> 00:04:30,210
このリストを降りていって、

127
00:04:30,430 --> 00:04:31,520
これらの他の映画のフィーチャーも

128
00:04:31,700 --> 00:04:35,260
どんなだったらリーズナブルか見つけようと試みる事が出来る。

129
00:04:39,160 --> 00:04:41,890
このxiを学習するという問題を定式化しよう。

130
00:04:42,410 --> 00:04:44,220
ユーザーが我らに

131
00:04:44,340 --> 00:04:45,860
自分の嗜好を教えてくれるとする。

132
00:04:46,580 --> 00:04:47,950
つまり我らのユーザーが来てくれて、

133
00:04:48,130 --> 00:04:49,100
シータ1からシータnuまでの値を

134
00:04:49,330 --> 00:04:50,800
教えてくれると

135
00:04:50,890 --> 00:04:52,990
しよう。

136
00:04:53,280 --> 00:04:54,430
そして映画iに関する

137
00:04:54,790 --> 00:04:56,130
フィーチャーベクトルxiを学習したい。

138
00:04:56,540 --> 00:04:58,020
だから我らがやる事は

139
00:04:58,200 --> 00:05:00,830
以下のような最適化問題を解く事だ。

140
00:05:01,220 --> 00:05:02,210
その為、映画iを

141
00:05:02,840 --> 00:05:04,600
レーティングしたユーザー全員にわたって

142
00:05:04,930 --> 00:05:06,280
インデックスjに関する

143
00:05:06,950 --> 00:05:08,340
和を取りたい。

144
00:05:08,750 --> 00:05:10,040
何故なら我らが学習したいのは

145
00:05:10,950 --> 00:05:13,560
映画iのフィーチャーだからで、それはフィーチャーベクトルxiだ。

146
00:05:14,650 --> 00:05:15,660
だから、そこでやりたい事は

147
00:05:15,780 --> 00:05:18,450
この二乗誤差を最小化したい、

148
00:05:19,020 --> 00:05:20,160
つまりフィーチャーxiを

149
00:05:20,420 --> 00:05:22,430
ユーザーjが映画iを

150
00:05:22,900 --> 00:05:25,000
どうレーティングするかの予測値が

151
00:05:25,200 --> 00:05:26,820
二乗誤差の意味で

152
00:05:27,110 --> 00:05:28,170
実際の値y ij、つまりユーザーjの映画iに対する

153
00:05:28,900 --> 00:05:30,130
実際のレーティングの観測値に近い、

154
00:05:30,440 --> 00:05:31,910
そんなに離れていないように、

155
00:05:32,530 --> 00:05:35,330
フィーチャーxiを

156
00:05:35,530 --> 00:05:37,130
選びたい。

157
00:05:38,310 --> 00:05:40,790
ではまとめの為に、

158
00:05:41,040 --> 00:05:42,320
この項がしている事は、

159
00:05:42,840 --> 00:05:44,060
フィーチャーxiを

160
00:05:45,040 --> 00:05:46,590
以下の条件を満たすように選ぶ。

161
00:05:46,960 --> 00:05:48,210
その条件とは、その映画をレーティングしている

162
00:05:48,360 --> 00:05:50,190
全てのユーザーjに対して、

163
00:05:50,860 --> 00:05:52,830
アルゴリズムが予測するそのユーザーの

164
00:05:52,900 --> 00:05:55,490
その映画のレーティングが、実際の値とそんなに離れていないように

165
00:05:56,170 --> 00:05:57,720
という条件だ。

166
00:05:57,810 --> 00:05:59,730
離れていないとはユーザーが実際にその映画に対して行ったレーティングからの

167
00:06:00,000 --> 00:06:02,310
二乗誤差の意味でだ。

168
00:06:03,380 --> 00:06:04,560
これが二乗誤差の項だ。

169
00:06:05,420 --> 00:06:07,200
いつも通り、この種の

170
00:06:07,310 --> 00:06:08,430
正規化項を足して、

171
00:06:08,520 --> 00:06:09,850
フィーチャーが大きくなりすぎるのを

172
00:06:10,300 --> 00:06:11,870
防止する事も出来る。

173
00:06:13,720 --> 00:06:15,610
さて、以上が一つの特定の映画の

174
00:06:15,760 --> 00:06:16,910
フィーチャーを

175
00:06:17,420 --> 00:06:19,140
学習する方法だが、

176
00:06:19,690 --> 00:06:20,480
我らがやりたいのは、

177
00:06:20,740 --> 00:06:22,060
全ての映画の全てのフィーチャーを

178
00:06:22,230 --> 00:06:23,820
学習する事だ。

179
00:06:24,080 --> 00:06:25,050
だからやるべき事は、この追加の

180
00:06:25,240 --> 00:06:26,620
シグマをここに追加して、

181
00:06:26,780 --> 00:06:28,840
n m個の映画全てに渡って和を取る、

182
00:06:29,260 --> 00:06:33,140
n下付き添字m 個の映画について、そしてこの

183
00:06:33,830 --> 00:06:34,670
目的関数を最小化する、

184
00:06:35,010 --> 00:06:37,080
全ての映画についての和の。

185
00:06:37,410 --> 00:06:39,930
それを行うと、結局以下のような最適化の問題となる。

186
00:06:40,950 --> 00:06:42,320
これを最小化すると、

187
00:06:42,890 --> 00:06:44,520
全ての映画についての、

188
00:06:44,680 --> 00:06:47,440
リーズナブルなフィーチャーの集合が得られる事が期待出来る。

189
00:06:48,650 --> 00:06:50,080
全てをあわせると、

190
00:06:50,210 --> 00:06:51,050
我らが前のビデオで議論してきた

191
00:06:51,330 --> 00:06:52,730
アルゴリズムと、

192
00:06:53,180 --> 00:06:54,810
このビデオで今議論してきたアルゴリズムは

193
00:06:55,730 --> 00:06:57,070
前のビデオで見てきたのは

194
00:06:57,180 --> 00:06:58,710
えーと、

195
00:06:58,820 --> 00:06:59,700
映画のレーティングの集合が

196
00:06:59,790 --> 00:07:00,640
あったとすると、

197
00:07:00,640 --> 00:07:03,960
つまりデータr ijとy ij、

198
00:07:04,090 --> 00:07:06,100
それは映画のレーティングだが、それがあったとすると、

199
00:07:08,500 --> 00:07:09,650
別々の映画に対してのフィーチャーが所与であれば、

200
00:07:09,800 --> 00:07:11,800
これらのパラメータ、シータが学習出来る、という事だった。

201
00:07:12,340 --> 00:07:13,110
つまり、もしフィーチャーを知ってたら、

202
00:07:13,830 --> 00:07:15,000
別々のユーザーのパラメータ、シータを

203
00:07:15,650 --> 00:07:16,850
学習する事が出来る。

204
00:07:18,250 --> 00:07:19,770
そしてこのビデオの前半で

205
00:07:19,930 --> 00:07:21,400
見てきたように、

206
00:07:21,790 --> 00:07:22,860
もしユーザーがあなたに

207
00:07:23,000 --> 00:07:25,450
喜んでパラメータを提供してくれれば、

208
00:07:25,560 --> 00:07:28,060
別々の映画のフィーチャーを推計する事が出来る。

209
00:07:29,270 --> 00:07:31,490
つまりこれは、鶏と卵の問題だ。

210
00:07:31,770 --> 00:07:32,290
どっちが先に来る？

211
00:07:32,900 --> 00:07:35,570
シータが得られれば、xを知る事が出来る。

212
00:07:36,060 --> 00:07:38,160
xが分かっていれば、シータを学習出来る。

213
00:07:39,500 --> 00:07:40,500
そこでとりうる手段としては、

214
00:07:40,680 --> 00:07:41,790
そしてこれは実際に

215
00:07:41,910 --> 00:07:43,000
うまく行くのだが、それは、

216
00:07:43,110 --> 00:07:44,530
出来る事は、実際にランダムに

217
00:07:45,170 --> 00:07:47,160
シータの何らかの値を推測してしまう、という事だ。

218
00:07:48,210 --> 00:07:49,200
この最初のランダムなシータの

219
00:07:49,530 --> 00:07:50,630
推測に基づいて、

220
00:07:50,940 --> 00:07:52,530
前進する事が出来て、

221
00:07:53,160 --> 00:07:54,210
別々の映画のフィーチャーを学習する為に

222
00:07:54,460 --> 00:07:55,810
ここまで話してきた手順が

223
00:07:56,060 --> 00:07:57,740
使える事になる。

224
00:07:58,800 --> 00:07:59,990
今、何らかのフィーチャーの初期の値が

225
00:08:00,130 --> 00:08:01,160
映画に対して与えられたとき、

226
00:08:01,240 --> 00:08:02,730
この前回のビデオで話した

227
00:08:03,050 --> 00:08:04,060
最初の手法を用いて

228
00:08:04,130 --> 00:08:06,180
パラメータシータの推計を

229
00:08:06,360 --> 00:08:08,590
改善する事が出来る。

230
00:08:09,560 --> 00:08:12,420
いまやユーザーのシータの改善された値を得たので、

231
00:08:12,860 --> 00:08:13,850
それを用いてさらにフィーチャーを

232
00:08:14,070 --> 00:08:15,140
改善した物が得られるかもしれない、

233
00:08:15,240 --> 00:08:17,110
などなど。

234
00:08:17,380 --> 00:08:18,400
ある種の繰り返しを

235
00:08:18,600 --> 00:08:19,440
続ける事で、行ったり来たりする事で、

236
00:08:19,790 --> 00:08:21,270
シータ、x、シータ、x、シータ、xと

237
00:08:21,560 --> 00:08:24,000
最適化をしていく事が出来る。

238
00:08:24,270 --> 00:08:25,290
これは実際に機能する。

239
00:08:25,410 --> 00:08:26,340
これを行うと、これは実際に

240
00:08:26,800 --> 00:08:28,360
映画のフィーチャーと

241
00:08:28,930 --> 00:08:30,430
ユーザーごとに異なったパラメータの

242
00:08:31,340 --> 00:08:32,650
リーズナブルな組に

243
00:08:32,790 --> 00:08:34,880
収束する。

244
00:08:36,080 --> 00:08:38,870
以上が基本的な協調的フィルタリングのアルゴリズムだ。

245
00:08:39,770 --> 00:08:40,850
これは実際に使う、最終的なアルゴリズムでは

246
00:08:41,020 --> 00:08:42,890
無い。次のビデオで、

247
00:08:43,120 --> 00:08:44,100
このアルゴリズムを

248
00:08:44,790 --> 00:08:45,610
改善する事が出来る。

249
00:08:45,920 --> 00:08:47,430
それでもっとずっと計算量的に効率的になる。

250
00:08:48,390 --> 00:08:49,510
でもこれで、別々の映画から、

251
00:08:49,640 --> 00:08:50,600
パラメータとフィーチャーを

252
00:08:50,680 --> 00:08:51,980
同時に学習する、という問題を

253
00:08:52,040 --> 00:08:52,990
どう定式化するかが

254
00:08:53,930 --> 00:08:57,200
なんとなく分かったんじゃないかな。

255
00:08:58,440 --> 00:08:59,660
そしてこの問題に関して言うと、

256
00:08:59,740 --> 00:09:01,100
リコメンダーシステムの問題に関して言うと、

257
00:09:01,390 --> 00:09:02,950
これが可能なのは、各ユーザーが

258
00:09:03,490 --> 00:09:04,840
複数の映画をレーティングしていて、

259
00:09:05,100 --> 00:09:06,410
さらに出来たら全ての映画が

260
00:09:06,790 --> 00:09:08,710
複数のユーザーにレーティングされてて初めて可能となる。

261
00:09:09,280 --> 00:09:10,150
つまり、この行ったり来たりして

262
00:09:10,270 --> 00:09:11,150
シータとxを推計する手順が使用出来る。

263
00:09:11,200 --> 00:09:14,400
ではまとめよう。

264
00:09:14,830 --> 00:09:15,910
このビデオでは、

265
00:09:16,140 --> 00:09:18,710
最初の協調的フィルタリングのアルゴリズムを見てきた。

266
00:09:19,680 --> 00:09:21,550
協調的フィルタリングという用語は

267
00:09:22,020 --> 00:09:23,620
たくさんのユーザーに対して

268
00:09:23,760 --> 00:09:25,020
このアルゴリズムを実行した時を観察すると、

269
00:09:25,210 --> 00:09:26,790
全てのユーザーが

270
00:09:26,960 --> 00:09:28,410
事実上、ある種の協調

271
00:09:29,070 --> 00:09:31,300
--またはコラボレーション-- をして、

272
00:09:31,490 --> 00:09:32,770
皆にとってより良い映画のレーティングを得ている事が

273
00:09:33,010 --> 00:09:34,610
観察される事による。何故なら各ユーザーが

274
00:09:34,840 --> 00:09:36,540
映画のサブセットをレーティングする、という行動でもって

275
00:09:37,350 --> 00:09:39,040
アルゴリズムがちょっとだけ改善されたフィーチャーを得るのを

276
00:09:39,300 --> 00:09:41,490
各ユーザーが助けているからだ。

277
00:09:42,900 --> 00:09:44,390
そして助ける事で --

278
00:09:44,490 --> 00:09:46,690
2, 3の映画を自分でレーティングする事で、

279
00:09:47,810 --> 00:09:49,550
私はシステムがより良いフィーチャーを学習するのを助けている事になり、

280
00:09:49,680 --> 00:09:50,750
そしてこれらのフィーチャーを

281
00:09:50,930 --> 00:09:52,610
システムがその他全員に対して

282
00:09:52,890 --> 00:09:54,380
映画のよりよい予測を行う為に使う事が出来る。

283
00:09:54,640 --> 00:09:55,450
つまりある種の協調作業が

284
00:09:55,530 --> 00:09:56,980
ある訳だ：各ユーザーが、

285
00:09:57,370 --> 00:09:58,980
公共の利益の為に、システムがより良いフィーチャーを

286
00:09:59,360 --> 00:10:00,740
学習するのを手助けする。

287
00:10:00,810 --> 00:10:03,450
これが協調的フィルタリングだ。

288
00:10:04,070 --> 00:10:04,990
そして次のビデオでやる事は、

289
00:10:05,140 --> 00:10:07,490
ここまでやってきたアイデアを

290
00:10:07,740 --> 00:10:08,850
用いて、より良いアルゴリズムの

291
00:10:09,090 --> 00:10:09,910
構築を試みる。

292
00:10:10,170 --> 00:10:11,920
協調フィルタリングにとって

293
00:10:12,180 --> 00:10:13,640
もうちょっとだけ良い方法を。