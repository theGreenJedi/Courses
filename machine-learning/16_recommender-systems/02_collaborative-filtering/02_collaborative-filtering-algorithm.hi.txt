पिछले कुछ विडीओज़ में, हमने बात की सुझावों की कि कैसे, पहले, यदि आपको दिए हैं फ़ीचर्ज़ मूवीज़ के, आप कर सकते हैं इस्तेमाल उन्हें लर्न करने के लिए पेरमिटर्स डेटा यूज़र्ज़ के लिए. और दूसरे, यदि आपको दिए हैं पेरमिटर्स यूज़र्ज़ के , तो आप कर सकते हैं इस्तेमाल उन्हें लर्न करने के लिए फ़ीचर्ज़ मूवीज़ के. इस विडीओ में हम लेंगे उन सुझावों को और रखेंगे उन्हें एक साथ बनाने के लिए कलैबरटिव फ़िल्टरिंग अल्गोरिद्म. अत: एक काम जो हमें कर पाए पहले वह है कि यदि आपके पास हैं फ़ीचर्ज़ मूवीज़ के लिए तब आप हल कर सकते हैं यह मिनीमाईज़ेशन प्रॉब्लम जानने के लिए पेरमिटर्स थीटा आपके यूज़र्ज़ के लिए. और तब हमने यह भी किया कि यदि आपको दिए हैं पेरमिटर्सज़ थीटा, आप उसको भी इस्तेमाल करके अनुमान लगा सकते हो फ़ीचर एक्स का, और आप कर सकते हैं वैसा हल करके यह मिनीमाईज़ेशन प्रॉब्लम. इसलिए एक काम जो आप कर सकते हैं वास्तव में कि जाएँ पीछे और आगे. शायद रेंडम / क्रमरहित ईनिशीयलाईज़ करें पेरमिटर्स को और तब हल करें थीटा के लिए, हल करें  एक्स के लिए, हल करें थीटा के लिए, हल करें  एक्स के लिए. लेकिन ऐसा है कि यहाँ है एक अधिक कार्यक्षम  अल्गोरिद्म जिसे नहीं है आवश्यकता जाने की पीछे और आगे बीच में एक्स के और थीटा के, लेकिन वह हल कर सकता है थीटा और एक्स के लिए एक साथ. और यहाँ है यह. हम क्या करेंगे कि मूलत: लेंगे ये दोनों ऑप्टिमायज़ेशन ओबजेक्टिव्स, और रखेंगे उनको एक ही अब्जेक्टिव में. तो मैं करूँगा परिभाषित नया ऑप्टिमायज़ेशन ओबजेक्टिव जे, जो है एक कॉस्ट फ़ंक्शन, वह है एक फ़ंक्शन मेरे फ़ीचर्ज़ एक्स का और एक फ़ंक्शन मेरे पेरमिटर्स थीटा का. और यह मूलत: है दो ऑप्टिमायज़ेशन ओबजेक्टिव्स जो मेरे पास ऊपर थे, लेकिन मैंने उन्हें एक साथ रखा है. इसलिए करने के लिए स्पष्ट इसे, पहले, मैं चाहता हूँ दिखाना कि यह यह टर्म यहाँ पर, यह स्क्वेर्ड एरर टर्म, है वही जो स्क्वेर्ड एरर टर्म थी और समेशन्स दिखते है थोड़े अलग, लेकिन चलिए देखते हैं समेशन्स वास्तव में क्या कर रहे हैं. पहला समेशन है सम सारे यूज़र्ज़ जे पर और फिर सम सारी मूवीज़ पर जो रेट की हैं उस यूज़र ने. तो, यह वास्तव में हैं सम करना सारे जोड़े आइ जे पर, जो कॉरेस्पॉंड करते हैं एक मूवी जो रेट की थी एक यूज़र ने. जे पर सम कहता है, प्रत्येक यूज़र के लिए, सम सारी मूवीज़ का जो उस यूज़र ने रेट की हैं. यह समेशन नीचे यहाँ, करता हैं यह काम केवल विपरीत क्रम में. यह बताता है प्रत्येक मूवी आइ के लिए, सम सारे यूज़र्ज़ जे का जिन्होंने किया है रेट उस मूवी को और इसलिए, आप जानते हैं ये समेशन्स,  ये दोनो हैं केवल समेशन्स सारे जोड़ों आई जे पर जिनके लिए आर आइजे का है बराबर 1 के. यह है केवल समेशन सारे यूज़र मूवी जोड़े पर जिनके लिए आपके पास रेटिंग है. और इसलिए, वे दो टर्म्स ऊपर वहाँ हैं केवल बिलकुल यह पहली टर्म के जैसे, और मैंने केवल लिखा समेशन यहाँ स्पष्ट रूप से. जहाँ मैं सिर्फ़ कह रहा हूँ कि सम सारे जोड़े आईजे पर, ताकि आर आइ जे का बराबर हो 1 के. तो हम क्या करेंगे कि परिभाषित करेंगे एक संयुक्त ऑप्टिमायज़ेशन ओबजेक्टिव जो हम करना चाहते हैं मिनमायज़ / न्यूनतम करने के लिए हल एक साथ एक्स और थीटा. और तब दूसरी टर्मज़ ऑप्टिमायज़ेशन ओबजेक्टिव में हैं यह, जो है एक रेग्यूलराईज़ेशन थीटा की टर्म्स में. तो वह नीचे आया यहाँ और अंतिम भाग है यह टर्म जो है मेरा ऑप्टिमायज़ेशन ओबजेक्टिव एक्स के लिए और वह बन गया यह. और यह ऑप्टिमायज़ेशन ओबजेक्टिव जे का वास्तव में हैं दिलचस्प गुण कि यदि आप रखें एक्स को कॉन्स्टंट और सिर्फ़ मिनमायज़ करें विद रिस्पेक्ट टु थीटाज़ तब आप हल कर रहे होंगे बिलकुल यही प्रॉब्लम, जबकि यदि आपको करना हो इसके विपरीत, यदि आप रखें थीटाज़ को कॉन्स्टंट, और मिनमायज़ करें जे को केवल विद रिस्पेक्ट टु एक्स, तब यह बन जाता है समतुल्य इसके. क्योंकि या तो यह टर्म या यह टर्म है कॉन्स्टंट यदि आप कर रहे हैं मिनमायज़ सिर्फ़ विद रिस्पेक्ट टु एक्स या सिर्फ़ विद रिस्पेक्ट टू थीटाज़. तो यहाँ है एक ऑप्टिमायज़ेशन अब्जेक्टिव जो रखता हैं एक साथ मेरा कॉस्ट फ़ंक्शनज़ एक्स के टर्म्ज़ में और थीटा की टर्म्ज़ में. और बनाने के लिए केवल एक ऑप्टिमायज़ेशन प्रॉब्लम, हम क्या करेंगे कि ब्यवहार करेगे / देखेंगे इस कॉस्ट फ़ंक्शन को, एक फ़ंक्शन की तरह मेरे फ़ीचर्ज़ एक्स का और मेरे यूज़र यूज़र पेरामिटरज़ थीटा का और केवल मिनमायज़ करेंगे इस पूरे को, एक फ़ंक्शन दोनो एक्स के और थीटाज़ के एक फ़ंक्शन की तरह॰ और वास्तव में केवल अंतर बीच में इसके और पुराने अलगोरिद्म में केवल यह है कि, बजाय जाने के पीछे और आगे, पहले हमने बात की मिनमायज़ करने की विद रिस्पेक्ट टु थीटा तब मिनमायज़ करेंगे विद रिस्पेक्ट टु एक्स, जब मिनमायज़ कर रहे थे विद रिस्पेक्ट टु थीटा, मिनमायज़ कर रहे थे विद रिस्पेक्ट टु एक्स और इसी प्रकार आगे. इस नए वर्ज़न में बजाय क्रम से जाने के बीच में 2 सेट पेरामिटर एक्स और थीटा के, हम क्या करेंगे कि मिनमायज़ करेंगे विद रिस्पेक्ट दोनो पेरमिटर्स के सेट से एक साथ. अंत में एक आख़िरी जानकारी है कि जब हम कर रहे हैं लर्न फ़ीचर्ज़ इस प्रकार. पहले हम प्रयोग करते रहे हैं यह कन्वेन्शन कि हमारे पास है एक फ़ीचर एक्स0 बराबर एक के जो कॉरेस्पॉंड करता है एक इंटर्सेप्टर को. जब हम इस्तेमाल कर रहे है इस प्रकार के फ़ॉर्मलिज़म का जब हम वास्तव में लर्न कर रहे हैं फ़ीचर्ज़, हम वास्तव में समाप्त करने वाले हैं इस कन्वेन्शन को. और इसलिए फ़ीचर्ज़ एक्स जो हम लर्न करेंगे, होंगे आर एन में. जबकि पहले जब हमारे पास थे फ़ीचर्ज़ एक्स और आर एन +1 थे इंटर्सेप्ट टर्म को मिला कर. हटाने से एक्स 0 अब हमारे पास हैं केवल एक्स आर एन में. और इसी प्रकार, क्योंकि पेरमिटर्स थीटा हैं उसी डिमेन्शन में, हमारे पास अब थीटा भी है आर एन में क्योंकि अगर नहीं है एक्स 0, तब कोई आवश्यकता नहीं है पेरामिटर थीटा 0 की भी. और कारण कि हम समाप्त कर रहे हैं यह कन्वेन्शन है क्योंकि अब हम लर्न कर रहे हैं सारे फ़ीचर्ज़, सही? अत: कोई आवश्यकता नहीं है हार्ड कोड करने की फ़ीचर जो हमेशा बराबर एक है. क्योंकि यदि अल्गोरिद्म को वास्तव में चाहिए एक फ़ीचर जो है हमेशा बराबर 1 के, वह लर्न कर सकता है उसे अपने लिए. अत: यदि अल्गोरिद्म चाहता है, यह सेट कर सकता है फ़ीचर एक्स 1 बराबर 1 के. अत: कोई आवश्यकता नहीं है हार्ड कोड करने की फ़ीचर एक्स 0 जो है 1, अल्गोरिद्म के पास अब विकल्प है उसे अपने आप लर्न करने का. अत: रखते हुए सब एक साथ, यहाँ है हमारा कलैबरटिव फ़िल्टरिंग अल्गोरिद्म. पहले हम करेंगे ईनिशीयलाइज एक्स को और थीटा को कुछ छोटी रैंडम वैल्यूज़ से. और यह है थोड़ा न्यूरल नेटवर्क ट्रेनिंग जैसे, जहाँ वहाँ भी हम कर रहे थे ईनिशीयलाइज न्यूरल नेटवर्क के सभी पेरमिटर्स को छोटी रैंडम वैल्यूज़ से. आगे हम तब करेंगे मिनमायज़ कोस्ट फ़ंक्शन को प्रयोग करते हुए ग्रेट इंटर्सेप्ट्स या कोई एक एडवांस्ड ऑप्टिमायज़ेशन अल्गोरिद्म. अत:, यदि आप लें डेरिवेटिव आपको मिलेगा ग्रेट इंटर्सेप्ट इन जैसे और इसलिए यह टर्म यहाँ है पर्शियल डेरिवेटिव कॉस्ट फ़ंक्शन का, मैं उसे नहीं लिखूँगा, विद रिस्पेक्ट टु फ़ीचर वैल्यू एक्स आइ के और इसी प्रकार यह टर्म भी यहाँ है एक पर्शियल डेरिवेटिव वैल्यू कॉस्ट फ़ंक्शन की विद रिस्पेक्ट टु पेरामिटर थीटा जो हम मिनमायज़ कर रहे हैं. और सिर्फ़ आपको याद कराने के लिए, इस फ़ॉर्म्युला में जिसमें हमारे पास नहीं है अब यह एक्स 0 बराबर है 1 और इसलिए हमारे पास है वह एक्स आर एन में और थीटा आर एन में इस नए फ़ॉर्मलिज़म में, हम रेग्युलराइज़ कर रहे हैं हमारा प्रत्येक पेरामिटरज़ थीटा, आप जानते हैं, हमारा प्रत्येक पेरामिटरज़ एक्स एन. अब नहीं है विशेष केस थीटा ज़ीरो, जो की गई थी रेग्युलराइज़ अलग तरह से, या जो नहीं की गई थी रेग्युलराइज़ तुलनात्मक रूप में पेरामिटर थीटा 1 से लेकर नीचे थीटा एन तक. अत: अब नहीं है एक थीटा 0, जिसकी वजह से इन अप्डेट्स में मैंने नहीं अलग किया विशेष केस फॉर के बराबर है 0. अत: तब हम करतें हैं इस्तेमाल ग्रेडीयंट डिसेंट मिनिमाईज़ करने के लिए कॉस्ट फ़ंक्शन जे को विद रिस्पेक्ट टु फ़ीचरज़ एक्स और विद रिस्पेक्ट टु पेरामिटरज़ थीटा. और अंत में, दिया होने पर एक यूज़र, यदि एक यूज़र के हैं कुछ पेरमिटर्स, थीटा, और यदि है एक मूवी कुछ प्रकार के लर्न किए हुए फ़ीचर्ज़ एक्स के साथ हम तब प्रिडिक्ट करेंगे कि उस मूवी को दी जाएगी एक स्टॉर रेटिंग उस यूज़र द्वारा थीटा ट्रैन्स्पोज़ जे से. या सिर्फ़ उनको भर लेने के लिए, तब हम कहते हैं कि यदि यूज़र जे ने अभी नहीं किया है रेट मूवी आइ को, तब हम करेंगे प्रिडिक्ट कि यूज़र जे करेगा रेट मूवी आइ को थीटा जे ट्रैन्स्पोज़ एक्स आइ जैसे. तो वह है कलैबरटिव फ़िल्टरिंग अल्गोरिद्म और यदि आप इम्प्लमेंट करते हैं इस अल्गोरिद्म को तो आपको वास्तव में मिल सकता है एक बहुत उपयोगी लर्निंग अल्गोरिद्म जो करेगा एक साथ अच्छे फ़ीचर्ज़ लर्न आशा है सारी मूवीज़ के लिए तथा लर्न करेगा पेरमिटर्स भी सारे यूज़र्ज़ के लिए और आशा है देगा काफ़ी अच्छी प्रिडिक्शनज़ कि कैसे विभिन्न यूज़र्ज़ रेट करेंगे विभिन्न मूवीज़ को जो उन्होंने अभी तक रेट नहीं की हैं.