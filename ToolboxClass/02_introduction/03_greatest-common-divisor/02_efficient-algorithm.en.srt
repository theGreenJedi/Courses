1
00:00:02,713 --> 00:00:05,390
Hello everybody, welcome back.

2
00:00:05,390 --> 00:00:08,080
Today we're going to be talking a little
bit more about computing greatest

3
00:00:08,080 --> 00:00:10,040
common divisors.

4
00:00:10,040 --> 00:00:10,840
In particular today,

5
00:00:10,840 --> 00:00:14,010
we're going to be talking about a much
more efficient algorithm than last time.

6
00:00:14,010 --> 00:00:17,200
This is know as the Euclidean Algorithm,
we'll talk about that and

7
00:00:17,200 --> 00:00:20,170
we'll talk a little bit
about how its runtime works.

8
00:00:21,620 --> 00:00:26,120
Just to recall for integers, a and
b, their greatest common divisor

9
00:00:26,120 --> 00:00:28,880
is the biggest integer d
that divides both of them.

10
00:00:30,150 --> 00:00:32,490
What we'd like to do is we'd
like to be able to compute this,

11
00:00:32,490 --> 00:00:34,800
given two integers we want
to compute their GCD.

12
00:00:36,460 --> 00:00:39,780
We found a bad algorithm for
this and we'd like a better one.

13
00:00:39,780 --> 00:00:43,060
It turns out that in order
to find a better algorithm,

14
00:00:43,060 --> 00:00:45,360
you need to know something interesting.

15
00:00:45,360 --> 00:00:46,870
There's this Key Lemma that we have,

16
00:00:48,040 --> 00:00:52,458
where suppose that we let a' be
the remainder when a is divided by b,

17
00:00:52,458 --> 00:00:58,241
then the gcd(a,b) is actually
the same as the gcd(a',b),

18
00:00:58,241 --> 00:01:04,230
and also the same as the 
gcd(b, a').

19
00:01:04,230 --> 00:01:08,510
The proof of this, once you know what to
prove, is actually not very difficult.

20
00:01:08,510 --> 00:01:12,010
The idea is that because
a' is a remainder,

21
00:01:12,010 --> 00:01:17,800
this means a is equal to a' plus some
multiple of b plus b times q, for some q.

22
00:01:19,710 --> 00:01:22,560
From that you can show that
if d divides both a and

23
00:01:22,560 --> 00:01:27,270
b, that happens if, and only if,
it divides both a' and b.

24
00:01:27,270 --> 00:01:34,000
Because, for example, if d divides a' and
b, it divides a' plus bq, which is a.

25
00:01:36,010 --> 00:01:39,520
From this statement,
we know that the common divisors of a and

26
00:01:39,520 --> 00:01:44,310
b are exactly the same as
the common divisors of a' and b.

27
00:01:44,310 --> 00:01:46,560
Therefore, the greatest
common divisor of a and

28
00:01:46,560 --> 00:01:49,071
b is the greatest common divisor of a' and
b.

29
00:01:50,610 --> 00:01:51,890
This is the idea for the algorithm.

30
00:01:52,930 --> 00:01:58,736
Basically, we have the gcd(a,b)
is the same as the gcd(b,a'),

31
00:01:58,736 --> 00:02:01,760
but a' is generally smaller than a.

32
00:02:01,760 --> 00:02:05,920
If we compute that new GCD recursively,
hopefully that will be an easier problem.

33
00:02:07,600 --> 00:02:10,210
Now, we do need a base case for this, so

34
00:02:10,210 --> 00:02:13,170
we're going to start off by
saying if b is equal to zero,

35
00:02:14,540 --> 00:02:18,700
everything divides zero, so we just
need the biggest thing that divides a.

36
00:02:18,700 --> 00:02:20,670
We're going to return a in that case.

37
00:02:22,310 --> 00:02:27,810
Otherwise, we're going to let a' be
the remainder when a is divided by b, and

38
00:02:27,810 --> 00:02:32,154
we're going to return the gcd(b,a'),
computed recursively.

39
00:02:34,060 --> 00:02:37,540
By the Lemma that we just gave,
if this ever returns an answer,

40
00:02:37,540 --> 00:02:40,040
it will always give the correct answer.

41
00:02:40,040 --> 00:02:43,250
At the moment, we don't even know
that it will necessarily terminate,

42
00:02:43,250 --> 00:02:45,560
much less do so
in any reasonable amount of time.

43
00:02:47,430 --> 00:02:49,310
Let's look at an example.

44
00:02:49,310 --> 00:02:58,390
Suppose that we want to compute
the gcd(3918848,1653264).

45
00:02:58,390 --> 00:03:04,470
So b here is not zero,
we divide a by b, we get a remainder

46
00:03:04,470 --> 00:03:09,860
that's something like 612000, and
now we have a new GCD problem to solve.

47
00:03:11,100 --> 00:03:18,543
Once again, b is not zero, we divide a by
b, we get a new remainder of 428,000 some.

48
00:03:18,543 --> 00:03:23,290
We repeat this process, gives us
a remainder of 183,000 some, 61,000 some.

49
00:03:23,290 --> 00:03:25,250
Divide again we get a remainder of zero.

50
00:03:26,400 --> 00:03:29,940
And now b is 0, so we return the answer,

51
00:03:29,940 --> 00:03:34,510
61232, and this is the right answer.

52
00:03:34,510 --> 00:03:39,980
You'll note though, this thing took us
six steps to get to the right answer.

53
00:03:39,980 --> 00:03:42,380
Whereas, if we'd used
the algorithm from last time,

54
00:03:42,380 --> 00:03:46,969
we would've had to check something like 5
million different possible common divisors

55
00:03:47,990 --> 00:03:49,100
to find the best one.

56
00:03:51,350 --> 00:03:56,780
This it turns out is a lot better, and to
get a feel of how well this thing works,

57
00:03:56,780 --> 00:04:01,700
or why it works well, every time we take
one of these remainders with division,

58
00:04:01,700 --> 00:04:05,069
we reduce the size of the number
involved by a factor of about 2.

59
00:04:06,180 --> 00:04:10,627
And if every step were reducing
things by a factor of two,

60
00:04:10,627 --> 00:04:16,279
after about log(ab) many steps,
our numbers are now tiny or zero, and

61
00:04:16,279 --> 00:04:22,879
so, basically after log(ab) many steps,
this algorithm is going to terminate.

62
00:04:22,879 --> 00:04:27,763
This means that, suppose that we want
to compute GCDs of 100-digit numbers,

63
00:04:27,763 --> 00:04:30,920
this is only going to take
us about 600 steps to do it.

64
00:04:30,920 --> 00:04:35,445
Each of the steps that we've used here
is a single division with remainder,

65
00:04:35,445 --> 00:04:39,547
600 divisions with remainder is
something you can do trivially,

66
00:04:39,547 --> 00:04:41,330
on any reasonable computer.

67
00:04:43,140 --> 00:04:47,110
This algorithm will compute
quite large GCDs very quickly.

68
00:04:49,030 --> 00:04:52,840
In summary, once again,
we had this computational problem.

69
00:04:52,840 --> 00:04:55,620
There was a naive algorithm,
one that was very simple,

70
00:04:55,620 --> 00:05:00,640
came right from the definition, but it
was far too slow for practical purposes.

71
00:05:00,640 --> 00:05:04,140
There's a correct algorithm which is much,
much better, very usable.

72
00:05:04,140 --> 00:05:08,480
Once again, finding the right algorithm
makes all the difference in the world.

73
00:05:08,480 --> 00:05:12,080
But here there was this
interesting thing that we found.

74
00:05:12,080 --> 00:05:14,140
In order to get the correct algorithm,

75
00:05:14,140 --> 00:05:18,070
it required that we actually know
something interesting about the problem.

76
00:05:18,070 --> 00:05:20,050
We needed this Key Lemma
that we saw today.

77
00:05:21,590 --> 00:05:24,110
This is actually a theme that you'll
see throughout this course, and

78
00:05:24,110 --> 00:05:26,870
throughout your study of algorithms.

79
00:05:26,870 --> 00:05:31,520
Very often, in order to find a better
algorithm for a problem, you need to

80
00:05:31,520 --> 00:05:35,490
understand something interesting about
the structure of the solution, and

81
00:05:35,490 --> 00:05:37,480
that will allow you to
simplify things a lot.

82
00:05:38,790 --> 00:05:42,930
In any case, that's all for today, come
back next lecture, we'll start talking

83
00:05:42,930 --> 00:05:47,730
about how to actually compute
runtimes in a little bit more detail.

84
00:05:47,730 --> 00:05:49,338
Until then good bye.