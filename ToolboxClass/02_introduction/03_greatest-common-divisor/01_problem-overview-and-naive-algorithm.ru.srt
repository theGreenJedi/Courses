1
00:00:00,800 --> 00:00:01,400
Здравствуйте.

2
00:00:01,400 --> 00:00:02,360
И снова здравствуйте.

3
00:00:02,360 --> 00:00:06,622
Сегодня мы будем говорить о вычислении наибольших общих делителей.

4
00:00:06,622 --> 00:00:09,970
И в частности, что бы нам хотелось сделать на лекции,

5
00:00:09,970 --> 00:00:12,980
это описать задачу нахождения наибольшего общего делителя.

6
00:00:12,980 --> 00:00:15,560
И затем мы поговорим о неэффективном методе их вычисления.

7
00:00:15,560 --> 00:00:18,845
А на следующей лекции мы обсудим, как сделать лучше.

8
00:00:18,845 --> 00:00:20,040
Итак, начали.

9
00:00:20,040 --> 00:00:20,640
Что такое НОДы?

10
00:00:21,770 --> 00:00:24,200
Допустим, у вас есть дробь, a/b

11
00:00:24,200 --> 00:00:26,910
И вы хотите упростить ее.

12
00:00:26,910 --> 00:00:30,730
Обычно, для этого мы делим и числитель,

13
00:00:30,730 --> 00:00:37,175
и знаменатель, на некоторое число d, чтобы 
получить эквивалентное дробное значение a/d / b/d.

14
00:00:37,175 --> 00:00:39,260
Звучит логично.

15
00:00:39,260 --> 00:00:42,210
Итак, какое d мы могли бы здесь использовать?

16
00:00:42,210 --> 00:00:44,550
Необходимо, чтобы оно удовлетворяло двум критериям.

17
00:00:45,850 --> 00:00:50,330
Во-первых, d должно делить как a, 
так и b, т.к. новые числитель и 

18
00:00:50,330 --> 00:00:52,160
знаменатель - оба целые числа.

19
00:00:53,210 --> 00:00:57,190
Но, при этом, мы бы хотели
чтобы число d было наибольшим.

20
00:00:57,190 --> 00:00:59,930
Чтобы мы могли сократить дробь 
насколько это возможно.

21
00:01:01,190 --> 00:01:04,970
Итак, выведем определение,
пусть у нас есть два целых числа, a и

22
00:01:04,970 --> 00:01:07,640
b, тогда их наибольший общий делитель, или НОД,

23
00:01:07,640 --> 00:01:13,340
- это наибольшее целое число d,
которое делит a и b.

24
00:01:13,340 --> 00:01:16,300
Таким образом, мы используем 
его чтобы сокращать дроби.

25
00:01:16,300 --> 00:01:20,150
Однако, оказывается что НОДы
чрезвычайно важная

26
00:01:20,150 --> 00:01:22,360
вещь в теории чисел.

27
00:01:22,360 --> 00:01:26,780
Изучение простых чисел,
разложение на множители, и прочее.

28
00:01:26,780 --> 00:01:30,960
И, т.к. это очень важно для теории
чисел, выходит что возможность

29
00:01:30,960 --> 00:01:34,880
вычислить НОД очень 
важна в криптографии.

30
00:01:34,880 --> 00:01:40,650
И тот факт, что вы можете
безопасно использовать онлайн-банк, происходит в том числе

31
00:01:40,650 --> 00:01:44,790
благодаря тому, что мы можем быстро
вычислить НОДы для заданных чисел,

32
00:01:44,790 --> 00:01:46,880
а это является одной из важных частей 
работы криптографических алгоритмов.

33
00:01:48,460 --> 00:01:53,420
Т.к. это все очень важно, мы
хотим научиться вычислять НОД.

34
00:01:53,420 --> 00:01:57,920
Мы хотим найти такой алгоритм, который при наличии 
двух положительных целых чисел a и b,

35
00:01:57,920 --> 00:02:00,480
смог бы вычислить НОД для a и b.

36
00:02:01,570 --> 00:02:05,750
И, чтобы всем было понятно,
 о каких числах идет речь,

37
00:02:05,750 --> 00:02:08,890
мы хотим чтобы этот алгоритм 
работал для очень больших чисел.

38
00:02:08,890 --> 00:02:15,020
Мы не хотим просто посчитать 
НОД для 5 и 12, или 11 и 73.

39
00:02:15,020 --> 00:02:20,243
Мы хотим, чтобы было 
возможным вычислить НОД

40
00:02:20,243 --> 00:02:26,160
для 3,918,848 и 1,653,264.

41
00:02:26,160 --> 00:02:31,060
На самом деле, мы хотим иметь возможность 
обрабатывать очень большие числа,

42
00:02:31,060 --> 00:02:31,860
длиной в 20, 50, 100, 1000 знаков.

43
00:02:31,860 --> 00:02:35,950
И мы хотим, чтобы НОД вычислялся 
для таких чисел довольно быстро.

44
00:02:37,740 --> 00:02:39,250
Итак, начнем.

45
00:02:39,250 --> 00:02:42,890
Начнем с того, что просто
найдем алгоритм, который работает.

46
00:02:42,890 --> 00:02:47,210
Мы хотим найти самое большое 
число который делит a b.

47
00:02:48,250 --> 00:02:49,480
Первое, что мы можем сделать,

48
00:02:49,480 --> 00:02:53,170
это просто проверить все числа,
подходящие для этого,

49
00:02:53,170 --> 00:02:57,100
выясняя, какое делит и a, и b,
и возвращая наибольшее. 

50
00:02:58,590 --> 00:03:01,150
Вот простая реализация этого.

51
00:03:01,150 --> 00:03:03,830
Создадим переменную best,
и зададим ей значение 0.

52
00:03:03,830 --> 00:03:06,530
В ней будет храниться наибольшее число,
которое мы нашли на текущий момент.

53
00:03:07,870 --> 00:03:10,624
Затем переберем d от 1 до a + b,

54
00:03:10,624 --> 00:03:14,921
т.к. это весь нужный нам 
диапазон значений.

55
00:03:14,921 --> 00:03:19,692
Теперь, если d делит a, 
и d делит b, т.к. d возрастает,

56
00:03:19,692 --> 00:03:22,754
оно должно быть новым значением 
best на текущий момент.

57
00:03:22,754 --> 00:03:26,146
Итак, в переменную best мы записываем d,
и, в итоге,

58
00:03:26,146 --> 00:03:28,460
мы возвращаем наиболее 
подходящее значение для НОД.

59
00:03:29,490 --> 00:03:31,620
Таким образом, это прекрасный алгоритм.

60
00:03:31,620 --> 00:03:32,700
Он работает.

61
00:03:32,700 --> 00:03:35,030
К сожалению, он довольно медленный,

62
00:03:35,030 --> 00:03:38,880
потому что нам нужно пройти 
этот цикл for, a + b, много раз.

63
00:03:39,990 --> 00:03:45,290
Следовательно, даже если a и b, 
скажем, 20 знаков в длину, это уже 

64
00:03:45,290 --> 00:03:49,280
займет для вычисления
как минимум тысячу лет. 

65
00:03:50,430 --> 00:03:54,440
Таким образом, это не эффективно
для наших задач.

66
00:03:54,440 --> 00:03:56,710
Нам нужен алгоритм получше.

67
00:03:56,710 --> 00:04:00,970
Итак, смотрите следующую лекцию,
где мы поговорим о том, как найти алгоритм получше

68
00:04:00,970 --> 00:04:02,500
для решения этой проблемы, 
и что для этого нужно.