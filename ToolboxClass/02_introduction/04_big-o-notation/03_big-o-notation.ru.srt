1
00:00:03,123 --> 00:00:04,330
Всем привет.

2
00:00:04,330 --> 00:00:05,928
И снова здравствуйте.

3
00:00:05,928 --> 00:00:09,220
Сегодня разговор пойдет о "Большом О",

4
00:00:09,220 --> 00:00:14,290
особом типе асимптотического представления, который мы будем весьма часто использовать дальше.

5
00:00:14,290 --> 00:00:17,360
Поэтому сейчас есть смысл познакомиться со значением Большого О 

6
00:00:17,360 --> 00:00:22,000
и частично охарактеризовать его преимущества и недостатки.

7
00:00:22,000 --> 00:00:23,300
Итак, начнем с определения.

8
00:00:23,300 --> 00:00:25,820
Основная идея в том, что нам нужен механизм обработки

9
00:00:25,820 --> 00:00:30,930
больших объемов информации, когда мы можем как бы игнорировать константы. 

10
00:00:30,930 --> 00:00:32,680
Давайте попробуем найти определение.

11
00:00:32,680 --> 00:00:34,903
Пусть f и g - две функции.

12
00:00:34,903 --> 00:00:37,574
g(n) равна "О" Большому от g(n)

13
00:00:37,574 --> 00:00:42,218
при условии, что существуют заглавная N и строчная с - две константы,

14
00:00:42,218 --> 00:00:45,352
при которых для всех n равных или больше N 

15
00:00:45,352 --> 00:00:49,311
f(n) меньше или равна g(n), умноженной на c.

16
00:00:49,311 --> 00:00:54,100
Смысл этого в том, что, по крайней мере, при достаточно больших входных данных

17
00:00:54,100 --> 00:00:57,640
для f существует верхнее ограничение в виде некого константного кратного g.

18
00:00:58,690 --> 00:01:00,926
Что по сути и есть идея, которую мы постулировали вначале.

19
00:01:00,926 --> 00:01:07,580
Ну, к примеру, 3 на n в квадрате плюс 5 на n, плюс 2 равно О от n в квадрате,

20
00:01:08,760 --> 00:01:13,180
потому что, если взять любое n, равное или больше 1, то 3n в квадрате + 5n + 2

21
00:01:13,180 --> 00:01:18,040
меньше или равно 3n в квадрате + 5n в квадрате + 2n в квадрате, что равно 10 на n в квадрате.

22
00:01:19,470 --> 00:01:21,490
Некое кратное n в квадрате.

23
00:01:21,490 --> 00:01:24,360
Теперь, в частности, если вы посмотрите на эти две функции, 

24
00:01:24,360 --> 00:01:27,640
они, действительно, в некотором смысле, возрастают с одинаковой прогрессией.  

25
00:01:27,640 --> 00:01:32,320
Если рассматривать соотношение между ними, оно, конечно, большое, 10n к 1,

26
00:01:32,320 --> 00:01:35,810
но по мере возрастания n оно, фактически, падает до 3.

27
00:01:35,810 --> 00:01:39,350
А когда вы начинаете вводить данные, при n равному 100,

28
00:01:39,350 --> 00:01:44,270
n в квадрате - миллион, 3 на n в квадрате + 5n + 2 это чуть больше трех миллионов.

29
00:01:45,440 --> 00:01:48,190
Таким образом, функции не равны.

30
00:01:48,190 --> 00:01:50,750
Одна из них значительно больше другой,

31
00:01:50,750 --> 00:01:54,720
но она больше не на много, не больше, чем примерно в 3 раза.

32
00:01:57,720 --> 00:02:01,030
На протяжении этого курса мы будем использовать "О" Большое,

33
00:02:01,030 --> 00:02:03,700
в основном, для выражения времени работы наших алгоритмов.

34
00:02:03,700 --> 00:02:06,760
И это даст нам несколько преимуществ.

35
00:02:07,890 --> 00:02:11,070
Во-первых, это прояснит для нас геометрическую прогрессию.

36
00:02:11,070 --> 00:02:12,330
Как я уже говорил,

37
00:02:12,330 --> 00:02:18,350
часто нам важно, как наше время работы соотносится с размером входной информации.

38
00:02:18,350 --> 00:02:22,400
И это, можно сказать, артефакт того факта, что на самом деле нас зачастую волнует,

39
00:02:22,400 --> 00:02:26,390
что происходит, когда мы вводим в алгоритм реально, реально объемные данные.

40
00:02:26,390 --> 00:02:28,820
Насколько много мы можем себе позволить, прежде, чем все начнет ломаться?

41
00:02:29,840 --> 00:02:33,980
И, если вы дали мне некоторое сложное выражение

42
00:02:33,980 --> 00:02:36,320
со множеством разных условий, для использования его в качестве входных данных

43
00:02:36,320 --> 00:02:39,940
то сравнить два алгоритма может быть действительно сложно.

44
00:02:39,940 --> 00:02:43,910
Я имею ввиду, то, какой алгоритм работает дольше будет зависеть
от того, что именно я подаю ему на вход.

45
00:02:43,910 --> 00:02:47,580
Это потребует раздражающих вычислений 
для определения, при каких именно значениях

46
00:02:47,580 --> 00:02:49,310
один алгоритм лучше другого.

47
00:02:49,310 --> 00:02:53,530
Но, если мы посмотрим на это ассимптотически,
что происходит, когда n становится большим?

48
00:02:53,530 --> 00:02:57,610
Часто становится значительно понятнее,
после того, как n стало очень, очень большим,

49
00:02:57,610 --> 00:02:59,710
что алгоритм a лучше алгоритма b.

50
00:03:01,510 --> 00:03:04,540
Вторая вещь - таким образом проясняются обозначения.

51
00:03:04,540 --> 00:03:09,115
Мы можем написать O(n²)
вместо 3n² + 5n + 2.

52
00:03:09,115 --> 00:03:12,551
Это намного понятнее и с этим проще работать.

53
00:03:12,551 --> 00:03:18,280
Мы можем написать O(n) вместо n + log₂(n) + sin(n).

54
00:03:18,280 --> 00:03:24,370
Мы можем написать O(n log(n)) вместо of 4n log₂(n) + 7.

55
00:03:24,370 --> 00:03:26,500
И заметьте, что в терминах большого O

56
00:03:26,500 --> 00:03:30,840
нам, вообще-то, не нужно определять
основания логарифмов, которые мы используем.

57
00:03:30,840 --> 00:03:34,870
Потому что log₂(n) и log₃(n) и log₁₀(n),

58
00:03:34,870 --> 00:03:39,510
и log₇(n).  Отличаются только в константе, 
на которую происходит умножение.

59
00:03:39,510 --> 00:03:43,230
А что до умножения на константу -
в большом О это нас не особо волнует.

60
00:03:44,990 --> 00:03:48,040
Другое последствие этого - так как наша нотация
стала чище,

61
00:03:48,040 --> 00:03:51,870
потому что мы значительно снизили количество
условий, с которыми приходится иметь дело,

62
00:03:51,870 --> 00:03:54,330
и это делает алгебраические вычисления,
с которыми приходится иметь дело значительно проще.

63
00:03:54,330 --> 00:03:58,900
Это делает манипуляции с большим О проще,
потому что они не в беспорядке.

64
00:04:00,870 --> 00:04:03,860
И последнее - нотация большого О действительно

65
00:04:03,860 --> 00:04:07,550
решает проблемы, о которых мы говорили 
несколько лекций назад.

66
00:04:07,550 --> 00:04:11,180
Чтобы вычислять время выполнения, используя подход
большой О, нам на самом деле не нужно знать

67
00:04:11,180 --> 00:04:15,510
такие вещи, как насколько быстр компьютер, или
как выглядит организация памяти,

68
00:04:15,510 --> 00:04:18,730
или какой используется компилятор,
 поскольку, в общем и целом,

69
00:04:18,730 --> 00:04:23,120
хотя эти сведения и будут иметь
значительное влияние на ваше конечное время выполнения,

70
00:04:23,120 --> 00:04:26,630
это влияние, как правило,
будет всего лишь константным множителем.

71
00:04:26,630 --> 00:04:30,200
А если два выражения отличаются только
константным множителем,

72
00:04:30,200 --> 00:04:31,440
у них одна и та же О.

73
00:04:32,900 --> 00:04:33,690
Вот и всё.

74
00:04:34,830 --> 00:04:36,515
Теперь я должен предупредить.

75
00:04:36,515 --> 00:04:40,490
О невероятно полезна, мы будем
использовать её для почти всех задач в

76
00:04:40,490 --> 00:04:44,960
этом курсе, но из-за неё вы теряете много
информации о вашем времени выполнения.

77
00:04:44,960 --> 00:04:48,170
Она не обращает внимания на любые константные множители.

78
00:04:48,170 --> 00:04:51,840
То есть, если у вас есть 2 алгоритма, и
один из них в 100 раз быстрее,

79
00:04:51,840 --> 00:04:53,269
они будут иметь одну и ту же О.

80
00:04:54,360 --> 00:04:56,980
Но на практике, 
если вы хотите ускорить работу,

81
00:04:56,980 --> 00:04:59,810
ускорение в 100 весьма значительно.

82
00:04:59,810 --> 00:05:01,867
Даже ускорение в 2 раза значительно.

83
00:05:01,867 --> 00:05:06,386
И поэтому, если вы действительно хотите
ускорить работу, как только вы получили хорошее

84
00:05:06,386 --> 00:05:11,661
асимптотическое время выполнения, вы захотите
углубиться в детали.

85
00:05:11,661 --> 00:05:13,520
Могу ли я ускорить это в 2 раза?

86
00:05:13,520 --> 00:05:16,440
Могу ли я каким-то образом изменить это, чтобы
выполнение шло более гладко?

87
00:05:16,440 --> 00:05:19,539
Могу ли я добиться лучшего
взаимодействия с памятью?

88
00:05:19,539 --> 00:05:20,728
Могу ли я сделать x, y и

89
00:05:20,728 --> 00:05:26,690
z, чтобы ускорить работу на константные множители,
которых мы не увидели ранее?

90
00:05:26,690 --> 00:05:31,604
Ещё одна вещь, на которую
вам также следует обратить внимание, это что О

91
00:05:31,604 --> 00:05:33,030
только асимптотична.

92
00:05:33,030 --> 00:05:37,790
В каком-то смысле, всё, что она говорит вам - это
что происходит, когда вы запускаете алгоритм на очень, очень,

93
00:05:37,790 --> 00:05:40,180
очень, очень,
очень больших объёмах входных данных.

94
00:05:41,215 --> 00:05:46,370
И, собственно, если вы на самом деле хотите,
чтобы ваш алгоритм работал на конкретных данных,

95
00:05:46,370 --> 00:05:50,120
О не скажет вам ничего о том,
как долго это займёт.

96
00:05:50,120 --> 00:05:55,210
Я имею в виду, что обычно константы,
скрытые за О, достаточно невелики, и,

97
00:05:55,210 --> 00:05:57,870
следовательно, это даёт вам какую-то полезную информацию.

98
00:05:57,870 --> 00:05:59,820
Но иногда они велики.

99
00:05:59,820 --> 00:06:03,470
Иногда алгоритм
с худшим временем выполнения по О,

100
00:06:03,470 --> 00:06:08,350
который хуже асимптотически на
очень больших объёмах данных, на самом деле, для

101
00:06:08,350 --> 00:06:13,520
всех используемых на практике объёмов,
уступает какому-то другому алгоритму.

102
00:06:13,520 --> 00:06:16,390
И есть случаи, когда
вы находите 2 алгоритма,

103
00:06:16,390 --> 00:06:20,010
а работает лучше, чем б, на очень, очень, очень больших объёмах данных.

104
00:06:20,010 --> 00:06:21,650
Но иногда очень, очень,

105
00:06:21,650 --> 00:06:26,400
очень большие означает больше, чем вы могли бы
вообще хранить на своём компьютере.

106
00:06:26,400 --> 00:06:31,020
И поэтому, для любых реальных входных данных
вам стоит использовать алгоритм б.

107
00:06:32,130 --> 00:06:35,920
Однако, в любом случае, несмотря на эти 
предостережения, О невероятно полезна.

108
00:06:35,920 --> 00:06:38,200
Мы будем её использовать
на протяжении всего этого курса.

109
00:06:38,200 --> 00:06:39,900
И поэтому на следующей лекции

110
00:06:39,900 --> 00:06:42,720
мы немного поговорим 
о том, как обращаться с О-выражениями,

111
00:06:42,720 --> 00:06:46,660
как использовать их
для вычисления времени выполнения, но

112
00:06:46,660 --> 00:06:51,310
как только мы справимся с этим, мы действительно
будем готовы к тому, чтобы заняться алгоритмами.

113
00:06:53,450 --> 00:06:56,450
В любом случае, это всё по 
данной лекции, возвращайтесь снова, и

114
00:06:56,450 --> 00:06:57,210
мы поговорим об этом.