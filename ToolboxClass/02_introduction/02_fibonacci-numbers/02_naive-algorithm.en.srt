1
00:00:00,740 --> 00:00:01,410
Hello everybody.

2
00:00:01,410 --> 00:00:02,440
Welcome back.

3
00:00:02,440 --> 00:00:06,320
Today we'll talk a little bit more
about how to compute Fibonacci numbers.

4
00:00:06,320 --> 00:00:09,230
And, in particular, today what we're going
to do is we're going to show you how to

5
00:00:09,230 --> 00:00:13,640
produce a very simple algorithm that
computes these things correctly.

6
00:00:13,640 --> 00:00:16,970
On the other hand, we're going to show
that this algorithm is actually very slow,

7
00:00:16,970 --> 00:00:18,940
and talk a little bit
about how to analyze that.

8
00:00:20,060 --> 00:00:22,700
So let's take a look at
the definition again.

9
00:00:22,700 --> 00:00:24,550
The zero'th Fibonacci number is 0.

10
00:00:24,550 --> 00:00:26,710
The first Fibonacci number is 1.

11
00:00:26,710 --> 00:00:31,470
And from there after each Fibonacci
number is the sum of the previous two.

12
00:00:32,710 --> 00:00:34,810
Now these grow pretty rapidly,

13
00:00:34,810 --> 00:00:39,010
and what we would like to do is
have an algorithm to compute them.

14
00:00:39,010 --> 00:00:41,950
So let's take a look at
how we might do this.

15
00:00:41,950 --> 00:00:46,800
Well, there's a pretty easy way to
go about it, given the definition.

16
00:00:46,800 --> 00:00:49,870
So if n is 0, we're supposed to return 0.

17
00:00:49,870 --> 00:00:52,740
And if n is 1, we're supposed to return 1.

18
00:00:52,740 --> 00:00:56,810
So we could just start with a case
that says if n is at most 1,

19
00:00:56,810 --> 00:00:58,040
we're going to return n.

20
00:01:00,150 --> 00:01:02,020
Otherwise what are we supposed to do?

21
00:01:02,020 --> 00:01:06,257
Otherwise, we're supposed to
return the sum of the n- 1, and

22
00:01:06,257 --> 00:01:08,680
n- 2 Fibonacci numbers.

23
00:01:08,680 --> 00:01:12,660
So we can just compute those two
recursively, add them together, and

24
00:01:12,660 --> 00:01:13,920
return them.

25
00:01:13,920 --> 00:01:17,840
So, this gives us a very simple
algorithm four lines long that

26
00:01:17,840 --> 00:01:22,140
basically took the definition of our
problem and turned it into an algorithm

27
00:01:22,140 --> 00:01:24,190
that correctly computes
the thing it's supposed to.

28
00:01:25,670 --> 00:01:26,340
Good for us.

29
00:01:26,340 --> 00:01:28,520
We have an algorithm and it works.

30
00:01:28,520 --> 00:01:34,170
However, in this course, we care a lot
more than just, does our algorithm work?

31
00:01:34,170 --> 00:01:38,380
We also want to know if it's efficient, so
we'd like to know how long this algorithm

32
00:01:38,380 --> 00:01:41,920
takes to run, and there's sort of
a rough approximation to this.

33
00:01:41,920 --> 00:01:45,720
We're going to let T(n) denote
the number of lines of code

34
00:01:45,720 --> 00:01:48,720
that are executed by this
algorithm on input n.

35
00:01:50,140 --> 00:01:53,090
So to count this is
actually not very hard.

36
00:01:53,090 --> 00:01:57,390
So if n is at most one,
the algorithm checks the if case,

37
00:01:57,390 --> 00:02:00,190
goes to the return statement,
and that's two lines of code.

38
00:02:01,250 --> 00:02:01,750
Not so bad.

39
00:02:02,840 --> 00:02:05,950
If n is at least two,
we go to the if case.

40
00:02:05,950 --> 00:02:11,060
We go to the else condition, and
then run a return statement.

41
00:02:11,060 --> 00:02:12,710
That's three lines of code.

42
00:02:13,940 --> 00:02:18,622
However ,in this case we also need
to recursively compute the n-1, and

43
00:02:18,622 --> 00:02:20,880
n-2 Fibonacci numbers.

44
00:02:20,880 --> 00:02:24,820
So we need to add to that however many
lines of code those recursive calls take.

45
00:02:25,920 --> 00:02:30,400
So all in all though,
we have a nice recursive formula for T(n).

46
00:02:30,400 --> 00:02:33,080
It's two as long as n is at most one.

47
00:02:34,140 --> 00:02:40,310
And otherwise, it's equal to T(n) minus
one plus T(n) minus two plus three.

48
00:02:40,310 --> 00:02:41,760
So a nice recursive formula.

49
00:02:43,240 --> 00:02:47,560
Now, if you look at this formula for
a little bit, you'll notice that it looks

50
00:02:47,560 --> 00:02:51,640
very similar to the original formula that
we used to define the Fibonacci numbers.

51
00:02:51,640 --> 00:02:54,880
Each guy was more or
less the sum of the previous two.

52
00:02:56,130 --> 00:02:59,320
And in fact,
from this you can show pretty easily

53
00:02:59,320 --> 00:03:03,020
that T( n) is at least the n'th
Fibonacci number for all n.

54
00:03:04,720 --> 00:03:08,410
And this should be ringing some warning
bells because we know that the Fibonacci

55
00:03:08,410 --> 00:03:12,354
numbers get very, very,
very large, so T(n) must as well.

56
00:03:12,354 --> 00:03:19,921
In fact,
T(100) is already 1.77 times 10 to the 21.

57
00:03:19,921 --> 00:03:21,336
1.77 sextillion.

58
00:03:21,336 --> 00:03:24,510
This is a huge number.

59
00:03:24,510 --> 00:03:27,980
Now, suppose we were running
this program on a computer that

60
00:03:27,980 --> 00:03:30,150
executed a billion lines of code a second.

61
00:03:30,150 --> 00:03:31,980
It ran it at a gigahertz.

62
00:03:31,980 --> 00:03:37,360
It would still take us about 56,000
years to complete this computation.

63
00:03:38,480 --> 00:03:42,330
Now, I don't have 56,000 years to wait for
my computer to finish.

64
00:03:42,330 --> 00:03:47,200
You probably don't either, so
this really is somehow not acceptable,

65
00:03:47,200 --> 00:03:50,500
if we want to compute Fibonacci
numbers of any reasonable size.

66
00:03:52,260 --> 00:03:54,600
So what we'd really like is
we'd like a better algorithm.

67
00:03:54,600 --> 00:03:56,490
And we'll get to that next lecture.

68
00:03:56,490 --> 00:04:00,580
But first we should talk a little bit
about why this algorithm is so slow.

69
00:04:02,310 --> 00:04:06,790
And to see that, maybe the clearest
way to demonstrate it is to look at

70
00:04:06,790 --> 00:04:11,780
all of the recursive calls this algorithm
needs in order to compute its answer.

71
00:04:12,820 --> 00:04:15,860
So, if we want to compute
the n'th Fibonacci number,

72
00:04:15,860 --> 00:04:21,960
we need to make recursive calls to compute
the n-1,and n-2 Fibonacci numbers.

73
00:04:21,960 --> 00:04:25,590
To compute the n-1,
we need the n-2 to the n-3.

74
00:04:25,590 --> 00:04:30,750
To compute the n-2, we need the n-3, and
n-4, and it just keeps going on and on.

75
00:04:30,750 --> 00:04:33,650
From there we get this big
tree of recursive calls.

76
00:04:35,420 --> 00:04:37,850
Now if you'll look at this
tree a little bit closer,

77
00:04:37,850 --> 00:04:41,090
it looks like we're doing
something a little bit silly.

78
00:04:41,090 --> 00:04:44,860
We're computing Fn-3,
three separate times in this tree.

79
00:04:45,920 --> 00:04:49,860
And the way with our algorithm works,
every time we're asked to compute it,

80
00:04:49,860 --> 00:04:53,810
since this is a new recursive call,
we compute the whole thing from scratch.

81
00:04:53,810 --> 00:05:00,828
We recompute Fn-4, and Fn-5, and then,
add them together and get our answer.

82
00:05:00,828 --> 00:05:04,160
And it's this computing
the same thing over and

83
00:05:04,160 --> 00:05:06,950
over again that's really slowing us down.

84
00:05:06,950 --> 00:05:10,760
And to make it even more extreme,
let's blow up the tree a little bit more.

85
00:05:10,760 --> 00:05:15,390
Fn-4 actually gets computed these
five separate times by the algorithm.

86
00:05:15,390 --> 00:05:18,300
And as you keep going down more and
more and more times,

87
00:05:18,300 --> 00:05:20,590
are you just computing the same
thing over and over again?

88
00:05:21,640 --> 00:05:26,480
And this is really the problem with
this particular algorithm, but

89
00:05:26,480 --> 00:05:29,410
it's not clear immediately
that we can do better.

90
00:05:29,410 --> 00:05:33,350
So, come back next lecture and we'll talk
about how to get around this difficulty,

91
00:05:33,350 --> 00:05:35,280
and actually get a fairly
efficient algorithm.