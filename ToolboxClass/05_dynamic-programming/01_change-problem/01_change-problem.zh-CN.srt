1
00:00:00,370 --> 00:00:03,600
录制这个演讲之前，我去了咖啡厅。

2
00:00:04,650 --> 00:00:05,660
这卡布奇诺还是不错的。

3
00:00:08,540 --> 00:00:13,070
当我拿了$5给收银员，摆在她面前的

4
00:00:13,070 --> 00:00:17,970
是一个算法问题：她该拿哪几种硬币来找零

5
00:00:19,340 --> 00:00:24,430
而世界各地的收银员都使用贪心算法(Greedy Algorithm)
来解决这个问题

6
00:00:24,430 --> 00:00:28,350
而世界各地的收银员都使用贪心算法(Greedy Algorithm)
来解决这个问题

7
00:00:28,350 --> 00:00:33,580
今天，我们将学习收银员和计算机科学家

8
00:00:33,580 --> 00:00:38,520
如何使用贪心算法解决这些实际问题。

9
00:00:39,610 --> 00:00:43,850
找零问题是如何用最小数量的硬币来找零

10
00:00:43,850 --> 00:00:45,380
找零问题是如何用最小数量的硬币来找零

11
00:00:46,520 --> 00:00:52,440
正式地讲，输入是找零金额，正整数，

12
00:00:52,440 --> 00:00:57,400
COIN1，COIN2，COINd，表示能使用的硬币面值。

13
00:00:57,400 --> 00:01:00,815
例如，在美国，COIN1将是1美分，

14
00:01:00,815 --> 00:01:06,500
COIN2将是5美分，10美分，25美分和50美分。

15
00:01:06,500 --> 00:01:11,563
输出是找零中所含硬币的最小数

16
00:01:11,563 --> 00:01:15,290
输出是找零中所含硬币的最小数

17
00:01:17,100 --> 00:01:21,695
所以今天早上，收银员要找我40美分，

18
00:01:21,695 --> 00:01:25,650
她最有可能使用下面的算法。

19
00:01:25,650 --> 00:01:28,710
首先，找到小于40美分的最大的硬币面值

20
00:01:28,710 --> 00:01:31,190
首先，找到小于40美分的最大的硬币面值

21
00:01:31,190 --> 00:01:33,200
是25美分。

22
00:01:33,200 --> 00:01:35,870
于是，她给了我25，还剩15美分

23
00:01:35,870 --> 00:01:38,220
那么下一个问题是如何找零15美分。

24
00:01:39,230 --> 00:01:44,180
她接下来可能去拿15范围内数额最大的硬币

25
00:01:44,180 --> 00:01:45,500
是10美分。

26
00:01:45,500 --> 00:01:49,260
她给了我10美分，最后，再找5美分。

27
00:01:49,260 --> 00:01:56,170
结果是，用25加10加5找零40美分，

28
00:01:56,170 --> 00:02:00,765
这是不是找零时可能的最小硬币数？

29
00:02:02,300 --> 00:02:06,750
在美国，这是最小数目。

30
00:02:06,750 --> 00:02:10,250
但是，如果你在坦桑尼亚，不会这样

31
00:02:10,250 --> 00:02:15,130
在坦桑尼亚除了25，10，5，还有20分硬币。

32
00:02:15,130 --> 00:02:20,220
因此，贪心算法在坦桑尼亚会失败

33
00:02:20,220 --> 00:02:24,940
找零40分，只要拿两个20分硬币

34
00:02:24,940 --> 00:02:30,540
找零40分，只要拿两个20分硬币

35
00:02:32,580 --> 00:02:37,570
既然贪心算法来解决这个问题失败，

36
00:02:37,570 --> 00:02:39,330
试试别的

37
00:02:39,330 --> 00:02:44,660
我们尝试用递归算法解决

38
00:02:44,660 --> 00:02:47,940
假设我们要找零9美分，而

39
00:02:47,940 --> 00:02:53,270
我们的面额有1美分，5美分和6美分。

40
00:02:53,270 --> 00:02:58,500
找零9美分的最佳方法是什么？

41
00:02:58,500 --> 00:03:05,414
按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4(9-5)美分，8(9-1)美分

42
00:03:05,414 --> 00:03:10,991
按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4 (9-5)美分，8 (9-1)美分

43
00:03:10,991 --> 00:03:15,710
按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4 (9-5)美分，8(9-1)美分

44
00:03:15,710 --> 00:03:18,908
换句话说，要找零九美分

45
00:03:18,908 --> 00:03:23,346
我们要先知道如何找零较小的金额<br />

46
00:03:23,346 --> 00:03:28,340
在现在的情况下，较小的金额为3分，4分和8分。

47
00:03:28,340 --> 00:03:33,180
所以我们写这样一个递归程序来解决这个问题

48
00:03:33,180 --> 00:03:38,170
所以我们写这样一个递归程序来解决这个问题

49
00:03:39,290 --> 00:03:43,765
就是这个RecursiveChange程序

50
00:03:44,800 --> 00:03:49,520
找钱的话有以下几种选择，coins, coin1, coin2, coind 

51
00:03:49,520 --> 00:03:53,750
找钱的话有以下几种选择，coins, coin1, coin2, coind 

52
00:03:53,750 --> 00:03:59,332
依次递归调用 money-coin1, money-coin2, money-coind

53
00:03:59,332 --> 00:04:05,130
依次递归调用 money-coin1, money-coin2, money-coind

54
00:04:05,130 --> 00:04:10,482
然后从以上得出的答案中选择最小的

55
00:04:10,482 --> 00:04:15,480
然后从以上得出的答案中选择最小的

56
00:04:17,150 --> 00:04:22,360
看上去这样做是对的

57
00:04:22,360 --> 00:04:26,970
我们看看运行有多快

58
00:04:28,220 --> 00:04:33,520
要找的钱是76，有三个选择

59
00:04:33,520 --> 00:04:38,240
接下来再递归解决70（76-6），71（76-5），75（76-1）

60
00:04:38,240 --> 00:04:40,940
接下来再递归解决70（76-6），71（76-5），75（76-1）

61
00:04:42,420 --> 00:04:48,670
这三种选择又各自衍生出三种选择

62
00:04:49,700 --> 00:04:53,346
这个三叉树增长非常快

63
00:04:53,346 --> 00:04:57,520
这个三叉树增长非常快

64
00:04:58,800 --> 00:05:05,020
在找零70美分的问题上，我们重复解决了多少次？

65
00:05:05,020 --> 00:05:09,900
三次，而我们才刚刚开始

66
00:05:09,900 --> 00:05:14,630
再继续下去，会增长到六次

67
00:05:14,630 --> 00:05:19,280
再继续下去，会增长到六次

68
00:05:21,110 --> 00:05:26,370
你们认为找零30美分要递归多少次？

69
00:05:26,370 --> 00:05:31,200
你们认为找零30美分要递归多少次？

70
00:05:32,330 --> 00:05:37,230
我们会重复解决同样的问题多达数万亿次，

71
00:05:37,230 --> 00:05:42,158
也就是说，这个看上去非常简洁的代码，我们这辈子都看不到它跑完

72
00:05:42,158 --> 00:05:49,120
也就是说，这个看上去非常简洁的代码，我们这辈子都看不到它跑完

73
00:05:49,120 --> 00:05:54,196
无论是贪心算法还是递归都不能解决这个问题

74
00:05:54,196 --> 00:05:57,860
无论是贪心算法还是递归都不能解决这个问题

75
00:05:57,860 --> 00:06:05,110
60年前，一个杰出的数学家，理查德·贝尔曼，有不同的想法。

76
00:06:06,450 --> 00:06:11,750
有没有可能改进递归算法，避免这样它重复工作

77
00:06:11,750 --> 00:06:17,050
有没有可能改进递归算法，避免这样它重复工作

78
00:06:18,310 --> 00:06:21,996
把一些解决过的问题存储，要用的时候直接调用

79
00:06:21,996 --> 00:06:27,180
把一些解决过的问题存储，要用的时候直接调用

80
00:06:27,180 --> 00:06:30,291
把一些解决过的问题存储，要用的时候直接调用

81
00:06:32,230 --> 00:06:39,360
这个思想也就是动态规划，如今大规模的应用在各种实际问题中

82
00:06:39,360 --> 00:06:44,260
这个思想也就是动态规划，如今大规模的应用在各种实际问题中

83
00:06:45,260 --> 00:06:50,600
核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左

84
00:06:50,600 --> 00:06:55,760
核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左

85
00:06:55,760 --> 00:06:59,180
核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左

86
00:06:59,180 --> 00:07:01,410
从最小开始，

87
00:07:01,410 --> 00:07:05,710
找0美分要多少硬币？

88
00:07:05,710 --> 00:07:07,850
0

89
00:07:07,850 --> 00:07:10,720
找1美分要多少硬币？

90
00:07:10,720 --> 00:07:15,700
1

91
00:07:15,700 --> 00:07:19,220
找0美分的硬币数+1

92
00:07:19,220 --> 00:07:23,240
接下来用类似方法找零2美分，3美分，4美分

93
00:07:23,240 --> 00:07:26,820
接下来用类似方法找零2美分，3美分，4美分

94
00:07:26,820 --> 00:07:32,440
之前的数字只有一种答案

95
00:07:32,440 --> 00:07:39,110
5美分有两种可能答案

96
00:07:39,110 --> 00:07:44,486
直接用5美分硬币，或是 找4美分的硬币数+ 1

97
00:07:44,486 --> 00:07:51,095
直接用5美分硬币，或是 找4美分的硬币数+ 1

98
00:07:51,095 --> 00:07:53,681
该选哪种？

99
00:07:53,681 --> 00:07:58,530
当然是前一种

100
00:08:00,390 --> 00:08:06,285
6美分就有三种可能

101
00:08:06,285 --> 00:08:12,020
我们选择最优情况，

102
00:08:12,020 --> 00:08:16,490
就是直接用6美分硬币找

103
00:08:16,490 --> 00:08:21,550
接下来7美分，8美分同样以此类推

104
00:08:21,550 --> 00:08:26,815
9美分需要四个硬币

105
00:08:26,815 --> 00:08:31,340
9美分需要四个硬币

106
00:08:31,340 --> 00:08:36,950
DPChange程序就这样很简便的填满了之前展示的那个方阵

107
00:08:36,950 --> 00:08:42,330
DPChange程序就这样很简便的填满了之前展示的那个方阵

108
00:08:43,470 --> 00:08:49,200
DPChange程序是你在这节课看到的第一个动态规划算法

109
00:08:49,200 --> 00:08:51,010
之后会有很多

110
00:08:52,080 --> 00:08:55,970
你可能会问为什么这个算法叫动态规划

111
00:08:55,970 --> 00:08:58,680
跟编程有什么关系？

112
00:08:58,680 --> 00:09:00,760
其实动态编程和编程无关。

113
00:09:00,760 --> 00:09:03,220
其实动态编程和编程无关。

114
00:09:04,250 --> 00:09:07,730
这是计算机科学家公认最实用的一个算法

115
00:09:07,730 --> 00:09:12,580
这是计算机科学家公认最实用的一个算法

116
00:09:12,580 --> 00:09:16,406
但是，当理查德·贝尔曼正在研究这个时

117
00:09:16,406 --> 00:09:21,690
他的上峰，也就是空军项目的大佬们觉得他在浪费时间

118
00:09:22,710 --> 00:09:26,870
所以为了不受干扰的研究

119
00:09:26,870 --> 00:09:31,380
所以为了不受干扰的研究

120
00:09:31,380 --> 00:09:34,110
他想出了这个名字

121
00:09:34,110 --> 00:09:39,910
跟这个算法的实质没任何关系的名字

122
00:09:39,910 --> 00:09:43,950
他原话是，我还能选什么名字

123
00:09:43,950 --> 00:09:49,190
我考虑过用计划（planning）,后来还是考虑用规划(Programming)

124
00:09:49,190 --> 00:09:52,050
我考虑过用计划（planning）,后来还是考虑用规划(Programming)

125
00:09:52,050 --> 00:09:56,870
我想特别传达动态(dynamic)这个特质

126
00:09:56,870 --> 00:10:00,400
他们什么都不懂，但一听到这个词就觉得项目很有潜力