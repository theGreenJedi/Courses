Ahora convertiremos nuestra relación recurrente en un algoritmo de programación dinámica Comenzamos por implementar un procedimiento que calcule el mínimo y el máximo valor de la sub expresión (i,j) mediante los valores óptimos para sub expresiones menores. El procedimiento es llamado MinAndMax(i,j). Lo primero es declarar dos variables,
 max y min. Inicialmente min es igual a más infinito,
max es igual a menos infinito, o un valor lo suficientemente grande,
o un valor lo suficientemente pequeño Luego analizamos todos los posibles
valores de k entre i y j-1, es decir, se analizan todas las posibles
formas en que la sub expresión (i,j) puede ser dividida en dos sub expresiones desde i hasta k y desde k + 1 hasta j. Cuando se fija una partición, calculamos cuatro posibles valores, aplicando opk ya sea a dos valores máximos o a dos valores mínimos de esta sub expresión o a un valor máximo y uno mínimo, o un valor mínimo y un máximo. Cuando los dos valores son calculados, solo chequeamos si uno de ellos mejora los valores máximo o mínimo. Si lo mejora entonces actualizamos la variable min o max según sea el caso. Por último retornamos el valor máximo y mínimo de nuestra sub expresión. Nuestra relación recursiva expresa la solución para una expresión (i,j) mediante soluciones de sub sub expresiones más pequeñas ¿Qué significa cuando decimos más pequeñas? Bueno, significa que son más cortas, ¿sí? Así, de nuevo, cuando calculamos el valor para una sub expresión (i,j) nos apoyamos en el hecho de que esos valores para las sub expresiones más cortas ya están calculadas. Esto significa que nuestro algoritmo necesita calcular las soluciones de todos los sub problemas en orden de tamaño creciente, a decir, en order creciente del valor j menos i, ¿sí? Entonces, para este problema, tenemos aproximadamente un número cuadrático de sub problemas. A decir, nuestro sub problema E_i,j es parametrizado por el valor de i y j, que a su vez corren de 1 a n. Así que tiene sentido en este caso guardar los valores de todos los sub problemas en una tabla bi dimensional de tamaño n por n. Recuerda también que debemos resolver nuestro sub problema en orden de valor j-i creciente. Podemos hacer esto pasando por todos los sub problemas en el orden mostrado en la pantalla. ¿Por qué este orden? Pues simplemente porque pasa por todos los posibles valores de i y j, en orden creciente de j-i, como requerimos. Veamos: en esta diagonal tenemos todas las celdas donde j-i=0, ¿sí? Así, aquí la primera celda es 1,1, la segunda celda es 2,2, la tercera celda es 3,3 y así. Seguimos ahora con esta celda. Aquí i=1, j=2, así que la diferencia es 1. Seguimos con esta celda. Esta es la celda 2,3, con la diferencia igual a 1, de nuevo. Seguimos con esta celda, que es 3,4, y así. Así, en esta diagonal tenemos todas las celdas i,j donde j-i=0. En esta diagonal tenemos todas las celdas i,j donde j-i=1. Para esta diagonal la diferencia es igual a 2. Para esta diagonal la diferencia es igual a 3, y así. Así, el valor resultante de nuestro sub problema inicial, será calculado como el valor de la última celda, ajá, porque esta celda corresponde a la sub expresión inicial de 1 a n. Ahora todo está listo para escribir un algoritmo. En el algoritmo mantendremos 2 tablas, m y M. La primera para guardar los valores mínimos de todas las sub expresiones, y la segunda para guardar los valores máximos de todas las sub expresiones. Empezamos inicializando estas tablas como sigue. Cuando las sub expresiones contienen sólo un dígito, es decir, cuando j=1, entonces no hay nada para minimizar o maximizar porque no hay operaciones. Entonces no hay order en las operaciones. Debido a esto simplemente inicializamos las diagonales principales de ambas tablas, con los dígitos correspondientes. Esto se hace en el siguiente bucle. Así, m(i,i) y M(i,i) = d_i Entonces pasamos por todos los posibles sub problemas de manera creciente, y esto se hace como sigue. Aumentamos gradualmente el parámetro s de 1 a n-1. Esto se hace en el siguiente bucle. Cuando s es fija, i va de 1 a n-s, y j se calcula como i+s. Esto se hace para pasar por todos los pares posibles (i,j), tal que j-i=s, ¿sí? Cuando i y j están fijas llamamos al procedimiento MinAndMax para calcular los valores mínimo y máximo de la sub expresión i,j, ¿sí? su tiempo.
Muy bien. Finalmente devolvemos el valor de M(1,n), como el resultado de nuestro problema inicial, porque esta sub expresión, 1,n, corresponde a nuestro problema inicial, que contiene todos los dígitos de 1 a n. Bien, el tiempo de ejecución de este algoritmo es cúbico, de O(n^3), y esto se puede ver notando que tenemos 2 bucles anidados, el primero con n-1 iteraciones, el interior con n-s iteraciones, que a lo más es n. También, dentro de estos dos bucles hacemos un llamado a MinAndMax. El tiempo de ejecución del procedimiento MinAndMax, es proporcional a j-i, que también es a lo más n. Así, el tiempo de ejecución de nuestro algoritmo es O de n x n x n, que es n^3. Esta diapositiva muestra un ejemplo de cómo se ven las tablas m y M cuando corremos nuestro algoritmo en nuestro ejemplo de juguete, esto es, la expresión 5-8+7x4-8+9. veamos este ejemplo paso a paso. Empezamos llenando los valores de la 
diagonal principal en ambas matrices. Así, esto es 8, esto es 7, esto es 4, 8, 9, esto corresponde a las sub expresiones 
que consisten en un solo dígito, así que no hay nada que maximizar o minimizar. Hacemos lo mismo para M. Seguimos con la segunda diagonal. Bien, ponemos -3 aquí, que corresponde a esta sub expresión, de nuevo, en este caso hay una sola operación, así que no hay nada que minimizar o maximizar aquí, porque tenemos un solo ordenamiento, 
cuando tenemos un signo. Así, ponemos -3 aquí que corresponde al sub problema 1,2, déjenme poner todos los índices aquí, por cierto. Entonces procedemos a la celda 2,3,
 que corresponde a este sub problema. De nuevo, no hay nada que maximizar o minimizar, 
así que seguimos del mismo modo. En este caso, no es tan interesante y entonces procedemos a la tercera diagonal, a esta celda. Ésta corresponde a la sub expresión 1,3, que consiste de 3 dígitos y 2 operaciones, resta y suma. Sabemos que una de ellas es la última 
operación en el orden óptimo cuando calculamos el valor mínimo, por ejemplo. Supón que es la resta. Ésta dividirá la sub expresión en dos 
sub sub expresiones, 5 y 8+7. Para ambas sub expresiones ya
 sabemos sus valores máximo y mínimo. Entonces, de nuevo, esta sub expresión corresponde a 1,1, esta sub expresión corresponde a 2,3. Así, del segundo al tercer dígitos, y del primer al primer dígitos. Y, ya sabemos para la primera sub expresión su valor mínimo, está aquí, y su valor máximo, acá. Para la segunda sub expresión ya sabemos su valor mínimo, está aquí, es 15, y su valor máximo, es 15 también. Así, yendo por todos los pares posibles de estos valores máximo y mínimo, en este caso, todos son los mismos, calculamos el valor mínimo, que es 5-15, que es -10. Sin embargo, este fue sólo el primer caso de dividir esta sub expresión en dos sub expresiones. Otra posibilidad sería la siguiente, entonces, podríamos dividirla en las siguientes 2 sub expresiones. Esto corresponde a 1,2, y esto corresponde a 3,3, ¿sí? ¿Verdad? Entonces, para 1,2 ya sabemos su valor mínimo, es -3, y su valor máximo es también -3. Para 3,3 sabemos su valor máximo, está aquí, 7, su valor mínimo y su valor máximo. Entonces podemos calcular -3+7, que nos da 4. Así, para la sub expresión 1,3
 escogemos su valor máximo como 4, para el valor mínimo seleccionamos -10. Así, procedemos a llenar la tabla de manera similar. Así, ponemos 36 aquí en esta celda, 
entonces -28 aquí en esta celda, paralelamente ponemos 60 aquí, 20 acá, y así. Al final vemos el valor 200 aquí. Y este es el máximo valor de nuestra expresión inicial. Esto todavía no nos da el ordenamiento óptimo en sí, pero seremos capaces de reconstruirlo 
a partir de estas dos tablas. Ahora estamos seguros de que el valor 
máximo de nuestra expresión inicial es 200, y encontraremos el ordenamiento óptimo, 
o el poner paréntesis de manera óptima, en un minuto.