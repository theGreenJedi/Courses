1
00:00:00,600 --> 00:00:04,380
Hola bienvenidos a la lección del
 problema de ordenamiento.

2
00:00:05,870 --> 00:00:08,750
Como siempre, empezamos con una 
revisión del problema.

3
00:00:10,090 --> 00:00:14,270
El ordenamiento es un problema 
computacional fundamental.

4
00:00:14,270 --> 00:00:18,480
La entrada en este problema consiste
 de una secuencia de n elementos

5
00:00:18,480 --> 00:00:23,000
y tu objetivo es devolver estos elementos en,
 por ejemplo, un orden no decreciente.

6
00:00:24,580 --> 00:00:27,680
El enunciado formal de este problema es como sigue.

7
00:00:27,680 --> 00:00:30,360
Te dan una secuencia finita de n elementos,

8
00:00:30,360 --> 00:00:33,950
y usualmente denotaremos la secuencia
 como A, en esta lección.

9
00:00:33,950 --> 00:00:38,860
Y tu propósito es devolver estos mismos
 elementos en orden no decreciente.

10
00:00:40,560 --> 00:00:41,470
De nuevo,

11
00:00:41,470 --> 00:00:47,330
el ordenamiento es una tarea computacional importante
 usada en muchos algoritmos eficientes.

12
00:00:47,330 --> 00:00:50,460
Para algunos algoritmos es importante procesar

13
00:00:50,460 --> 00:00:55,290
los elementos dados en orden no decreciente, 
del más chico al más grande.

14
00:00:55,290 --> 00:00:59,090
En algunos otros algoritmos, sólo 
por ordenar tus datos de entrada,

15
00:00:59,090 --> 00:01:03,440
ganas la posibilidad de llevar a cabo consultas 
de manera mucho más eficiente.

16
00:01:03,440 --> 00:01:07,000
Un ejemplo canónico de tal situación
 es un problema de búsqueda.

17
00:01:07,000 --> 00:01:09,550
En este problema, nos dan una 
secuencia de n elementos

18
00:01:09,550 --> 00:01:13,150
y el objetivo es checar si un 
elemento particular está presente

19
00:01:13,150 --> 00:01:14,380
en la secuencia.

20
00:01:14,380 --> 00:01:19,040
Una forma simple de resolver este problema es,
 por supuesto, explorar tu secuencia de entrada

21
00:01:19,040 --> 00:01:24,960
de izquierda a derecha, y checar si tu
 elemento se encuentra en la secuencia.

22
00:01:24,960 --> 00:01:27,660
Esto te da un algoritmo de tiempo lineal,

23
00:01:27,660 --> 00:01:31,060
y ya sabes ahora que si tus datos de entrada,

24
00:01:31,060 --> 00:01:36,110
si tu secuencia de entrada está ordenada, entonces
 puedes hacerlo mucho más rápido.

25
00:01:36,110 --> 00:01:40,980
Básicamente en tiempo logarítmico 
del tamaño de la entrada.

26
00:01:40,980 --> 00:01:43,799
Entonces, primero comparas tu
 elemento con el elemento a la mitad.

27
00:01:45,060 --> 00:01:49,710
si son iguales entonces ya
 terminaste, si no, continúas

28
00:01:49,710 --> 00:01:53,320
con el lado izquierdo de la secuencia o con el derecho.

29
00:01:53,320 --> 00:01:57,620
Así, en un número logarítmico de 
comparaciones en el peor de los casos,

30
00:01:57,620 --> 00:02:01,840
serás capaz de decir si tu elemento 
está presente en la secuencia o no.

31
00:02:01,840 --> 00:02:06,010
Entonces, si te dan una secuencia y 
esperar tener muchas consultas,

32
00:02:06,010 --> 00:02:12,370
esto es, esperas que te pidan checar
 si un objeto está presente o no,

33
00:02:12,370 --> 00:02:17,840
muchas veces, entonces tiene sentido 
que ordenes primero tus datos de entrada

34
00:02:17,840 --> 00:02:20,830
y sólo entonces llevar a cabo las consultas.

35
00:02:20,830 --> 00:02:24,210
Esto te dará un algoritmo mucho más eficiente en general.

36
00:02:24,210 --> 00:02:25,060
su tiempo.
Muy bien.

37
00:02:25,060 --> 00:02:27,290
Y esto es sólo un pequeño ejemplo.

38
00:02:27,290 --> 00:02:29,140
Veremos otras muchas situaciones,

39
00:02:29,140 --> 00:02:34,720
donde ordenar primero tus datos ayuda a
 llevar a cabo consultas de manera más eficiente.

40
00:02:34,720 --> 00:02:37,851
En los videos posteriores a esta lección,

41
00:02:37,851 --> 00:02:41,498
estudiaremos muchos algoritmos 
que son eficientes para ordenar.