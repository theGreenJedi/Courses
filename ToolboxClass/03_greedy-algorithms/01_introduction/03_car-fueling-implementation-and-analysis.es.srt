1
00:00:00,240 --> 00:00:03,840
Hola, en este video aprenderás a implementar el algoritmo voraz

2
00:00:03,840 --> 00:00:07,540
del video anterior, y analizarás su tiempo de ejecución.

3
00:00:07,540 --> 00:00:09,550
Aquí tenemos el pseudocódigo para este algoritmo

4
00:00:09,550 --> 00:00:12,240
y el procedimiento se llama MinRefills (mínimo de recargas).

5
00:00:12,240 --> 00:00:15,690
y la principal entrada en este procedimiento es el arreglo x.

6
00:00:15,690 --> 00:00:18,230
Del enunciado del problema, sabemos que

7
00:00:18,230 --> 00:00:23,490
las posiciones de las estaciones de gas están dados por los números del x1 al xn.

8
00:00:23,490 --> 00:00:27,210
Y éstos están medidos en km, en términos de distancias desde A

9
00:00:27,210 --> 00:00:31,910
a la correspondiente estación en el camino de A a B.

10
00:00:31,910 --> 00:00:36,160
Por conveniencia agregamos al arreglo X, las posiciones del punto A,

11
00:00:36,160 --> 00:00:41,020
que es x0 y es el valor más pequeño en el arreglo,

12
00:00:41,020 --> 00:00:47,215
y el punto B, que es x_(n+1), y es el valor más grande en el arreglo x.

13
00:00:49,240 --> 00:00:53,830
En el camino de A a B visitaremos algunos puntos.

14
00:00:53,830 --> 00:00:55,240
Por supuesto empezaremos desde el punto A,

15
00:00:55,240 --> 00:01:00,080
y entonces iremos probablemente a una estación de gasolina, recargamos ahí,

16
00:01:00,080 --> 00:01:05,210
y entonces vamos a otra estación, y a otra y a otra,

17
00:01:05,210 --> 00:01:10,080
y entonces en algún momento llegaremos al punto B o punto x_(n+1).

18
00:01:10,080 --> 00:01:15,970
Así que vemos que sólo necesitamos guardar las posiciones en el arreglo x,

19
00:01:15,970 --> 00:01:20,450
no necesitamos considerar posiciones entre los elementos del arreglo x.

20
00:01:20,450 --> 00:01:23,420
Y así, guardaremos en la variable currentRefill

21
00:01:24,870 --> 00:01:28,450
la posición en el arreglo x en la que estamos actualmente.

22
00:01:28,450 --> 00:01:30,590
Y la inicializaremos con 0,

23
00:01:30,590 --> 00:01:34,900
porque empezamos desde el punto A que es lo mismo que x0

24
00:01:34,900 --> 00:01:38,209
y tiene índice 0 en el arreglo x.

25
00:01:39,960 --> 00:01:45,180
Más tarde, currentRefill guardará el índice en el arreglo x

26
00:01:45,180 --> 00:01:46,720
donde estemos parados.

27
00:01:47,750 --> 00:01:52,545
También vamos a guardar la respuesta a nuestro problema en la variable numRefills.

28
00:01:53,830 --> 00:01:57,200
En cada punto en la ejecución del algoritmo,

29
00:01:57,200 --> 00:02:00,758
contendrá el número de recargas que hemos hecho.

30
00:02:00,758 --> 00:02:05,688
Y lo incializamos con 0, porque el enunciado del problema nos pide

31
00:02:05,688 --> 00:02:10,190
contar el número mínimo de recargas que necesitamos hacer,

32
00:02:10,190 --> 00:02:13,730
sin contar la recarga inicial en el punto A.

33
00:02:13,730 --> 00:02:15,260
Así que cuando estamos en el punto A,

34
00:02:15,260 --> 00:02:18,320
consideramos que no hemos hecho ninguna recarga todavía.

35
00:02:19,780 --> 00:02:22,560
Entonces, el principal bucle while externo inicia,

36
00:02:24,090 --> 00:02:27,880
y continúa mientras estemos a la izquierda del punto B

37
00:02:27,880 --> 00:02:32,060
porque entonces necesitamos ir a la derecha para llegar a nuestro destino B,

38
00:02:32,060 --> 00:02:34,620
y checamos esta condición con esta desigualdad,

39
00:02:34,620 --> 00:02:36,430
de que currentRefill is a lo más n,

40
00:02:36,430 --> 00:02:41,230
lo que significa que la posición o índice en el arreglo x es a lo más n, y así

41
00:02:41,230 --> 00:02:44,150
estamos a la izquierda de B.

42
00:02:44,150 --> 00:02:47,220
En este caso necesitamos todavía ir a la derecha.

43
00:02:47,220 --> 00:02:52,990
Y primero guardamos nuestra posición actual en el arreglo x en la variable lastRefill.

44
00:02:52,990 --> 00:02:58,380
Esto significa que hicimos nuestra última recarga en la posición currentRefill.

45
00:02:59,510 --> 00:03:05,450
Y ahora necesitamos ir a la derecha desde ahí y, o llegamos al destino B,

46
00:03:05,450 --> 00:03:09,900
o llegamos estación más a la derecha alcanzable y recargamos ahí.

47
00:03:09,900 --> 00:03:12,820
Y el siguiente bucle while interno hace exactamente eso.

48
00:03:14,130 --> 00:03:20,910
Incrementa gradualmente nuestra posición currentRefill en el arreglo x hasta alcanzar

49
00:03:20,910 --> 00:03:25,546
el punto más a la derecha en el arreglo x que es alcanzable desde la posición lastRefill.

50
00:03:26,960 --> 00:03:31,050
Entonces primero checamos que la posición currentRefill es a lo más n porque

51
00:03:31,050 --> 00:03:35,640
si es n+1 significa que alcanzamos nuestro destino B,

52
00:03:35,640 --> 00:03:38,610
y no hay razón de seguir incrementándolo.

53
00:03:38,610 --> 00:03:40,370
Si estamos todavía a la izquierda de B,

54
00:03:40,370 --> 00:03:45,224
entonces checaremos la siguiente posición a la derecha, x en currentRefill+1.

55
00:03:47,020 --> 00:03:50,850
Necesitamos checar si es alcanzable desde la posición de lastRefill o no.

56
00:03:50,850 --> 00:03:53,797
Y primero podemos construir la distancia desde la posición lastRefill

57
00:03:53,797 --> 00:04:00,610
a la posición currentRefill+1, restando estos valores en el arreglo x.

58
00:04:00,610 --> 00:04:05,433
Y si la distancia es a lo más L, entonces significa que podemos viajar

59
00:04:05,433 --> 00:04:08,853
esta distancia con tanque lleno, sin recargar.

60
00:04:08,853 --> 00:04:11,951
Y por supuesto, en la posición lastRefill

61
00:04:11,951 --> 00:04:15,500
pudimos recargar nuestro tanque a su máxima capacidad,

62
00:04:15,500 --> 00:04:18,830
y entonces seremos capaces de viajar por L km.

63
00:04:18,830 --> 00:04:23,216
Así que esta desigualdad checa si la posición currentRefill+1 

64
00:04:23,216 --> 00:04:26,100
es alcanzable desde la posición lastRefill.

65
00:04:26,100 --> 00:04:29,890
Si lo es, incrementamos el valor de currentRefill

66
00:04:29,890 --> 00:04:33,020
y continuamos con nuestro bucle while interno.

67
00:04:33,020 --> 00:04:39,380
Cuando salimos de este bucle while interno tal vez ya estemos en el punto B,

68
00:04:39,380 --> 00:04:45,189
o a la mejor estamos en algún punto donde está la estación más lejana alcanzable.

69
00:04:46,420 --> 00:04:49,760
Ahora comparamos la posición con la de lastRefill,

70
00:04:49,760 --> 00:04:54,960
y si resulta que son las mismas, significa que no pudimos ir a la derecha.

71
00:04:54,960 --> 00:04:59,270
No tenemos suficiente combustible para llegar a la siguiente estación.

72
00:04:59,270 --> 00:05:03,820
Y entonces no podemos devolver el mínimo número de recargas que necesitamos hacer

73
00:05:03,820 --> 00:05:08,950
en el camino de A a B, porque es imposible llegar de A a B.

74
00:05:08,950 --> 00:05:12,320
Y así, devolvemos IMPOSIBLE como respuesta.

75
00:05:12,320 --> 00:05:17,880
De otra forma, nos movemos al menos un poco a la derecha y necesitamos checar.

76
00:05:17,880 --> 00:05:21,630
Si ya estamos en el punto B no necesitamos hacer nada más.

77
00:05:21,630 --> 00:05:23,580
De otro modo, necesitamos recargar ahí.

78
00:05:23,580 --> 00:05:29,279
Así que checamos si estamos a la izquierda de B con esta desigualdad.

79
00:05:29,279 --> 00:05:32,950
Y si es cierta, entonces estamos en alguna estación de gasolina y necesitamos recargar,

80
00:05:32,950 --> 00:05:36,870
e incrementamos la variable numRefills por uno,

81
00:05:36,870 --> 00:05:41,000
y regresamos al principio de nuestro bucle while externo.

82
00:05:41,000 --> 00:05:44,060
Y ahí, de nuevo checamos. Si estamos a la izquierda del punto B,

83
00:05:44,060 --> 00:05:46,190
necesitamos otra iteración.

84
00:05:46,190 --> 00:05:51,110
Y si currentRefill es ya n+1, entonces alcanzamos el punto B

85
00:05:51,110 --> 00:05:53,620
y salimos del bucle while externo.

86
00:05:53,620 --> 00:05:54,480
En este caso,

87
00:05:54,480 --> 00:05:58,350
sólo regresamos la respuesta que es el número de recargas que hemos hecho hasta ahora.

88
00:06:00,650 --> 00:06:03,960
Ya implementamos el algoritmo voraz de la clase pasada,

89
00:06:03,960 --> 00:06:06,219
ahora analicemos su tiempo de ejecución.

90
00:06:06,219 --> 00:06:11,248
A primera vista pareciera que opera en tiempo n al cuadrado porque

91
00:06:11,248 --> 00:06:15,925
tenemos el bucle while externo que puede hacer n iteraciones

92
00:06:15,925 --> 00:06:19,298
y el bucle interno que puede hacer n iteraciones.

93
00:06:19,298 --> 00:06:24,203
Así que nxn es n cuadrado, pero vamos a mostrar que

94
00:06:24,203 --> 00:06:29,210
sólo hace del O de n acciones para el algoritmo entero.

95
00:06:29,210 --> 00:06:32,600
Para probar esto, primero chequemos la variable currentRefill.

96
00:06:33,920 --> 00:06:37,690
Vemos que sólo cambia de uno en uno,

97
00:06:40,660 --> 00:06:43,032
comenzando del cero.

98
00:06:43,032 --> 00:06:47,480
y ¿cuál es el valor más grande que puede alcanzar?

99
00:06:48,510 --> 00:06:53,510
Por supuesto, el número más grande es n+1 porque

100
00:06:53,510 --> 00:06:59,670
es el mayor índice en el arreglo x, y currentRefill es un índice en el arreglo x.

101
00:06:59,670 --> 00:07:04,389
Entonces, la variable currentRefill empieza en cero, cambia de uno en uno,

102
00:07:04,389 --> 00:07:08,408
y el mayor valor que puede tener es n+1.

103
00:07:08,408 --> 00:07:12,979
Eso significa que se incrementa a lo más n+1 veces lo que es del O de n.

104
00:07:12,979 --> 00:07:15,270
Pero eso no es todo.

105
00:07:15,270 --> 00:07:18,280
También aumentamos la variable numRefills aquí.

106
00:07:20,030 --> 00:07:23,220
Pero también la aumentamos de uno en uno, siempre.

107
00:07:23,220 --> 00:07:25,070
También empieza desde cero,

108
00:07:25,070 --> 00:07:28,360
y, ¿cuál es el mayor número que esta variable puede alcanzar?

109
00:07:29,560 --> 00:07:33,000
Bien, por supuesto que es n, porque tenemos n estaciones de gasolina.

110
00:07:33,000 --> 00:07:36,230
No hay necesidad de rellenar dos veces en la misma estación de gas.

111
00:07:36,230 --> 00:07:39,490
Así que podemos rellenar a lo más n veces.

112
00:07:39,490 --> 00:07:45,210
Así que la variable numRefills va desde 0 hasta n y cambia de uno en uno.

113
00:07:45,210 --> 00:07:48,160
Así que sólo cambió a lo más n veces,

114
00:07:49,210 --> 00:07:52,560
y por tanto, es también lineal en términos de n.

115
00:07:52,560 --> 00:07:58,220
Entonces, tenemos a lo más n+1 iteraciones en el bucle while externo.

116
00:07:58,220 --> 00:08:01,830
Todo excepto el bucle while interno toma tiempo constante,

117
00:08:01,830 --> 00:08:05,550
esta asignación, este if, y este if con asignación,

118
00:08:06,610 --> 00:08:08,970
y el bucle externo y el

119
00:08:08,970 --> 00:08:15,120
bucle interno combinados también gastan a lo más un tiempo lineal en las iteraciones,

120
00:08:15,120 --> 00:08:18,640
porque cambian la variable currentRefill

121
00:08:18,640 --> 00:08:21,320
que cambia a lo más un número lineal de veces.

122
00:08:21,320 --> 00:08:24,800
Así que todo nuestro algoritmo trabaja en tiempo O de n..

123
00:08:25,810 --> 00:08:29,010
Repasemos esta demostración de nuevo.

124
00:08:29,010 --> 00:08:33,480
El lema dice que el tiempo de ejecución del algoritmo completo es O de n.

125
00:08:33,480 --> 00:08:36,440
Y probamos esto primero notando que la variable

126
00:08:36,440 --> 00:08:40,150
currentRefill cambia sólo de 0 hasta a lo más n+1,

127
00:08:40,150 --> 00:08:42,610
y el cambio es siempre de uno en uno.

128
00:08:42,610 --> 00:08:46,220
Que la variable numRefills cambia desde 0 hasta a lo más n,

129
00:08:46,220 --> 00:08:47,690
y también lo hace de uno en uno.

130
00:08:47,690 --> 00:08:52,050
Por lo que las dos variables cambian en tiempo O de n.

131
00:08:52,050 --> 00:08:55,850
Y todo lo demás que pasa es tiempo constante.

132
00:08:55,850 --> 00:08:58,090
Cada iteración del bucle externo, y

133
00:08:58,090 --> 00:09:01,440
hay a lo más n+1 iteraciones del bucle externo.

134
00:09:01,440 --> 00:09:06,329
Por lo que nuestro algoritmo corre en tiempo lineal.

135
00:09:06,329 --> 00:09:07,465
este de aquí,

136
00:09:07,465 --> 00:09:11,809
vamos a revisar lo que aprendimos sobre algoritmos voraces en general.