1
00:00:00,370 --> 00:00:05,190
Hi, in this lesson, we will review what
we saw in this module about greedy

2
00:00:05,190 --> 00:00:10,600
algorithms and specify what is common and
important to all greedy algorithms.

3
00:00:10,600 --> 00:00:14,860
The main ingredients of any greedy
algorithm are greedy choice and

4
00:00:14,860 --> 00:00:16,810
reduction to a subproblem.

5
00:00:16,810 --> 00:00:20,430
You have to prove that your
greedy choice is a safe move.

6
00:00:20,430 --> 00:00:25,540
And also, you have to check that the
problem that is left after your safe move

7
00:00:25,540 --> 00:00:27,010
is really a subproblem.

8
00:00:27,010 --> 00:00:31,010
That is, a problem of the same kind but
with fewer parameters.

9
00:00:31,010 --> 00:00:34,930
After you have both,
you have a greedy algorithm.

10
00:00:34,930 --> 00:00:37,840
Then, you need to estimate
its running time and

11
00:00:37,840 --> 00:00:39,779
check that it's good enough for you.

12
00:00:41,130 --> 00:00:43,740
Safe moves in different
problems are different.

13
00:00:43,740 --> 00:00:47,630
Basically, you have to invent something
each time you have a new problem.

14
00:00:47,630 --> 00:00:52,385
In the first problem it was,
select the maximum digit and put it first.

15
00:00:52,385 --> 00:00:57,840
In the last problem it was select the item
with the maximum total value per weight.

16
00:00:58,910 --> 00:01:04,720
And you see that in every safe move,
there's something like maximum,

17
00:01:04,720 --> 00:01:09,150
or minimum, or first, or
leftmost, or rightmost.

18
00:01:09,150 --> 00:01:14,400
So, always safe move is greedy,
but not all greedy moves are safe.

19
00:01:14,400 --> 00:01:16,930
So, you really have to prove every time

20
00:01:16,930 --> 00:01:18,810
that the move that you
invented is really safe.

21
00:01:20,390 --> 00:01:23,140
Also, you can notice that sometimes we can

22
00:01:23,140 --> 00:01:28,440
optimize our initial greedy algorithm
if we sort our object somehow.

23
00:01:28,440 --> 00:01:32,100
So, you can maybe try to solve problem,

24
00:01:32,100 --> 00:01:37,030
assuming that everything is
sorted in some convenient order.

25
00:01:37,030 --> 00:01:38,680
And if you see that, because of that,

26
00:01:38,680 --> 00:01:43,335
your greedy algorithm can be
implemented asymptotically faster,

27
00:01:43,335 --> 00:01:48,060
then you can just apply sorting first and
then your greedy algorithm.

28
00:01:49,510 --> 00:01:53,020
The general strategy is
when I have a problem,

29
00:01:53,020 --> 00:01:57,250
you can try to come up with some greedy
choices, and then for some of them,

30
00:01:57,250 --> 00:02:00,950
you'll be able to prove that
they're really safe moves.

31
00:02:00,950 --> 00:02:04,160
And if you've proven
that this is a safe move,

32
00:02:04,160 --> 00:02:07,070
then you've reduced your
problem to something.

33
00:02:07,070 --> 00:02:10,080
And then you have to check that
this something is a subproblem.

34
00:02:10,080 --> 00:02:13,850
That is, the problem about the same thing,

35
00:02:13,850 --> 00:02:17,070
optimizing the same thing
with the same restrictions.

36
00:02:17,070 --> 00:02:19,070
And then, this is a subproblem.

37
00:02:19,070 --> 00:02:24,250
And then you can solve it in the same way
that you solved your initial problem.

38
00:02:24,250 --> 00:02:27,730
And you have this loop from
problem to subproblem and

39
00:02:27,730 --> 00:02:32,840
back to the problem, always reducing
it by the number of parameters.

40
00:02:32,840 --> 00:02:35,430
And in the end of this loop,
you will have a problem so

41
00:02:35,430 --> 00:02:41,530
simple that you can solve it right
away for one object or zero objects.

42
00:02:41,530 --> 00:02:43,727
And then you have your greedy algorithm.