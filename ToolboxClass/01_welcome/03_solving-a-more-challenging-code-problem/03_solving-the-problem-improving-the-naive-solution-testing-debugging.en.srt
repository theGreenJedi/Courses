1
00:00:00,390 --> 00:00:04,680
In this video, we will consider
a more interesting code problem.

2
00:00:04,680 --> 00:00:10,540
This problem will require us to implement
a faster than a naive solution first,

3
00:00:10,540 --> 00:00:15,530
then to debug it, then to stress
test it before we actually come up with

4
00:00:15,530 --> 00:00:21,390
a correct solution that will be able to
pass all the tests in the testing system.

5
00:00:21,390 --> 00:00:25,870
So the problem is called the maximum
prioritized product problem.

6
00:00:25,870 --> 00:00:30,815
In this problem, we're given an array,
or a sequence of n numbers.

7
00:00:30,815 --> 00:00:35,300
And our goal is to find
a number which can be obtained

8
00:00:35,300 --> 00:00:39,650
by multiplying some two
numbers from this sequence.

9
00:00:40,730 --> 00:00:46,020
So recall that our problem is given
a sequence of n non-negative integers

10
00:00:46,020 --> 00:00:48,920
to find the maximum pairwise product.

11
00:00:48,920 --> 00:00:52,960
So the input to this problem
consists of two lines.

12
00:00:52,960 --> 00:00:56,521
The first line contains
just a single number n,

13
00:00:56,521 --> 00:01:01,163
which is at least 2 and
at most 2 multiplied by 10 to the 5.

14
00:01:01,163 --> 00:01:05,154
The next line contains the sequence
of n numbers which are

15
00:01:05,154 --> 00:01:08,909
non-negative integers not
exceeding 10 to the 5.

16
00:01:08,909 --> 00:01:15,090
So our goal is to output a single number,
the maximum pairwise product.

17
00:01:15,090 --> 00:01:18,447
The page contains also two sample tests.

18
00:01:18,447 --> 00:01:24,262
For example, if an input to our program
is a sequence of length 3 consisting

19
00:01:24,262 --> 00:01:29,241
of numbers 1, 2, 3,
then the output should be, of course, 6,

20
00:01:29,241 --> 00:01:32,500
because this is just 2 multiplied by 3.

21
00:01:32,500 --> 00:01:37,867
For a slightly longer sequence of size 10,

22
00:01:37,867 --> 00:01:41,399
the output should be 140,

23
00:01:41,399 --> 00:01:45,789
and this is 10 multiplied by 14.

24
00:01:45,789 --> 00:01:50,094
So as usual there is also a section that

25
00:01:50,094 --> 00:01:54,940
contains starter files and let's begin,

26
00:01:54,940 --> 00:02:01,818
choose C++ as our programming language for
this problem.

27
00:02:01,818 --> 00:02:06,490
This is how the starter C++
solution file looks like.

28
00:02:06,490 --> 00:02:11,540
So we start by reading the number
n from the standard input.

29
00:02:11,540 --> 00:02:15,540
We then create an array,
or a vector of size n.

30
00:02:15,540 --> 00:02:21,200
We then fill in this vector by elements
of our sequence, element by element.

31
00:02:21,200 --> 00:02:23,950
Then we read from the standard input.

32
00:02:23,950 --> 00:02:27,485
We then pass the real
numbers to the function

33
00:02:27,485 --> 00:02:31,850
MaxPairwiseProduct that computes
the answer to our problem.

34
00:02:32,900 --> 00:02:36,953
Let's see what is going on inside
the function MaxPairwiseProduct.

35
00:02:36,953 --> 00:02:42,936
So we start by initializing
the variable result by 0 and

36
00:02:42,936 --> 00:02:50,300
we then go through all possible
pairs of different elements.

37
00:02:50,300 --> 00:02:55,460
That is, we go through all possible i and
j, where i is less than j.

38
00:02:55,460 --> 00:02:58,040
We do this by two nested loops.

39
00:02:58,040 --> 00:03:02,580
And for each such pair, we check whether
the product of the corresponding two

40
00:03:02,580 --> 00:03:05,140
numbers is greater than
our current result.

41
00:03:05,140 --> 00:03:08,110
And if it is, we update the result.

42
00:03:08,110 --> 00:03:10,469
Finally, we return the result.

43
00:03:11,810 --> 00:03:16,100
So this algorithm is correct for
an obvious reason.

44
00:03:16,100 --> 00:03:21,380
The goal in our problem is to find
the maximum pairwise product, right?

45
00:03:21,380 --> 00:03:25,090
So to do this we just go
through all possible pairs and

46
00:03:25,090 --> 00:03:26,339
select the maximum product.

47
00:03:27,900 --> 00:03:33,166
Okay, to check that it is indeed correct,
let's, as usual, compile it.

48
00:03:36,801 --> 00:03:39,878
So for this we use.

49
00:03:42,503 --> 00:03:46,037
The compiler flags for C++.

50
00:03:58,560 --> 00:04:00,092
Okay, and then, we test it.

51
00:04:05,530 --> 00:04:10,381
For example, for the sequence of length 3,

52
00:04:10,381 --> 00:04:16,250
consisting of numbers 1 through 3,
then say 6.

53
00:04:16,250 --> 00:04:18,743
Let's test it one more time.

54
00:04:18,743 --> 00:04:22,160
For example, this sequence of length 5.

55
00:04:22,160 --> 00:04:25,723
Consisting of numbers 3, 4, 5, 1, 2.

56
00:04:25,723 --> 00:04:32,900
So the answer is 20 as expected,
because this is the product of 4 and 5.

57
00:04:32,900 --> 00:04:37,510
Okay, so it seems that this solution
is correct and let's just go ahead and

58
00:04:37,510 --> 00:04:41,320
submit it as a solution
to the testing system.

59
00:04:41,320 --> 00:04:45,380
So I've just submitted our current
solution to the grading system,

60
00:04:45,380 --> 00:04:48,370
but unfortunately it
hadn't passed all the tests.

61
00:04:48,370 --> 00:04:52,960
In particular, there is an error
message shown in the grading system.

62
00:04:52,960 --> 00:04:53,570
Let's take a look.

63
00:04:54,710 --> 00:04:59,190
So it says that our solution failed

64
00:04:59,190 --> 00:05:03,230
test case number three,
which consists of just two numbers.

65
00:05:03,230 --> 00:05:07,158
The first one is 10 to the 5, and

66
00:05:07,158 --> 00:05:10,970
the second one is 90,000.

67
00:05:10,970 --> 00:05:15,798
Let's check whether we can reproduce
this behavior on our local machine.

68
00:05:15,798 --> 00:05:20,777
So let's call our program

69
00:05:20,777 --> 00:05:25,303
with just two numbers,

70
00:05:25,303 --> 00:05:31,686
10 to the 5 and 90,000.

71
00:05:31,686 --> 00:05:36,350
So indeed, as a result,
instead of getting nine

72
00:05:36,350 --> 00:05:41,130
billions as we would expect,
we got some random number.

73
00:05:41,130 --> 00:05:44,830
So this usually happens when
there is an integer overflow.

74
00:05:44,830 --> 00:05:48,970
And indeed, so
we use the standard integer type for

75
00:05:48,970 --> 00:05:53,420
storing the result of
multiplying two numbers.

76
00:05:53,420 --> 00:05:55,700
While nine billion is too much for

77
00:05:55,700 --> 00:06:00,000
the integer type, so
it doesn't fit into the integer type.

78
00:06:00,000 --> 00:06:05,950
So what we are supposed to do is
actually to use a long, long C++ type.

79
00:06:05,950 --> 00:06:11,271
So let's do this and check whether this

80
00:06:11,271 --> 00:06:16,440
will fix our problem, our solution.

81
00:06:19,190 --> 00:06:23,609
So for
this we need to change all the places

82
00:06:23,609 --> 00:06:27,913
where we compute and store the results.

83
00:06:27,913 --> 00:06:32,437
So first of all we change
the declaration of this variable,

84
00:06:32,437 --> 00:06:38,020
we change also the type of
the return observe returns result.

85
00:06:38,020 --> 00:06:44,520
When computing the product of
this to numbers we first cast.

86
00:06:46,200 --> 00:06:51,281
For example, the first

87
00:06:51,281 --> 00:06:57,384
one to the long, long type.

88
00:07:00,117 --> 00:07:04,444
Okay, and also

89
00:07:04,444 --> 00:07:09,360
here, great.

90
00:07:09,360 --> 00:07:10,780
Let's now compile it once again.

91
00:07:13,550 --> 00:07:22,220
Yes, and let's run it to check whether it
correctly processes our previous data set.

92
00:07:26,300 --> 00:07:30,750
So 10 to the 5 and 90,000.

93
00:07:30,750 --> 00:07:35,080
Great, so
it correctly outputs nine billion.

94
00:07:35,080 --> 00:07:38,690
So now, we must be completely sure
that our solution is correct.

95
00:07:38,690 --> 00:07:43,090
Because, well, first of all,
to find the maximum pairwise product,

96
00:07:43,090 --> 00:07:47,540
we'd just go through all possible
pairs and select the maximum product.

97
00:07:47,540 --> 00:07:50,670
So what can we do else?

98
00:07:50,670 --> 00:07:56,110
And also, we now use the right type for
storing the result.

99
00:07:56,110 --> 00:08:02,860
So let's go ahead and submit our new
solution to the grading system.

100
00:08:02,860 --> 00:08:07,630
Unfortunately our solution
is still incorrect.

101
00:08:07,630 --> 00:08:12,430
So in this particular case, the output
of the grading system is the following:

102
00:08:12,430 --> 00:08:15,040
Failed case 4, time limit exceeded.

103
00:08:15,040 --> 00:08:18,730
So it means that our solution
is quite slow, that for

104
00:08:18,730 --> 00:08:24,050
large datasets it runs
in more than one second.

105
00:08:25,820 --> 00:08:28,740
So let's try to understand why it so
happens.

106
00:08:28,740 --> 00:08:34,051
First of all, the maximum size of a data
set is the maximum size of a sequence for

107
00:08:34,051 --> 00:08:37,768
this problem, in our case,
it is roughly 10 to the 5.

108
00:08:37,768 --> 00:08:42,296
So what is the number of operations
performed by our algorithm on such

109
00:08:42,296 --> 00:08:43,900
a sequence?

110
00:08:43,900 --> 00:08:48,940
So recall that in our algorithm
we just go through all possible pairs

111
00:08:48,940 --> 00:08:50,150
of input numbers.

112
00:08:50,150 --> 00:08:51,720
So this is roughly n squared.

113
00:08:51,720 --> 00:08:55,150
So when n is equal to 10 to the 5,
this is 10 to the 10.

114
00:08:55,150 --> 00:08:59,160
And this is more than one billion.

115
00:08:59,160 --> 00:09:03,760
And one billion is roughly the number of
basic operations that modern computers can

116
00:09:03,760 --> 00:09:06,320
perform in one second.

117
00:09:06,320 --> 00:09:12,480
So we conclude that we need a faster
algorithm to solve this problem.

118
00:09:12,480 --> 00:09:18,110
In particular, we realize that we need
to find the maximum pairwise product,

119
00:09:18,110 --> 00:09:22,830
without actually going through
all possible pairs of numbers.

120
00:09:22,830 --> 00:09:30,440
So in search of an inspiration,
let's take a look at the problem page.

121
00:09:30,440 --> 00:09:36,940
In particular let's review
the second sample case.

122
00:09:36,940 --> 00:09:41,204
In this case,
our input consists of ten integers,

123
00:09:41,204 --> 00:09:44,787
and the output in this case, is 140.

124
00:09:44,787 --> 00:09:46,500
And why is that? Well,

125
00:09:46,500 --> 00:09:51,920
this is just because in our sequence
there are two numbers, 14 and 10.

126
00:09:51,920 --> 00:09:55,870
These two numbers are two
maximal numbers actually.

127
00:09:55,870 --> 00:10:01,148
So for any other two numbers,
their product are less than 140.

128
00:10:01,148 --> 00:10:06,455
So this gives us an idea: that to find
the maximum product of two numbers from

129
00:10:06,455 --> 00:10:13,130
our sequence, it is actually enough to
find two maximal numbers in our sequence.

130
00:10:13,130 --> 00:10:18,790
This is because all of our integers
in this sequence are non-negative.

131
00:10:18,790 --> 00:10:26,220
So let's just implement
this idea in our C++ file.

132
00:10:26,220 --> 00:10:29,690
So this is already implemented,
and it looks as follows.

133
00:10:29,690 --> 00:10:34,240
So the new function is called
MaxPairwiseProductFast.

134
00:10:34,240 --> 00:10:37,027
So it already uses the long.long type for

135
00:10:37,027 --> 00:10:40,400
storing the result and
we do the following.

136
00:10:40,400 --> 00:10:45,340
Just by scanning the input array two
times, we find two maximal numbers.

137
00:10:45,340 --> 00:10:51,140
So in the first block,
we find the first maximum and

138
00:10:51,140 --> 00:10:55,760
we store its index in
the max_index variable, and

139
00:10:55,760 --> 00:11:02,580
in the second block,
we find the second maximal element.

140
00:11:02,580 --> 00:11:07,930
So the difference in the second
block is that we also need to skip

141
00:11:07,930 --> 00:11:10,040
the first maximal element

142
00:11:11,810 --> 00:11:12,840
while scanning the array.

143
00:11:12,840 --> 00:11:16,545
So what we do is,
we do this in this check.

144
00:11:17,710 --> 00:11:23,085
Okay, and then we just return the product

145
00:11:23,085 --> 00:11:28,956
of two maximum numbers in our array,
right?

146
00:11:28,956 --> 00:11:34,574
Let's, as usual, compile it and

147
00:11:34,574 --> 00:11:40,980
see that everything works correctly.

148
00:11:40,980 --> 00:11:45,340
So, this is our new file,
max_pairwise_product_fast.ccp.

149
00:11:45,340 --> 00:11:51,275
We compile it and
we first run it on some small sequence.

150
00:11:51,275 --> 00:11:59,120
For example, size 3, for example,
2, 3, 4 it gives us 12 as expected.

151
00:11:59,120 --> 00:12:01,120
Great, now let's do the following.

152
00:12:01,120 --> 00:12:05,770
Let's check what is the running
time when a huge data set.

153
00:12:06,980 --> 00:12:11,966
So for this, let's instead of reading

154
00:12:11,966 --> 00:12:16,346
the data from the standard input,

155
00:12:16,346 --> 00:12:21,493
let's just generate a huge array here.

156
00:12:21,493 --> 00:12:28,487
Let's use vector of int of size 10 to the 5,

157
00:12:28,487 --> 00:12:34,746
and let it be an array filled by zeroes,

158
00:12:34,746 --> 00:12:40,470
let's compile it and let's run it.

159
00:12:41,600 --> 00:12:45,130
So it outputs zero immediately
which means that it,

160
00:12:45,130 --> 00:12:48,010
well, it is much faster then
the previous algorithm.

161
00:12:48,010 --> 00:12:52,590
So now our solution just
must be completely correct.

162
00:12:52,590 --> 00:12:57,312
So it is fast, it uses the right type for
storing the solution and

163
00:12:57,312 --> 00:13:00,198
it is also obviously correct because,

164
00:13:00,198 --> 00:13:05,283
well it selects two maximal numbers,
right, and multiplies them.

165
00:13:05,283 --> 00:13:10,229
No other product of two numbers can
be larger because we selected two

166
00:13:10,229 --> 00:13:12,280
maximal numbers.

167
00:13:12,280 --> 00:13:16,210
However, unfortunately,
even this solution is not correct.

168
00:13:16,210 --> 00:13:21,310
So you can submit it to the testing
system and see that the output

169
00:13:21,310 --> 00:13:26,430
will be wrong answer for some test case.

170
00:13:26,430 --> 00:13:31,670
In the next video, Michael will
tell you about stress testing and

171
00:13:31,670 --> 00:13:34,220
will show you how to fix this solution.