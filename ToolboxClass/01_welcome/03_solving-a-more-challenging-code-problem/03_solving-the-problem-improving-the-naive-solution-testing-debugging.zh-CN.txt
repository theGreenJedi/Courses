在这段视频中，我们会考虑一个更有趣的代码问题。 这个问题需要我们去实现比一个比朴素解决方案更快的方案， 然后我们调试它，进行压力测试 这样才能得到一个正确的解决方案，并能通过在线测试系统 我们的示范问题叫最大乘积优先问题
(maximum priortised product problem) 我们得到一个数组，或有n个数字的序列。 我们的目标是得到一个数字 由这个序列中两个最大的数字相乘得到 示范问题中有一个给定的n个非负整数序列 从中计算最大有限乘积( maximum pairwise product) 问题的输入有两行 第一行只是一个单一的数字n n至少大于2，且小于2乘10的5次方 下一行包含n个数的序列 都是非负整数且不超过10的5次方。 我们的目标是要输出一个整数，也就是最大乘积。 该页面还有两个检验示例 例如，如果输入序列1，2，3； 长度为3，则输出是6， 因为2乘以3 对于大小为10的稍长序列 输出应该是140， 这是10乘以14。 这里的部分 可以下载对应的编程语言文件开始做题 这次我们选C++ C++写出来的方案是这样的 我们从读取数字n开始。 然后，我们创建一个数组，或大小为n的向量。 然后，我们用数组元素填充这个向量 然后，我们再读取输入。 然后我们向函数传送实数 MaxPairwiseProduct(函数)得出我们的答案 让我们来看看函数MaxPairwiseProduct里面发生了什么 我们初始化变量result为0， 那么我们遍历所有元素两两配对的组合 也就是说，我们遍历所有可能的i和j的组合，其中i小于j 我们用两个嵌套循环执行此操作 对于每个租个，我们检查他们的乘积 是否比变量result当前的值大 如果是，我们更新结果 最后，我们返回结果。 这个算法自然是正确的。 我们的目标是找到最大优先的，对不对？ 因此，我们遍历所有可能的组合，得到它们的乘积 从中选择最大的 好了，要检查它确实是正确的，我们像往常一样，编译它。 我们使用 C++编译器 好了，然后，我们测试它。 例如，对于长度为3的序列， 包含1，2，3， 结果是6 让我们再测试一次 例如，长度为5的这种序列。 由数字3，4，5，1，2组成 因此，答案是20，因为4乘5 好了，看来这个解决方案是正确的，我们继续前进， 提交到测试系统。 所以，我刚刚提交了程序到测试系统， 但遗憾的是它没有通过所有的测试。 测试系统中有错误消息。 让我们一起来看看让我们一起来看看 所以说，我们的算法失败 第三个检测例，其中只包含两个数字。 第一个10的5次方 第二个是9万 让我们来看看我们是否能够在自己的机器上重现第三例的情况 打开程序 输入两个数字 10的5次方和9万 其结果，不是9亿 而是另一个数字 这叫整数溢出 我们使用的是标准的整数类型来储存结果 我们使用的是标准的整数类型来储存结果 90亿太大 整数型范围放不下 所以，我们应该用C++长整数类型。 我们看看用长整数型能否解决 我们看看用长整数型能否解决 所以我们需要改变所有储存结果的变量 所以我们需要改变所有储存结果的变量 所以首先我们改变这个变量的声明， 我们还改变返回观察返回结果的类型。 计算乘积时，我们把第一个数配到长整型 计算乘积时，我们把第一个数配到长整型 计算乘积时，我们把第一个数配到长整型 计算乘积时，我们把第一个数配到长整型 计算乘积时，我们把第一个数配到长整型 现在，再一次编译。 是的，让我们来运行它来检查其是否正确处理我们以前的数据集。 10的5次方和9万 太好了，这次正确输出九十亿。 我们必须确保我们的解决方案是正确的。 我们刚刚遍历了所有元素两两配对的组合 我们刚刚遍历了所有元素两两配对的组合 我们还干了什么？ 我们现在用了正确的类型来 现在再提交程序到测试系统， 还是不对 这次的判定结果是： 时间超过限制。 因此，这意味着我们的程序运行缓慢的，对于 数组处理时间就超过一秒 我们来看 数组的大小限制在10的5次方以内 数组的大小限制在10的5次方以内 处理数组时，有多少命令被执行？ 处理数组时，有多少命令被执行？ 在这个算法里，我们遍历所有可能的组合，得到它们的乘积 在这个算法里，我们遍历所有可能的组合，得到它们的乘积 大致是n平方次运行 所以，当n等于10的5次方，就要运行10的10次方。 这是超过十亿。 十亿次大致是一个现代计算机在一秒内运行的次数 十亿次大致是一个现代计算机在一秒内运行的次数 所以我们要用一个快一点的算法 我们没必要遍历所有配对组合来的到最大乘积 我们没必要遍历所有配对组合来的到最大乘积 我们来看看问题描述 重新来看第二个测试例 输入包括十个数字 输出是140 为何如此？ 你看 因为数列里最大的两个数字是14和10 因为数列里最大的两个数字是14和10 对于任何其他两个数字，其乘积是小于140。 所以得到最大乘积，只要找到最大的两个数字 所以得到最大乘积，只要找到最大的两个数字 因为所有这个序列整数都是非负的。 我们来重新写个程序 我们来重新写个程序 新的函数名为 已经用了长整数型来存储结果 已经用了长整数型来存储结果 遍历数组两边，找到两个最大数 第一段语句里，找出第一个最大值 存储在MAX_INDEX变量， 在第二段语句里，找出第二个最大数。 所以在第二块中的不同之处在于，我们还需要跳过 第一个最大数 第一个最大数 我们通过这个语句 然后返回两个最大数的乘积 然后返回两个最大数的乘积 现在我们编译它 现在我们编译它 所以，这是我们的新文件，max_pairwise_product_fast.ccp。 我们编译它，我们先对一些小的运行。 例如，容量3，元素2，3，4 结果输出12 我们继续 让我们来看看一个巨大的数组。 我们不用常规的输入读取方法 我们不用常规的输入读取方法 而是创建一个巨大的数组 使用10的5次方向量 将其变成一个用0数组， 然后 立刻输出结果 比上一个算法快多了 我们这次应该 这次算法效率很多，也用了合适类型来存储结果 我们也找到了两个最大数 我们也找到了两个最大数 我们也找到了两个最大数 我们也找到了两个最大数 但是这次 这次的测试，显示还是有些测试例不对 这次的测试，显示还是有些测试例不对 在下一个录像，Michael会告诉你什么是压力测试 还会告诉你们如何解决这个问题