1
00:00:00,170 --> 00:00:03,890
In this video we will launch
the stress test to find a test

2
00:00:03,890 --> 00:00:07,690
on which our main solution and
alternative solutions differ,

3
00:00:07,690 --> 00:00:11,650
use this test to debug our
main solution and fix it.

4
00:00:11,650 --> 00:00:12,590
So we save the file.

5
00:00:13,780 --> 00:00:18,620
Now we will compile this file
because we will want to run it.

6
00:00:18,620 --> 00:00:25,130
And to compile this file, we go to the
section Solving Programming Assignments.

7
00:00:25,130 --> 00:00:33,100
We look at the C++ Flags, copy them,
and then use them to compile our file.

8
00:00:33,100 --> 00:00:37,390
Also, of course,
specify which file want to compile and

9
00:00:37,390 --> 00:00:41,401
also the name for the output file
will be stress_test, without .cpp.

10
00:00:42,890 --> 00:00:48,060
So we compile our stress test and
then we launch it and see what happens.

11
00:00:48,060 --> 00:00:52,370
So we see,
our screen was filled with a lot of lines.

12
00:00:52,370 --> 00:00:57,812
Actually, those lines were words,
OK, and some numbers,

13
00:00:57,812 --> 00:01:03,695
like number n from 2 to 11, and
input numbers, which are big.

14
00:01:03,695 --> 00:01:08,376
And there are a lot of tests for
which our solutions didn't differ, and

15
00:01:08,376 --> 00:01:10,180
that all went pretty fast.

16
00:01:10,180 --> 00:01:15,350
And then in the end,
we have number 11, which is n, and

17
00:01:15,350 --> 00:01:19,530
then 11 big numbers, which is
the input test, and then the words,

18
00:01:19,530 --> 00:01:24,895
Wrong answer and two very big numbers
which are different, which are the answers

19
00:01:24,895 --> 00:01:29,400
correspondingly of the first and
the second solution we implemented.

20
00:01:29,400 --> 00:01:30,220
So now,

21
00:01:30,220 --> 00:01:36,020
we already have a test on which at least
one of our solution runs incorrectly.

22
00:01:36,020 --> 00:01:41,030
But it is very hard to work with this
test because we have 11 numbers and

23
00:01:41,030 --> 00:01:44,250
they are very big and
the answer to this problem is even bigger.

24
00:01:44,250 --> 00:01:50,160
So let us try to find a smaller test
on which our solution still fails.

25
00:01:50,160 --> 00:01:56,530
Usually we can create a very
small test with this technique.

26
00:01:56,530 --> 00:02:01,820
So let's go back to our code,
stress_test.cpp.

27
00:02:01,820 --> 00:02:09,050
And let's decrease the restrictions
on n and on the numbers.

28
00:02:09,050 --> 00:02:14,080
So, for example,
we want our number n to be no more than 5,

29
00:02:14,080 --> 00:02:18,230
then we first generate a random number
modulo 4 so it will be from 0 to 3.

30
00:02:18,230 --> 00:02:22,170
And then, after adding 2,
it will be from 2 to 5.

31
00:02:22,170 --> 00:02:26,950
And also,
we want our numbers to be less than 10.

32
00:02:26,950 --> 00:02:30,270
So we just generate numbers modulo ten.

33
00:02:31,340 --> 00:02:33,540
And that's everything we change.

34
00:02:33,540 --> 00:02:35,720
Now we save the file.

35
00:02:35,720 --> 00:02:39,110
We recompile with the same options.

36
00:02:39,110 --> 00:02:41,430
And we again launch our stress test.

37
00:02:42,790 --> 00:02:49,030
Now, we found a test on which
solutions differ even faster.

38
00:02:49,030 --> 00:02:52,260
Only maybe five or seven tests were OK.

39
00:02:52,260 --> 00:02:56,100
And now we have a test with five numbers,
which are 2, 9, 3, 1, and 9,

40
00:02:56,100 --> 00:02:59,000
on which our solutions differ.

41
00:02:59,000 --> 00:03:01,820
And the answer of
the first solution is 81.

42
00:03:01,820 --> 00:03:04,350
And the answer of
the second solution is 27.

43
00:03:04,350 --> 00:03:05,990
Which one of those is correct?

44
00:03:05,990 --> 00:03:11,930
Of course, the first one is correct,
because we have numbers 9 and

45
00:03:11,930 --> 00:03:17,100
second 9, which are the biggest in
the input, and their product is 81.

46
00:03:17,100 --> 00:03:21,330
So our first naive solution
gives a correct answer, but

47
00:03:21,330 --> 00:03:25,040
our second fast solution
gives an incorrect answer.

48
00:03:25,040 --> 00:03:28,770
And let's think why that can be.

49
00:03:28,770 --> 00:03:33,610
Well, that can be if it multiplies
wrong numbers from the array.

50
00:03:33,610 --> 00:03:38,810
So, let's go back in the code and
check which are those numbers.

51
00:03:40,800 --> 00:03:43,020
We can go into the code and

52
00:03:43,020 --> 00:03:48,010
we look into the code for
function MaxPairwiseProductFast.

53
00:03:48,010 --> 00:03:52,070
It's very convenient that we
have a separate function for

54
00:03:52,070 --> 00:03:56,200
this solution because the error
should be localized somewhere here.

55
00:03:56,200 --> 00:03:59,650
So to simplify our goal of debugging,

56
00:03:59,650 --> 00:04:04,900
let's output the indices of
the maximum number and of the second

57
00:04:04,900 --> 00:04:10,750
maximum number that at least this function
thinks are two maximums in the array.

58
00:04:10,750 --> 00:04:13,190
So we output them to cout.

59
00:04:13,190 --> 00:04:17,320
First the first index,
then a space to separate them,

60
00:04:17,320 --> 00:04:21,090
then the second index, and
then newline character.

61
00:04:22,250 --> 00:04:24,050
So we save our program.

62
00:04:24,050 --> 00:04:29,460
We again recompile it, and
we again launch the stress test.

63
00:04:29,460 --> 00:04:35,620
So note that although we generate
random tests, it is safe to

64
00:04:35,620 --> 00:04:40,690
launch our stress test again
because those are pseudo random.

65
00:04:40,690 --> 00:04:44,960
The sequence of generated
random values is the same.

66
00:04:44,960 --> 00:04:48,590
So this is a reproducible test.

67
00:04:48,590 --> 00:04:53,300
So now, again, we have the same
test in which two solutions differ

68
00:04:53,300 --> 00:04:56,290
with five numbers, the same five numbers.

69
00:04:56,290 --> 00:05:01,280
And now, under the line with five numbers,
we have another line which says 1 2.

70
00:05:01,280 --> 00:05:08,140
This is actually our debug output, which
means that the index of the first number,

71
00:05:08,140 --> 00:05:12,452
which is maximum, is 1 and
it corresponds to number

72
00:05:12,452 --> 00:05:18,090
9 because we enumerate our numbers
from 0 in our C++ array.

73
00:05:18,090 --> 00:05:22,402
And the second number has index 2,
and this is number 3, again,

74
00:05:22,402 --> 00:05:24,810
because we enumerate from 0.

75
00:05:24,810 --> 00:05:29,400
So, our fast solution thinks
that the second maximum number

76
00:05:29,400 --> 00:05:33,130
in the array is the number 3 instead
of number 9, which is in position four.

77
00:05:34,450 --> 00:05:38,399
So let's go back to the code and
see why it happened.

78
00:05:39,770 --> 00:05:42,500
Again, we open the file with the code.

79
00:05:42,500 --> 00:05:45,920
We go to the function
MaxPairwiseProductFast.

80
00:05:45,920 --> 00:05:47,710
We ignore the code for

81
00:05:47,710 --> 00:05:52,350
the max_index1 and we're very
interested in the code for max_index2.

82
00:05:52,350 --> 00:05:57,390
So now let's look at this
complex if expression,

83
00:05:58,430 --> 00:06:04,410
where we try to determine
whether a number at position j

84
00:06:05,530 --> 00:06:11,660
may be a new maximum, which is different
from the maximum we've already found.

85
00:06:11,660 --> 00:06:16,450
And let's look more closely at
this particular first condition.

86
00:06:16,450 --> 00:06:21,240
So here, what we do is we check
that number at position number j is

87
00:06:21,240 --> 00:06:24,620
different from the maximum
we've already found.

88
00:06:24,620 --> 00:06:26,640
But that's exactly the problem.

89
00:06:26,640 --> 00:06:30,120
What we need is instead, that j

90
00:06:30,120 --> 00:06:34,960
is different from max_index1 because we
don't want to find the same number, but

91
00:06:34,960 --> 00:06:40,600
we can find number which is equal
to the first found maximum.

92
00:06:40,600 --> 00:06:45,574
So, instead of this comparison,
what we actually need is to compare j,

93
00:06:49,210 --> 00:06:52,039
To max_index1.

94
00:06:52,039 --> 00:06:57,360
If we fix our code this way,
then we will be at least able

95
00:06:57,360 --> 00:07:03,570
to find the second number 9 in our
input array 2 9 3 1 9, which we saw.

96
00:07:03,570 --> 00:07:07,450
So let's see how it
goes after we fix this.

97
00:07:07,450 --> 00:07:12,460
So we save the file, we again
recompile it with the same options and

98
00:07:12,460 --> 00:07:14,820
we launch our stress test.

99
00:07:14,820 --> 00:07:20,510
So now what we see is a screen
which is very quickly filling with

100
00:07:20,510 --> 00:07:25,240
some numbers, some words OK, and
then some numbers again and words OK.

101
00:07:25,240 --> 00:07:30,170
And we should wait for some time,
for maybe 10 seconds or

102
00:07:30,170 --> 00:07:37,025
even 30 seconds to be sure that we cannot
find a test in which our solutions differ.

103
00:07:37,025 --> 00:07:40,380
But, by now,
it seems that that is the case.

104
00:07:40,380 --> 00:07:43,255
And in the next video,
we will do more testing and

105
00:07:43,255 --> 00:07:46,984
then submit our main solution to
the system and see how it goes.