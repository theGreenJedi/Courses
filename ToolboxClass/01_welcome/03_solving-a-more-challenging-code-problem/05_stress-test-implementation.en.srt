1
00:00:00,000 --> 00:00:03,857
The previous video ended on
an unsuccessful attempt to submit our

2
00:00:03,857 --> 00:00:06,680
solution to the max
pairwise product problem.

3
00:00:06,680 --> 00:00:09,950
Even worse, we don't know what is
the test on which our program fails

4
00:00:09,950 --> 00:00:12,340
because the system doesn't show it to us.

5
00:00:12,340 --> 00:00:14,881
This is actually a pretty
standard situation when

6
00:00:14,881 --> 00:00:17,127
solving algorithmic programming assignments.

7
00:00:17,127 --> 00:00:21,849
In this, and the next few videos, we will
learn how to overcome this situation and

8
00:00:21,849 --> 00:00:23,976
to even avoid it in the first place.

9
00:00:23,976 --> 00:00:25,279
I will explain to you and

10
00:00:25,279 --> 00:00:29,340
show you in action a powerful
technique called stress testing.

11
00:00:29,340 --> 00:00:32,782
By the end, you will be able
to implement a stress test for

12
00:00:32,782 --> 00:00:36,800
your solution of an algorithmic problem,
use it to find a small and

13
00:00:36,800 --> 00:00:40,532
easy test on which your program fails,
debug your program, and

14
00:00:40,532 --> 00:00:44,453
make sure it works correctly
afterwards with high confidence.

15
00:00:44,453 --> 00:00:48,499
Also, you will be able to list and apply
the set of standard testing techniques,

16
00:00:48,499 --> 00:00:52,012
which should be always applied when
solving algorithmic programming

17
00:00:52,012 --> 00:00:52,799
assignments.

18
00:00:52,799 --> 00:00:54,958
So what is stress testing?

19
00:00:54,958 --> 00:00:59,786
In general, it is a program that generates
random tests in an infinite loop, and

20
00:00:59,786 --> 00:01:03,194
for each test,
it launches your solution on this test and

21
00:01:03,194 --> 00:01:07,257
an alternative solution on the same
test and compares the results.

22
00:01:07,257 --> 00:01:12,027
This alternative solution you also have
to invent and implement yourself, but

23
00:01:12,027 --> 00:01:17,008
it is usually easy, because it can be any
simple, slow, brute force solution, or

24
00:01:17,008 --> 00:01:20,510
just any other solution that
you can come up with.

25
00:01:20,510 --> 00:01:23,160
The only requirement is that
it should be significantly

26
00:01:23,160 --> 00:01:24,199
different from your main solution.

27
00:01:25,310 --> 00:01:29,480
Then you just wait until you find
a test on which your solutions differ.

28
00:01:29,480 --> 00:01:34,077
If one of them is correct and another is
wrong, then it is guaranteed to happen,

29
00:01:34,077 --> 00:01:38,742
because there is some test for which your
wrong solution gives the wrong answer, and

30
00:01:38,742 --> 00:01:42,606
your correct solution gives correct
answer, and so they differ.

31
00:01:42,606 --> 00:01:47,549
If, however, both of your solutions
are wrong, which also happens often,

32
00:01:47,549 --> 00:01:52,339
they are still almost guaranteed to have
some test on which one of them gives

33
00:01:52,339 --> 00:01:57,210
wrong answer and another one gives
correct answer because they're probably

34
00:01:57,210 --> 00:01:59,940
wrong in different places.

35
00:01:59,940 --> 00:02:04,620
When you find a test on which
your solutions' answers differ,

36
00:02:04,620 --> 00:02:09,038
you can determine which one of
them returns wrong answer and

37
00:02:09,038 --> 00:02:13,210
debug it, fix it, and
then repeat the stress testing.

38
00:02:13,210 --> 00:02:16,159
Now let's look at
the practical implementation.

39
00:02:16,159 --> 00:02:19,921
I've already implemented
the stress test for this problem.

40
00:02:19,921 --> 00:02:23,264
It is in the file called stress_test.cpp.

41
00:02:23,264 --> 00:02:25,633
Let's look into that.

42
00:02:25,633 --> 00:02:30,466
So it is almost the same as
the solution that we've sent

43
00:02:30,466 --> 00:02:35,210
in the previous video, but
I've added some things.

44
00:02:35,210 --> 00:02:39,430
First, we add this #include <cstd.lib>.

45
00:02:39,430 --> 00:02:42,935
And this include just
allows us to use a part of

46
00:02:42,935 --> 00:02:47,006
standard library to generate
some random numbers.

47
00:02:47,006 --> 00:02:51,630
And we will use it to generate
some random tests automatically.

48
00:02:51,630 --> 00:02:54,621
Then we have the same
code of two functions,

49
00:02:54,621 --> 00:02:58,780
MaxPairwiseProduct and
MaxPairwiseProductFast,

50
00:02:58,780 --> 00:03:03,280
which we used in our last solution
which was submitted in the system.

51
00:03:03,280 --> 00:03:08,580
But now in the main function,
we have a whole additional while loop.

52
00:03:09,600 --> 00:03:14,985
Here it is, and
this is where the stress test itself is.

53
00:03:14,985 --> 00:03:20,639
So what do we do in principle is
we generate some random tests,

54
00:03:20,639 --> 00:03:25,863
then we launch both solutions,
MaxPairwiseProduct and

55
00:03:25,863 --> 00:03:33,630
MaxPairwiseProductFast on this random test,
and we compare the results.

56
00:03:33,630 --> 00:03:40,098
And the idea is if you have a correct
solution and another correct solution and

57
00:03:40,098 --> 00:03:45,471
the correct answer for
your problem is the only correct answer,

58
00:03:45,471 --> 00:03:51,465
then any two correct solutions will
give the same answers for any test.

59
00:03:51,465 --> 00:03:56,366
And if you have some wrong solution and
some correct solution,

60
00:03:56,366 --> 00:04:00,168
then on some tests,
their answers will differ.

61
00:04:00,168 --> 00:04:04,798
And also if you have two wrong solutions,
then probably they're

62
00:04:04,798 --> 00:04:09,343
wrong in a different way, and
then there will also be some test,

63
00:04:09,343 --> 00:04:12,893
hopefully, on which their
answers differ.

64
00:04:12,893 --> 00:04:17,676
If you generate a lot of tests,
then with some probability, at some point,

65
00:04:17,676 --> 00:04:22,337
you will generate a test for which
the answers of the solutions differ.

66
00:04:22,337 --> 00:04:26,964
You can detect that situation, and then
look at the input test and at the answers.

67
00:04:28,260 --> 00:04:33,210
And you can determine which of the
algorithms was right, and which was wrong,

68
00:04:33,210 --> 00:04:34,710
maybe both were wrong.

69
00:04:34,710 --> 00:04:38,545
But anyway, you will find at least one of
the algorithms which are wrong because if

70
00:04:38,545 --> 00:04:42,880
their answers are different, then at
least one of them gives wrong answer.

71
00:04:42,880 --> 00:04:47,039
And then you will be able
to debug that algorithm,

72
00:04:47,039 --> 00:04:50,912
fix the bug, and
then run the stress test again.

73
00:04:50,912 --> 00:04:54,873
And either,
you will again find some difference, or

74
00:04:54,873 --> 00:04:59,538
you won't find any difference anymore,
and then hopefully,

75
00:04:59,538 --> 00:05:04,569
you fixed all the bugs in
all the solutions, and you can submit it.

76
00:05:04,569 --> 00:05:07,657
So how it works in practice.

77
00:05:07,657 --> 00:05:10,142
First, we need to generate the test for
our problem.

78
00:05:10,142 --> 00:05:15,482
We'll start with generating number n,
the number of numbers.

79
00:05:15,482 --> 00:05:22,517
And our problem states that
n should be at least 2.

80
00:05:22,517 --> 00:05:28,229
So we first generate a big random
number using function rand.

81
00:05:28,229 --> 00:05:30,389
Then we take it modulo 10, and

82
00:05:30,389 --> 00:05:34,962
it gives us some random number
between 0 and 9, and then we add 2.

83
00:05:34,962 --> 00:05:39,049
And so
we get a random number between 2 and 11.

84
00:05:39,049 --> 00:05:40,304
Why is it so small?

85
00:05:40,304 --> 00:05:47,385
Well, we first want both our
solutions to work fast enough.

86
00:05:47,385 --> 00:05:52,218
And also if we create a big random test,
it will be hard for

87
00:05:52,218 --> 00:05:57,782
us to debug it, so we start with
some relatively small value of n.

88
00:05:57,782 --> 00:06:02,042
We immediately output it on the screen,
so that if we find some tests for

89
00:06:02,042 --> 00:06:06,020
which our solution is wrong,
we immediately see it on the screen.

90
00:06:07,240 --> 00:06:12,349
After generating n, we should generate
the array of numbers, a, itself.

91
00:06:12,349 --> 00:06:18,713
So we iterate n times,
and we add random numbers

92
00:06:18,713 --> 00:06:24,771
from 0 to 99,999 to the end of array a.

93
00:06:24,771 --> 00:06:27,489
So these are the numbers in
the range which is allowed.

94
00:06:28,620 --> 00:06:31,760
And then we also output all
these numbers in one line,

95
00:06:31,760 --> 00:06:36,780
separated by spaces and
a newline character.

96
00:06:36,780 --> 00:06:41,810
So by this time, we've already output
the whole input test on the screen.

97
00:06:41,810 --> 00:06:44,830
Now what we need to do is
actually need to launch

98
00:06:44,830 --> 00:06:48,510
both our solutions on this input test and
get two results,

99
00:06:48,510 --> 00:06:52,660
the result of the main solution and
the result of the fast solution.

100
00:06:52,660 --> 00:06:55,382
After that, we compare those two results.

101
00:06:55,382 --> 00:06:59,850
If they are different, it means that at
least one of the solutions was wrong.

102
00:06:59,850 --> 00:07:04,640
So we output words Wrong answer
on the screen, and we also output

103
00:07:04,640 --> 00:07:10,330
the first result, a space, and the second
result and a newline character.

104
00:07:10,330 --> 00:07:12,657
After that, we break our loop.

105
00:07:12,657 --> 00:07:17,586
We can notice that our while loop
is a so-called infinite loop, but

106
00:07:17,586 --> 00:07:23,318
we actually end it as soon as we find
some test for which our solutions differ.

107
00:07:23,318 --> 00:07:28,866
If we don't find the different sum test,
we just output the word OK on the screen,

108
00:07:28,866 --> 00:07:34,164
to denote that actually both solutions
have already computed the answers,

109
00:07:34,164 --> 00:07:36,287
but the answers are the same.

110
00:07:36,287 --> 00:07:37,860
And then we continue.

111
00:07:37,860 --> 00:07:42,642
So we continue our infinite loop,
in the search of the test

112
00:07:42,642 --> 00:07:47,341
that will save us,
that we can use to debug our solution.

113
00:07:47,341 --> 00:07:52,423
And we wrote that code just in front
of all the code to read the numbers

114
00:07:52,423 --> 00:07:57,791
from the input, to compute the answer,
and to output it to the screen.

115
00:07:57,791 --> 00:08:03,270
So we basically inserted this
code in our regular program.

116
00:08:03,270 --> 00:08:06,790
But instead of reading
numbers from the input,

117
00:08:06,790 --> 00:08:11,896
it will first try to find the test for
which our two solutions differ.

118
00:08:11,896 --> 00:08:16,548
And in the next video, we will launch this
stress test to find a test in which our

119
00:08:16,548 --> 00:08:20,139
solutions differ,
debug our fast solution, and fix it.