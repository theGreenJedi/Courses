1
00:00:00,550 --> 00:00:03,290
In this video we'll look at
creating a faster divide and

2
00:00:03,290 --> 00:00:06,680
conquer algorithm in order to solve
the polynomial multiplication problem.

3
00:00:08,650 --> 00:00:15,460
This problem, this approach was invented
by Karatsuba in the early 1960s.

4
00:00:15,460 --> 00:00:18,500
So he was a graduate
student of Komolgorov,

5
00:00:18,500 --> 00:00:20,946
a famous Russian mathematician.

6
00:00:20,946 --> 00:00:26,380
And Komolgorov theorized that n squared
was the best that one could do.

7
00:00:26,380 --> 00:00:31,680
So there was a lower bound of n squared,
doing polynomial multiplication.

8
00:00:31,680 --> 00:00:34,960
Karatsuba, a grad student,
heard the problem, went away,

9
00:00:34,960 --> 00:00:38,040
came back a week later with a solution.

10
00:00:38,040 --> 00:00:41,510
So let's look at what is involved.

11
00:00:41,510 --> 00:00:46,494
So if we look at A(x) it's just
a very simple polynomial, a1x + a0.

12
00:00:46,494 --> 00:00:50,824
And B(x) = b1x + b0, and then C(x) is,
what would match in there?

13
00:00:50,824 --> 00:00:55,074
a1b1x squared + (a1b0 + a0b1)x + a0b0.

14
00:00:55,074 --> 00:00:57,970
So we'll notice here we
need four multiplications.

15
00:00:57,970 --> 00:00:59,370
We need to multiply a1 times b1.

16
00:00:59,370 --> 00:01:05,100
We need to multiply a1 times b0,
a0 times b1, and a0 times b0.

17
00:01:05,100 --> 00:01:10,430
This is how we did the divide and
conquer in fact in our last video.

18
00:01:10,430 --> 00:01:12,590
So we need four multiplications.

19
00:01:12,590 --> 00:01:17,400
Karatsuba's insight was that
there was a way to re-write C(x),

20
00:01:17,400 --> 00:01:20,650
so that you only needed to do
three multiplications.

21
00:01:20,650 --> 00:01:24,351
So basically what he did is
he re-wrote that inner term,

22
00:01:24,351 --> 00:01:28,580
a1b0 + a0b1 as something
slightly more complicated.

23
00:01:28,580 --> 00:01:32,512
So he added together, (a1 + a0) (b1 + b0).

24
00:01:32,512 --> 00:01:40,830
So (a1 + a0) (b1 + b0) is just
a1b1 + a0b1 + a1b0 + a0b0.

25
00:01:40,830 --> 00:01:44,308
And then he subtracted out the a1b1 and

26
00:01:44,308 --> 00:01:48,609
the a0b0, so he's left with a1b0 + a0b1.

27
00:01:48,609 --> 00:01:50,929
Which is exactly what's
there to begin with.

28
00:01:50,929 --> 00:01:54,510
The key here though,
is how many multiplications are needed.

29
00:01:54,510 --> 00:01:56,770
It only needs three multiplications.

30
00:01:56,770 --> 00:02:00,380
We need to compute a1 b1,
even though we use it twice.

31
00:02:00,380 --> 00:02:05,920
We need to compute a0 b0, even again,
though we use it only twice.

32
00:02:05,920 --> 00:02:11,560
And then we need to multiply
together (a1 + a0) and (b1 + b0).

33
00:02:11,560 --> 00:02:13,430
So we do have some extra additions.

34
00:02:13,430 --> 00:02:16,130
But the key is, when we have three
multiplications instead of four.

35
00:02:17,240 --> 00:02:17,840
Why does this matter?

36
00:02:19,030 --> 00:02:22,560
Well, why it matters is because

37
00:02:22,560 --> 00:02:26,590
we are reducing the number
of problems at each level.

38
00:02:26,590 --> 00:02:27,870
But let's first look at an example.

39
00:02:27,870 --> 00:02:29,191
So here we've got A(x).

40
00:02:29,191 --> 00:02:32,330
We're going to have 4 x
cubed + 3 x squared + 2x +1.

41
00:02:32,330 --> 00:02:34,907
B(x) = x cubed + 2 x squared + 3x + 4.

42
00:02:34,907 --> 00:02:38,227
We're going to go ahead and
pull out D1 and D0 like we did before.

43
00:02:38,227 --> 00:02:40,040
In our divide and conquer.

44
00:02:40,040 --> 00:02:44,420
The key is what we're going to actually
do in terms of the subproblems.

45
00:02:44,420 --> 00:02:45,770
So we have D1 and D0.

46
00:02:45,770 --> 00:02:47,840
We have E1 and we have E0.

47
00:02:47,840 --> 00:02:51,165
We're going to compute D1 E1,
again, just like we did before.

48
00:02:51,165 --> 00:02:54,852
We're going to compute D0 E0,
again just like we did before.

49
00:02:54,852 --> 00:02:59,242
But now we won't compute D1 E0 and D0 E1.

50
00:02:59,242 --> 00:03:02,310
Instead we're going to sum together D1 and
D0.

51
00:03:02,310 --> 00:03:03,829
Sum together E1 and E0.

52
00:03:06,200 --> 00:03:10,500
So (D1 + D0) is going to be (6x + 4).

53
00:03:10,500 --> 00:03:13,450
(E1 + E0) is going to be (4x plus 6).

54
00:03:13,450 --> 00:03:18,720
And then we multiply those two polynomials
together, yielding 24 x squared + 52x + 24.

55
00:03:18,720 --> 00:03:21,510
So, so far,
how many multiplications have we done?

56
00:03:21,510 --> 00:03:22,570
Three.

57
00:03:22,570 --> 00:03:27,702
And then, our final result for
A(x) B(x) is

58
00:03:27,702 --> 00:03:33,560
D1E1 times x to the fourth +,
now what do we do here?

59
00:03:33,560 --> 00:03:37,460
We take that (D1 + D0) (E1 + E0).

60
00:03:37,460 --> 00:03:39,150
(24x squared + 52x + 24), okay?

61
00:03:41,080 --> 00:03:42,340
Add that in the second term.

62
00:03:42,340 --> 00:03:45,340
And then subtract out D1 E1.

63
00:03:45,340 --> 00:03:46,920
Subtract out D0 E0.

64
00:03:48,220 --> 00:03:51,651
And then our final term will be D0 E0.

65
00:03:51,651 --> 00:03:56,863
If we simplify that middle portion,
and all of it.

66
00:03:56,863 --> 00:04:01,728
We just end up with 4 x to the sixth + 11 x to
the fifth + 20 x to the fourth + 3 x cubed +

67
00:04:01,728 --> 00:04:03,410
20 x squared + 11x + 4.

68
00:04:03,410 --> 00:04:06,724
Which is the exact same result we got
doing it in the more naive divide and

69
00:04:06,724 --> 00:04:07,650
conquer.

70
00:04:07,650 --> 00:04:11,810
And also the same way we'd do it if we
did a straight naive problem, okay?

71
00:04:11,810 --> 00:04:13,330
So we get the same result,

72
00:04:13,330 --> 00:04:15,700
three multiplications instead
of four multiplications.

73
00:04:15,700 --> 00:04:18,540
That extra multiplication
makes a big difference.

74
00:04:18,540 --> 00:04:19,760
Let's look at our runtime.

75
00:04:19,760 --> 00:04:22,160
So our initial problem is of size n.

76
00:04:22,160 --> 00:04:25,010
When we break it down,
we have three problems of size n over 2,

77
00:04:25,010 --> 00:04:26,414
again, rather than 4.

78
00:04:27,580 --> 00:04:29,690
So level 0, problem size n.

79
00:04:29,690 --> 00:04:31,640
Level 1, a problem of size n over 2.

80
00:04:31,640 --> 00:04:34,490
At level i,
our problems are of size n over 2 to the i,

81
00:04:34,490 --> 00:04:36,810
just like they were in the other
divide and conquer problem.

82
00:04:36,810 --> 00:04:38,890
And we have the same number of leaves.

83
00:04:40,300 --> 00:04:43,470
So at log base 2 of n level,
all the problems are of size 1.

84
00:04:43,470 --> 00:04:48,380
And the number of problems that we have,
1 of them at level 0,

85
00:04:48,380 --> 00:04:51,350
3 instead of 4 at level 1, 3 to the i.

86
00:04:51,350 --> 00:04:53,070
instead of 4 to the i, at level i.

87
00:04:53,070 --> 00:04:56,062
And 3 to the log base 2 of n,
instead of 4 to the log base,

88
00:04:56,062 --> 00:04:57,480
2 of n at the bottom level.

89
00:04:58,690 --> 00:04:59,880
How much work?

90
00:04:59,880 --> 00:05:03,300
We'll multiply together, so we'll figure
out for each problem how much it takes.

91
00:05:03,300 --> 00:05:05,706
In this case at level 0 it's kn.

92
00:05:07,935 --> 00:05:11,540
At level 1,
each problem takes k(n/2) work.

93
00:05:11,540 --> 00:05:12,640
And there are three of them.

94
00:05:12,640 --> 00:05:14,005
So it's k(3/2) n.

95
00:05:14,005 --> 00:05:18,020
At the ith level, we end up
with k times (3/2) to the i times n.

96
00:05:18,020 --> 00:05:23,040
And at the bottom level,
k times 3 to the log base 2 of n.

97
00:05:23,040 --> 00:05:31,030
a to the log base b of c, is the same
thing as c to the log base b of a.

98
00:05:31,030 --> 00:05:34,480
So therefore this is the same
as kn to the log base 2 of 3.

99
00:05:35,660 --> 00:05:41,856
We sum those, summation from i =
zero to log base 2 of n of

100
00:05:41,856 --> 00:05:47,290
3 to the i times k times n over 2 to the i.

101
00:05:47,290 --> 00:05:52,450
This is bounded, it's this geometric
series bounded by the last term.

102
00:05:52,450 --> 00:05:56,570
Which is big Theta of n
to the log base 2 of 3.

103
00:05:56,570 --> 00:05:58,770
Log base 2 of 3 is about 1.58.

104
00:05:58,770 --> 00:06:06,210
So, we now have a problem where our
solution is big Theta of n to the 1.58.

105
00:06:06,210 --> 00:06:12,370
Compared to our original problem, which
had a big Theta of n squared solution.

106
00:06:12,370 --> 00:06:17,150
So this makes a huge difference as n gets
large, in terms of our final runtime.

107
00:06:18,280 --> 00:06:22,060
It's not uncommon for divide and
conquer algorithms sometimes to require

108
00:06:22,060 --> 00:06:25,450
sort of a way of looking at it in
terms of breaking up a problem.

109
00:06:25,450 --> 00:06:27,744
So that you have fewer subproblems.

110
00:06:29,490 --> 00:06:34,280
And because of the compounding of the fact
that the more subproblems at a level,

111
00:06:34,280 --> 00:06:35,830
you have more, and more, and more.

112
00:06:37,090 --> 00:06:40,495
Reducing the number of subproblems,
reduces the final runtime.