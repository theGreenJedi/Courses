1
00:00:00,210 --> 00:00:05,400
В этом видео мы рассмотрим псевдокод
алгоритма "быстрой сортировки".

2
00:00:05,400 --> 00:00:08,850
Как вы можете помнить, алгоритм является рекурсивным.

3
00:00:08,850 --> 00:00:14,300
Поэтому, мы передаем в процедуру "быстрой сортировки" массив "А",

4
00:00:14,300 --> 00:00:18,660
и, также, два индекса: l (левый указатель) и r (правый указатель).

5
00:00:18,660 --> 00:00:24,770
и, таким образом, процедура сортирует подмассив массива А с индексами от l до r.

6
00:00:24,770 --> 00:00:28,380
Таким образом, сначала мы проверяем, что l не превышает r.

7
00:00:28,380 --> 00:00:32,330
И если это так, то это значит, что соответствующий
подмассив содержит

8
00:00:32,330 --> 00:00:33,670
не более одного элемента.

9
00:00:33,670 --> 00:00:37,000
и это значит, что ничего не нужно делать,
и мы просто делаем возврат из процедуры.

10
00:00:38,240 --> 00:00:42,780
В противном случае, мы вызываем процедуру разделения с такими же параметрами.

11
00:00:42,780 --> 00:00:46,470
Она возвращает индекс m, который находится между l и r.

12
00:00:46,470 --> 00:00:49,380
Таким образом, процедура перестраивает все элементы внутри

13
00:00:49,380 --> 00:00:52,760
этого подмассива следующим образом:

14
00:00:52,760 --> 00:00:57,580
После вызова этой процедуры, A[m] находится в своей конечной позиции.

15
00:00:57,580 --> 00:01:05,090
 Это значит, что все элементы слева не превышают A[m],

16
00:01:05,090 --> 00:01:08,570
и все элементы справа строго больше A[m].

17
00:01:08,570 --> 00:01:11,530
Еще раз, после вызова процедуры разделения

18
00:01:11,530 --> 00:01:15,140
A[m] находится в конечной позиции.

19
00:01:15,140 --> 00:01:20,590
Таким образом, остается только отсортировать все элементы,
которые не превышают A[m],

20
00:01:20,590 --> 00:01:25,810
они находятся левее A[m]. И все элементы,
что стоят справа от A[m].

21
00:01:25,810 --> 00:01:29,350
Мы просто делаем это с помощью двух рекурсивного вызовов.

22
00:01:29,350 --> 00:01:33,082
Вот как визуально выглядит алгоритм "быстрой сортировки".

23
00:01:33,082 --> 00:01:38,222
Еще раз, нам дан массив А с двумя индексами l и r.

24
00:01:38,222 --> 00:01:43,914
и мы собираемся отсортировать подмассив
массива A с индексами от l до r.

25
00:01:43,914 --> 00:01:49,463
Сначала мы вызываем процедуру разделения
с параметрами A, l и r.

26
00:01:49,463 --> 00:01:55,740
Которая возвращает индекс m, находящийся между
индексами l и r и обладающий следующим свойством:

27
00:01:55,740 --> 00:02:00,930
Все элементы левее A[m] не превышают A[m],

28
00:02:00,930 --> 00:02:04,320
Все элементы справа строго больше A[m].

29
00:02:04,320 --> 00:02:09,840
Далее мы делаем два рекурсивным вызова для сортировки
левой части с индексами

30
00:02:09,840 --> 00:02:15,360
от l до m - 1, и правой части с индексами от m + 1, до r.

31
00:02:15,360 --> 00:02:20,880
И сразу же после рекурсивных вызовов мы имеем отсортированный массив.

32
00:02:20,880 --> 00:02:25,160
Перед тем как увидеть псевдокод процедуры разделения,

33
00:02:25,160 --> 00:02:29,430
рассмотрим её основную идею на простом примере.

34
00:02:29,430 --> 00:02:34,890
Во первых, возьмем элемент A[l] и обозначим его за x.

35
00:02:34,890 --> 00:02:37,820
Это будет наш опорный элемент (pivot).

36
00:02:37,820 --> 00:02:41,000
Опорный элемент - это элемент по отношению к которому 

37
00:02:41,000 --> 00:02:44,040
мы будем разделять наш подмассив.

38
00:02:44,040 --> 00:02:47,480
Таким образом, элемент x будет размещен в своей конечной позиции.

39
00:02:47,480 --> 00:02:53,265
Таким образом, наша цель расставить элементы подмасства таким образом,

40
00:02:53,265 --> 00:02:58,524
что элемент х будет находится в своей финальной позиции,
и все элементы левее "х"

41
00:02:58,524 --> 00:03:04,010
не превышают "x", и элементы справа от "х" строго больше "х".

42
00:03:04,010 --> 00:03:09,840
Мы будем делать это постепенно расширяя диапазон
уже рассмотренных элементов.

43
00:03:09,840 --> 00:03:16,560
Для этого будем использовать счетчик i, и будем 
поддерживать следующий инвариант (неизменное условие):

44
00:03:16,560 --> 00:03:19,356
i будет увеличиваться от l + 1 до r, и 

45
00:03:19,356 --> 00:03:24,633
в каждый момент времени, когда мы уже
просмотрели i-ый элемент,

46
00:03:24,633 --> 00:03:30,970
мы будем поддерживать от l + 1 до i два диапазона.

47
00:03:30,970 --> 00:03:36,310
в первом, от l + 1 до k, мы будем хранить элементы
не превышающие "x".

48
00:03:36,310 --> 00:03:41,370
Во втором диапазоне, с индексами от j + 1 до i

49
00:03:41,370 --> 00:03:46,340
будем хранить элементы строго большие, чем "x".

50
00:03:46,340 --> 00:03:47,780
Рассмотрим простой пример.

51
00:03:48,880 --> 00:03:52,470
Представим, что мы где то в середине этого процесса.

52
00:03:52,470 --> 00:03:55,270
В данном случае, x = 6 и 

53
00:03:55,270 --> 00:03:59,520
и нам нужно разделить все элементы
по отношению к "x".

54
00:03:59,520 --> 00:04:04,080
Мы уже имеем два дипазона: в оранжевом

55
00:04:04,080 --> 00:04:07,520
мы храним все элементы, которые меньше или равны "x".

56
00:04:07,520 --> 00:04:12,100
В синем диапазоне находятся все элементы, которые 

57
00:04:12,100 --> 00:04:13,185
строго больше, чем "x".

58
00:04:14,270 --> 00:04:20,747
Теперь передвинем i в следующую позицию
 и рассмотрим элемент "9".

59
00:04:20,747 --> 00:04:23,298
9 > 6, таким образом

60
00:04:23,298 --> 00:04:27,690
мы должны просто расширить второй (синий) диапазон,

61
00:04:27,690 --> 00:04:30,460
диапазон элементов, который строго больше 6.

62
00:04:30,460 --> 00:04:32,480
В этом случае мы ничего не делаем.

63
00:04:33,990 --> 00:04:38,750
Следующий случай интереснее. Мы сдвигаем указатель i дальше и

64
00:04:38,750 --> 00:04:41,060
попадаем на элемент 4.

65
00:04:41,060 --> 00:04:44,710
В этом случае мы должны как то переместить 4-ку в оранжевый диапазон,

66
00:04:44,710 --> 00:04:49,050
диапазон элементов, который не превышают 6.

67
00:04:49,050 --> 00:04:52,790
Для этого мы просто меняем его местами с текущим

68
00:04:52,790 --> 00:04:57,230
первым элементов синего диапазона, в данном случае с 9.

69
00:04:57,230 --> 00:05:02,618
Если мы сделаем это, 4 будем последним элементов оранжевого диапазона,

70
00:05:02,618 --> 00:05:04,490
и 9 переместиться в синий диапазон.

71
00:05:04,490 --> 00:05:09,940
Делаем это, и также увеличиваем значение j

72
00:05:09,940 --> 00:05:15,450
для того чтобы показать, что оранжевый регион был расширен.

73
00:05:15,450 --> 00:05:20,360
Затем сдвигаем i на следующий элемент, на 7-ку,

74
00:05:20,360 --> 00:05:24,880
которая больше 6, что означает, что мы просто расширяем синий диапазон.

75
00:05:24,880 --> 00:05:28,660
Затем мы переходим к элементу 6,

76
00:05:28,660 --> 00:05:31,850
6 не превышает 6 (6=6), таким образом

77
00:05:31,850 --> 00:05:33,790
мы должны передвинуть шестерку в оранжевый диапазон.

78
00:05:33,790 --> 00:05:39,240
Опять мы меняем местами с первым элементом синего диапазона, и

79
00:05:39,240 --> 00:05:42,340
затем расширяем оранжевый диапазон. 

80
00:05:42,340 --> 00:05:47,592
Увеличиваем j, чтобы показать, что оранжевый регион был расширен.

81
00:05:47,592 --> 00:05:51,469
Затем рассматриваем следующий элемент,
который не превосходит 6.

82
00:05:51,469 --> 00:05:54,720
Переносим его в конец оранжевого диапазона.

83
00:05:55,950 --> 00:06:03,201
И в конечном итоге, мы должны перенести опорный элемент,

84
00:06:03,201 --> 00:06:08,969
который равен 6 в данном случае, в его конечную позицию.

85
00:06:08,969 --> 00:06:12,020
Его конечное положение может быть легко найдено в данном случае.

86
00:06:12,020 --> 00:06:14,780
У нас есть оранжевый и синий диапазоны.

87
00:06:14,780 --> 00:06:18,740
В оранжевом все элементы не превышают 6,
в синем диапазоне

88
00:06:18,740 --> 00:06:20,720
все элементы строго больше 6.

89
00:06:20,720 --> 00:06:25,952
Таким образом, мы просто меняем местами 6-ку с последним
элементом оранжевого диапазона.

90
00:06:25,952 --> 00:06:31,003
В данном примере это 1. Если мы поменяем 
местами эти два элемента,

91
00:06:31,003 --> 00:06:37,290
вы можете видеть, что, действительно, все элементы синего диапазона больше 6.

92
00:06:37,290 --> 00:06:41,770
Все элементы оранжевого диапазона меньше 6.

93
00:06:41,770 --> 00:06:44,920
То есть, мы выполнили процедуру разделения.

94
00:06:44,920 --> 00:06:49,550
Теперь мы готовы увидеть псевдокод процедуры разделения.

95
00:06:49,550 --> 00:06:53,570
Вспомни, что мы собираемся разместить какой то элемент "х",

96
00:06:53,570 --> 00:06:59,080
который называется опорным, в его конечную 
позицию таким образом, что все элементы до

97
00:06:59,080 --> 00:07:04,130
"х" не превышают "х", и все элементы после "х", строго больше "х".

98
00:07:04,130 --> 00:07:09,020
В этой процедуре, мы собираемся использовать опорным элементом 
просто первый элемент

99
00:07:09,020 --> 00:07:13,320
соответствующего подмассива. То есть, x = A[l].

100
00:07:14,370 --> 00:07:19,300
Также, мы будем поддерживать следующие два подрегиона

101
00:07:19,300 --> 00:07:24,110
Во первых, мы будем постепенно увеличивать диапазон просмотренных элементов

102
00:07:24,110 --> 00:07:28,479
То есть, i увеличивается от l + 1 до r, и внутри этого региона

103
00:07:28,479 --> 00:07:33,735
уже просмотренных элементов, мы будем поддерживать два диапазона.

104
00:07:33,735 --> 00:07:37,208
В первом регионе, с индексами от l + 1 до j

105
00:07:37,208 --> 00:07:40,210
будем хранить элементы не превышающие "x".

106
00:07:40,210 --> 00:07:45,310
Во втором регионе, с индексами от j + 1 до i, мы будем хранить все элементы,

107
00:07:45,310 --> 00:07:50,310
которые больше "х". И мы будем постепенно увеличивать i.

108
00:07:50,310 --> 00:07:54,770
Когда i было увеличенно.

109
00:07:54,770 --> 00:07:57,110
Мы рассматриваем новый элемент A[i].

110
00:07:57,110 --> 00:08:01,750
Если A[i] > x, значит второй

111
00:08:01,750 --> 00:08:06,170
диапазон элементов, которые больше "х",

112
00:08:06,170 --> 00:08:10,830
расширяется автоматически, и нам ничего не нужно делать в этом случае.

113
00:08:10,830 --> 00:08:14,930
Однако, если рассматриваемый элемент не превышает "x"

114
00:08:14,930 --> 00:08:17,830
мы должны разместить его в первом (левом) диапазоне.

115
00:08:17,830 --> 00:08:19,940
Мы делаем это следующим образом:

116
00:08:19,940 --> 00:08:23,525
Мы увеличиваем значение j, указывая на тот факт что

117
00:08:23,525 --> 00:08:28,019
первый диапазон был увеличен, и затем обмениваем местами элементы

118
00:08:28,019 --> 00:08:31,043
A[j] и A[i]

119
00:08:31,043 --> 00:08:37,130
Таким образом, мы поддерживаем наш инвариант каждый раз, когда увеличиваем i.

120
00:08:37,130 --> 00:08:40,970
В самом конце, когда i достигает r.

121
00:08:40,970 --> 00:08:45,350
мы также должны разместить наш начальный элемент

122
00:08:45,350 --> 00:08:50,520
между двумя диапазонами.

123
00:08:50,520 --> 00:08:57,291
Для этого мы просто меняем местами A[l] (опорный элемент) с A[j].

124
00:08:57,291 --> 00:09:03,097
И затем возвращаем значение j, как индекс нашего опорного элемента.