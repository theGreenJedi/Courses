1
00:00:00,350 --> 00:00:02,960
Привет! Итак, теперь давайте поговорим о бинарном поиске.

2
00:00:04,280 --> 00:00:08,990
Словарь - это хороший
пример упорядоченного списка,

3
00:00:08,990 --> 00:00:11,270
где все слова находятся в определённом порядке.

4
00:00:11,270 --> 00:00:13,550
И это делает поиск слов гораздо проще.

5
00:00:13,550 --> 00:00:16,300
Вы можете представить себе, как сложно
было бы искать слова в словаре,

6
00:00:16,300 --> 00:00:18,910
если бы их порядок был случайным.

7
00:00:18,910 --> 00:00:21,710
Вам бы пришлось просмотреть
каждую страницу, и, фактически,

8
00:00:21,710 --> 00:00:22,689
каждое слово на каждой странице.

9
00:00:22,689 --> 00:00:23,760
Это бы потребовало достаточно долгого времени.

10
00:00:25,050 --> 00:00:29,490
Поэтому давайте рассмотрим постановку задачи
поиска в отсортированном массиве.

11
00:00:29,490 --> 00:00:33,530
Итак, нам дан массив А вместе с нижней

12
00:00:33,530 --> 00:00:37,780
и верхней границей, указывающими пределы
внутри массива, в которых следует вести поиск.

13
00:00:37,780 --> 00:00:41,250
Важной особенностью массива
является то, что он отсортирован.

14
00:00:41,250 --> 00:00:45,900
Под этим подразумевается, что если мы посмотрим
на произвольный элемент под индексом i,

15
00:00:45,900 --> 00:00:51,590
а затем на следующий элемент, то первый элемент будет не больше второго.

16
00:00:51,590 --> 00:00:55,340
Мы не говорим "меньше", поскольку допускаем наличие

17
00:00:55,340 --> 00:00:57,350
массивов с повторяющимися элементами.

18
00:00:58,410 --> 00:01:03,517
Это называется монотонный неубывающий массив.

19
00:01:04,570 --> 00:01:06,230
Ещё одно исходное значение - ключ, который нужно найти.

20
00:01:07,540 --> 00:01:12,251
Выходное значение - любой из индексов, под которым находится элемент,

21
00:01:12,251 --> 00:01:16,030
равный ключу.

22
00:01:16,030 --> 00:01:20,260
Мы говорим "любой из них", поскольку, в отличие от рассмотренного ранее линейного поиска,

23
00:01:20,260 --> 00:01:22,461
здесь может быть более одного элемента -

24
00:01:22,461 --> 00:01:26,710
более одного совпадающего с ключом элемента, поскольку в массиве могут быть повторяющиеся значения.

25
00:01:28,560 --> 00:01:30,540
Если совпадение не найдено,

26
00:01:30,540 --> 00:01:33,295
вместо того, чтобы возвратить НЕ_НАЙДЕНО (NOT_FOUND), как мы делали в случае с линейным поиском,

27
00:01:33,295 --> 00:01:36,290
Мы вернём несколько более полезную информацию,

28
00:01:36,290 --> 00:01:39,370
а именно - позицию в массиве, куда вы могли бы

29
00:01:39,370 --> 00:01:44,600
вставить искомый элемент, если бы захотели.

30
00:01:44,600 --> 00:01:48,020
Или где он находился бы, если бы присутствовал в массиве.

31
00:01:48,020 --> 00:01:50,577
То есть мы возвращаем наибольший индекс i,

32
00:01:50,577 --> 00:01:52,129
для которого A[i] меньше k.

33
00:01:52,129 --> 00:01:54,882
Таким образом, если ключ отсутствует в массиве,

34
00:01:54,882 --> 00:02:00,225
мы возвращаем индекс, элемент под которым

35
00:02:00,225 --> 00:02:05,000
меньше ключа, но следующий за ним элемент больше ключа.

36
00:02:07,146 --> 00:02:11,991
Также мы должны задуматься: что если все элементы

37
00:02:11,991 --> 00:02:14,810
в массиве больше ключа?

38
00:02:14,810 --> 00:02:17,509
В этом случае мы сразу же возвратим -1.

39
00:02:19,070 --> 00:02:19,990
Взгляните на пример.

40
00:02:19,990 --> 00:02:24,620
У нас есть массив из 7 элементов, в котором элемент 20 повторяется.

41
00:02:24,620 --> 00:02:29,350
Если мы ищем в этом массиве 2, мы возвращаем 0,

42
00:02:29,350 --> 00:02:32,540
сообщая таким образом, что все элементы массива больше данного.

43
00:02:32,540 --> 00:02:35,168
Если же мы ищем 3, то возвращаем 1.

44
00:02:35,168 --> 00:02:38,259
Если ищем 4, мы также возвращаем 1,

45
00:02:38,259 --> 00:02:41,333
что на самом деле означает "между 1 и 2".

46
00:02:41,333 --> 00:02:44,440
То есть это больше, чем 3, но меньше, чем 5.

47
00:02:46,130 --> 00:02:48,740
Если мы ищем 20, то возвращаем 4.

48
00:02:48,740 --> 00:02:50,120
Также мы могли бы вернуть 5.

49
00:02:50,120 --> 00:02:54,380
Любое из значений верно, поскольку под обоими этими индексами находится число 20.

50
00:02:54,380 --> 00:02:56,400
А если мы ищем 60, то возвратим 7.

51
00:02:56,400 --> 00:03:00,287
Но если мы ищем 70, мы также возвратим 7.

52
00:03:02,711 --> 00:03:05,150
Итак, давайте посмотрим на нашу реализацию бинарного поиска.

53
00:03:05,150 --> 00:03:09,110
Мы напишем рекурсивную функцию, принимающую в качестве аргументов А, нижнюю и верхнюю границы и ключ,

54
00:03:09,110 --> 00:03:11,440
в точности как мы обозначили в постановке задачи.

55
00:03:12,810 --> 00:03:13,880
Сначала наш базовый случай.

56
00:03:13,880 --> 00:03:18,590
Если у нас пустой массив, то есть верхняя граница меньше нижней, следовательно,

57
00:03:18,590 --> 00:03:20,789
элементов нет, то мы возвращаем -1.

58
00:03:22,570 --> 00:03:24,490
Иначе, мы вычислим среднюю точку.

59
00:03:24,490 --> 00:03:27,820
Нам нужно что-то посередине между нижней и верхней границей.

60
00:03:27,820 --> 00:03:32,935
Поэтому мы вычислим ширину, вычтя из верхней границы нижнюю,

61
00:03:32,935 --> 00:03:37,399
разобьём пополам, разделив результат на 2, а затем прибавим это к нижней границе.

62
00:03:37,399 --> 00:03:40,234
Это может не быть целым числом,

63
00:03:40,234 --> 00:03:45,133
поскольку верх минус низ, разделенное на 2, может иметь дробную часть,

64
00:03:45,133 --> 00:03:47,479
поэтому мы округлим результат вниз.

65
00:03:49,803 --> 00:03:54,185
Например, в предыдущем случае у нас были границы 1 и 7, тогда 7 - 1 = 6,

66
00:03:54,185 --> 00:03:58,100
разделить на 2 будет 3, плюс нижняя граница 1, получим 4, то есть серединой будет 4.

67
00:03:58,100 --> 00:03:59,410
Скоро мы увидим это на примере.

68
00:04:01,870 --> 00:04:08,430
Теперь мы проверяем, равен ли элемент в этой середине нашему ключу.

69
00:04:08,430 --> 00:04:11,050
Если да, то мы закончили, возвращаем её.

70
00:04:11,050 --> 00:04:13,138
Если нет, то хорошая новость состоит в том, что, конечно,

71
00:04:13,138 --> 00:04:17,810
нам не придётся проверять все остальные элементы, половину их мы исключили.

72
00:04:17,810 --> 00:04:21,570
Так что, если ключ меньше, чем средний элемент,

73
00:04:21,570 --> 00:04:24,140
то мы игнорируем все, стоящие за ним.

74
00:04:24,140 --> 00:04:28,851
Поэтому мы продолжаем и возвращаем результат бинарного поиска в массиве А от нижней границы до середины - 1,

75
00:04:28,851 --> 00:04:31,571
полностью игнорируя всё, что находится там, далее.

76
00:04:31,571 --> 00:04:34,963
В противном случае, ключ больше середины, и, опять же,

77
00:04:34,963 --> 00:04:39,200
мы можем отбросить всё, стоящее ниже, и, начиная с середины + 1, идти далее, до верхней границы.

78
00:04:41,080 --> 00:04:42,280
Рассмотрим пример.

79
00:04:42,280 --> 00:04:46,280
Допустим, мы ищем ключ 50 в этом массиве из 11 элементов.

80
00:04:46,280 --> 00:04:50,260
То есть мы произведём бинарный поиск в этом массиве, начиная от индекса 1 до 11, и будем искать число 50.

81
00:04:50,260 --> 00:04:53,865
Низ равен 1, верх равен 11.

82
00:04:53,865 --> 00:04:59,213
Вычислим середину, она будет равна 11 - 1 = 10,

83
00:04:59,213 --> 00:05:03,432
разделить на 2 = 5, прибавить это к 1, середина равна 6.

84
00:05:03,432 --> 00:05:07,693
И теперь мы проверяем, равен ли элемент в середине 50?

85
00:05:07,693 --> 00:05:08,243
Собственно, нет.

86
00:05:08,243 --> 00:05:11,295
Средний элемент равен 15, а элемент, который мы ищем,

87
00:05:11,295 --> 00:05:12,982
искомый ключ, равен 50.

88
00:05:12,982 --> 00:05:18,070
Поэтому мы идём дальше, игнорируя первую половину массива и

89
00:05:18,070 --> 00:05:24,050
теперь вызываем функцию бинарного поиска снова, с нижней границей, равной 7, то есть на 1 больше середины.

90
00:05:25,140 --> 00:05:27,920
То есть теперь мы получили уменьшенную версию задачи.

91
00:05:27,920 --> 00:05:31,660
Мы ищем 50 среди элементов от индекса 7 до 11, вычисляем середину.

92
00:05:31,660 --> 00:05:35,321
11 - 7 = 4, разделённое на 2 = 2, теперь

93
00:05:35,321 --> 00:05:39,708
прибавим это к 7 и получим середину, равную 9.

94
00:05:39,708 --> 00:05:44,594
Проверяем, равен ли элемент под индексом 9 нашему ключу?

95
00:05:44,594 --> 00:05:48,210
Элемент под индексом 9 равен 20, а наш ключ 50, они не равны.

96
00:05:49,540 --> 00:05:54,900
Однако, 50 больше 20, поэтому мы идём дальше и

97
00:05:54,900 --> 00:05:59,978
делаем новый рекурсивный вызов с середины + 1, что равно 10,

98
00:05:59,978 --> 00:06:02,281
Итак, снова, мы производим бинарный поиск от 10 до 11.

99
00:06:02,281 --> 00:06:03,260
Рассчитываем середину.

100
00:06:04,830 --> 00:06:10,013
Низ минус верх, 11 - 10 = 1, разделённое на 2 равно 0,5, + 10, получим 10,5,

101
00:06:10,013 --> 00:06:15,140
округляем вниз, получаем 10 с половиной, то есть наша середина равна 10 с половиной.

102
00:06:15,140 --> 00:06:17,480
Я прошу прощения, наша середина равна 10.

103
00:06:17,480 --> 00:06:18,470
Теперь проверяем.

104
00:06:18,470 --> 00:06:22,820
Элемент 10 равен нашему ключу?

105
00:06:22,820 --> 00:06:26,140
Элемент 10 равен 50, наш ключ равен 50, значит, да.

106
00:06:26,140 --> 00:06:30,390
Далее мы возвращаем середину, которая равна 10.

107
00:06:30,390 --> 00:06:35,310
Подводя итог, мы разбили задачу на

108
00:06:35,310 --> 00:06:37,715
непересекающиеся подзадачи того же типа.

109
00:06:37,715 --> 00:06:39,790
Мы рекурсивно решили подзадачи.

110
00:06:39,790 --> 00:06:42,920
И затем мы объединяем решения этих подзадач.

111
00:06:42,920 --> 00:06:45,960
Мы выделили из задачи вдвое меньшую по размеру задачу.

112
00:06:45,960 --> 00:06:47,460
(чуть меньше, чем половина исходной).

113
00:06:47,460 --> 00:06:49,860
Мы рекурсивно решили эту подзадачу и

114
00:06:49,860 --> 00:06:52,770
затем мы очень легко объединили решения, просто возвратив результат.

115
00:06:53,850 --> 00:06:57,330
На следующем видео мы продолжим и увидим время выполнения для

116
00:06:57,330 --> 00:06:58,830
бинарного поиска,

117
00:06:58,830 --> 00:07:00,540
а также итеративной версии.

118
00:07:00,540 --> 00:07:06,050
И мы вернёмся к обсуждению проблемы, которую я упоминал

119
00:07:06,050 --> 00:07:07,840
в задаче перевода с помощью словаря.

120
00:07:09,030 --> 00:07:09,640
Скоро увидимся.