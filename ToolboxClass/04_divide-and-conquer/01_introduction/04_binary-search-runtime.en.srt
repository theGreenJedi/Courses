1
00:00:00,170 --> 00:00:03,980
Hi, in this video we're going to be
looking at the run time of BinarySearch

2
00:00:03,980 --> 00:00:06,510
along with looking at an
iterative version of it.

3
00:00:06,510 --> 00:00:08,840
So here's our BinarySearch
algorithm again.

4
00:00:08,840 --> 00:00:11,480
We look in the middle, if it's not found,

5
00:00:11,480 --> 00:00:13,710
then we either look in the lower half or
the upper half.

6
00:00:14,760 --> 00:00:18,030
So whats our recurrence relation for
the worst-case runtime?

7
00:00:18,030 --> 00:00:20,894
Well, the worst case is if
we don't find an element.

8
00:00:20,894 --> 00:00:27,696
So were going to look at T(n) Is
equal to T of roughly n over 2 + c.

9
00:00:27,696 --> 00:00:32,330
We have a floor there of n
over 2 because if n is odd,

10
00:00:32,330 --> 00:00:36,780
let's say there are five elements,
then the question is:

11
00:00:36,780 --> 00:00:40,085
how big is the problem
size on the next call.

12
00:00:40,085 --> 00:00:44,306
So if we have five elements we're going to
either end up looking in the upper half of

13
00:00:44,306 --> 00:00:44,815
the array.

14
00:00:44,815 --> 00:00:47,665
Those two elements or the lower half
of the array, those two elements

15
00:00:47,665 --> 00:00:49,055
because we skipped the midpoint.

16
00:00:49,055 --> 00:00:50,575
We already checked them.

17
00:00:50,575 --> 00:00:57,660
Plus some constant amount of work to add
together, to calculate the midpoint.

18
00:00:57,660 --> 00:01:01,000
As well as checking
the midpoint against the key.

19
00:01:01,000 --> 00:01:07,500
And then our base case is
when we have an empty array.

20
00:01:07,500 --> 00:01:09,580
And that's just a constant
amount of time to check.

21
00:01:11,260 --> 00:01:12,460
So what's the runtime look like?

22
00:01:12,460 --> 00:01:15,130
We got our original size n, and
we're going to break it down,

23
00:01:15,130 --> 00:01:16,250
n over 2, n over 4.

24
00:01:16,250 --> 00:01:17,710
All the way down.

25
00:01:17,710 --> 00:01:21,150
How many of these problems are there.

26
00:01:21,150 --> 00:01:23,880
Well, if we're cutting something
in two over and over again.

27
00:01:23,880 --> 00:01:29,030
It's going to take log base two such
iterations until we get down to 1.

28
00:01:29,030 --> 00:01:34,400
So the total here,
is actually log base two of n + 1.

29
00:01:34,400 --> 00:01:37,410
The amount of work we're doing is c.

30
00:01:37,410 --> 00:01:40,900
So at each level, we're doing c work.

31
00:01:40,900 --> 00:01:42,730
So the total amount of work if we sum it,

32
00:01:42,730 --> 00:01:46,480
is just the sum from i=0
to log base 2 of n of c.

33
00:01:47,760 --> 00:01:54,110
That is just log base 2 of n + 1, that is
log base 2 of n, that quantity, plus one times c.

34
00:01:55,110 --> 00:01:58,330
And that is just theta of
log based two of n, but

35
00:01:58,330 --> 00:02:04,207
really what we'd normally say is theta of
log n, because the base doesn't matter.

36
00:02:04,207 --> 00:02:06,379
That's just a constant
multiplicative factor.

37
00:02:08,892 --> 00:02:12,315
All right,
what's the iterative version look like.

38
00:02:12,315 --> 00:02:16,600
The iterative version has the same
parameters low, high, and key.

39
00:02:16,600 --> 00:02:20,350
And we have a while loop that goes
through similar to the base case so

40
00:02:20,350 --> 00:02:26,570
in the base case of the recursive version
we were stopping if high is less than low.

41
00:02:26,570 --> 00:02:30,510
Here, we have a while loop where the while
loop stops if high is less than low.

42
00:02:30,510 --> 00:02:33,790
We calculate the midpoint and
then again check the key.

43
00:02:33,790 --> 00:02:38,750
If it matches the element at the midpoint
we return the midpoint. Otherwise,

44
00:02:38,750 --> 00:02:40,310
if the key is less than

45
00:02:40,310 --> 00:02:43,452
the element, we know we're in
the first half of the array and so

46
00:02:43,452 --> 00:02:47,308
instead of making a new recursive call
like we did in the recursive version we have

47
00:02:47,308 --> 00:02:48,401
the original array.

48
00:02:48,401 --> 00:02:52,953
And we want to look at the first half of
it so we're going to change the value of

49
00:02:52,953 --> 00:02:57,790
high and that will be mid minus one
because we already checked mid.

50
00:02:57,790 --> 00:03:02,540
Otherwise, we want to look in the upper
half of the array so we move low up.

51
00:03:05,340 --> 00:03:08,070
If we reach the end of the while loop.

52
00:03:08,070 --> 00:03:11,310
That is if we drop out of the while
loop because high is less than low.

53
00:03:11,310 --> 00:03:13,040
That meant we have nothing more to search.

54
00:03:13,040 --> 00:03:14,200
We have an empty array.

55
00:03:14,200 --> 00:03:17,030
And therefore,
we didn't find the element in the array.

56
00:03:17,030 --> 00:03:18,740
We're going to return low minus 1.

57
00:03:18,740 --> 00:03:21,408
So the same result as
the recursive version.

58
00:03:21,408 --> 00:03:24,228
The difference is we won't be
using the stack space that

59
00:03:24,228 --> 00:03:25,730
the recursive version uses.

60
00:03:25,730 --> 00:03:30,736
You remember we talked two videos ago
about this real-life example where we had

61
00:03:30,736 --> 00:03:35,905
five languages and we were translating
words between any two of those languages.

62
00:03:35,905 --> 00:03:39,924
The way we had that represented
was parallel arrays,

63
00:03:39,924 --> 00:03:44,388
so that at any given index,
each of the element in the arrays

64
00:03:44,388 --> 00:03:49,051
represented words that were
the same in all those languages.

65
00:03:49,051 --> 00:03:53,362
So for instance,
chair in English is at index two, and

66
00:03:53,362 --> 00:03:57,597
in Spanish that's silla and
in Italian it's sedia.

67
00:03:57,597 --> 00:04:01,439
The problem was it took a long time to look,
right?

68
00:04:01,439 --> 00:04:05,970
We had 50,000 elements in our arrays, and
it took like ten seconds for searching,

69
00:04:05,970 --> 00:04:08,820
because we had to really
search through all of them

70
00:04:08,820 --> 00:04:11,530
if it wasn't there, on average,
half of them, just 25,000.

71
00:04:11,530 --> 00:04:14,304
So one question might be,
why didn't we use a sorted array?

72
00:04:14,304 --> 00:04:14,886
Right?

73
00:04:14,886 --> 00:04:17,890
You could imagine, for
instance, sorting these arrays.

74
00:04:17,890 --> 00:04:18,898
Here they're sorted.

75
00:04:18,898 --> 00:04:23,930
The good part is, it's easy to find a
particular word in a particular language.

76
00:04:23,930 --> 00:04:26,460
So I can find house in English,
for instance, and

77
00:04:26,460 --> 00:04:30,060
find what index that is at very quickly,
using binary search.

78
00:04:30,060 --> 00:04:31,150
The problem is,

79
00:04:31,150 --> 00:04:35,450
I no longer have this correspondence,
because the order of the words that

80
00:04:35,450 --> 00:04:38,700
are sorted in English is different from
the order of the words sorted in Spanish.

81
00:04:38,700 --> 00:04:43,000
So if I look at chair, for instance,
in English, it no longer maps to silla.

82
00:04:43,000 --> 00:04:46,040
So instead, if I look at chair and
that's to casa.

83
00:04:46,040 --> 00:04:49,922
So although we can find a particular
word in our source language,

84
00:04:49,922 --> 00:04:53,816
we don't know the corresponding
word in the target language.

85
00:04:53,816 --> 00:04:58,963
So the solution was to try and
find some way we could do sorting and yet

86
00:04:58,963 --> 00:05:04,474
still preserve this relationship
where everything at an index meant

87
00:05:04,474 --> 00:05:10,638
the same translated word. The way
to do that was an augmented set of arrays.

88
00:05:10,638 --> 00:05:15,237
So what we really did was keep these
augmented arrays which were

89
00:05:15,237 --> 00:05:20,270
pointers back into the original
arrays in sorted order.

90
00:05:20,270 --> 00:05:22,230
So we're having a kind
of level of indirection.

91
00:05:22,230 --> 00:05:25,630
So if I look at English for example, the
order of the words in English is chair,

92
00:05:25,630 --> 00:05:26,580
house, pimple.

93
00:05:26,580 --> 00:05:29,180
Well, what order is that
in the original array?

94
00:05:29,180 --> 00:05:35,820
It is first element 2, and
then element 1, and then element 3.

95
00:05:35,820 --> 00:05:39,808
So if you want to do a binary search,
you can use this sorted array.

96
00:05:39,808 --> 00:05:41,950
Whenever you want to
look at what an element

97
00:05:43,440 --> 00:05:45,840
is in that represented sorted array.

98
00:05:45,840 --> 00:05:49,320
So for instance,
if we looked at the middle element, 

99
00:05:49,320 --> 00:05:53,740
which in the sorted array is 2, it has
the value 1 and that says go find house.

100
00:05:53,740 --> 00:05:58,620
So we basically,
say house is sort of at element 2 and

101
00:05:58,620 --> 00:06:01,500
chair is at element 1 and
pimple's at element 3.

102
00:06:01,500 --> 00:06:04,080
The Spanish, of course,
has different mapping, so

103
00:06:04,080 --> 00:06:08,890
in Spanish, the first sorted word
happens to be the first word in the array.

104
00:06:08,890 --> 00:06:12,230
The second sorted word is the third
word in the Spanish array; and

105
00:06:12,230 --> 00:06:16,830
the third sorted word, silla,
is the second element.

106
00:06:17,960 --> 00:06:19,300
So what happened when we ran this?

107
00:06:19,300 --> 00:06:22,120
Well what happened,
we had a space time trade off.

108
00:06:23,300 --> 00:06:25,560
We had to pay extra space.

109
00:06:25,560 --> 00:06:29,320
And there were, of course, not only just English
 and Spanish sorted but also French,

110
00:06:29,320 --> 00:06:30,310
Italian, and German.

111
00:06:30,310 --> 00:06:32,950
So,  five arrays, extra arrays.

112
00:06:32,950 --> 00:06:33,450
Each array,

113
00:06:33,450 --> 00:06:38,240
had 50,000 entries in it and what was
the size of each element of the array?

114
00:06:38,240 --> 00:06:41,530
Well, it represented a number
from one to 50,000 that

115
00:06:41,530 --> 00:06:44,590
can be represented in
16-bits which is two bytes.

116
00:06:44,590 --> 00:06:48,080
So we had 50,000 elements times 2 bytes,

117
00:06:48,080 --> 00:06:52,120
that is 100,000 bytes
times 5 is 500,000 bytes.

118
00:06:52,120 --> 00:06:55,300
So about a half a megabyte,
which today is almost nothing.

119
00:06:55,300 --> 00:06:58,580
And even then,
was certainly doable 20 years ago.

120
00:07:00,280 --> 00:07:02,840
That's the cost we have in space.

121
00:07:02,840 --> 00:07:06,260
What is the benefit that we get.

122
00:07:06,260 --> 00:07:11,130
Well, instead of having to do let's
say 50,000 look ups in the worst-case.

123
00:07:11,130 --> 00:07:13,152
Instead, we have to do log
base two of 50,000 lock ups.

124
00:07:13,152 --> 00:07:19,479
So log base 2 of 50,000, that's about, let's
see, log base of 1,000 is about ten

125
00:07:19,479 --> 00:07:24,160
because two to the ten equals 1024, so
we have another factor of 50 to go.

126
00:07:24,160 --> 00:07:26,092
Log base 2 of 50 is around,

127
00:07:26,092 --> 00:07:31,979
let's say six because I know that 2 to
the 5th is equal 32, 2 to the 6th equals 64.

128
00:07:31,979 --> 00:07:33,408
So, what that means is,

129
00:07:33,408 --> 00:07:37,574
we have 16 references we have to
do the array instead of 50,000.

130
00:07:37,574 --> 00:07:41,039
That's almost a factor of a thousand, so

131
00:07:41,039 --> 00:07:46,583
what that ended up meaning is that
when the user clicks translate,

132
00:07:46,583 --> 00:07:53,250
instead of taking ten seconds,
it was what appeared to be instantaneous.

133
00:07:53,250 --> 00:07:56,420
It was well under a tenth of a second.

134
00:07:57,590 --> 00:07:58,190
So in summary,

135
00:07:58,190 --> 00:08:03,130
what we've seen is that the runtime of
binary search is big theta of log n.

136
00:08:03,130 --> 00:08:08,810
Substantially quicker than the big
theta of n that linear search takes.

137
00:08:08,810 --> 00:08:11,200
So sorted arrays really help.

138
00:08:11,200 --> 00:08:13,920
In the next lesson we're going to
be looking at a more complicated

139
00:08:13,920 --> 00:08:15,670
application of divide and conquer,

140
00:08:15,670 --> 00:08:19,630
where we actually have multiple
subproblems instead of just one subproblem.