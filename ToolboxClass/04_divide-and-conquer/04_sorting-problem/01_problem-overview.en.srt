1
00:00:00,600 --> 00:00:04,380
Hello, and
welcome to the sorting problem lesson.

2
00:00:05,870 --> 00:00:08,750
As usual,
we start with a problem I'll review.

3
00:00:10,090 --> 00:00:14,270
So sorting is a fundamental
computational problem.

4
00:00:14,270 --> 00:00:18,480
Your input in this problem consists
of a sequence of elements, and

5
00:00:18,480 --> 00:00:23,000
your goal is to output this element in,
for example, non-decreasing order.

6
00:00:24,580 --> 00:00:27,680
The formal statement of
this problem is as follows.

7
00:00:27,680 --> 00:00:30,360
You are given a sequence
of finite elements.

8
00:00:30,360 --> 00:00:33,950
We will usually denote the sequence
by A throughout this lesson.

9
00:00:33,950 --> 00:00:38,860
And your goal is to output these same
elements in non-decreasing order.

10
00:00:40,560 --> 00:00:41,470
Once again,

11
00:00:41,470 --> 00:00:47,330
sorting is an important computational
task used in many efficient algorithms.

12
00:00:47,330 --> 00:00:50,460
For some algorithms,
it is just as important to process

13
00:00:50,460 --> 00:00:55,290
given elements in non-decreasing order,
going from smaller ones to larger ones.

14
00:00:55,290 --> 00:00:59,090
In some other algorithms,
just by sorting your input data,

15
00:00:59,090 --> 00:01:03,440
you gain a possibility to perform
your queries much more efficiently.

16
00:01:03,440 --> 00:01:07,000
A canonical example of such
situation is a search problem.

17
00:01:07,000 --> 00:01:09,550
In this problem, we are given
a sequence of finite elements.

18
00:01:09,550 --> 00:01:13,150
And your goal is to check whether
a particular element is present

19
00:01:13,150 --> 00:01:14,380
in your sequence.

20
00:01:14,380 --> 00:01:19,040
A simple way to solve this problem, is of
course, just to scan your input sequence

21
00:01:19,040 --> 00:01:24,960
from left to right and to check, whether
your element is present in this sequence.

22
00:01:24,960 --> 00:01:27,660
This gives you a linear kind algorithm.

23
00:01:27,660 --> 00:01:31,060
And you know already
that if you input data,

24
00:01:31,060 --> 00:01:36,110
if you input sequences you sorted,
then you can do this much more faster.

25
00:01:36,110 --> 00:01:40,980
Basically, in time, in logarithmic time,
in the size of your input sequence.

26
00:01:40,980 --> 00:01:43,799
So ou first compare your
element to the middle element.

27
00:01:45,060 --> 00:01:49,710
If it is just few element, then you
are done, if it is not, you continue

28
00:01:49,710 --> 00:01:53,320
with the left half of your sequence or
the right half of your sequence.

29
00:01:53,320 --> 00:01:57,620
So in logarithmic number of comparison,
and the worst case, you

30
00:01:57,620 --> 00:02:01,840
will be able to say whether your element
is present in this sequence or not.

31
00:02:01,840 --> 00:02:06,010
So, if you are given a sequence and
you are expecting many such queries.

32
00:02:06,010 --> 00:02:12,370
You're expecting to be asked to check
whether a given object is present or not.

33
00:02:12,370 --> 00:02:17,840
For me such objects, then it just makes
sense to first sort your input data and

34
00:02:17,840 --> 00:02:20,830
only then perform all these queries.

35
00:02:20,830 --> 00:02:24,210
This will give you a much more
efficient algorithm in general.

36
00:02:24,210 --> 00:02:25,060
All right.

37
00:02:25,060 --> 00:02:27,290
And this is only a small example.

38
00:02:27,290 --> 00:02:29,140
We will see many other situations,

39
00:02:29,140 --> 00:02:34,720
where sorting your data first helps to
perform queries much more efficiently.

40
00:02:34,720 --> 00:02:37,851
So in the subsequent
videos of this lesson,

41
00:02:37,851 --> 00:02:41,498
we will study many efficient
sorting algorithms.