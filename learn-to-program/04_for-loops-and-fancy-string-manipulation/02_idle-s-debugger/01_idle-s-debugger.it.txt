Il visualizzatore di Python ha dei limiti, non
permette delle istruzioni di import e smette di tracciare dopo 500 passi.
Idle possiede un debugger integrato, che è una funzionalità simile al visualizzatore, ma senza
i disegni carini. Qui vediamo le funzioni convert to minutes
e convert to seconds, che abbiamo analizzato nelle lezioni dell'ultima settimana.
Attiviamo il debugger di IDLE. Andremo ad assicurarci che la finestra della 
shell di Python sia in cima, e poi selezioniamo debug-, debugger.
Questo apre una finestra chiamata debug control. Ora sto per, per ridimensionarla in modo che
possiamo vedere tutto mentre viene eseguito. Andiamo a controllare la spunta per
source. Poi, torniamo qui al nostro modulo
su cui vogliamo effettuare il debug e selezioniamo run, run module.
Questa area centrale mostra lo stack di chiamata, o per lo meno la funzione che viene chiamata. Qui sotto si vedono le variabili all'interno
della chiamata corrente. Notate che la variabile per le funzioni integrate è
lì, e anche le altre tre variabili di cui non abbiamo ancora discusso in questo corso.
Step è come il forward del visualizzatore. Definiremo le nostre due funzioni.
Notate che abbiamo le variabili quaggiù. Tutte quelle, fanno riferimento a funzioni.
Questa qui, è un indirizzo di memoria. Noterete che ha delle lettere all'interno.
Questo perché è in base sedici, che è usata, spesso in programmazione i 
numeri dallo zero al nove, più le lettere A, B, C, D, E ed F per un totale di
sedici caratteri. Qui abbiamo visto che è evidenziata
in grigio la riga corrente. E la riga venti è quella linea.
Quindi ci dice qual è la linea che viene eseguita.
Quando andiamo ad effettuare lo step di chiamata della funzione convert to seconds.
Abbiamo solo il parametro num hours disponibile finora per covert to
seconds. Se vogliamo vedere le, le variabili del modulo,
possiamo semplicemente cliccare lì e quello passa alla vista per l'esecuzione
locale, le variabili locali. Ritorneremo a convert to seconds e entreremo
nella chiamata di convert to minutes. Ora abbiamo tre elementi nello stack di chiamata,
coinvolte in quel programma. Andiamo avanti ancora di un passo per definire
la nostra variabile minutes. Minutes ora vale 120.
Solo per controllare, ritorneremo indietro al frame per convert to seconds, e noteremo
che ha solo la variabile num hours. Il motivo è, che noi non abbiamo finito questa
chiamata a convert to minutes, e quindi questa variabile minutes non è ancora stata creata.
Sto per passare nuovamente alla visuale del, del frame principale.
E, quando vado un passo avanti, sta solo andando ad eseguire l'istruzione di return tutta insieme
includendo far apparire il frame dallo stack.
Non arriviamo a vedere il valore di ritorno prima che il return venga eseguito.
Quindi siamo di nuovo in convert to seconds, stiamo per valutare 120 per 60 e assegnare
il risultato a seconds, dove otteniamo 7200 e andremo a ritornare 7200.
Questa chiamata a convert to seconds, e. creerà la variabile seconds,
nello stack frame per il modulo principale.
Passando alla nostra vista precedente e cliccando step questo causa la
fine del nostro programma, visto che questo era l'ultimo passo del programma.
Torniamo di nuovo lì e notiamo che abbiamo effettivamente una variabile seconds creata.
Quindi alla fine di un programma si crea un po' di confusione dato che in un'istruzione di return,
e con l'espressione di return all'interno di una funzione che è l'ultima istruzione
che viene eseguita, il programma finirà e lo stack frame non verrà rimosso
dato che il debugger non aggiorna alla fine di un programma una volta che il programma
è terminato.