1
00:00:01,020 --> 00:00:05,073
Quando si lavora con le stringhe, spesso dobbiamo 
estrarre delle sottostringhe.

2
00:00:05,073 --> 00:00:10,303
Ad esempio, se una stringa contiene un numero
di telefono, potremmo voler estrarre il codice

3
00:00:10,303 --> 00:00:12,919
dell'area.
In questa lezione, introdurrò due

4
00:00:12,919 --> 00:00:17,953
tecniche, l'indexing e lo slicing, e
useremo questi per estrarre delle sottostringhe

5
00:00:17,953 --> 00:00:23,548
delle stringhe con cui stiamo lavorando.
In questa lezione, useremo la stringa

6
00:00:23,548 --> 00:00:30,138
learn to program come nostro esempio.
Ogni carattere della stringa ha un indice

7
00:00:30,138 --> 00:00:33,680
che, che è la sua posizione nella
stringa.

8
00:00:33,680 --> 00:00:39,859
Quindi, la stringa all'indice zero, indicata
usando questa notazione di parentesi, è la L.

9
00:00:39,859 --> 00:00:45,461
All'indice uno della stringa, abbiamo una e.
All'indice due, c'è la prima a.

10
00:00:45,461 --> 00:00:49,333
Notate che zero è la prima posizione,
non uno.

11
00:00:49,333 --> 00:00:57,197
Iniziamo a contare da zero.
Possiamo anche usare degli indici negativi per contare

12
00:00:57,197 --> 00:01:03,741
dal fondo, oppure dalla parte destra
della stringa.

13
00:01:03,741 --> 00:01:09,809
Quindi la fine della stringa al -uno è la m.
A -due c'è l'ultima a.

14
00:01:09,809 --> 00:01:17,216
A -tre c'è la r, la ultima r.
Quindi, una volta che abbiamo visto usare un indice,

15
00:01:17,216 --> 00:01:22,622
possiamo estrarre parti della stringa un carattere
alla volta. Ma, possiamo estrarre più di

16
00:01:22,622 --> 00:01:25,760
un carattere usando un approccio chiamato
slicing.

17
00:01:25,760 --> 00:01:31,858
Con lo slicing, forniamo un indice di partenza
seguito da un due punti, seguito da un indice di

18
00:01:31,858 --> 00:01:38,352
arrivo e che ci da una sottostringa dall'indice
di partenza fino a, ma non includendo

19
00:01:38,352 --> 00:01:42,866
l'indice finale.
Ad esempio, possiamo ottenere questa stringa dalla

20
00:01:42,866 --> 00:01:49,043
posizione zero, indice zero fino a, ma non
includendo l'indice cinque, e questo ci da

21
00:01:49,043 --> 00:01:54,311
la stringa Learn.
Dall'indice sei fino, ma non includendo

22
00:01:54,311 --> 00:02:00,144
l'indice otto, c'è il to.
E, dall'indice nove fino al sedici, c'è

23
00:02:00,144 --> 00:02:05,748
la parola Program, stringa Program.
Sedici è pari alla lunghezza della

24
00:02:05,748 --> 00:02:09,123
stringa.
Quindi, un modo alternativo sarebbe quello di iniziare

25
00:02:09,123 --> 00:02:14,480
all'indice nove, ma andare fino a len s.
Len è una funzione integrata che ritorna

26
00:02:14,480 --> 00:02:19,984
la lunghezza della stringa, quindi questa
espressione è equivalente a quella sopra.

27
00:02:19,984 --> 00:02:25,927
Un'altra alternativa sarebbe quella di andare da
nove, posizionare i due punti, e omettere l'indice

28
00:02:25,927 --> 00:02:29,449
di arrivo.
In questo caso, per default si va fino alla

29
00:02:29,449 --> 00:02:34,880
fine della stringa, e quindi è anche 
equivalente alle due espressioni precedenti.

30
00:02:35,580 --> 00:02:41,986
Anche l'indice iniziale può essere omesso.
Quindi, per esempio, possiamo includere i due punti e

31
00:02:41,986 --> 00:02:46,527
andare fino all'indice a.
Possiamo anche omettere sia l'indice di partenza 

32
00:02:46,527 --> 00:02:50,420
che quello di arrivo.
E questo ci restituisce l'intera stringa.

33
00:02:51,160 --> 00:02:57,906
Abbiamo visto che gli indici negativi possono essere
usati per l'indicizzazione, e possono anche essere

34
00:02:57,906 --> 00:03:03,303
usati per lo slicing.
Prendiamo questa sottostringa dall'indice uno fino

35
00:03:03,303 --> 00:03:09,206
ma non includendo l'indice otto.
E la nostra espressione equivalente è di prendere

36
00:03:09,206 --> 00:03:15,531
da uno fino a ma non includendo -otto,
O di andare da -quindici fino a, ma non

37
00:03:15,531 --> 00:03:19,832
includendo -otto.
Quindi, queste tre espressioni sono tutte

38
00:03:19,832 --> 00:03:24,415
equivalenti.
Lo slicing e l'operazione di indicizzazione non

39
00:03:24,415 --> 00:03:29,405
modificano la stringa su cui agiscono.
Quindi, il valore a cui s si riferisce è

40
00:03:29,405 --> 00:03:35,990
invariato dalle operazioni precedenti.
Infatti, non possiamo cambiare il valore di una

41
00:03:35,990 --> 00:03:40,279
stringa.
Le operazioni come le seguenti terminano con

42
00:03:40,279 --> 00:03:44,750
errori.
Se prendo una stringa all'indice sei e cerco

43
00:03:44,750 --> 00:03:51,229
di impostarlo a d, ottengo un errore.
Allo stesso modo, se cerco di modificare la stringa

44
00:03:51,229 --> 00:03:57,800
dall'indice nove fino al sedici, e lo faccio
girare, ottengo anche in questo caso un errore.

45
00:03:59,080 --> 00:04:05,679
Ma, immaginate che voglia cambiare la
stringa s a Learned to Program.

46
00:04:05,679 --> 00:04:12,449
Ecco qui un approccio che possiamo usare.
Possiamo usare il valore attuale di s e ottenere

47
00:04:12,449 --> 00:04:19,306
la parola learn, concatenarla con ed
per farla diventare learned, e concatenarla

48
00:04:19,306 --> 00:04:23,420
con il resto della stringa, che è, to
program.

49
00:04:23,780 --> 00:04:29,818
Questo viene valutato a Learned to Program.
E ora che abbiamo questa nuova stringa,

50
00:04:29,818 --> 00:04:35,386
Learned to Program, possiamo fare in modo che
s faccia riferimento a quella, anziché al suo vecchio valore.

51
00:04:35,386 --> 00:04:40,875
Notate che non abbiamo modificato la stringa
a cui s faceva originariamente riferimento,

52
00:04:40,875 --> 00:04:45,659
non possiamo modificarla.
Invece, abbiamo creato una nuova stringa e

53
00:04:45,659 --> 00:04:47,620
abbiamo fatto puntare s a quella nuova
stringa.