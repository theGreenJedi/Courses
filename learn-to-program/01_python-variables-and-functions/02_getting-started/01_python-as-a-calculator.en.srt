1
00:00:01,043 --> 00:00:04,019
Hello.
In this lecture we'll begin to program.

2
00:00:04,019 --> 00:00:09,028
We refer to this lecture as Python as a
calculator because we're going to focus on

3
00:00:09,028 --> 00:00:13,038
mathematical expressions.
In this lecture and throughout the course,

4
00:00:13,038 --> 00:00:17,067
we'll be using IDLE, a program that comes
with the Python installation.

5
00:00:17,067 --> 00:00:20,085
Let's switch over to IDLE now and start
programming.

6
00:00:18,746 --> 00:00:23,732
This is IDLE, and the window that we're
currently looking at is called the shell.

7
00:00:23,732 --> 00:00:27,759
This is where we can try out Python
instructions and explore Python's

8
00:00:27,759 --> 00:00:32,728
features.
This symbol, the three arrow symbols, is

9
00:00:32,728 --> 00:00:37,776
called the prompt.
Next to the prompt, we will type Python

10
00:00:37,776 --> 00:00:41,722
instructions.
And when we hit Enter, Python will

11
00:00:41,722 --> 00:00:46,714
evaluate those instructions.
For example, let's type the instruction

12
00:00:46,714 --> 00:00:49,746
two plus three, and ask Python to evaluate
it.

13
00:00:49,797 --> 00:00:55,770
It's important to note that nothing
happens until I hit the Enter key.

14
00:00:55,770 --> 00:01:01,792
Let's look at another expression, six
subtract two, and again nothing happens

15
00:01:01,792 --> 00:01:06,726
until I hit Enter.
At that point, Python evaluates the

16
00:01:06,726 --> 00:01:11,719
expression.
Another expression could be seven times

17
00:01:11,719 --> 00:01:15,720
three.
So far we've seen three operators,

18
00:01:15,720 --> 00:01:22,721
addition, subtraction and multiplication.
Another operation is exponentiation.

19
00:01:22,721 --> 00:01:27,712
And we read this expression, as two to the
power of five.

20
00:01:28,737 --> 00:01:33,707
Next, let's take four and divide it by
two.

21
00:01:33,745 --> 00:01:38,709
When Python evaluates its expression, the
result that we get looks a little bit

22
00:01:38,709 --> 00:01:43,792
different from what we've seen so far.
The expression evaluates to give us 2.0 as

23
00:01:43,792 --> 00:01:48,743
opposed to just two.
What we're seeing here is that Python has

24
00:01:48,743 --> 00:01:53,781
multiple types, and two of its numeric
types are type int, which stands for

25
00:01:53,781 --> 00:01:57,795
integer, and float, which stands for
floating point number.

26
00:01:58,726 --> 00:02:03,706
This division operation gives us a
floating point result.

27
00:02:03,765 --> 00:02:07,722
Let's explore a few more examples of
division.

28
00:02:07,722 --> 00:02:12,509
Five divided by two gives 2.5.
And we would expect that two divided by

29
00:02:12,509 --> 00:02:15,740
three would give .666666, with six as
repeating.

30
00:02:15,740 --> 00:02:21,717
That is what it gives, although instead of
an infinite number of 6's, we're limited

31
00:02:21,717 --> 00:02:24,769
by the number of significant digits
available.

32
00:02:24,769 --> 00:02:28,750
So, Python has a limited amount of memory
to work with.

33
00:02:28,750 --> 00:02:34,734
And the number that we get, the result of
dividing two by three is an approximation

34
00:02:34,734 --> 00:02:38,764
to the real number.
Floating point numbers are approximations

35
00:02:38,764 --> 00:02:43,613
to real numbers.
Another example would be to divide five by

36
00:02:43,613 --> 00:02:49,782
three, and we can see that the result as
an approximate result with 1.66666 and the

37
00:02:49,782 --> 00:02:57,736
last digit is actually a seven.
Similarly, seven divided by three, there's

38
00:02:57,736 --> 00:03:04,757
2.333333, and the last digit is a five.
7/3 is floating point division, and since

39
00:03:04,757 --> 00:03:10,718
floating point numbers are approximations
to real numbers, there's some imprecision,

40
00:03:10,718 --> 00:03:15,746
and that's what we're seeing here.
Python has a second type of division

41
00:03:15,746 --> 00:03:19,791
called integer division.
We'll divide four by two using integer

42
00:03:19,791 --> 00:03:23,751
division.
And when Python evaluates this expression,

43
00:03:23,751 --> 00:03:27,731
it will evaluate to give an end as opposed
to a float.

44
00:03:28,709 --> 00:03:35,759
When we divide two by three is an integer,
integer division, we also get an INT zero.

45
00:03:35,761 --> 00:03:43,703
So the way to think about this result is
that if we were to rewrite this, we could

46
00:03:43,703 --> 00:03:50,709
rewrite two and a third as zero and
two-thirds, and what we're getting back is

47
00:03:50,709 --> 00:03:57,736
this whole number part of the result.
So let's consider five divided by three

48
00:03:57,749 --> 00:04:03,723
using integer division and again the
result is one whole number.

49
00:04:03,723 --> 00:04:10,741
So we could rewrite five over three as one
and two-thirds, and we're getting the one.

50
00:04:12,724 --> 00:04:19,704
Dividing seven by three, using integer
division, we get two.

51
00:04:19,704 --> 00:04:24,743
So this would be rewritten as two and a
third.

52
00:04:25,736 --> 00:04:31,757
We're only getting part of the result when
we do this, part of the result that the

53
00:04:31,757 --> 00:04:34,783
division.
The other part we can get using a

54
00:04:34,783 --> 00:04:40,706
different operator called the remainder
operator, or the mod operator.

55
00:04:40,706 --> 00:04:44,792
We use the percentage sign to send this
to, signify this operation.

56
00:04:44,792 --> 00:04:50,752
So four mod two is the way we read this
expression, and the result is zero.

57
00:04:50,753 --> 00:04:55,746
There's no remainder for the division of
four divided by two.

58
00:04:55,756 --> 00:05:01,775
When we divide two by three, the remainder
in this case is two.

59
00:05:02,757 --> 00:05:08,762
And when we divide five by three, the
remainder is two.

60
00:05:08,762 --> 00:05:15,790
So, again, as a review, we can think of
five divided by three, rewriting that as

61
00:05:15,790 --> 00:05:21,748
one and two-thirds.
When we do five divided by three, we get

62
00:05:21,748 --> 00:05:27,716
this whole number one.
When we do five mod three, we get this.

63
00:05:27,716 --> 00:05:31,732
Two.
The numerator of the fractional part of

64
00:05:31,732 --> 00:05:36,730
the result.
So when we do seven MOD three, we get a

65
00:05:36,730 --> 00:05:43,699
one, because that expression could be
rewritten as two one-third.

66
00:05:43,707 --> 00:05:50,722
We get that one.
Now that we've worked with these operators

67
00:05:50,722 --> 00:05:53,772
separately, let's combine them into
expressions.

68
00:05:53,772 --> 00:05:59,761
We'll add three to four and subtract five.
And the operations are performed, are

69
00:05:59,761 --> 00:06:04,761
applied from left to right.
Three is added to four, and then five is

70
00:06:04,761 --> 00:06:10,772
subtracted from that result.
Next, let's add four to five and multiply

71
00:06:10,772 --> 00:06:14,730
by three.
In this case, the order of operations

72
00:06:14,730 --> 00:06:20,705
dictates that multiplication should be
applied first, followed by addition.

73
00:06:20,705 --> 00:06:25,718
Five is multiplied by three and then that
result is added to four.

74
00:06:26,730 --> 00:06:30,779
The next expression, we'll use a negative
number.

75
00:06:30,779 --> 00:06:37,780
So this minus sign that we used for
subtraction is also used with a single

76
00:06:37,780 --> 00:06:44,763
number in order to mean negation.
We'll take -ten, multiply it by three, add

77
00:06:44,763 --> 00:06:48,775
five, and take, that to the power of
three.

78
00:06:48,775 --> 00:06:53,706
The order of operations will apply as
follows.

79
00:06:53,754 --> 00:06:56,776
Five.
Well first we take it to power of three,

80
00:06:56,776 --> 00:07:00,733
because exponentiation has the highest
precedence.

81
00:07:00,763 --> 00:07:08,757
Then over here, the negative sign applies
to the ten first and the result, negative

82
00:07:08,757 --> 00:07:15,706
ten is multiplied by three.
Finally these values are combined using

83
00:07:15,706 --> 00:07:21,778
the addition.
Just like in regular math, we can override

84
00:07:21,778 --> 00:07:28,701
operator precedence using parentheses.
I can have the expression four + five

85
00:07:28,701 --> 00:07:32,766
evaluate first, before multiplying the
result with three.

86
00:07:33,751 --> 00:07:41,731
Similarly, I can decide that I would like
the addition to happen first in the second

87
00:07:41,731 --> 00:07:48,718
expression we looked at, by using
parentheses to evaluate, have it evaluate

88
00:07:48,718 --> 00:07:53,740
first.
Up to this point, every instruction that

89
00:07:53,740 --> 00:07:58,792
we gave to Python yielded a result.
For example, when we asked Python to

90
00:07:58,792 --> 00:08:04,704
evaluate the expression two plus three, it
gave us the result five.

91
00:08:04,704 --> 00:08:09,794
That's because the expression two plus,
plus three follows the syntax of the

92
00:08:09,794 --> 00:08:14,721
Python language.
Syntax is the rules that specify which

93
00:08:14,721 --> 00:08:20,727
combinations of symbols are legal, and two
plus three is a valid expression in

94
00:08:20,727 --> 00:08:24,715
Python.
The expression three plus with a

95
00:08:24,715 --> 00:08:28,726
combination of symbols, three +, is not
valid syntax.

96
00:08:28,726 --> 00:08:33,761
So when I ask Python to evaluate this
expression, we get an error.

97
00:08:33,761 --> 00:08:38,764
This is our first syntax error and we'll
see many more throughout the course.

98
00:08:38,764 --> 00:08:43,767
So Python does not understand what to do
with those, with that combination of

99
00:08:43,767 --> 00:08:48,757
symbols and it can't give us back a
result, so instead it gives us an error.

100
00:08:48,757 --> 00:08:53,780
Another combination symbols that will
result in a syntax error would be to just

101
00:08:53,780 --> 00:08:59,710
use the exponentiation operator on its own
without providing any [indiscernible].

102
00:08:59,710 --> 00:09:06,741
We can also write an expression like the
one we just saw, only instead of having an

103
00:09:06,741 --> 00:09:12,768
open, opening and closing parentheses, we
just include a closing parenthesis.

104
00:09:12,768 --> 00:09:19,743
That will give us a syntax error.
It would include an opening parenthesis

105
00:09:19,743 --> 00:09:23,755
but no closing, then we end up with a
different situation.

106
00:09:23,755 --> 00:09:28,732
When I hit enter, nothing happens, or it
looks like nothing happens.

107
00:09:28,732 --> 00:09:33,723
That's because Python allows instructions
to extend multiples lines.

108
00:09:33,723 --> 00:09:38,715
When we hit enter, it's waiting, actually,
for the closing parenthesis.

109
00:09:38,715 --> 00:09:43,778
Until I give that closing parenthesis, and
hit enter, then, the expression isn't

110
00:09:43,778 --> 00:09:48,717
violated.
In addition to syntax errors, we'll also

111
00:09:48,717 --> 00:09:53,752
encounter semantic errors.
Semantic errors occur when the meaning of

112
00:09:53,752 --> 00:09:59,578
a particular expression is invalid.
So for example, the syntax of two plus

113
00:09:59,578 --> 00:10:03,769
three is valid that is above the
combination of symbols.

114
00:10:03,769 --> 00:10:09,759
And meaning and semantics of that
expression is that two is added to three.

115
00:10:09,759 --> 00:10:14,785
So this is fine.
Four divided by three is valid

116
00:10:14,785 --> 00:10:18,779
syntactically.
We're able to use this combination of

117
00:10:18,779 --> 00:10:22,758
symbols.
However, the meaning of this expression is

118
00:10:22,758 --> 00:10:26,721
invalid.
It's not possible to divide a number by

119
00:10:26,721 --> 00:10:31,729
zero, and so we get a zero division error,
which is a semantic error.