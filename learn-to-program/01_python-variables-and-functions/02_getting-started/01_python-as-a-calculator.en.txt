Hello.
In this lecture we'll begin to program. We refer to this lecture as Python as a
calculator because we're going to focus on mathematical expressions.
In this lecture and throughout the course, we'll be using IDLE, a program that comes
with the Python installation. Let's switch over to IDLE now and start
programming. This is IDLE, and the window that we're
currently looking at is called the shell. This is where we can try out Python
instructions and explore Python's features.
This symbol, the three arrow symbols, is called the prompt.
Next to the prompt, we will type Python instructions.
And when we hit Enter, Python will evaluate those instructions.
For example, let's type the instruction two plus three, and ask Python to evaluate
it. It's important to note that nothing
happens until I hit the Enter key. Let's look at another expression, six
subtract two, and again nothing happens until I hit Enter.
At that point, Python evaluates the expression.
Another expression could be seven times three.
So far we've seen three operators, addition, subtraction and multiplication.
Another operation is exponentiation. And we read this expression, as two to the
power of five. Next, let's take four and divide it by
two. When Python evaluates its expression, the
result that we get looks a little bit different from what we've seen so far.
The expression evaluates to give us 2.0 as opposed to just two.
What we're seeing here is that Python has multiple types, and two of its numeric
types are type int, which stands for integer, and float, which stands for
floating point number. This division operation gives us a
floating point result. Let's explore a few more examples of
division. Five divided by two gives 2.5.
And we would expect that two divided by three would give .666666, with six as
repeating. That is what it gives, although instead of
an infinite number of 6's, we're limited by the number of significant digits
available. So, Python has a limited amount of memory
to work with. And the number that we get, the result of
dividing two by three is an approximation to the real number.
Floating point numbers are approximations to real numbers.
Another example would be to divide five by three, and we can see that the result as
an approximate result with 1.66666 and the last digit is actually a seven.
Similarly, seven divided by three, there's 2.333333, and the last digit is a five.
7/3 is floating point division, and since floating point numbers are approximations
to real numbers, there's some imprecision, and that's what we're seeing here.
Python has a second type of division called integer division.
We'll divide four by two using integer division.
And when Python evaluates this expression, it will evaluate to give an end as opposed
to a float. When we divide two by three is an integer,
integer division, we also get an INT zero. So the way to think about this result is
that if we were to rewrite this, we could rewrite two and a third as zero and
two-thirds, and what we're getting back is this whole number part of the result.
So let's consider five divided by three using integer division and again the
result is one whole number. So we could rewrite five over three as one
and two-thirds, and we're getting the one. Dividing seven by three, using integer
division, we get two. So this would be rewritten as two and a
third. We're only getting part of the result when
we do this, part of the result that the division.
The other part we can get using a different operator called the remainder
operator, or the mod operator. We use the percentage sign to send this
to, signify this operation. So four mod two is the way we read this
expression, and the result is zero. There's no remainder for the division of
four divided by two. When we divide two by three, the remainder
in this case is two. And when we divide five by three, the
remainder is two. So, again, as a review, we can think of
five divided by three, rewriting that as one and two-thirds.
When we do five divided by three, we get this whole number one.
When we do five mod three, we get this. Two.
The numerator of the fractional part of the result.
So when we do seven MOD three, we get a one, because that expression could be
rewritten as two one-third. We get that one.
Now that we've worked with these operators separately, let's combine them into
expressions. We'll add three to four and subtract five.
And the operations are performed, are applied from left to right.
Three is added to four, and then five is subtracted from that result.
Next, let's add four to five and multiply by three.
In this case, the order of operations dictates that multiplication should be
applied first, followed by addition. Five is multiplied by three and then that
result is added to four. The next expression, we'll use a negative
number. So this minus sign that we used for
subtraction is also used with a single number in order to mean negation.
We'll take -ten, multiply it by three, add five, and take, that to the power of
three. The order of operations will apply as
follows. Five.
Well first we take it to power of three, because exponentiation has the highest
precedence. Then over here, the negative sign applies
to the ten first and the result, negative ten is multiplied by three.
Finally these values are combined using the addition.
Just like in regular math, we can override operator precedence using parentheses.
I can have the expression four + five evaluate first, before multiplying the
result with three. Similarly, I can decide that I would like
the addition to happen first in the second expression we looked at, by using
parentheses to evaluate, have it evaluate first.
Up to this point, every instruction that we gave to Python yielded a result.
For example, when we asked Python to evaluate the expression two plus three, it
gave us the result five. That's because the expression two plus,
plus three follows the syntax of the Python language.
Syntax is the rules that specify which combinations of symbols are legal, and two
plus three is a valid expression in Python.
The expression three plus with a combination of symbols, three +, is not
valid syntax. So when I ask Python to evaluate this
expression, we get an error. This is our first syntax error and we'll
see many more throughout the course. So Python does not understand what to do
with those, with that combination of symbols and it can't give us back a
result, so instead it gives us an error. Another combination symbols that will
result in a syntax error would be to just use the exponentiation operator on its own
without providing any [indiscernible]. We can also write an expression like the
one we just saw, only instead of having an open, opening and closing parentheses, we
just include a closing parenthesis. That will give us a syntax error.
It would include an opening parenthesis but no closing, then we end up with a
different situation. When I hit enter, nothing happens, or it
looks like nothing happens. That's because Python allows instructions
to extend multiples lines. When we hit enter, it's waiting, actually,
for the closing parenthesis. Until I give that closing parenthesis, and
hit enter, then, the expression isn't violated.
In addition to syntax errors, we'll also encounter semantic errors.
Semantic errors occur when the meaning of a particular expression is invalid.
So for example, the syntax of two plus three is valid that is above the
combination of symbols. And meaning and semantics of that
expression is that two is added to three. So this is fine.
Four divided by three is valid syntactically.
We're able to use this combination of symbols.
However, the meaning of this expression is invalid.
It's not possible to divide a number by zero, and so we get a zero division error,
which is a semantic error.