1
00:00:01,043 --> 00:00:04,019
¡Hola 
En esta clase vamos a comenzar a programar.

2
00:00:04,019 --> 00:00:09,028
Nos referimos a esta clase de Python como
calculadora porque nos vamos a centrar en

3
00:00:09,028 --> 00:00:13,038
expresiones matemáticas.
En esta clase, y durante todo el curso,

4
00:00:13,038 --> 00:00:17,067
usaremos IDLE, un programa que viene 
con la instalación de Python.

5
00:00:17,067 --> 00:00:20,085
Vamos a cambiar a IDLE ahora y empezar a
programar.

6
00:00:18,746 --> 00:00:23,732
Esto es IDLE, y la ventana que estamos
viendo actualmente se llama la shell.

7
00:00:23,732 --> 00:00:27,759
Aquí es donde podemos probar
instrucciones de Python y explorar características de

8
00:00:27,759 --> 00:00:32,728
Python.
Este símbolo, los tres símbolos de flecha, es

9
00:00:32,728 --> 00:00:37,776
llamado prompt.
Junto al prompt, vamos a escribir instrucciones

10
00:00:37,776 --> 00:00:41,722
Python.
Y cuando presionamos la tecla Enter, Python

11
00:00:41,722 --> 00:00:46,714
evaluará esas instrucciones. 
Por ejemplo, vamos a escribir la instrucción

12
00:00:46,714 --> 00:00:49,746
dos más tres, y pedir a Python la evalúe.

13
00:00:49,797 --> 00:00:55,770
Es importante tener en cuenta que nada
pasará hasta que presione la tecla Enter

14
00:00:55,770 --> 00:01:01,792
Veamos otra expresión, seis 
menos dos, y otra vez no pasa nada

15
00:01:01,792 --> 00:01:06,726
hasta que presione la tecla Enter 
En ese punto, Python evalúa la

16
00:01:06,726 --> 00:01:11,719
expresión.
Otra expresión podría ser siete por

17
00:01:11,719 --> 00:01:15,720
tres.
Hasta ahora hemos visto tres operadores,

18
00:01:15,720 --> 00:01:22,721
suma, resta y multiplicación.
Otra operación es la exponenciación

19
00:01:22,721 --> 00:01:27,712
Y leemos esta expresión, como dos a la
potencia de cinco.

20
00:01:28,737 --> 00:01:33,707
A continuación, vamos a dividir cuatro para
dos.

21
00:01:33,745 --> 00:01:38,709
Cuando Python evalúa esta expresión, el 
resultado que obtenemos se ve un poco

22
00:01:38,709 --> 00:01:43,792
diferente de lo que hemos visto hasta ahora.
La expresión se evalúa y nos da 2.0

23
00:01:43,792 --> 00:01:48,743
en lugar de solamente dos.
Lo que estamos viendo aquí es que Python tiene

24
00:01:48,743 --> 00:01:53,781
múltiples tipos, y dos de sus tipos numéricos
son de tipo int, que significa

25
00:01:53,781 --> 00:01:57,795
entero y float, que significa
número de punto flotante.

26
00:01:58,726 --> 00:02:03,706
Esta operación de división nos da un
resultado de coma flotante.

27
00:02:03,765 --> 00:02:07,722
Vamos a explorar algunos ejemplos más de
división.

28
00:02:07,722 --> 00:02:12,509
Cinco dividido para dos da 2.5.
Y es de esperar que dos dividido para

29
00:02:12,509 --> 00:02:15,740
tres daría 0.666666, con seis
repetiendose

30
00:02:15,740 --> 00:02:21,717
Eso es lo que da, aunque en vez de
un número infinito de 6`s, estamos limitados

31
00:02:21,717 --> 00:02:24,769
por el número de dígitos significativos
disponibles.

32
00:02:24,769 --> 00:02:28,750
Así, Python tiene una cantidad limitada de memoria
para trabajar.

33
00:02:28,750 --> 00:02:34,734
Y el número que obtenemos, el resultado de
dividir dos para tres es una aproximación

34
00:02:34,734 --> 00:02:38,764
al número real.
Los números de punto flotante son aproximaciones

35
00:02:38,764 --> 00:02:43,613
a los números reales.
Otro ejemplo sería dividir cinco para

36
00:02:43,613 --> 00:02:49,782
tres, y podemos ver que el resultado como
un resultado aproximado con 1,66666 y el

37
00:02:49,782 --> 00:02:57,736
última cifra es en realidad una de siete.
Del mismo modo, siete dividido para tres, es

38
00:02:57,736 --> 00:03:04,757
2.333333, y el último dígito es un cinco.
7/3 es la división de punto flotante, y como

39
00:03:04,757 --> 00:03:10,718
Los números de punto flotante son aproximaciones
a los números reales, hay algo de imprecisión,

40
00:03:10,718 --> 00:03:15,746
y eso es lo que estamos viendo aquí.
Python tiene un segundo tipo de división

41
00:03:15,746 --> 00:03:19,791
llamado división entera.
Dividiremos cuatro para dos usando división de

42
00:03:19,791 --> 00:03:23,751
enteros
Y cuando Python evalúa esta expresión,

43
00:03:23,751 --> 00:03:27,731
se evaluará para dar un final al contrario
de un float.

44
00:03:28,709 --> 00:03:35,759
Cuando dividimos dos para tres es un número entero
división de enteros, también conseguimos un INT cero.

45
00:03:35,761 --> 00:03:43,703
Así que la manera de pensar sobre este resultado es 
que si tuviéramos que volver a escribir esto, podríamos

46
00:03:43,703 --> 00:03:50,709
reescribir dos y un tercio como cero y
dos tercios, y lo que estamos obteniendo es

47
00:03:50,709 --> 00:03:57,736
este número completo parte del resultado
Así que consideremos cinco dividido para tres

48
00:03:57,749 --> 00:04:03,723
usando división de enteros y de nuevo el
resultado es un número completo.

49
00:04:03,723 --> 00:04:10,741
Así que podríamos reescribir cinco sobre tres como uno
y dos tercios, y obteniendo el uno.

50
00:04:12,724 --> 00:04:19,704
La división de siete para tres, utilizando divisón
de enteros, obtenemos dos.

51
00:04:19,704 --> 00:04:24,743
Así que esto podría volverse a escribir como dos un
tercio.

52
00:04:25,736 --> 00:04:31,757
Estamos consiguiendo solamente parte del resultado cuando
hacemos esto, parte del resultado de la

53
00:04:31,757 --> 00:04:34,783
división.
La otra parte que podemos conseguir utilizando un

54
00:04:34,783 --> 00:04:40,706
operador diferente llamado el operador
de resto o el operador mod.

55
00:04:40,706 --> 00:04:44,792
Usamos el signo de porcentaje para enviar esto
a, significar esta operación.

56
00:04:44,792 --> 00:04:50,752
Así que cuatro mod dos es la forma en que leemos esta
expresión, y el resultado es cero.

57
00:04:50,753 --> 00:04:55,746
No hay restante para la división de
cuatro dividido para dos.

58
00:04:55,756 --> 00:05:01,775
Cuando dividimos dos para tres, el restante
en este caso es dos.

59
00:05:02,757 --> 00:05:08,762
Y cuando dividimos cinco para tres, el
restante es dos.

60
00:05:08,762 --> 00:05:15,790
Así, de nuevo, como repaso, podemos pensar en
cinco dividido para tres, reescribiendo eso como

61
00:05:15,790 --> 00:05:21,748
uno y dos tercios
Cuando hacemos cinco dividido para tres, obtenemos

62
00:05:21,748 --> 00:05:27,716
este número completo uno
Cuando hacemos cinco mod tres, obtenemos esto.

63
00:05:27,716 --> 00:05:31,732
Dos
El numerador de la parte fraccionaria de

64
00:05:31,732 --> 00:05:36,730
el resultado
Así que cuando hacemos siete MOD tres, obtenemos un

65
00:05:36,730 --> 00:05:43,699
uno, porque esa expresión podría ser
reescrito como dos un tercio.

66
00:05:43,707 --> 00:05:50,722
Recibimos ese uno.
Ahora que hemos trabajado con estos operadores

67
00:05:50,722 --> 00:05:53,772
por separado, vamos a combinarlos en
expresiones.

68
00:05:53,772 --> 00:05:59,761
Vamos a agregar tres a cuatro y restar cinco
Y las operaciones llevadas a cabo, son

69
00:05:59,761 --> 00:06:04,761
aplicado de izquierda a derecha
Tres se añade a cuatro, y luego cinco es

70
00:06:04,761 --> 00:06:10,772
substraído de ese resultado
A continuación, vamos a agregar cuatro a cinco y multiplicar

71
00:06:10,772 --> 00:06:14,730
por tres.
En este caso, el orden de las operaciones

72
00:06:14,730 --> 00:06:20,705
dicta que la multiplicación debe ser
aplicado primero, seguido de la adición.

73
00:06:20,705 --> 00:06:25,718
Cinco se multiplica por tres y luego ese
resultado se suma a cuatro.

74
00:06:26,730 --> 00:06:30,779
La siguiente expresión, usaremos un número
negativo.

75
00:06:30,779 --> 00:06:37,780
Así que este signo negativo que utilizamos para la
substracción también se utiliza con un solo

76
00:06:37,780 --> 00:06:44,763
número con el fin de significar la negación.
Tomaremos diez, multiplicamos por tres, añadimos

77
00:06:44,763 --> 00:06:48,775
cinco, y tomar, eso a la potencia de
tres.

78
00:06:48,775 --> 00:06:53,706
El orden de las operaciones se aplicará a como
sigue

79
00:06:53,754 --> 00:06:56,776
Cinco.
Bueno, primero lo llevamos a la potencia de tres,

80
00:06:56,776 --> 00:07:00,733
porque exponenciación tiene la mayor
precedencia.

81
00:07:00,763 --> 00:07:08,757
Entonces aquí, el signo negativo se aplica
a los diez primero y el resultado, negativo

82
00:07:08,757 --> 00:07:15,706
diez es multiplicado por tres
Finalmente estos valores se combinan utilizando

83
00:07:15,706 --> 00:07:21,778
la adición
Al igual que en matemáticas regular, podemos anular

84
00:07:21,778 --> 00:07:28,701
precedencia de operadores mediante paréntesis.
Yo puedo tener la expresión de cuatro + cinco

85
00:07:28,701 --> 00:07:32,766
evaluarla primero, antes de multiplicar el
resultado por tres.

86
00:07:33,751 --> 00:07:41,731
Del mismo modo, puedo decidir que me gustaría
que la adición pase primero en la segunda

87
00:07:41,731 --> 00:07:48,718
expresión que mirábamos, utilizando
paréntesis para evaluar, que lo evalúe

88
00:07:48,718 --> 00:07:53,740
primero.
Hasta este punto, cada instrucción que

89
00:07:53,740 --> 00:07:58,792
hemos dado a Python ha dado un resultado.
Por ejemplo, cuando le preguntamos a Python

90
00:07:58,792 --> 00:08:04,704
evaluar la expresión dos más tres,
nos dio el resultado de cinco.

91
00:08:04,704 --> 00:08:09,794
Esto se debe a la expresión dos más,
más tres sigue la sintaxis del

92
00:08:09,794 --> 00:08:14,721
lenguaje Python.
La sintaxis es la regla que especifica qué

93
00:08:14,721 --> 00:08:20,727
combinaciones de símbolos son legales, y dos
más tres es una expresión válida en

94
00:08:20,727 --> 00:08:24,715
Python.
La expresión de tres más una

95
00:08:24,715 --> 00:08:28,726
combinación de símbolos, tres +, no es
sintaxis válida.

96
00:08:28,726 --> 00:08:33,761
Así que cuando le pregunto a Python para evaluar esta
expresión, obtenemos un error.

97
00:08:33,761 --> 00:08:38,764
Este es nuestro primer error de sintaxis y vamos a
ver muchos más durante todo el curso.

98
00:08:38,764 --> 00:08:43,767
Así que Python no entiende qué hacer
con los que, con esa combinación de

99
00:08:43,767 --> 00:08:48,757
símbolos y no nos puede devolver un
resultado, por lo que en vez de eso nos da un error.

100
00:08:48,757 --> 00:08:53,780
Otra combinación de los símbolo que
da lugar a un error de sintaxis sería justo

101
00:08:53,780 --> 00:08:59,710
utilizar el operador de exponenciación por sí mismo
sin proporcionar ninguna [indiscernible].

102
00:08:59,710 --> 00:09:06,741
También podemos escribir una expresión como la 
que acabamos de ver, sólo que en lugar de tener un

103
00:09:06,741 --> 00:09:12,768
abierto, apertura y cierre de paréntesis, nos
basta con incluir un paréntesis de cierre.

104
00:09:12,768 --> 00:09:19,743
Eso nos dará un error de sintaxis
Incluiría un paréntesis de apertura

105
00:09:19,743 --> 00:09:23,755
pero no de cierre, y luego terminamos con una
situación diferente.

106
00:09:23,755 --> 00:09:28,732
Cuando presione la tecla Enter, no pasará nada, o
parece que no pasa nada.

107
00:09:28,732 --> 00:09:33,723
Eso es porque Python permite instrucciones
para extender en las líneas múltiples.

108
00:09:33,723 --> 00:09:38,715
Cuando presionamos la tecla Enter, está esperando, en realidad,
por el paréntesis de cierre.

109
00:09:38,715 --> 00:09:43,778
Hasta que doy ese paréntesis de cierre, y
presione Enter, entonces, la expresión no es

110
00:09:43,778 --> 00:09:48,717
violado
Además de los errores de sintaxis, también vamos a

111
00:09:48,717 --> 00:09:53,752
encontrar errores semánticos
Se producen errores semánticos cuando el significado de

112
00:09:53,752 --> 00:09:59,578
una expresión particular es inválida
Así, por ejemplo, la sintaxis de dos más

113
00:09:59,578 --> 00:10:03,769
tres es válido que está por encima de la
combinación de símbolos.

114
00:10:03,769 --> 00:10:09,759
Y el significado y semántica de que la
expresión es que dos se añade a tres

115
00:10:09,759 --> 00:10:14,785
Así  esto está muy bien.
Cuatro dividido para tres es válido

116
00:10:14,785 --> 00:10:18,779
sintácticamente
Somos capaces de utilizar esta combinación de

117
00:10:18,779 --> 00:10:22,758
símbolos.
Sin embargo, el significado de esta expresión es

118
00:10:22,758 --> 00:10:26,721
inválida.
No es posible dividir un número para

119
00:10:26,721 --> 00:10:31,729
cero, y así se obtiene un error de división para cero,
que es un error semántico.