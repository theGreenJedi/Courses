Bonjour.
Dans ce cours nous commençons à programmer. Ce cours s'intitule "Python en tant que
calculette" car nous allons nous concentrer sur des expressions mathématiques.
Dans ce cours comme dans la suite, Nous utiliserons IDLE, un programme qui
viens avec l'installation de Python. Basculons maintenant sur IDLE et
commençons à programmer. Ceci est IDLE, et la fenêtre que nous
avons sous les yeux est appelée le "Shell". C'est ici qu'on peut essayer les instructions
de Python et explorer ses fonctionnalités.
Ce symbole, triple flèche, est appelé le "Prompt".
C'est à côté du Prompt que nous allons taper les instructions Python.
En tapant Entrée, Python va évaluer ces instructions.
Par exemple, tapons l'instruction deux plus trois, et demandons à Python
de l'évaluer. Il est important de remarquer que rien
ne se produit tant que je n'ai pas appuyé sur Entrée. Observons une autre expression: six moins deux
et encore une fois, rien ne se produit tant que je n'ai pas appuyé sur Entrée.
À ce moment, Python évalue l'expression.
Une autre expression pourrait être sept fois trois. Pour l'instant nous avons vu trois opérateurs : addition, soustraction, et multiplication.
Une autre opération est l'exponentielle, et ont lit cette expression comme deux à la
puissance cinq. Ensuite, prenons quatre et
divisons le par deux. Quand Python évalue cette expression, le
résultat est un peu différent de ce qu'on a vu jusqu'à maintenant.
L'expression évaluée nous donne "2.0" et non pas juste "2".
On voit ici que Python a plusieurs types, et deux de ses types
numériques sont "int" qui corresponds à un Entier et "float", qui corresponds à
un nombre à virgule flottante. Cette opération de division nous
donne un résultat à virgule flottante. Explorons un peu plus avec
la division. Cinq divisé par deux donne 2.5
et on peut supposer que deux divisé par trois donnerais 0.66666 avec les 6 répétant
à l'infinie. C'est ce qu'on obtiens, bien qu'a la place
d'un nombre infini de six, on est limités par le nombre de chiffres disponibles. Python a une quantité limitée de mémoire
avec laquelle travailler, et le nombre qu'on obtiens, le résultat de
la division de deux par trois est une approximation du nombre réel.
Les nombres à virgule flottante sont des approximations de nombres réels.
Un autre exemple serait de diviser cinq par trois, et on peut voir que le résultat
est approximé à 1.66666... et le dernier chiffre est en fait un sept.
Dans la même série, sept divisé par trois : 2.333333... et le dernier chiffre est un cinq.
7/3 est une division à virgule flottante, et puisque les nombres à virgule flottante sont des
approximations de réels, il y a des imprécisions. C'est ce que nous voyons ici.
Python a un second type de division appelé division entière.
Nous allons diviser quatre par deux utilisant cette division.
Et quand Python évalue cette expression, il produira un "int", pas un "float". Quand on divise deux par trois avec cette
division, on obtient aussi un "int" : zéro. Pensez y de cette manière :
si on devais réécrire cette expression, on pourrait écrire deux troisièmes comme
zéro et deux troisièmes, et ce qu'on récupère c'est la partie entière de ce résultat.
Considérons cinq divisé par trois avec la division entière et encore
une fois le résultat est un nombre entier. On pourrait réécrire cinq sur trois comme
un et deux tiers, et on récupère le un. En divisant sept par trois avec la
division entière, on obtiens deux. Donc ça pourrait être réécrit
comme deux et un tiers. On obtiens qu'une partie du résultat quand
on fait ça. L'autre partie peut être récupérée avec un opérateur différent appelé le "reste",
ou l'opérateur "modulo". On utilise le signe pourcent pour
utiliser cette opération. On lit cette expression quatre modulo deux
et le résultat est zéro. Il n'y a pas de reste pour la division de
quatre par deux. Quand on divise deux par trois, le reste
dans ce cas est deux, et quand on divise cinq par tris, le
reste est deux. Donc pour réviser encore, on peut penser
à cinq divisé par trois en le réécrivant un et deux tiers.
Quand on fais cinq divisé par trois on obtient ce nombre entier un.
Quand on fais cinq modulo trois, on obtiens ce deux.
Le numérateur de la fraction du résultat.
Donc quand on fais sept MOD trois, on obtiens un un, parce que cette expression pourrait
être réécrite comme deux et un tiers. On obtiens ça.
Maintenant qu'on a travaillé avec ces opérateurs séparément, combinons les pour former
des expressions. Nous allons ajouter trois à quatre et
soustraire cinq. Les opérations sont réalisées de gauche à droite.
Trois est ajouté à quatre, et puis cinq est soustrait de ce résultat.
Ensuite, ajoutons quatre à cinq et multiplions par trois.
Dans ce cas, l'ordre des opérations dicte que la multiplication doit être
appliquée en premier, suivie par l'addition. Cinq est multiplié par trois et ensuite
quatre est ajouté à ce résultat. Pour la prochaine expression, on va utiliser
un nombre négatif. Donc ce signe moins que l'on a utilisé
pour la soustraction peut aussi être utilisé avec un seul nombre pour signifier négation.
On va prendre moins dix, fois trois, plus cinq et prendre ça
à la puissance trois. L'ordre des opérations sera appliqué
ainsi : Cinq est d'abord passé
à la puissance trois, car l'exponentiation est l'opération
avec la plus haute précédence. Ensuite ici, le signe moins s'applique
d'abord au dix et le résultat - moins dix - est multiplié par trois.
Finallement, ces valeurs sont combinées par l'addition.
Comme en math, on peut forcer la précédence en utilisant des parenthèses.
Je peux faire évaluer quatre + cinq en premier, avant de multiplier
le résultat par trois. De la même manière, je peux décider
que l'addition vienne en premier dans la seconde expression que nous avons vu, en
utilisant des parenthèses pour forcer l'évaluation.
Jusqu'à là, toutes les expressions passées à Python ont produit un résultat.
Par exemple, quand on a demandé à Python d'évaluer l'expression deux plus trois,
il nous a donné le résultat cinq. C'est parce que l'expression deux plus
trois suit les règles de syntaxe du language Python.
La syntaxe c'est les règles qui spécifient quelles combinaisons de symboles sont légales;
et deux plus trois est une expression valide en Python.
L'expression trois plus, ou la combinaison de symboles "3" "+" n'est pas
syntaxiquement valide. Donc quand on demande à Python d'évaluer
cette expression, on obtiens une erreur. C'est notre première erreur de syntaxe
et on en verra beaucoup pendant cette classe. Donc Python ne comprends pas quoi faire
avec cette combinaison de symboles et il ne peut pas nous donner
un résultat, donc à la place il donne une erreur. Une autre combinaison qui produirait
une erreur serait de juste utiliser l'opérateur puissance tout seul
sans fournir d'opérandes. On peut aussi écrire une expression comme
celle qu'on viens de voir sauf qu'à la place d'une parenthèse ouvrante puis
fermante, on ne met qu'une ouvrante. Cella nous donnera une erreur de syntaxe.
Si on met une parenthèse ouvrante mais pas de fermante, on se retrouve
avec une situation différente. Quand j'appuie sur Entrée, rien ne se
produit, ou en tout cas rien de visible. C'est parce que Python permet que les
instructions s'étendent sur plusieures lignes. Quand on appuie sur Entrée, il est en
fait entrain d'attendre la parenthèse fermante. Tant que je n'aurais pas donné cette parenthèse
et appuyé sur Entrée, l'expression n'est pas évaluée.
En plus des erreurs de syntaxe, nous allons aussi voir des erreurs sémantiques.
Ces erreurs se produisent quand le sens d'une expression est invalide.
Par exemple, la syntaxe de deux plus trois est valide. C'est une combinaison
valide de symboles. Le me sens, la sémantique de cette
expression est que deux est ajouté à trois. Donc c'est bon.
Quatre divisé par zéro est syntaxiquement valide.
Nous pouvons utiliser cette combinaison de symboles.
Cependant, le sens de cette expression est invalide : il n'est pas
possible de diviser un nombre par zéro, et donc on obtiens une erreur de
division par zéro, qui est une erreur sémantique.