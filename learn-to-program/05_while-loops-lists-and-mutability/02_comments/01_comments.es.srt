1
00:00:01,600 --> 00:00:04,564
Ahora que tenemos declaraciones de condición If e iteraciones,
los problemas que

2
00:00:04,564 --> 00:00:08,000
vamos a enfrentar van a ser
más complicados

3
00:00:08,000 --> 00:00:10,128
Los cuerpos de las funciones van a
ser más largas también

4
00:00:10,128 --> 00:00:12,760
y van a necesitar alguna explicación
en Inglés

5
00:00:15,280 --> 00:00:18,970
Aquí está la función up_to_vowel de
la lectura de la iteración While

6
00:00:18,970 --> 00:00:21,290
Hemos añadido dos comentarios

7
00:00:21,290 --> 00:00:24,090
Un comentario empieza con un carácter signo
de número #

8
00:00:24,090 --> 00:00:26,190
Comúnmente llamado carácter hash

9
00:00:26,190 --> 00:00:31,420
Y es válido hasta el final de la línea
Python ignora estos carácteres.

10
00:00:31,420 --> 00:00:36,880
Su propósito es para documentar el código, muy
parecido a las funciones de documentos doc string

11
00:00:36,880 --> 00:00:40,950
La primera describe las variables que
son usadas en esta función

12
00:00:40,950 --> 00:00:45,000
Noten como vincula conjuntamente antes de la
vocal s e i.

13
00:00:45,000 --> 00:00:49,080
Vamos a explorar un poco que
significa esto

14
00:00:49,080 --> 00:00:54,078
lo haremos usando la palabra zymurgy con
índices

15
00:00:54,078 --> 00:00:59,218
cero, uno, dos, tres, cuatro, cinco y seis

16
00:00:59,218 --> 00:01:02,226
Bien, sabemos que el segundo índice no esta

17
00:01:02,226 --> 00:01:05,986
incluido in mi sub-string, lo que significa
que

18
00:01:05,986 --> 00:01:10,460
esta empezando con el índice cero aumentando
hasta el índice siete

19
00:01:12,370 --> 00:01:17,060
Qué es s desde cero hasta el índice seis?

20
00:01:17,060 --> 00:01:22,000
Eso es zymurg.

21
00:01:22,000 --> 00:01:26,344
Y desde cero a cinco, es

22
00:01:26,344 --> 00:01:31,758
zymur.
S desde cero a cuatro

23
00:01:31,758 --> 00:01:37,768
es zymu.
S desde cero a tres

24
00:01:37,768 --> 00:01:44,240
es zym.
S desde cero a dos es zy.

25
00:01:44,240 --> 00:01:50,906
S desde cero a uno is z.
Y aquí esta bit gracioso s desde

26
00:01:50,906 --> 00:01:57,300
cero hasta cero, solo siguiendo el patrón
de reducir

27
00:01:57,300 --> 00:02:03,050
la longitud por uno, me da una string
vacía

28
00:02:03,050 --> 00:02:09,190
Bien, empezamos antes de la vocales off en la
string vacía y empiezo off en cero.

29
00:02:09,190 --> 00:02:10,934
Así que si insertamos cero en

30
00:02:10,934 --> 00:02:11,915
[INAUDIBLE]

31
00:02:11,915 --> 00:02:17,753
I, terminamos, con una S desde cero
hasta cero, eso es lo que es esto.

32
00:02:17,753 --> 00:02:20,185
Y S desde cero hasta cero es la

33
00:02:20,185 --> 00:02:23,605
string vacía, por lo que de hecho, antes que la vocal
contiene todos

34
00:02:23,605 --> 00:02:26,341
los caractéres encontrados en S desde cero
hasta

35
00:02:26,341 --> 00:02:29,090
cero y antes de la vocal es la string vacía

36
00:02:30,530 --> 00:02:34,210
Esta simple inicialización, donde
asignamos una string

37
00:02:34,210 --> 00:02:36,930
vacía antes del valor y asignamos cero

38
00:02:36,930 --> 00:02:37,980
 a i.

39
00:02:37,980 --> 00:02:41,750
Estableciendo que esta descripción aquí es
correcta

40
00:02:44,120 --> 00:02:48,467
Por otra parte, la primera vez a travéz de la iteración
vamos a a añadir s al índice cero

41
00:02:48,467 --> 00:02:54,788
antes de la vocal y reemplazar lo que tenemos.
Bien ahora antes que la vocal contenga a Z.

42
00:02:54,788 --> 00:03:02,540
I era cero, así que i mas 1 es 1, hará i
1.

43
00:03:02,540 --> 00:03:09,176
Ahora estamos en esa línea donde i es 1. Y en efecto esta

44
00:03:09,176 --> 00:03:11,870
descripción aún es válida

45
00:03:14,460 --> 00:03:17,199
La próxima vez a través de la iteración veremos a

46
00:03:17,199 --> 00:03:20,400
S en el índice uno, viniendo aquí, eso es
y

47
00:03:21,500 --> 00:03:27,350
Tomamos la y, y la ponemos al final delante de la vocal, y luego incrementamos i.

48
00:03:27,350 --> 00:03:30,233
I es ahora dos, así que S, desde cero hasta

49
00:03:30,233 --> 00:03:34,430
dos, es en efecto lo que hemos guardado dentro de la vocal anterior

50
00:03:36,110 --> 00:03:39,883
Manteniendo este tipo de relaciones
entre variables

51
00:03:39,883 --> 00:03:42,193
es un negocio tramposo, pero esto

52
00:03:42,193 --> 00:03:46,370
realmente ayuda a entender que es lo que está pasando
dentro de la iteración

53
00:03:47,840 --> 00:03:50,801
Llegar con a estas relaciones en primer lugar es

54
00:03:50,801 --> 00:03:55,160
también un desafío pero con la práctica irás mejorando

55
00:03:55,160 --> 00:03:59,880
Cuando escribas un azo habrá una relación entre las variables

56
00:03:59,880 --> 00:04:02,440
Trata y encuentra que relación
es y

57
00:04:02,440 --> 00:04:05,290
vas a tener un tiempo fácil escribiendo
el cuerpo de la iteración

58
00:04:06,380 --> 00:04:09,840
Así mismo, una vez qye hallas figurado la relación, anótala

59
00:04:09,840 --> 00:04:11,820
Pon un comentario de tal forma que no tendrás
que

60
00:04:11,820 --> 00:04:14,240
figurar nuevamente la próxima vez que leas
el código

61
00:04:15,920 --> 00:04:21,240
Este segundo comentario, acumula las no vocales al comienzo del string,

62
00:04:21,240 --> 00:04:27,290
describe lo que la iteración hace, muy parecido a doc string, no dice como la función trabaja

63
00:04:27,290 --> 00:04:32,290
Este comentario no dice como la iteración hace el trabajo

64
00:04:32,290 --> 00:04:35,040
Solo describe el efecto

65
00:04:35,040 --> 00:04:38,352
Los comentarios son destinados para los programadores
y ellos no

66
00:04:38,352 --> 00:04:40,910
necesitan describir como la iteración hace su
trabajo

67
00:04:42,850 --> 00:04:47,440
Debes tratar y comentar bits complicados de código para explicar

68
00:04:47,440 --> 00:04:49,090
el propósito de este.

69
00:04:49,090 --> 00:04:50,656
Y debes así mismo escribir comentarios

70
00:04:50,656 --> 00:04:53,150
para describir relaciones entre tus
variables