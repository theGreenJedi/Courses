آن آدرسهای حافظه که از آنها استفاده میکرده ایم حالا معلوم شده که واقعا مفید واقع میشوند. معلوم میشود که میتوانید محتوای بعضی از سوژه ها را میتوانید عوض کنید،و بدون آدرسهای حافظه ،واقعا دشوار است که آن چه را که پیش میاید را توضیح داد. با نشان دادن اینکه  سوژه های لیست قابل تغییر هستند کار را شروع میکنیم. در سطر اول عبارت تکلیفی هست. عبارت سمت راست را ارزیابی کرده و آن یک لیست سوژه به وجود میاورد و شش عدد صحیح صفر،دو،چهار،شش،هشت،و ده. وقتی که لیست را ساختیم متغیر LST را برایش نامگذاری میکنیم. آدرس حافظه سوژه لیست. پس لیست LST شامل آدرس حافظه ID1 است که نظر به سوژه لیست دارد. در ضریب صفر،آدرس حافظه ID2 است. و،آ« به سوژه صفر نظر دارد. در ضریب یک،به دو نظر داریم. در ضریب دو به چهار و ..و..و در سطر دو عبارت تکلیفی دیگری وجود دارد. در سمت چپ،دقیقا متغیری نداریم. چیزی کمی پیچیده تر داریم،لیست در ضریب دو. در واقع میخواهیم که جایگاه حافظه ای را که دقیقا آنجا است را تغییر دهیم. لیست در ضریب دو،بعد از به جریان انداختن عبارت تکلیفی، دیگر به عدد صحیح چهار نظر ندارد. در عوض به عدد صحیح پنج نظر دارد. میخواهیم که سوژه ای را در میان انبوهی تغییر دهیم. وقتی که به سمت جلو کلیک میکنم،میبینیم که سوژه جدیدی در آدرس ID8 عدد داریم، و آن ضریب دو به سوژه جدید نظر دارد. برنامه را ویرایش کنیم و کاری دیگر را به پیش بریم. میخواهم که این برنامه را با برنامه ای دیگر جایگزین کنم. پردازش را مجسم کنیم. سطر اول،میدانیم که منتظر چه باشیم. لیست یک به لیستی نظر دارد. در ضریب صفر اولین ما صفر است. در ضریب یک نظر به دو،ضریب دو نظر به چهار دارد و..و..و.. در سطر دو،کار عجیبی میکنم. آدرس حافظهای را میگیرم که در لیست یک هست. و آن را در متغیر لیست دو جایش میدهم. تنها چیزی که عوض میشودمحتوای نام برنامه است. جلو برویم. اکنون،لیست یک و لیست دو به سوژه لیست نظر دارند. نام آن aliasاست،وقتی که هر دو متغیر به یک آدرس حافظه یکسانی دارند،alias پیش میاید. تا حالا که به خیر گذشت. الان قصد داریم که به آخرین آیتم لیست یک ، یا سوژه ای که لیست یک به آن نظر دارد مقدار 17 را اختصاص دهیم. پس آیتم در ضریب پنج در لیست تغییر خواهد یافت. قصد داریم که مرجع را تا10 ببازیم،و در عوض قصد داریم که آیتم در ضریب پنج به عدد صحیح 17 مربوط گردد. و در اینجا است. چیز جالب در اینجا لیست دو است که  ناظر بر تغییر است. لیست دو مشتمل بر آدرس حافظه سوژه لیست است سوژه را با استفاده از لیست یک عوض کردیم. ولی لیست دو نیز عوض شد. بنابراین وقتی که لیست یک را در ضریب منفی یک چاپ میکنیم،آخرین آیتم را چاپ کرده 17 را به دست میاوریم. و قصد داریم که دقیقا همان نتیجه ای را ببینیم که لیست دو را چاپ میکنیم با ضریب منفی یک. مثال دیگری از alias را انجام میدهیم. اینجا تابع double_even_indices را داریم که لیستی از اعداد صحیح را به عنوان پارامتر پذیرفته و چیزی تحویل نمیدهد،none جواب میدهد. doc strings ،با شروع با ضریب صفر،برای اعداد صحیح داخل لیست یک درمیان دوبل میکند. پس مقادیر در ضرایب صفر،دو،چهار،شش،هشت و و..و...و.. دوبل میشوند. i را با صفر شروع میکنیم. به زبانی دیگر،i ضریب آیتم بعدی است که باید دوبل شود. تا آنجا که چیزی نماند. کار را تا آنجا ادامه میدهیم که i از طول لیست کوچکتر باشد. به زبان دیگر وقتی i مساوی یا بزرگتر از طول لیست باشد. داخل چرخه،قصد داریم که به آیتم در ضریب i نگاه کرده و آن را دوبل کنیم. و مرجع را در آن مقدار جدید ضریب لیست شده iذخیره کند. آنگاه میخواهیم که به i دو تا اضافه کنیم زیرا که قصد داریم که به ضریب ذوج بعدی بپریم. برنامه اصلی ما لیستی به وجود مباورد، برای آن متغیرنام list one را برمیگزینیم. آن لیست را چاپ کنید،اعداد صحیح با ضرایب ذوج را دوبل کنید، و آنگاه دوباره لیست را چاپ کنید. تابع خود را تعریف میکنیم،ساختار لیست خود را به وجود آورده،لیست را چاپ میکنیم و اکنون متوجه باشید که متغیر list one آدرس حافظه ID2 را دارد و ID2 آدرس حافظه سوژه لیست ما است. میخواهیم که برای این alias بیافرینیم ولی از یک عبارت تکلیفی استفاده نمیکنیم در عوض از فراخوانی تابع استفاده میکنیم. مولفه ها را ارزیابی خواهیم کرد. حافظه invest ID2را به دست میاوریم،که قصد داریم که در لیست متغیر در چارچوبی که قرار است برای تابع double_even_indices ایجاد گردد. اکنون،در تابع double_even_indices لیست متغیر به آن لیست سوژه نظر دارد. متغیر list one نیز به آن سوژه لیست نظر دارد. به این معنی که هرگونه تغییری که در سوژه لیست ایجاد میکنیم در هر دو متغیر دیده میشود. i را با صفر شروع میکنیم،توجه کنید که i صفر است. طول های لیست یک،دو،سه،چهار،پنج،شش، هفت است. پس صفر از هفت کوچکتر است. قصد دارم که به مقدار در ضریب صفر نظر کرده و آن را در دو ضرب کنم. مقدار در ضریب صفر11 است، با ضرب کردن آن در 2 ،22 به دست میاید،و آن 22 را میگیریم، و دارای ضریب لیست شده است،که به آن نظر خواهید کرد. اکنون میخواهیم که 2 را به i بیافزاییم و بنابراین i دو است. دو از هفت کمتر است،پس همین کار را خواهم کرد ولی اینبار با ضریب لیست شده دو. ضریب لیست شده 2 برابر13 است. میخواهیم آن 13 را دوبل کرده ،26 را به دست دهد. و و میخواهیم که در ضریب دو آن را داخل لیست آدرس حافظه آن عدد صحیح جدید را که میخواهیم به دستش آوریم. و در دو برای i البته که به چهار میرسیم. i الان چهار است. چهار از هفت کمتر است،پس این کار را دوباره انجام میدهیم. این بار تغییر آیتم و ضریب 4،آن 15 را با 30 جایگزین کن. 2را به i اضافه کنید. شش کوچکتر از هفت است. ضریب لیست شده 6 میشود 17. با عمل کردن روی آن میرسیم به 34. پس ضریب لیست شده شش به 34 نظر دارد. با افزودن دو به i،i میشود هشت. که در اینجا شرط چرخه را به غلط میکشاند. آنجا که شرط چرخه غلط میشود،چرخه پایان میپذیرد،پس از چرخه خارج میشویم. در پایان تابع عبارت دیگری نیست. و بنابراین،none تحویل میگیریم. به خاطر داشته باشید که اگر عبارت return در تابع نباشد، آنگاه تابع مقدار none را از none type تحویل میدهد. کجا بودیم؟ در برنامه اصلی این پایین. آن را دقیقا double even indexes نامیدیم. نزدیک است که کارش تمام شود. به سطر 15 مراجعه میکنیم. List one اکنون به سوژه لیست نظر دارد که در ضریب فر 22 است که بعدا 12، بعد 26،14،30،بعد26،14،16،و34. بنابراین باوجودی که هرگز list one را درون بدنه این تابع تعریف نکردیم list one اکنون به سوژه ای نظر دارد که تغییر یافته است به طوری که خروجی ما مقادیر جدید را در خود دارد. به دلیل aliasing باید بدانیم که چه انواعی قابلیت جابجایی را دارند و کدام انواع قابل جابجایی نیستند. تابه حال لیست تنها نوع قابل جابجاشدن است. بقیه غیر قابل جابجایی هستند. و نیز،نیاز است که وقتی که doc strings را برای انواع جابجا شدنی مینویسیم کاملا حواسمان را جمع کنیم. نیاز است که در مورد این که آیا پارامتر با برنامه داخل تابع تغییر مییابد یا خیر روشن عمل کنیم.