1
00:00:01,360 --> 00:00:03,432
Dans cette vidéo nous allons voir à quel moment

2
00:00:03,432 --> 00:00:05,616
les variables sont crées, combien de temps elles existent

3
00:00:05,616 --> 00:00:08,192
dans la mémoire de la machine et ce qui arrive
quand deux variables

4
00:00:08,192 --> 00:00:10,580
ont le même nom et des fonctions différentes.

5
00:00:13,020 --> 00:00:15,026
Voici la fonction concert_to_minutes

6
00:00:15,026 --> 00:00:18,910
que nous avons détaillée dans le cours sur la visualisation des fonctions

7
00:00:18,910 --> 00:00:21,694
Nous avons ajouté la fonction convert_to_seconds dont l'objet

8
00:00:21,694 --> 00:00:24,310
est de convertir un nombre d'heures en secondes.

9
00:00:25,480 --> 00:00:28,146
convert_to_seconds fonctionne en appelant convert_to_minutes

10
00:00:28,146 --> 00:00:30,960
puis en multipliant le résultat par 60.

11
00:00:30,960 --> 00:00:33,330
Utilisons le visualiseur pour l'explorer.

12
00:00:35,190 --> 00:00:38,115
Passons rapidement sur la définition de la fonction

13
00:00:38,115 --> 00:00:41,534
deux objets fonction sont créés 

14
00:00:41,534 --> 00:00:41,926
qu'après une stimulation mécanique 

15
00:00:41,926 --> 00:00:45,590
et convert_to_seconds fait référence à l'autre.

16
00:00:46,960 --> 00:00:49,990
Nous sommes maintenant sur le point
de réaliser une assignation

17
00:00:49,990 --> 00:00:54,310
La première étape consiste à évaluer la partie droite qui est un appel de fonction

18
00:00:54,310 --> 00:00:58,570
Python évalue l'argument et crée un objet pour cette valeur.

19
00:00:58,570 --> 00:01:00,793
Ensuite Python crée un élément dans la pile des appels

20
00:01:00,793 --> 00:01:03,415
et enregistre l'adresse mémoire de "2" dans les paramètres

21
00:01:03,415 --> 00:01:04,480
[INAUDIBLE]

22
00:01:04,480 --> 00:01:10,830
Pour mémoire, cet endroit s'appelle la pile des appels

23
00:01:10,830 --> 00:01:14,140
Elle est représentée par une pile inversée d'éléments

24
00:01:14,140 --> 00:01:18,340
Lors de l'appel de fonction
un nouvel élément est ajouté dans la pile

25
00:01:18,340 --> 00:01:21,690
Et à chaque sortie de fonction, l'élément en cours dans la pile est supprimé

26
00:01:21,690 --> 00:01:24,310
et l'exécution de la fonction précédente reprend.

27
00:01:25,960 --> 00:01:26,968
La première ligne du corps

28
00:01:26,968 --> 00:01:30,190
de convert_to_seconds est une autre assignation.

29
00:01:30,190 --> 00:01:32,580
La partie droite est un appel de fonction

30
00:01:32,580 --> 00:01:35,532
nous suivons la même règle que d'habitude,

31
00:01:35,532 --> 00:01:40,140
évaluer l'argument num_hours, qui contient 
l'adresse mémoire de "2"

32
00:01:40,140 --> 00:01:43,444
Un élément est alors créé dans la pile
à l'appel de convert_to_minutes

33
00:01:43,444 --> 00:01:47,250
et son paramètre mem_hours contient
l'adresse mémoire de cette valeur.

34
00:01:48,800 --> 00:01:51,750
Il y a deux variables appelées mem_hours

35
00:01:51,750 --> 00:01:55,234
L'une d'entre elles est contenue dans l'appel
à convert_to_minutes et l'autre

36
00:01:55,234 --> 00:01:58,310
est contenue dans l'appel
à convert_to_seconds.

37
00:01:58,310 --> 00:02:01,848
Python conserve ces deux fonctions 
en cours dans deux régions séparées de la mémoire

38
00:02:01,848 --> 00:02:04,810
il ne confond donc pas les variable à utiliser.

39
00:02:06,890 --> 00:02:09,330
De retour au suivi de léxecution

40
00:02:09,330 --> 00:02:13,250
la première ligne de convert_to_minutes
est une assignation

41
00:02:13,250 --> 00:02:17,210
A droite de l'expression nous avons
num_hours *  60

42
00:02:17,210 --> 00:02:18,840
Quel num_hours devons nous utiliser ?

43
00:02:19,840 --> 00:02:22,434
La réponse est que Python 
regarde dans la pile en cours

44
00:02:22,434 --> 00:02:27,890
num_hours fait référence à "2", num_hours fois 60
est évalué à 120.

45
00:02:27,890 --> 00:02:32,378
La deuxième étape de l'assignation est
d'assigner 120

46
00:02:32,378 --> 00:02:35,320
à la variable minutes.

47
00:02:35,320 --> 00:02:40,100
Si minutes n'existe pas dans la pile actuelle,
elle sera créée

48
00:02:43,530 --> 00:02:46,670
Chaque pile contient son propre lot de variables

49
00:02:46,670 --> 00:02:51,150
Celle de convert_to_minutes contient
num_hours et minutes

50
00:02:51,150 --> 00:02:54,860
Et celle de convert_to_seconds contient
seulement num_hours pour le moment

51
00:02:54,860 --> 00:03:00,090
Cependant, à la fin de l'exécution,
il contiendra également minutes et secondes.

52
00:03:00,090 --> 00:03:01,516
La pile pour le programme

53
00:03:01,516 --> 00:03:05,520
principal contient actuellement convert_to_minutes
et convert_to_seconds.

54
00:03:05,520 --> 00:03:08,640
Cependant, après l'assignation de la ligne 20

55
00:03:08,640 --> 00:03:11,410
la variable seconds y existera.

56
00:03:13,090 --> 00:03:14,740
Nous allons à présent renvoyer la valeur

57
00:03:14,740 --> 00:03:17,780
de la variable minutes et sortir de la fonction en cours

58
00:03:17,780 --> 00:03:20,160
Mais où allons nous retourner ?

59
00:03:20,160 --> 00:03:23,730
La réponse est toujours l'élément suivant de la pile d'appel.

60
00:03:23,730 --> 00:03:28,120
La pile actuelle est créée lors
de l'appel à convert_to_minutes

61
00:03:28,120 --> 00:03:30,892
Lorsque l'appel se termine, la pile actuelle

62
00:03:30,892 --> 00:03:33,790
est supprimée et Python renvoie la valeur de retour

63
00:03:33,790 --> 00:03:36,010
en tant que valeur d'initialisation de la fonction.

64
00:03:37,670 --> 00:03:40,270
Cet appel es sur la partie droite d'une assignation

65
00:03:40,270 --> 00:03:43,966
Pour finir la variable d'assignation minutes
va être créée et

66
00:03:43,966 --> 00:03:47,280
Python va enregistrer 
l'adresse en mémoire de la valeur retournée

67
00:03:49,090 --> 00:03:50,090
Regardons ce qui se passe.

68
00:03:52,160 --> 00:03:53,900
Remarquez que la pile de convert_to_minutes

69
00:03:53,900 --> 00:03:56,394
a été supprimée et que la variable
minutes

70
00:03:56,394 --> 00:03:58,192
a été créée dans la pile de convert_to_seconds

71
00:03:58,192 --> 00:04:02,420
Nous avons ici une nouvelle assignation.

72
00:04:02,420 --> 00:04:08,500
La partie droite minutes fois 60 va donner 120 fois 60

73
00:04:08,500 --> 00:04:10,757
et une nouvelle variable "seconds"
va être créée

74
00:04:10,757 --> 00:04:13,330
et contenir l'adresse mémoire de cette nouvelle valeur.

75
00:04:14,850 --> 00:04:17,137
Ensuite nous retournons seconds.

76
00:04:17,137 --> 00:04:20,837
Seconds fait référence à 7200,
c'est donc ce que l'on obtient

77
00:04:20,837 --> 00:04:24,328
lorsque l'on appelle convert_to_seconds à la ligne 20

78
00:04:24,328 --> 00:04:30,944
[AUDIO VIERGE]