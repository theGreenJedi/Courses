1
00:00:00,000 --> 00:00:06,069
Los tres tipos de datos que han visto hasta ahora son
enteros, cadenas y flotantes, resulta que pueden

2
00:00:06,069 --> 00:00:14,037
convertir entre ellos como sigue.
Voy a tomar el número tres y

3
00:00:14,037 --> 00:00:20,091
voy a llamar algo denominado "sturd", que
me devuelve una cadena de longitud uno

4
00:00:20,091 --> 00:00:26,004
contenida en la letra tres, puedo 
asignar esto a una variable. 

5
00:00:26,004 --> 00:00:30,017
Tres es la cadena contenida en la 
letra tres.

6
00:00:31,001 --> 00:00:35,092
Dado que es una cadena, puedo multiplicarla por
lo que yo quiera.

7
00:00:35,092 --> 00:00:42,072
Tomemos 77 veces 3, simplemente por diversión.
Como pueden imaginar, puedo ir en la otra

8
00:00:42,072 --> 00:00:46,077
dirección.
si tengo cinco copias de esta cadena

9
00:00:46,077 --> 00:00:50,047
tres. 
En otras palabras, una cadena de enlace cinco

10
00:00:50,047 --> 00:00:56,015
contiene cinco letras 3.
Entonces, puedo tomar eso y convertirlo

11
00:00:56,015 --> 00:00:58,081
en un entero.
Aquí vamos, 33.333.

12
00:00:58,081 --> 00:01:04,050
Incluso puedo utilizar el resultado de ello y
convertirlo de nuevo en una cadena.

13
00:01:04,050 --> 00:01:11,081
Dándome lo que habría podido obtener si
simplemente hubiera multiplicado tres por cinco.

14
00:01:11,081 --> 00:01:18,067
También puedo convertir flotantes a cadenas.
Si uso INT en una cadena que contenga

15
00:01:18,067 --> 00:01:26,025
varios dígitos, entonces puedo volverla 
un entero extrayendo dicho valor de la

16
00:01:26,025 --> 00:01:27,085
cadena.
También puedo

17
00:01:28,012 --> 00:01:33,038
hacer la misma cosa con un flotante.
Nótese que di un flotante a una cadena

18
00:01:33,038 --> 00:01:40,018
que contiene letras que forman un entero y 
eso lo convierte en un número de punto flotante.

19
00:01:41,048 --> 00:01:47,044
Tengo que ser un poco cuidadoso si 
llamo un entero en una cadena que tiene cosas diferentes

20
00:01:47,044 --> 00:01:51,030
a dígitos dentro de ella, de hecho, voy a
obtener un error.

21
00:01:51,030 --> 00:01:57,005
Aquí, siempre, todo lo que voy a obtener es un
valor cualquiera, un literal inválido para un entero en

22
00:01:57,005 --> 00:02:02,000
base diez, tengo siete manzanas.
Esto simplemente está anunciando que Python

23
00:02:02,000 --> 00:02:09,436
no es capaz de realizar la conversión.
Una motivación para algo, es 

24
00:02:09,436 --> 00:02:15,060
que si llamo la entrada, digamos, "dime el
número de zapatos".

25
00:02:15,060 --> 00:02:22,025
Y el usuario digita, digamos, 863 zapatos es el
número que desean.

26
00:02:22,025 --> 00:02:33,073
Regreso una cadena si mi almacén de zapatos tiene
solamente 627 zapatos, entonces no puedo, por ahora,

27
00:02:33,073 --> 00:02:46,306
comparar la cadena 863 con el número 627.
La solución aquí es tomar el resultado de 

28
00:02:46,306 --> 00:02:52,006
lo que el usuario digite y convertirlo en un 
entero.

29
00:02:55,063 --> 00:03:02,097
Guardarlo en una variable y ahora puedo hacer mi
comparación.

30
00:03:02,097 --> 00:03:11,028
¿Quedan suficientes zapatos para
satisfacer a mi cliente? 

31
00:03:12,027 --> 00:03:13,082
Y la respuesta es no.