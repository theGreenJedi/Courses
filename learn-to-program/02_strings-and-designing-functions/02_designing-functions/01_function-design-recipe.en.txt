In this lecture, we're going to show you
a series of steps called the Design Recipe that you can use to write
your own functions. Here is our triangular function. We've added one part to
the doc strip examples of use. And expected vector in values. This function definition has five parts. It has the header, which includes
the function name and the parameters. It has the type contract, the types or values that are expected to
be past to the parameters. As well as the returned
type of the function. It has the description. It has a couple of examples
of use of this function. And last, it has the body of the function. Our design recipe helps you
develop those five parts. Plus one more where we test that our
function works, once we've written it. We'll explain the design recipe
as we develop another function. Here is the problem we'll work on. The United States measures
temperature in Fahrenheit and Canada measures it in Celsius. When traveling between the two countries
it helps to have a conversion function. We'll write a function that converts
from Fahrenheit to Celsius. The first step we will do is to
come up with some examples of using your function that
you're about to write. Think about what you want your
function to do and type one or two examples of calls on
the function you want to write. You'll need to think of a name for
your function. You can always change it later. Function names are often verbs or
verb phrases because they do things. So, if you're stuck enter the question,
what does the function do? Our answer here is convert
from Fahrenheit to Celsius. But that's pretty long, so
I'll use convert to Celsius. You can always improve the name later. What do we want to happen when we
call convert to Celsius on 32 degrees Fahrenheit? We hope to get back zero. We're going to add the angle brackets, so that it looks like it was
typed in the Python Shell. Let's add one more example to
convert at the boiling point. The next step is to figure
out the type contract. What types are the parameters and
what type is the value that gets returned. It looks like we want to convert
to Celsius to work with integers. But we can imagine that it
should work with floats as well. We're going to use the word number,
to indicate that it can handle either, and presumably,
it will return a number as well. Now that you've written some calls and you
have guesses to what the type should be. It's time to write
the header of the function. Pick a meaningful parameter name so that other programmers and you have an
easier time understanding your function. You can also modify your
function name here if you like. Let's fill in what we know for the header. We know that the function
name is convert_to Celsius. And we know that our parameter is
the number of degrees Fahrenheit, so that is Fahrenheit
as our parameter name. Everything below is supposed
to be in a dock string so let's take care of that now. [SOUND] By now you should have a very good
idea of what you want your function to do. It's time to write a description. Does our function do, return the number of Celsius degrees
equivalent to Fahrenheit degrees. Note that we've mentioned
the perimeter explicitly and we've also described the return value. This is very important
in all documentation. Now that you have a strong idea
of what your function should do. And you've decided on the function and
parameter names. You can write the code for the function. This will be much easier to do if you
spent time thinking about the examples, contract, header, and the description. As we learned in school,
we subtract 32 from Fahrenheit. And then we multiply by five-ninths. We haven't saved this yet,
and we really should. We're going to call this one, [SOUND] temperature.pi. It's time to test our
function on the examples. Since you've already figured out
what the return value should be. You can tell right away if your code,
or perhaps the examples, are incorrect. We move on this module. Set up the Windows so
we can see both of them at once. And then we can just copy and
paste our examples. And we see that we are expecting 0 but,
that we got back 14.2 repeating. What about the other one? No, that's not right either. You may have already seen the problem. Subtraction has lower precedence than
either multiplication or division. And so the subtraction is happening
last after we're calculating, 32 times 5 divided by 9. We fix this by adding parenthesis, saving, rerunning. And then trying our examples again We almost have what we
expected on our examples. Except we're getting back
a float instead of an int. This is because division
always produces a float. And various operators produce a float
if either operand isn't of float. The problem is not with our calculation,
it's in our examples and in our contract. A number is too general of a return type. We'll fix both. [SOUND]
Let's run our module one more time, call help
on our function and revel in our clarity.