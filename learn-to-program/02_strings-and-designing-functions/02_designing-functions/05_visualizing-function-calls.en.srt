1
00:00:01,630 --> 00:00:05,670
In this video we're going to use the
Python Visualizer to explore how function

2
00:00:05,670 --> 00:00:07,450
calls are managed in computer memory.

3
00:00:09,470 --> 00:00:12,040
We have written a function
called convert to minutes,

4
00:00:12,040 --> 00:00:15,860
which takes in a number of hours, and
returns the equivalent number of minutes.

5
00:00:17,100 --> 00:00:22,455
For example, if we call convert to
minutes with argument 2 then expect

6
00:00:22,455 --> 00:00:27,470
to get back 120,
because there are 120 minutes in 2 hours.

7
00:00:28,710 --> 00:00:33,510
Notice the indentation all code
belonging to a function must be indented

8
00:00:33,510 --> 00:00:35,750
typically four spaces.

9
00:00:35,750 --> 00:00:38,500
Let's visualize what happens
when we run this program.

10
00:00:39,550 --> 00:00:44,530
When we read the function definition,
of author one Python does,

11
00:00:44,530 --> 00:00:47,750
we see that a variable called
convert to minutes is created.

12
00:00:48,860 --> 00:00:52,100
It contains a memory address
of a function object.

13
00:00:52,100 --> 00:00:56,680
That function object contains all
information about the function including

14
00:00:56,680 --> 00:01:01,890
any code that needs to be executed,
the parameter, and the doc string.

15
00:01:03,100 --> 00:01:07,370
We are now now paused on line ten which
contains an assignment statement.

16
00:01:07,370 --> 00:01:10,770
Notice the variable minutes
too has not been created yet,

17
00:01:10,770 --> 00:01:16,120
that will happen after we finish
executing the assignment statement.

18
00:01:16,120 --> 00:01:19,570
So first we have to evaluate
the expression on the right hand side of

19
00:01:19,570 --> 00:01:23,340
the equals symbol, and
that expression is a function call.

20
00:01:23,340 --> 00:01:28,240
Once that function call has returned it
will give us back a value and minutes

21
00:01:28,240 --> 00:01:32,970
too will be created and it will store
the memory address of that returned value.

22
00:01:35,240 --> 00:01:39,264
In order to execute this function
call the argument is evaluated.

23
00:01:39,264 --> 00:01:44,389
That will create a box for value 2 in
addition a new region of memory will be

24
00:01:44,389 --> 00:01:50,032
created to keep track of what happens
while convert_to_minutes is executed.

25
00:01:53,762 --> 00:01:57,614
Here is value 2 and
here is variable num_hours,

26
00:01:57,614 --> 00:02:02,510
the area of computer memory to
the right is called the heap.

27
00:02:02,510 --> 00:02:07,190
And contains all the values that
are created during execution of a program.

28
00:02:07,190 --> 00:02:09,971
The area of memory to the left
is called the call stack,

29
00:02:09,971 --> 00:02:12,941
it's called a stack because
it's like a stack of plates.

30
00:02:12,941 --> 00:02:16,734
When a function is called,
a stack frame is created and

31
00:02:16,734 --> 00:02:21,364
when that function returns,
its frame is removed from the stack.

32
00:02:21,364 --> 00:02:25,677
And control passes back to
the caller of that function,

33
00:02:25,677 --> 00:02:32,660
each frame contains variables that are
specific to that section of the program.

34
00:02:32,660 --> 00:02:37,710
The main frame contains variables that
are created outside of a new function and

35
00:02:37,710 --> 00:02:41,740
frames for functions contain
parameters and local variables.

36
00:02:43,650 --> 00:02:47,857
A local variable is any
variable that is created inside

37
00:02:47,857 --> 00:02:50,880
of a function such as variable result.

38
00:02:52,300 --> 00:02:54,990
Line seven contains
an assignment statement,

39
00:02:54,990 --> 00:02:57,430
we evaluate the right hand side.

40
00:02:57,430 --> 00:03:03,110
We look up what num_hours is and
it's 2, 2 times 60 is 120.

41
00:03:03,110 --> 00:03:07,440
So we're going to see
a value 120 get created.

42
00:03:07,440 --> 00:03:11,445
And we're going to see a variable
result get created inside function

43
00:03:11,445 --> 00:03:14,450
convert_to_minutes.

44
00:03:14,450 --> 00:03:19,156
Result refers to 120,
num_hours refers to 2.

45
00:03:19,156 --> 00:03:25,840
We're about to execute a return statement
that's going to evaluate result,

46
00:03:25,840 --> 00:03:31,119
which is 120 and
it's going to yield that memory address.

47
00:03:31,119 --> 00:03:34,970
Notice that we get to see
what the return value is.

48
00:03:36,960 --> 00:03:40,150
As soon as we click forward one more time

49
00:03:40,150 --> 00:03:43,094
we're going to exit function
convert_to_minutes.

50
00:03:44,300 --> 00:03:49,600
Control is going to pass back to where we
were in the program, that was right here.

51
00:03:49,600 --> 00:03:52,410
We're going to finish this call to
convert_to_minutes with argument 2 and

52
00:03:52,410 --> 00:03:56,910
it's going to give us back
the memory address of value 120.

53
00:03:56,910 --> 00:04:05,870
That should create a variable minutes 2,
In deed, that's what happens.

54
00:04:07,480 --> 00:04:10,840
The stack frame for
the call to convert_to_minutes is gone,

55
00:04:10,840 --> 00:04:12,870
gone from computer memory.

56
00:04:12,870 --> 00:04:20,040
That's what happens when a function exits,
we're going to step through

57
00:04:20,040 --> 00:04:24,320
another column convert_to_minutes, this
time we're going to pass an argument 3.

58
00:04:24,320 --> 00:04:27,270
And we're going to save the results
to result the minutes_3 here.

59
00:04:28,750 --> 00:04:33,781
Let's watch that happen, we evaluate
3 which creates it in the heap,

60
00:04:33,781 --> 00:04:38,310
Num_hours refers to that value now.

61
00:04:38,310 --> 00:04:41,040
It used to refer,
on the first call, to value two.

62
00:04:41,040 --> 00:04:44,870
Now it refers to value 3 because we've
called it with a different argument.

63
00:04:49,814 --> 00:04:54,156
Now, when I calculate num_hours times 60,
I look at the stack here and

64
00:04:54,156 --> 00:04:57,630
I see that I'm taking 3 times 60,
and that's 180.

65
00:04:57,630 --> 00:05:00,780
And so we're going to get
a variable result referring to 180.

66
00:05:00,780 --> 00:05:05,212
We still have value 120 up here

67
00:05:05,212 --> 00:05:09,962
because outside of this function,

68
00:05:09,962 --> 00:05:14,090
minutes 2 still refers to it.

69
00:05:14,090 --> 00:05:18,843
Now we're going to return 180,
that will yield memory

70
00:05:18,843 --> 00:05:23,596
address id5 which is going be
stored inside a new variable

71
00:05:23,596 --> 00:05:28,161
minutes_3 which will be
created in this main module.