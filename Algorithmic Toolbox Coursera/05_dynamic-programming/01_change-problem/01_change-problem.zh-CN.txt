录制这个演讲之前，我去了咖啡厅。 这卡布奇诺还是不错的。 当我拿了$5给收银员，摆在她面前的 是一个算法问题：她该拿哪几种硬币来找零 而世界各地的收银员都使用贪心算法(Greedy Algorithm)
来解决这个问题 而世界各地的收银员都使用贪心算法(Greedy Algorithm)
来解决这个问题 今天，我们将学习收银员和计算机科学家 如何使用贪心算法解决这些实际问题。 找零问题是如何用最小数量的硬币来找零 找零问题是如何用最小数量的硬币来找零 正式地讲，输入是找零金额，正整数， COIN1，COIN2，COINd，表示能使用的硬币面值。 例如，在美国，COIN1将是1美分， COIN2将是5美分，10美分，25美分和50美分。 输出是找零中所含硬币的最小数 输出是找零中所含硬币的最小数 所以今天早上，收银员要找我40美分， 她最有可能使用下面的算法。 首先，找到小于40美分的最大的硬币面值 首先，找到小于40美分的最大的硬币面值 是25美分。 于是，她给了我25，还剩15美分 那么下一个问题是如何找零15美分。 她接下来可能去拿15范围内数额最大的硬币 是10美分。 她给了我10美分，最后，再找5美分。 结果是，用25加10加5找零40美分， 这是不是找零时可能的最小硬币数？ 在美国，这是最小数目。 但是，如果你在坦桑尼亚，不会这样 在坦桑尼亚除了25，10，5，还有20分硬币。 因此，贪心算法在坦桑尼亚会失败 找零40分，只要拿两个20分硬币 找零40分，只要拿两个20分硬币 既然贪心算法来解决这个问题失败， 试试别的 我们尝试用递归算法解决 假设我们要找零9美分，而 我们的面额有1美分，5美分和6美分。 找零9美分的最佳方法是什么？ 按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4(9-5)美分，8(9-1)美分 按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4 (9-5)美分，8 (9-1)美分 按照递归思路，我们要先知道如何找零 3 ( 9-6 )美分
, 4 (9-5)美分，8(9-1)美分 换句话说，要找零九美分 我们要先知道如何找零较小的金额<br /> 在现在的情况下，较小的金额为3分，4分和8分。 所以我们写这样一个递归程序来解决这个问题 所以我们写这样一个递归程序来解决这个问题 就是这个RecursiveChange程序 找钱的话有以下几种选择，coins, coin1, coin2, coind 找钱的话有以下几种选择，coins, coin1, coin2, coind 依次递归调用 money-coin1, money-coin2, money-coind 依次递归调用 money-coin1, money-coin2, money-coind 然后从以上得出的答案中选择最小的 然后从以上得出的答案中选择最小的 看上去这样做是对的 我们看看运行有多快 要找的钱是76，有三个选择 接下来再递归解决70（76-6），71（76-5），75（76-1） 接下来再递归解决70（76-6），71（76-5），75（76-1） 这三种选择又各自衍生出三种选择 这个三叉树增长非常快 这个三叉树增长非常快 在找零70美分的问题上，我们重复解决了多少次？ 三次，而我们才刚刚开始 再继续下去，会增长到六次 再继续下去，会增长到六次 你们认为找零30美分要递归多少次？ 你们认为找零30美分要递归多少次？ 我们会重复解决同样的问题多达数万亿次， 也就是说，这个看上去非常简洁的代码，我们这辈子都看不到它跑完 也就是说，这个看上去非常简洁的代码，我们这辈子都看不到它跑完 无论是贪心算法还是递归都不能解决这个问题 无论是贪心算法还是递归都不能解决这个问题 60年前，一个杰出的数学家，理查德·贝尔曼，有不同的想法。 有没有可能改进递归算法，避免这样它重复工作 有没有可能改进递归算法，避免这样它重复工作 把一些解决过的问题存储，要用的时候直接调用 把一些解决过的问题存储，要用的时候直接调用 把一些解决过的问题存储，要用的时候直接调用 这个思想也就是动态规划，如今大规模的应用在各种实际问题中 这个思想也就是动态规划，如今大规模的应用在各种实际问题中 核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左 核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左 核心思想是，从左到右填充这个方阵，
而不是像递归是从右到左 从最小开始， 找0美分要多少硬币？ 0 找1美分要多少硬币？ 1 找0美分的硬币数+1 接下来用类似方法找零2美分，3美分，4美分 接下来用类似方法找零2美分，3美分，4美分 之前的数字只有一种答案 5美分有两种可能答案 直接用5美分硬币，或是 找4美分的硬币数+ 1 直接用5美分硬币，或是 找4美分的硬币数+ 1 该选哪种？ 当然是前一种 6美分就有三种可能 我们选择最优情况， 就是直接用6美分硬币找 接下来7美分，8美分同样以此类推 9美分需要四个硬币 9美分需要四个硬币 DPChange程序就这样很简便的填满了之前展示的那个方阵 DPChange程序就这样很简便的填满了之前展示的那个方阵 DPChange程序是你在这节课看到的第一个动态规划算法 之后会有很多 你可能会问为什么这个算法叫动态规划 跟编程有什么关系？ 其实动态编程和编程无关。 其实动态编程和编程无关。 这是计算机科学家公认最实用的一个算法 这是计算机科学家公认最实用的一个算法 但是，当理查德·贝尔曼正在研究这个时 他的上峰，也就是空军项目的大佬们觉得他在浪费时间 所以为了不受干扰的研究 所以为了不受干扰的研究 他想出了这个名字 跟这个算法的实质没任何关系的名字 他原话是，我还能选什么名字 我考虑过用计划（planning）,后来还是考虑用规划(Programming) 我考虑过用计划（planning）,后来还是考虑用规划(Programming) 我想特别传达动态(dynamic)这个特质 他们什么都不懂，但一听到这个词就觉得项目很有潜力