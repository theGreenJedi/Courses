1
00:00:00,370 --> 00:00:03,600
Antes de grabar esta lección,
me detuve en la cafetería.

2
00:00:04,650 --> 00:00:05,660
Este capuchino es bueno.

3
00:00:08,540 --> 00:00:13,070
Tan pronto le di 5$ a la cajera, se enfrentó

4
00:00:13,070 --> 00:00:17,970
a un problema algorítmico, cuáles
monedas seleccionar para darme el cambio.

5
00:00:19,340 --> 00:00:24,430
Y los cajeros de todo el mundo usan
una aproximación algorítmica

6
00:00:24,430 --> 00:00:28,350
llamado algoritmo voraz
para resolver este problema.

7
00:00:28,350 --> 00:00:33,580
Hoy aprenderemos cómo los cajeros
y los científicos informáticos

8
00:00:33,580 --> 00:00:38,520
usan algoritmos voraces para
resolver muchos problemas prácticos.

9
00:00:39,610 --> 00:00:43,850
El problema del cambio consiste
en encontrar el mínimo número de monedas

10
00:00:43,850 --> 00:00:45,380
para devolver el cambio.

11
00:00:46,520 --> 00:00:52,440
Más formalmente, tenemos un problema en el que
hay un entero money y unos enteros positivos

12
00:00:52,440 --> 00:00:57,400
coin1, coin2, coind, que representan 
denominaciones de monedas.

13
00:00:57,400 --> 00:01:00,815
Por ejemplo, en EE.UU. coin1 será 1 centavo,

14
00:01:00,815 --> 00:01:06,500
coin2 serán 5 centavos, 10 centavos,
25 centavos y 50 centavos.

15
00:01:06,500 --> 00:01:11,563
Y la salida es el número mínimo de monedas,
cuyas denominaciones son coin1, 

16
00:01:11,563 --> 00:01:15,290
coin2, coind que cambian money exactamente.

17
00:01:17,100 --> 00:01:21,695
Hoy por la mañana, cuando
la cajera me devolvió 40 centavos,

18
00:01:21,695 --> 00:01:25,650
lo más probable es que usó
el siguiente algoritmo.

19
00:01:25,650 --> 00:01:28,710
Primero, encontrar la mayor
denominación de moneda

20
00:01:28,710 --> 00:01:31,190
que es menor que 40 centavos.

21
00:01:31,190 --> 00:01:33,200
Serán 25 centavos.

22
00:01:33,200 --> 00:01:35,870
Así que me dió 25, quedan 15 centavos y

23
00:01:35,870 --> 00:01:38,220
entonces el siguiente reto es
cómo cambiar 15 centavos.

24
00:01:39,230 --> 00:01:44,180
El siguiente paso es que probablemente
encontró la mayor moneda menor que 15 centavos,

25
00:01:44,180 --> 00:01:45,500
son 10 centavos.

26
00:01:45,500 --> 00:01:49,260
Ella me dió 10 centavos y finalmente
me devolvió 5 centavos.

27
00:01:49,260 --> 00:01:56,170
Como resultado, ella devolvió
40 centavos como 25 más 10 más 5.

28
00:01:56,170 --> 00:02:00,765
¿Piensas que este es el menor número
de monedas que podía posiblemente devolver?

29
00:02:02,300 --> 00:02:06,750
Es el mínimo número de monedas
en los Estados Unidos.

30
00:02:06,750 --> 00:02:10,250
Pero si viajas a Tanzania, no será

31
00:02:10,250 --> 00:02:15,130
el número mínimo de monedas porque
existe una moneda de 20 céntimos en Tanzania.

32
00:02:15,130 --> 00:02:20,220
Y, por tanto, este enfoque voraz
para resolver el problema del

33
00:02:20,220 --> 00:02:24,940
cambio fracasará en Tanzania porque
existe una mejor manera de cambiar 40 centavos,

34
00:02:24,940 --> 00:02:30,540
simplemente como 20 centavos más 20 centavos,
usando la moneda de 20 centavos tanzana.

35
00:02:32,580 --> 00:02:37,570
Ya que el enfoque voraz
para resolver el problema del cambio fracasa,

36
00:02:37,570 --> 00:02:39,330
vamos a intentar algo diferente.

37
00:02:39,330 --> 00:02:44,660
Vamos a intentar un algoritmo
recursivo para resolver el mismo problema.

38
00:02:44,660 --> 00:02:47,940
Se supone que queremos cambiar 9 centavos y

39
00:02:47,940 --> 00:02:53,270
nuestras denominaciones de monedas son
1 centavo, 5 centavos y 6 centavos.

40
00:02:53,270 --> 00:02:58,500
¿Cuál sería la forma óptima de cambiar 9 centavos?

41
00:02:58,500 --> 00:03:05,414
Bien, si sólo supieramos cuáles son las formas
óptimas de cambiar 9 menos 6 centavos,

42
00:03:05,414 --> 00:03:10,991
9 menos 5 centavos y 9 menos 1 centavo
entonces ¿sabríamos

43
00:03:10,991 --> 00:03:15,710
cuál es la forma óptima de cambiar 9 centavos?

44
00:03:15,710 --> 00:03:18,908
En otras palabras, para cambiar 9 centavos,

45
00:03:18,908 --> 00:03:23,346
necesitamos saber cómo cambiar cantidades
menores de centavos.

46
00:03:23,346 --> 00:03:28,340
En nuestro caso, 3 centavos, 4 centavos
y 8 centavos.

47
00:03:28,340 --> 00:03:33,180
Y, por consiguiente, un enfoque
para resolver este problema podría ser

48
00:03:33,180 --> 00:03:38,170
usar esta recurrencia para
escribir el programa recursivo.

49
00:03:39,290 --> 00:03:43,765
Esta idea está implementada
en el programa RecursiveChange.

50
00:03:44,800 --> 00:03:49,520
Para cambiar money, centavos
usando monedas, coin1,

51
00:03:49,520 --> 00:03:53,750
coin2, coind, haremos lo siguiente.

52
00:03:53,750 --> 00:03:59,332
Primero llamamos recursivamente a 
RecursiveChange con la cantidad money,

53
00:03:59,332 --> 00:04:05,130
money menos coin1, money menos coin2,
y money menos coind.

54
00:04:05,130 --> 00:04:10,482
Y encontramos la cantidad mínima
de monedas para estas d elecciones.

55
00:04:10,482 --> 00:04:15,480
Tenemos más 1 porque hay una moneda 
más que añadir y devolvemos el valor.

56
00:04:17,150 --> 00:04:22,360
Este parece ser el enfoque
correcto para resolver el problema,

57
00:04:22,360 --> 00:04:26,970
pero vamos a comprobar cuán rápido
es el programa resultante.

58
00:04:28,220 --> 00:04:33,520
Cuando queremos cambiar 76 monedas,
existen actualmente tres elecciones.

59
00:04:33,520 --> 00:04:38,240
Necesitamos llamar recursivamente
a RecursiveChange para 70 centavos

60
00:04:38,240 --> 00:04:40,940
71 centavos y 75 centavos.

61
00:04:42,420 --> 00:04:48,670
Pero para cada uno de estos valores,
necesitamos llamar de nuevo a tres elecciones.

62
00:04:49,700 --> 00:04:53,346
Y continuamos haciendo crecer este árbol y

63
00:04:53,346 --> 00:04:57,520
muy rápidamente se convierte
en un árbol gigantesco.

64
00:04:58,800 --> 00:05:05,020
Vamos a comprobar cuantas veces
hemos intentado cambiar 70 centavos.

65
00:05:05,020 --> 00:05:09,900
Tres veces, y sólo hemos
comenzado a expandir este árbol.

66
00:05:09,900 --> 00:05:14,630
De hecho, si continuamos más,
veremos que habían seis

67
00:05:14,630 --> 00:05:19,280
lugares en los que necesitamos
calcular RecursiveChange para 70.

68
00:05:21,110 --> 00:05:26,370
¿Cuántas veces piensas que tendremos
que ejecutar llamadas recursivas

69
00:05:26,370 --> 00:05:31,200
cuando calculamos el número
mínimo de monedas para 30 centavos?

70
00:05:32,330 --> 00:05:37,230
Resulta que necesitaremos
llamarlo trillones de veces,

71
00:05:37,230 --> 00:05:42,158
lo que significa que nuestro,
en apariencia muy elegante

72
00:05:42,158 --> 00:05:49,120
programa RecursiveChange, no finalizará
antes del fin de tu vida.

73
00:05:49,120 --> 00:05:54,196
Tan simple como parece ser el problema 
del cambio, ni el enfoque voraz ni

74
00:05:54,196 --> 00:05:57,860
un enfoque recursivo lo resuelven
en un tiempo razonable.

75
00:05:57,860 --> 00:06:05,110
Hace 60 años, un matemático brillante,
Richard Bellman tuvo una idea diferente.

76
00:06:06,450 --> 00:06:11,750
¿No sería bueno conocer las respuestas
para el cambio de money menos

77
00:06:11,750 --> 00:06:17,050
coini en el momento en el que necesitemos
calcular una forma óptima de cambiar money?

78
00:06:18,310 --> 00:06:21,996
Y en lugar de las llamadas costosas en 
tiempo a RecursiveChange

79
00:06:21,996 --> 00:06:27,180
money menos coin i, que pueden requerir
repetirse trillones de veces,

80
00:06:27,180 --> 00:06:30,291
mirar simplemente estos valores.

81
00:06:32,230 --> 00:06:39,360
Esta idea condujo al enfoque de programación
dinámica que es aplicado en miles de

82
00:06:39,360 --> 00:06:44,260
diversas aplicaciones prácticas en
miriadas de campos diferentes.

83
00:06:45,260 --> 00:06:50,600
Y la idea clave de la programación dinámica
es comenzar llenando esta matriz,

84
00:06:50,600 --> 00:06:55,760
no de derecha a izquierda, como hicimos
antes en el cambio recursivo, sino

85
00:06:55,760 --> 00:06:59,180
en su lugar, de la izquierda a la derecha.

86
00:06:59,180 --> 00:07:01,410
Primero responderemos a la pregunta trivial

87
00:07:01,410 --> 00:07:05,710
de cuál es el número mínimo de monedas
necesario para cambiar 0 centavos.

88
00:07:05,710 --> 00:07:07,850
Y, por supuesto, es 0.

89
00:07:07,850 --> 00:07:10,720
¿Cuál es el número mínimo de
monedas para cambiar 1 centavo?

90
00:07:10,720 --> 00:07:15,700
Obviamente es uno, pero podemos
calcular este número encontrando cuál

91
00:07:15,700 --> 00:07:19,220
es el número mínimo de monedas para
cambiar 0 centavos y añadir una moneda.

92
00:07:19,220 --> 00:07:23,240
Procederemos de forma similar
para calcular el número mínimo de

93
00:07:23,240 --> 00:07:26,820
monedas para cambiar 2 centavos, 3
centavos y 4 centavos.

94
00:07:26,820 --> 00:07:32,440
Solo existe una posibilidad de derivar
este número del anterior.

95
00:07:32,440 --> 00:07:39,110
Y para 5 centavos, realmente existen dos
posibilidades, verde y azul.

96
00:07:39,110 --> 00:07:44,486
En la verde, puedes obtenerlo de 0
centavos añadiendo una moneda de 5.

97
00:07:44,486 --> 00:07:51,095
Y para la posibilidad azul, podemos obtenerlo
desde 4 centavos añadiendo un penique.

98
00:07:51,095 --> 00:07:53,681
¿Qué posibilidad eligirías?

99
00:07:53,681 --> 00:07:58,530
Por supuesto, la que te de el número
mínimo de cambio para 5 monedas.

100
00:08:00,390 --> 00:08:06,285
Y continuarías y aplicarías el código a 
6 centavos con sus tres posibilidades y

101
00:08:06,285 --> 00:08:12,020
de nuevo seleccionamos la elección óptima
que corresponde al número mínimo de monedas.

102
00:08:12,020 --> 00:08:16,490
Digamos puede ser 0 monedas más 6 centavos.

103
00:08:16,490 --> 00:08:21,550
Continuamos para 7 centavos,
continuamos para 8 centavos y finalmente

104
00:08:21,550 --> 00:08:26,815
muy rápidamente, realmente encontramos
la respuesta correcta para 9 centavos.

105
00:08:26,815 --> 00:08:31,340
Necesitamos cuatro monedas para cambiar 9 centavos.

106
00:08:31,340 --> 00:08:36,950
Y ello resulta en el algoritmo
DPChange que simplemente rellena

107
00:08:36,950 --> 00:08:42,330
la tabla que les mostré
de izquierda a la derecha.

108
00:08:43,470 --> 00:08:49,200
DPChange es el primer algoritmo de programación
dinámica que has visto en este curso,

109
00:08:49,200 --> 00:08:51,010
y habrá miles más.

110
00:08:52,080 --> 00:08:55,970
Puede que te preguntes por qué este algoritmo
se denomina programación dinámica

111
00:08:55,970 --> 00:08:58,680
y qué tiene que ver con la programación.

112
00:08:58,680 --> 00:09:00,760
De hecho, programación en

113
00:09:00,760 --> 00:09:03,220
programación dinámica no tiene nada
que ver con programación.

114
00:09:04,250 --> 00:09:07,730
Sorprendentemente, la programación
dinámica es uno de 

115
00:09:07,730 --> 00:09:12,580
los algoritmos más prácticos que
los científicos informáticos usan.

116
00:09:12,580 --> 00:09:16,406
Pero cuando Richard Bellman estaba
desarrollando esta idea para

117
00:09:16,406 --> 00:09:21,690
para un proyecto de las Fuerzas Aéreas en el que
trabajaba, se veía completamente impráctico.

118
00:09:22,710 --> 00:09:26,870
Y quiso ocultar que realmente estaba
haciendo matemáticas para la Secretaría

119
00:09:26,870 --> 00:09:31,380
de Defensa, en vez de trabajar
en el proyecto de las Fuerzas Aéreas.

120
00:09:31,380 --> 00:09:34,110
Por tanto, inventó un nombre

121
00:09:34,110 --> 00:09:39,910
que básicamente no tiene que ver con la palabra
programación dinámica y lo que el algoritmo hace.

122
00:09:39,910 --> 00:09:43,950
En sus propias palabras, dijo: "¿qué nombre puedo escoger?"

123
00:09:43,950 --> 00:09:49,190
Estoy interesado en planificación, pero planificación
no es una buena palabra por varias razones.

124
00:09:49,190 --> 00:09:52,050
Decidí pues usar la palabra programación y

125
00:09:52,050 --> 00:09:56,870
quería transmitir la idea
de que esto era dinámico.

126
00:09:56,870 --> 00:10:00,400
Era algo que ningún congresista
podría objetar.