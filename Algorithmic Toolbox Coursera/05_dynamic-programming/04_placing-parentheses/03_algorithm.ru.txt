В этом видео мы рассмотрим псевдокод
алгоритма "быстрой сортировки". Как вы можете помнить, алгоритм является рекурсивным. Поэтому, мы передаем в процедуру "быстрой сортировки" массив "А", и, также, два индекса: l (левый указатель) и r (правый указатель). и, таким образом, процедура сортирует подмассив массива А с индексами от l до r. Таким образом, сначала мы проверяем, что l не превышает r. И если это так, то это значит, что соответствующий
подмассив содержит не более одного элемента. и это значит, что ничего не нужно делать,
и мы просто делаем возврат из процедуры. В противном случае, мы вызываем процедуру разделения с такими же параметрами. Она возвращает индекс m, который находится между l и r. Таким образом, процедура перестраивает все элементы внутри этого подмассива следующим образом: После вызова этой процедуры, A[m] находится в своей конечной позиции. Это значит, что все элементы слева не превышают A[m], и все элементы справа строго больше A[m]. Еще раз, после вызова процедуры разделения A[m] находится в конечной позиции. Таким образом, остается только отсортировать все элементы,
которые не превышают A[m], они находятся левее A[m]. И все элементы,
что стоят справа от A[m]. Мы просто делаем это с помощью двух рекурсивного вызовов. Вот как визуально выглядит алгоритм "быстрой сортировки". Еще раз, нам дан массив А с двумя индексами l и r. и мы собираемся отсортировать подмассив
массива A с индексами от l до r. Сначала мы вызываем процедуру разделения
с параметрами A, l и r. Которая возвращает индекс m, находящийся между
индексами l и r и обладающий следующим свойством: Все элементы левее A[m] не превышают A[m], Все элементы справа строго больше A[m]. Далее мы делаем два рекурсивным вызова для сортировки
левой части с индексами от l до m - 1, и правой части с индексами от m + 1, до r. И сразу же после рекурсивных вызовов мы имеем отсортированный массив. Перед тем как увидеть псевдокод процедуры разделения, рассмотрим её основную идею на простом примере. Во первых, возьмем элемент A[l] и обозначим его за x. Это будет наш опорный элемент (pivot). Опорный элемент - это элемент по отношению к которому мы будем разделять наш подмассив. Таким образом, элемент x будет размещен в своей конечной позиции. Таким образом, наша цель расставить элементы подмасства таким образом, что элемент х будет находится в своей финальной позиции,
и все элементы левее "х" не превышают "x", и элементы справа от "х" строго больше "х". Мы будем делать это постепенно расширяя диапазон
уже рассмотренных элементов. Для этого будем использовать счетчик i, и будем 
поддерживать следующий инвариант (неизменное условие): i будет увеличиваться от l + 1 до r, и в каждый момент времени, когда мы уже
просмотрели i-ый элемент, мы будем поддерживать от l + 1 до i два диапазона. в первом, от l + 1 до k, мы будем хранить элементы
не превышающие "x". Во втором диапазоне, с индексами от j + 1 до i будем хранить элементы строго большие, чем "x". Рассмотрим простой пример. Представим, что мы где то в середине этого процесса. В данном случае, x = 6 и и нам нужно разделить все элементы
по отношению к "x". Мы уже имеем два дипазона: в оранжевом мы храним все элементы, которые меньше или равны "x". В синем диапазоне находятся все элементы, которые строго больше, чем "x". Теперь передвинем i в следующую позицию
 и рассмотрим элемент "9". 9 > 6, таким образом мы должны просто расширить второй (синий) диапазон, диапазон элементов, который строго больше 6. В этом случае мы ничего не делаем. Следующий случай интереснее. Мы сдвигаем указатель i дальше и попадаем на элемент 4. В этом случае мы должны как то переместить 4-ку в оранжевый диапазон, диапазон элементов, который не превышают 6. Для этого мы просто меняем его местами с текущим первым элементов синего диапазона, в данном случае с 9. Если мы сделаем это, 4 будем последним элементов оранжевого диапазона, и 9 переместиться в синий диапазон. Делаем это, и также увеличиваем значение j для того чтобы показать, что оранжевый регион был расширен. Затем сдвигаем i на следующий элемент, на 7-ку, которая больше 6, что означает, что мы просто расширяем синий диапазон. Затем мы переходим к элементу 6, 6 не превышает 6 (6=6), таким образом мы должны передвинуть шестерку в оранжевый диапазон. Опять мы меняем местами с первым элементом синего диапазона, и затем расширяем оранжевый диапазон. Увеличиваем j, чтобы показать, что оранжевый регион был расширен. Затем рассматриваем следующий элемент,
который не превосходит 6. Переносим его в конец оранжевого диапазона. И в конечном итоге, мы должны перенести опорный элемент, который равен 6 в данном случае, в его конечную позицию. Его конечное положение может быть легко найдено в данном случае. У нас есть оранжевый и синий диапазоны. В оранжевом все элементы не превышают 6,
в синем диапазоне все элементы строго больше 6. Таким образом, мы просто меняем местами 6-ку с последним
элементом оранжевого диапазона. В данном примере это 1. Если мы поменяем 
местами эти два элемента, вы можете видеть, что, действительно, все элементы синего диапазона больше 6. Все элементы оранжевого диапазона меньше 6. То есть, мы выполнили процедуру разделения. Теперь мы готовы увидеть псевдокод процедуры разделения. Вспомни, что мы собираемся разместить какой то элемент "х", который называется опорным, в его конечную 
позицию таким образом, что все элементы до "х" не превышают "х", и все элементы после "х", строго больше "х". В этой процедуре, мы собираемся использовать опорным элементом 
просто первый элемент соответствующего подмассива. То есть, x = A[l]. Также, мы будем поддерживать следующие два подрегиона Во первых, мы будем постепенно увеличивать диапазон просмотренных элементов То есть, i увеличивается от l + 1 до r, и внутри этого региона уже просмотренных элементов, мы будем поддерживать два диапазона. В первом регионе, с индексами от l + 1 до j будем хранить элементы не превышающие "x". Во втором регионе, с индексами от j + 1 до i, мы будем хранить все элементы, которые больше "х". И мы будем постепенно увеличивать i. Когда i было увеличенно. Мы рассматриваем новый элемент A[i]. Если A[i] > x, значит второй диапазон элементов, которые больше "х", расширяется автоматически, и нам ничего не нужно делать в этом случае. Однако, если рассматриваемый элемент не превышает "x" мы должны разместить его в первом (левом) диапазоне. Мы делаем это следующим образом: Мы увеличиваем значение j, указывая на тот факт что первый диапазон был увеличен, и затем обмениваем местами элементы A[j] и A[i] Таким образом, мы поддерживаем наш инвариант каждый раз, когда увеличиваем i. В самом конце, когда i достигает r. мы также должны разместить наш начальный элемент между двумя диапазонами. Для этого мы просто меняем местами A[l] (опорный элемент) с A[j]. И затем возвращаем значение j, как индекс нашего опорного элемента.