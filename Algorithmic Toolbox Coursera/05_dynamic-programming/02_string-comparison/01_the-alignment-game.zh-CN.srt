1
00:00:05,247 --> 00:00:10,950
囊肿性纤维化是人类最常见的遗传性疾病的一种。

2
00:00:10,950 --> 00:00:17,050
大约每25人中一人携带囊肿性纤维化基因。

3
00:00:17,050 --> 00:00:22,100
当父母双方都携带有缺陷基因，有25％的几率

4
00:00:23,340 --> 00:00:26,560
他们的孩子将有囊肿性纤维化。

5
00:00:27,680 --> 00:00:34,630
在80年代早期，生物学家开始寻找囊肿性纤维化基因，

6
00:00:34,630 --> 00:00:41,490
这是人类基因组计划最早的基因猎获项目之一

7
00:00:41,490 --> 00:00:46,230
30年前，生物学家收窄了搜索范围

8
00:00:46,230 --> 00:00:52,490
囊肿性纤维化基因在7号染色体上某段区域，
有多达一百万个左右核苷酸。

9
00:00:52,490 --> 00:00:56,820
此区域还含有许多其他基因，
并且不清楚是哪些和囊性纤维化有关。

10
00:00:56,820 --> 00:01:01,800
此区域还含有许多其他基因，
并且不清楚是哪些和囊性纤维化有关。

11
00:01:01,800 --> 00:01:07,620
你会如何找到与囊肿性纤维化相关的基因？

12
00:01:08,620 --> 00:01:09,290
给你一个提示

13
00:01:10,370 --> 00:01:13,650
囊性纤维化会导致分泌的汗液里有异常高的钠含量。

14
00:01:13,650 --> 00:01:16,900
囊性纤维化会导致分泌的汗液里有异常高的钠含量。

15
00:01:18,060 --> 00:01:21,940
听上去，这个提示对解决我们当前的问题没什么用

16
00:01:21,940 --> 00:01:26,710
听上去，这个提示对解决我们当前的问题没什么用

17
00:01:26,710 --> 00:01:32,500
听上去，这个提示对解决我们当前的问题没什么用

18
00:01:32,500 --> 00:01:34,820
再给你第二个提示

19
00:01:34,820 --> 00:01:39,590
囊肿性纤维化基因猎获开始的时候

20
00:01:39,590 --> 00:01:44,900
生物学家已经知道哪些些基因的序列负责分泌

21
00:01:44,900 --> 00:01:48,050
比如，负责指导合成ATP结合蛋白的基因

22
00:01:48,050 --> 00:01:52,129
ATP结合蛋白是分泌物的传输通道

23
00:01:53,370 --> 00:01:58,240
你可能还是不知道这些线索有什么用

24
00:01:58,240 --> 00:02:03,230
你可能还是不知道这些线索有什么用

25
00:02:03,230 --> 00:02:07,450
你可能还是不知道这些线索有什么用

26
00:02:07,450 --> 00:02:08,800
那再给第三个提示

27
00:02:09,900 --> 00:02:15,150
我们可以在7号染色体的这片区域寻找和分泌相关基因类似的序列

28
00:02:15,150 --> 00:02:17,983
我们可以在7号染色体的这片区域寻找和分泌相关基因类似的序列

29
00:02:17,983 --> 00:02:23,910
生物学家利用这个思路，

30
00:02:23,910 --> 00:02:29,820
真的找到了类似ATP结合蛋白基因的一段序列

31
00:02:29,820 --> 00:02:36,830
真的找到了类似ATP结合蛋白基因的一段序列

32
00:02:36,830 --> 00:02:41,820
要了解生物学家如何解决这个问题的，

33
00:02:41,820 --> 00:02:46,900
我们先来了解对准游戏(Alignment Game)的概念

34
00:02:47,910 --> 00:02:51,310
这是一个单人游戏

35
00:02:51,310 --> 00:02:56,430
给玩家两个字符串，目标是去掉一些字符

36
00:02:56,430 --> 00:03:02,090
尽量得到最高分

37
00:03:02,090 --> 00:03:06,810
我现在解释一下得分规则

38
00:03:06,810 --> 00:03:11,710
以从头到尾的顺序，我们可以从两个字符串的相同位置去掉字符

39
00:03:11,710 --> 00:03:16,250
如果去掉的字符相同，得一分

40
00:03:16,250 --> 00:03:20,030
如果不同则不得分

41
00:03:20,030 --> 00:03:25,440
或者，你可以从其中一个字符串，删除一个符号

42
00:03:25,440 --> 00:03:28,390
这种情况下，不得分。

43
00:03:28,390 --> 00:03:30,240
我们玩一下这个游戏

44
00:03:30,240 --> 00:03:33,970
一开始，从两个字符串删除第一个符号，

45
00:03:33,970 --> 00:03:35,999
我们得一分。

46
00:03:35,999 --> 00:03:41,770
然后去掉另一对相同的符号，再加1。

47
00:03:41,770 --> 00:03:43,220
现在符号不同，所以

48
00:03:43,220 --> 00:03:48,430
去掉这两个没有意义，因为这么做我们只得零分。

49
00:03:48,430 --> 00:03:54,300
也许我们可以只从第二个字符串中删除C

50
00:03:54,300 --> 00:03:59,540
然后我们可以去掉两个个G 得一分

51
00:03:59,540 --> 00:04:04,332
然后继续，继续，继续

52
00:04:04,332 --> 00:04:08,860
直到字符串尾，我们得四分

53
00:04:08,860 --> 00:04:14,120
换一种玩法，我们有没有可能得五分？

54
00:04:15,400 --> 00:04:18,570
我们刚刚完成了两个字符串的对准

55
00:04:18,570 --> 00:04:22,660
我们刚刚完成了两个字符串的对准

56
00:04:22,660 --> 00:04:26,960
这可以看作两行矩阵，

57
00:04:26,960 --> 00:04:33,360
第一行就是一个字符串

58
00:04:33,360 --> 00:04:37,530
可能中间有空格

59
00:04:37,530 --> 00:04:42,630
第二行同理，是第二个字符串

60
00:04:42,630 --> 00:04:46,038
可能中间有空格

61
00:04:46,038 --> 00:04:50,840
完成对准后，矩阵的列代表匹配，或不匹配，或插入

62
00:04:50,840 --> 00:04:56,180
完成对准后，矩阵的列代表匹配，或不匹配，或插入

63
00:04:56,180 --> 00:04:59,860
完成对准后，矩阵的列代表匹配，或不匹配，或插入

64
00:04:59,860 --> 00:05:04,200
插入表示，我们从第二个字符串选中一个字符

65
00:05:04,200 --> 00:05:06,630
在第一行中用空格对应，

66
00:05:06,630 --> 00:05:12,100
删除标示，我们去掉了第一行字符串里的字符

67
00:05:12,100 --> 00:05:17,510
我们还可以为每一对相匹配的字符设置奖励分值

68
00:05:17,510 --> 00:05:23,510
不匹配，删除和插入设置惩罚

69
00:05:23,510 --> 00:05:28,590
删除和惩罚情况我们用indel来表示

70
00:05:28,590 --> 00:05:34,125
不匹配的话减μ，

71
00:05:34,125 --> 00:05:40,137
indel(删除和插入)的话减σ

72
00:05:40,137 --> 00:05:44,375
例如，现在，如果μ等于零

73
00:05:44,375 --> 00:05:51,440
σ等于1，那么得分为1

74
00:05:51,440 --> 00:05:56,450
所以我们把得分定义为匹配数减μ乘不匹配数再减σ乘indel次数

75
00:05:56,450 --> 00:06:00,780
所以我们把得分定义为匹配数减μ乘不匹配数再减σ乘indel次数

76
00:06:00,780 --> 00:06:06,810
最优对准问题的输入是两串字符不匹配一次减μ分，indel减σ分；

77
00:06:06,810 --> 00:06:13,530
合理运用这些操作，使得分最大

78
00:06:13,530 --> 00:06:18,720
我们对其中一个得分项得分特别感兴趣

79
00:06:18,720 --> 00:06:21,550
也就是由共有字符串所得的match得分

80
00:06:21,550 --> 00:06:25,520
也就是由共有字符串所得的match得分

81
00:06:25,520 --> 00:06:30,500
这里的共有字符串就是‘ATGT’

82
00:06:30,500 --> 00:06:35,470
接下来我们还会看到最长共有字符串的问题

83
00:06:35,470 --> 00:06:37,510
接下来我们还会看到最长共有字符串的问题

84
00:06:37,510 --> 00:06:40,390
输入是两个字符串

85
00:06:40,390 --> 00:06:42,990
从中找到最长共有字符串

86
00:06:44,050 --> 00:06:49,230
当然，你已经认识到找到最长共有字符串，

87
00:06:49,230 --> 00:06:54,830
最理想是让μ和σ都等于0

88
00:06:54,830 --> 00:06:59,550
最理想是让μ和σ都等于0

89
00:07:00,960 --> 00:07:05,790
另一个相关经典的问题是编辑距离(edit distance)问题

90
00:07:05,790 --> 00:07:11,270
给定两个字符串，进行最少的操作

91
00:07:11,270 --> 00:07:15,500
插入，删除，或是替换符号

92
00:07:15,500 --> 00:07:19,520
将一个字符串转变成第二个

93
00:07:19,520 --> 00:07:22,480
当然，对准游戏中，最小数目的插入，删除，

94
00:07:22,480 --> 00:07:28,530
和不匹配操作数就代表编辑距离(Edit Distance)

95
00:07:28,530 --> 00:07:34,320
例如，如果您要找到两个字符串之间的编辑距离，

96
00:07:34,320 --> 00:07:39,040
可以通过对准游戏设置期望得分来获得

97
00:07:39,040 --> 00:07:43,650
可以通过对准游戏设置期望得分来获得

98
00:07:43,650 --> 00:07:47,320
这里展示了匹配，不匹配，插入，删除的情况

99
00:07:47,320 --> 00:07:51,660
我们接下来会看到

100
00:07:51,660 --> 00:07:55,542
编辑距离问题和对准游戏有极大的相关性

101
00:07:55,542 --> 00:07:58,830
让我们计算两个字符串内的符号数总和。

102
00:08:00,120 --> 00:08:04,240
然而这个值等于匹配数，不匹配数，插入数，删除数的总和乘2

103
00:08:04,240 --> 00:08:08,040
然而这个值等于匹配数，不匹配数，插入数，删除数的总和乘2

104
00:08:08,040 --> 00:08:11,410
然而这个值等于匹配数，不匹配数，插入数，删除数的总和乘2

105
00:08:11,410 --> 00:08:16,454
我们把这个表达式扩展一下

106
00:08:16,454 --> 00:08:21,336
我们可以看到前三项涉及对准游戏得分

107
00:08:21,336 --> 00:08:25,490
后三项涉及编辑距离

108
00:08:26,670 --> 00:08:33,003
所以我们可以把编辑距离问题看作对准游戏问题的一个特殊版本

109
00:08:33,003 --> 00:08:37,327
所以我们可以把编辑距离问题看作对准游戏问题的一个特殊版本

110
00:08:37,327 --> 00:08:38,850
所以我们可以把编辑距离问题看作对准游戏问题的一个特殊版本