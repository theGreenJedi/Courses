1
00:00:00,390 --> 00:00:04,680
En este vídeo, consideraremos un
problema de código más interesante.

2
00:00:04,680 --> 00:00:10,540
Este problema nos obligará a implementar
una solución más rápida que la solución simple.

3
00:00:10,540 --> 00:00:15,530
Primero la depuraremos con pruebas de
estrés antes de alcanzar una

4
00:00:15,530 --> 00:00:21,390
una solución correcta que sea capaz de pasar todas
las pruebas en el sistema de pruebas.

5
00:00:21,390 --> 00:00:25,870
El problema se denomina el problema del
producto máximo priorizado.

6
00:00:25,870 --> 00:00:30,815
En este problema, nos darán un vector
o una secuencia de n números

7
00:00:30,815 --> 00:00:35,300
y nuestro objetivo es encontrar
un número que pueda ser obtenido

8
00:00:35,300 --> 00:00:39,650
multiplicando dos números
de esta secuencia.

9
00:00:40,730 --> 00:00:46,020
Recuerda que en nuestro problema nos dan
una secuencia de enteros no negativos

10
00:00:46,020 --> 00:00:48,920
encontrar el máximo producto entre pares.

11
00:00:48,920 --> 00:00:52,960
La entrada para este problema
consiste en dos líneas.

12
00:00:52,960 --> 00:00:56,521
La primera línea contiene
un único número n

13
00:00:56,521 --> 00:01:01,163
que es al menos 2 y como mucho
2 multiplicado por 10 a la 5.

14
00:01:01,163 --> 00:01:05,154
La línea siguiente contiene la
secuencia de números que son

15
00:01:05,154 --> 00:01:08,909
enteros no negativos
que no superan 10 a la 5.

16
00:01:08,909 --> 00:01:15,090
Nuestro objetivo es mostrar un único número,
el máximo producto entre pares.

17
00:01:15,090 --> 00:01:18,447
La página contiene también dos pruebas de ejemplo.

18
00:01:18,447 --> 00:01:24,262
Por ejemplo, si una entrada al programa
es la secuencia de 3 enteros consistente

19
00:01:24,262 --> 00:01:29,241
en los números 1, 2, 3,
entonces la salida debería ser, por supuesto, 6,

20
00:01:29,241 --> 00:01:32,500
porque es 2 multiplicado por 3.

21
00:01:32,500 --> 00:01:37,867
Para una secuencia ligeramente más larga de tamaño 10,

22
00:01:37,867 --> 00:01:41,399
la salida debería ser 140, 

23
00:01:41,399 --> 00:01:45,789
y esto es 10 multiplicado por 14.

24
00:01:45,789 --> 00:01:50,094
Como es habitual también hay una sección que

25
00:01:50,094 --> 00:01:54,940
contiene los ficheros de inicio. Y comenzamos 

26
00:01:54,940 --> 00:02:01,818
eligiendo C++ como nuestro lenguaje
de programación para este problema.

27
00:02:01,818 --> 00:02:06,490
Así es como se ve el fichero
de inicio de la solución en C++.

28
00:02:06,490 --> 00:02:11,540
Empezamos leyendo el número
n desde la entrada estándar.

29
00:02:11,540 --> 00:02:15,540
Después creamos una lista
o un vector de tamaño n.

30
00:02:15,540 --> 00:02:21,200
entonces llenamos este vector con los elementos de
nuestra secuencia, elemento por elemento,

31
00:02:21,200 --> 00:02:23,950
después leemos desde la entrada estándar.

32
00:02:23,950 --> 00:02:27,485
Entonces pasamos la secuencia 
de números a la función

33
00:02:27,485 --> 00:02:31,850
MaxPairwiseProduct que calcula
la respuesta a nuestro problema.

34
00:02:32,900 --> 00:02:36,953
Veamos que pasa dentro
de la función MaxPairwiseProduct.

35
00:02:36,953 --> 00:02:42,936
Empezamos inizializando
la variable result a 0 y

36
00:02:42,936 --> 00:02:50,300
examinamos todos los posibles
pares de diferentes elementos.

37
00:02:50,300 --> 00:02:55,460
esto es, pasamos por todos los posibles i y
j, donde i es menor que j.

38
00:02:55,460 --> 00:02:58,040
Lo hacemos mediante dos bucles anidados.

39
00:02:58,040 --> 00:03:02,580
Y para cada uno de estos pares, comprobamos si
el producto de los dos correspondientes

40
00:03:02,580 --> 00:03:05,140
números es mayor que
nuestro resultado actual.

41
00:03:05,140 --> 00:03:08,110
Si es así, actualizamos el resultado.

42
00:03:08,110 --> 00:03:10,469
Finalmente, devolvemos el resultado.

43
00:03:11,810 --> 00:03:16,100
Este algoritmo es correcto
por una razón obvia.

44
00:03:16,100 --> 00:03:21,380
El objetivo de nuestro problema es encontrar 
el máximo producto entre pares. ¿Correcto?

45
00:03:21,380 --> 00:03:25,090
Para hacer esto examinamos
todos los posibles pares y

46
00:03:25,090 --> 00:03:26,339
seleccionamos el máximo producto.

47
00:03:27,900 --> 00:03:33,166
De acuerdo. Para comprobar que es correcto,
vamos a compilarlo, como es habitual.

48
00:03:36,801 --> 00:03:39,878
Para ello usamos

49
00:03:42,503 --> 00:03:46,037
el flujo de compilador para C++.

50
00:03:58,560 --> 00:04:00,092
De acuerdo, y ahora lo probamos.

51
00:04:05,530 --> 00:04:10,381
Por ejemplo, para la secuencia de longitud 3,

52
00:04:10,381 --> 00:04:16,250
consistente en los números del 1 al 3,
entonces dice 6.

53
00:04:16,250 --> 00:04:18,743
Vamos a probarlo una vez más.

54
00:04:18,743 --> 00:04:22,160
Por ejemplo, esta secuencia de longitud 5,

55
00:04:22,160 --> 00:04:25,723
consistente en los números 3, 4, 5, 1, 2.

56
00:04:25,723 --> 00:04:32,900
La respuesta es 20 como se esperaba,
porque es el produco de 4 y 5.

57
00:04:32,900 --> 00:04:37,510
De acuerdo, parece que es esta es una
solución correcta y seguimos y

58
00:04:37,510 --> 00:04:41,320
la entregamos como una solución
al sistema de prueba.

59
00:04:41,320 --> 00:04:45,380
Hemos enviado nuestra solución
actual al sistema de calificación,

60
00:04:45,380 --> 00:04:48,370
pero desafortunadamente
no puede pasar todas las pruebas.

61
00:04:48,370 --> 00:04:52,960
En particular, hay un mensaje de error 
mostrado en el sistema de calificación.

62
00:04:52,960 --> 00:04:53,570
Echemos un vistazo. 

63
00:04:54,710 --> 00:04:59,190
Dice que nuestra solución ha fallado

64
00:04:59,190 --> 00:05:03,230
la prueba número tres,
que consiste sólo en dos números.

65
00:05:03,230 --> 00:05:07,158
El primero es 10 a la 5 y

66
00:05:07,158 --> 00:05:10,970
el segundo es 90.000

67
00:05:10,970 --> 00:05:15,798
Comprobemos si podemos reproducir
este comportamiento en nuestra máquina local.

68
00:05:15,798 --> 00:05:20,777
Llamamos a nuestro programa

69
00:05:20,777 --> 00:05:25,303
con sólo dos números,

70
00:05:25,303 --> 00:05:31,686
10 a la 5 y 90.000.

71
00:05:31,686 --> 00:05:36,350
Así que de hecho, como resultado,
en vez de obtener nueve mil

72
00:05:36,350 --> 00:05:41,130
millones como se esperaba,
obtenemos algún número aleatorio.

73
00:05:41,130 --> 00:05:44,830
Esto ocurre habitualmente cuando
hay un desbordamiento de enteros.

74
00:05:44,830 --> 00:05:48,970
Y, en efecto, hemos usado
el tipo estándar entero para

75
00:05:48,970 --> 00:05:53,420
almacenar el resultado de
multiplicar dos números,

76
00:05:53,420 --> 00:05:55,700
pero nueve mil millones es demasiado grande

77
00:05:55,700 --> 00:06:00,000
para el tipo entero, por lo que no
encaja en el tipo entero.

78
00:06:00,000 --> 00:06:05,950
Lo que se supone que debemos hacer es
usar un tipo long long C++.

79
00:06:05,950 --> 00:06:11,271
Hacemos esto y comprobamos si esto

80
00:06:11,271 --> 00:06:16,440
resuelve nuestro problema, nuestra solución.

81
00:06:19,190 --> 00:06:23,609
Para ello necesitamos 
cambiar todos los lugares

82
00:06:23,609 --> 00:06:27,913
donde calculamos y almacenamos los resultados.

83
00:06:27,913 --> 00:06:32,437
Primero que nada cambiamos
la declaración de esta variable.

84
00:06:32,437 --> 00:06:38,020
También cambiamos el tipo
de la variable de retorno del resultado.

85
00:06:38,020 --> 00:06:44,520
Cuando calculamos el producto de
estos dos números, primero asignamos,

86
00:06:46,200 --> 00:06:51,281
por ejemplo, el primero 

87
00:06:51,281 --> 00:06:57,384
a un tipo long long.

88
00:07:00,117 --> 00:07:04,444
De acuerdo, también y 

89
00:07:04,444 --> 00:07:09,360
también aquí, ¡genial!

90
00:07:09,360 --> 00:07:10,780
Lo compilamos de nuevo.

91
00:07:13,550 --> 00:07:22,220
Y volvemos a ejecutarlo para comprobar si
procesa correctamente nuestro conjunto de datos previo.

92
00:07:26,300 --> 00:07:30,750
10 a la 5 y 90.000.

93
00:07:30,750 --> 00:07:35,080
¡Genial! Muestra correctamente
nueve mil millones.

94
00:07:35,080 --> 00:07:38,690
Ahora debemos estar completamente
seguros de que nuestra solución es correcta,

95
00:07:38,690 --> 00:07:43,090
Porque para buscar el
máximo producto entre pares

96
00:07:43,090 --> 00:07:47,540
simplemente examinamos todos los pares
posibles y seleccionamos el máximo producto.

97
00:07:47,540 --> 00:07:50,670
¿Qué más podemos hacer?

98
00:07:50,670 --> 00:07:56,110
También ahora usamos el tipo correcto 
para almacenar el resultado.

99
00:07:56,110 --> 00:08:02,860
Sigamos adelante y enviemos nuestra
nueva solución al sistema de calificación.

100
00:08:02,860 --> 00:08:07,630
Desafortunadamente nuestra 
solución es aún incorrecta.

101
00:08:07,630 --> 00:08:12,430
En este caso particular, la salida del
sistema de calificación es la siguiente.

102
00:08:12,430 --> 00:08:15,040
"Caso 4 fallado, excedido el tiempo límite".

103
00:08:15,040 --> 00:08:18,730
Esto significa que nuestra solución
es demasiado lenta, que para 

104
00:08:18,730 --> 00:08:24,050
grandes conjuntos de datos se
ejecuta en más de un segundo.

105
00:08:25,820 --> 00:08:28,740
Vamos a intentar entender
por qué ocurre esto.

106
00:08:28,740 --> 00:08:34,051
Lo primero, el tamaño máximo de un conjunto de
datos es el tamaño máximo de una secuencia para

107
00:08:34,051 --> 00:08:37,768
este problema, en nuestro caso, es
aproximadamente 10 a la 5.

108
00:08:37,768 --> 00:08:42,296
¿Cuál es el número de operaciones realizadas
por nuestra solución simple en

109
00:08:42,296 --> 00:08:43,900
secuencia?

110
00:08:43,900 --> 00:08:48,940
Recuerda que nuestra solución simple
examina todos los pares posibles

111
00:08:48,940 --> 00:08:50,150
de los números de entrada.

112
00:08:50,150 --> 00:08:51,720
Esto es aproximadamente n cuadrado.

113
00:08:51,720 --> 00:08:55,150
Así cuando n es igual a 10 a la 5,
esto es 10 a la 10.

114
00:08:55,150 --> 00:08:59,160
lo que es más de mil millones.

115
00:08:59,160 --> 00:09:03,760
Y mil millones es aproximadamente el número de
operaciones básicas que un ordenador moderno puede

116
00:09:03,760 --> 00:09:06,320
realizar en un segundo.

117
00:09:06,320 --> 00:09:12,480
Podemos concluir que necesitamos un 
algoritmos más rápido para resolver este problema.

118
00:09:12,480 --> 00:09:18,110
En particular, nos damos cuenta de que necesitamos
encontrar el máximo producto entre pares

119
00:09:18,110 --> 00:09:22,830
sin necesidad de examinar todos los
pares posibles de números.

120
00:09:22,830 --> 00:09:30,440
Buscando una inspiración, echemos un 
vistazo a la página del problema.

121
00:09:30,440 --> 00:09:36,940
En particular, revisemos el
segundo ejemplo.

122
00:09:36,940 --> 00:09:41,204
En este caso, nuestra entrada
consiste en diez enteros

123
00:09:41,204 --> 00:09:44,787
y la salida, en este caso, es 140.

124
00:09:44,787 --> 00:09:46,500
¿Por qué es ésta? Bueno,

125
00:09:46,500 --> 00:09:51,920
porque en nuestra secuencia
están los números 14 y 10.

126
00:09:51,920 --> 00:09:55,870
Y estos dos números son los
dos máximos números.

127
00:09:55,870 --> 00:10:01,148
Por lo que para cualquier otros dos números,
su producto es menor que 140.

128
00:10:01,148 --> 00:10:06,455
Esto nos proporciona la idea de que para 
encontrar el máximo producto de dos números en

129
00:10:06,455 --> 00:10:13,130
nuestra secuencia basta con encontrar los dos
máximos números de nuestra secuencia.

130
00:10:13,130 --> 00:10:18,790
Esto es porque todos los enteros
de esta secuencia son no negativos.

131
00:10:18,790 --> 00:10:26,220
Vamos a implementar esta idea
en nuestro fichero C++.

132
00:10:26,220 --> 00:10:29,690
Aquí está ya implementada
y se ve de la siguiente manera.

133
00:10:29,690 --> 00:10:34,240
La nueva función se llama
MaxPairwiseProductFast.

134
00:10:34,240 --> 00:10:37,027
Ya utiliza el tipo long long para

135
00:10:37,027 --> 00:10:40,400
almacenar el resultado y
hacemos lo siguiente.

136
00:10:40,400 --> 00:10:45,340
Escaneando el vector de entrada dos veces,
encontramos los dos números máximos.

137
00:10:45,340 --> 00:10:51,140
En el primer bloque,
encontramos el primer máximo y

138
00:10:51,140 --> 00:10:55,760
almacenamos su índice en la variable max_index y

139
00:10:55,760 --> 00:11:02,580
en el segundo bloque,
hallamos el segundo mayor elemento.

140
00:11:02,580 --> 00:11:07,930
La diferencia en el segundo bloque es
que también necesitamos evitar

141
00:11:07,930 --> 00:11:10,040
el primer mayor elemento.

142
00:11:11,810 --> 00:11:12,840
¿Qué más puedes hacer?

143
00:11:12,840 --> 00:11:16,545
Lo que hacemos es,
lo que hacemos es comprobar esto.

144
00:11:17,710 --> 00:11:23,085
De acuerdo, y después devolvemos el producto

145
00:11:23,085 --> 00:11:28,956
de los dos máximos números en nuestro vector. ¿Correcto?

146
00:11:28,956 --> 00:11:34,574
Como es habitual, compilemos y

147
00:11:34,574 --> 00:11:40,980
veamos si todo funciona correctamente.

148
00:11:40,980 --> 00:11:45,340
Este es nuestro nuevo archivo
max_pairwise_product_fast.cpp

149
00:11:45,340 --> 00:11:51,275
Lo compilamos y primero lo ejecutamos
en una secuencia pequeña.

150
00:11:51,275 --> 00:11:59,120
Por ejemplo, tamaño 3, por ejemplo,
2, 3, 4, nos da 12 como se esperaba.

151
00:11:59,120 --> 00:12:01,120
Bien, ahora hacemos lo siguiente.

152
00:12:01,120 --> 00:12:05,770
Comprobamos cuál es el tiempo
de ejecución con un conjunto de datos enorme.

153
00:12:06,980 --> 00:12:11,966
Para ello, en lugar de leer

154
00:12:11,966 --> 00:12:16,346
los datos desde la entrada estándar,

155
00:12:16,346 --> 00:12:21,493
vamos a generar un enorme vector aquí.

156
00:12:21,493 --> 00:12:28,487
Usamos un vector de enteros de tamaño 10 a la 5

157
00:12:28,487 --> 00:12:34,746
y vamos a llenar el vector con ceros.

158
00:12:34,746 --> 00:12:40,470
Compilamos y lo ejecutamos.

159
00:12:41,600 --> 00:12:45,130
Pone cero inmediatamente,
lo que significa que

160
00:12:45,130 --> 00:12:48,010
es mucho más rápido que
el algoritmo previo.

161
00:12:48,010 --> 00:12:52,590
Así que ahora nuestra solución
debe ser completamente correcta.

162
00:12:52,590 --> 00:12:57,312
Es rápida, usa el tipo correcto para 
almacenar la solución y 

163
00:12:57,312 --> 00:13:00,198
es también obviamente correcta porque

164
00:13:00,198 --> 00:13:05,283
selecciona los dos mayores números
y los multiplica.

165
00:13:05,283 --> 00:13:10,229
El producto de los dos números puede
ser el mayor porque hemos seleccionado los dos

166
00:13:10,229 --> 00:13:12,280
mayores números.

167
00:13:12,280 --> 00:13:16,210
Sin embargo, desafortunadamente,
aún nuestra solución no es correcta.

168
00:13:16,210 --> 00:13:21,310
Puedes entregarla al sistema
de prueba y ves que la salida

169
00:13:21,310 --> 00:13:26,430
será respuesta incorrecta para algún caso de prueba.

170
00:13:26,430 --> 00:13:31,670
En el vídeo siguiente, Michael les 
hablará sobre las pruebas de estrés y

171
00:13:31,670 --> 00:13:34,220
les mostrará cómo arreglar esta solución.