1
00:00:00,390 --> 00:00:04,680
在这段视频中，我们会考虑一个更有趣的代码问题。

2
00:00:04,680 --> 00:00:10,540
这个问题需要我们去实现比一个比朴素解决方案更快的方案，

3
00:00:10,540 --> 00:00:15,530
然后我们调试它，进行压力测试

4
00:00:15,530 --> 00:00:21,390
这样才能得到一个正确的解决方案，并能通过在线测试系统

5
00:00:21,390 --> 00:00:25,870
我们的示范问题叫最大乘积优先问题
(maximum priortised product problem)

6
00:00:25,870 --> 00:00:30,815
我们得到一个数组，或有n个数字的序列。

7
00:00:30,815 --> 00:00:35,300
我们的目标是得到一个数字

8
00:00:35,300 --> 00:00:39,650
由这个序列中两个最大的数字相乘得到

9
00:00:40,730 --> 00:00:46,020
示范问题中有一个给定的n个非负整数序列

10
00:00:46,020 --> 00:00:48,920
从中计算最大有限乘积( maximum pairwise product)

11
00:00:48,920 --> 00:00:52,960
问题的输入有两行

12
00:00:52,960 --> 00:00:56,521
第一行只是一个单一的数字n

13
00:00:56,521 --> 00:01:01,163
n至少大于2，且小于2乘10的5次方

14
00:01:01,163 --> 00:01:05,154
下一行包含n个数的序列

15
00:01:05,154 --> 00:01:08,909
都是非负整数且不超过10的5次方。

16
00:01:08,909 --> 00:01:15,090
我们的目标是要输出一个整数，也就是最大乘积。

17
00:01:15,090 --> 00:01:18,447
该页面还有两个检验示例

18
00:01:18,447 --> 00:01:24,262
例如，如果输入序列1，2，3；

19
00:01:24,262 --> 00:01:29,241
长度为3，则输出是6，

20
00:01:29,241 --> 00:01:32,500
因为2乘以3

21
00:01:32,500 --> 00:01:37,867
对于大小为10的稍长序列

22
00:01:37,867 --> 00:01:41,399
输出应该是140，

23
00:01:41,399 --> 00:01:45,789
这是10乘以14。

24
00:01:45,789 --> 00:01:50,094
这里的部分

25
00:01:50,094 --> 00:01:54,940
可以下载对应的编程语言文件开始做题

26
00:01:54,940 --> 00:02:01,818
这次我们选C++

27
00:02:01,818 --> 00:02:06,490
C++写出来的方案是这样的

28
00:02:06,490 --> 00:02:11,540
我们从读取数字n开始。

29
00:02:11,540 --> 00:02:15,540
然后，我们创建一个数组，或大小为n的向量。

30
00:02:15,540 --> 00:02:21,200
然后，我们用数组元素填充这个向量

31
00:02:21,200 --> 00:02:23,950
然后，我们再读取输入。

32
00:02:23,950 --> 00:02:27,485
然后我们向函数传送实数

33
00:02:27,485 --> 00:02:31,850
MaxPairwiseProduct(函数)得出我们的答案

34
00:02:32,900 --> 00:02:36,953
让我们来看看函数MaxPairwiseProduct里面发生了什么

35
00:02:36,953 --> 00:02:42,936
我们初始化变量result为0，

36
00:02:42,936 --> 00:02:50,300
那么我们遍历所有元素两两配对的组合

37
00:02:50,300 --> 00:02:55,460
也就是说，我们遍历所有可能的i和j的组合，其中i小于j

38
00:02:55,460 --> 00:02:58,040
我们用两个嵌套循环执行此操作

39
00:02:58,040 --> 00:03:02,580
对于每个租个，我们检查他们的乘积

40
00:03:02,580 --> 00:03:05,140
是否比变量result当前的值大

41
00:03:05,140 --> 00:03:08,110
如果是，我们更新结果

42
00:03:08,110 --> 00:03:10,469
最后，我们返回结果。

43
00:03:11,810 --> 00:03:16,100
这个算法自然是正确的。

44
00:03:16,100 --> 00:03:21,380
我们的目标是找到最大优先的，对不对？

45
00:03:21,380 --> 00:03:25,090
因此，我们遍历所有可能的组合，得到它们的乘积

46
00:03:25,090 --> 00:03:26,339
从中选择最大的

47
00:03:27,900 --> 00:03:33,166
好了，要检查它确实是正确的，我们像往常一样，编译它。

48
00:03:36,801 --> 00:03:39,878
我们使用

49
00:03:42,503 --> 00:03:46,037
C++编译器

50
00:03:58,560 --> 00:04:00,092
好了，然后，我们测试它。

51
00:04:05,530 --> 00:04:10,381
例如，对于长度为3的序列，

52
00:04:10,381 --> 00:04:16,250
包含1，2，3， 结果是6

53
00:04:16,250 --> 00:04:18,743
让我们再测试一次

54
00:04:18,743 --> 00:04:22,160
例如，长度为5的这种序列。

55
00:04:22,160 --> 00:04:25,723
由数字3，4，5，1，2组成

56
00:04:25,723 --> 00:04:32,900
因此，答案是20，因为4乘5

57
00:04:32,900 --> 00:04:37,510
好了，看来这个解决方案是正确的，我们继续前进，

58
00:04:37,510 --> 00:04:41,320
提交到测试系统。

59
00:04:41,320 --> 00:04:45,380
所以，我刚刚提交了程序到测试系统，

60
00:04:45,380 --> 00:04:48,370
但遗憾的是它没有通过所有的测试。

61
00:04:48,370 --> 00:04:52,960
测试系统中有错误消息。

62
00:04:52,960 --> 00:04:53,570
让我们一起来看看让我们一起来看看

63
00:04:54,710 --> 00:04:59,190
所以说，我们的算法失败

64
00:04:59,190 --> 00:05:03,230
第三个检测例，其中只包含两个数字。

65
00:05:03,230 --> 00:05:07,158
第一个10的5次方

66
00:05:07,158 --> 00:05:10,970
第二个是9万

67
00:05:10,970 --> 00:05:15,798
让我们来看看我们是否能够在自己的机器上重现第三例的情况

68
00:05:15,798 --> 00:05:20,777
打开程序

69
00:05:20,777 --> 00:05:25,303
输入两个数字

70
00:05:25,303 --> 00:05:31,686
10的5次方和9万

71
00:05:31,686 --> 00:05:36,350
其结果，不是9亿

72
00:05:36,350 --> 00:05:41,130
而是另一个数字

73
00:05:41,130 --> 00:05:44,830
这叫整数溢出

74
00:05:44,830 --> 00:05:48,970
我们使用的是标准的整数类型来储存结果

75
00:05:48,970 --> 00:05:53,420
我们使用的是标准的整数类型来储存结果

76
00:05:53,420 --> 00:05:55,700
90亿太大

77
00:05:55,700 --> 00:06:00,000
整数型范围放不下

78
00:06:00,000 --> 00:06:05,950
所以，我们应该用C++长整数类型。

79
00:06:05,950 --> 00:06:11,271
我们看看用长整数型能否解决

80
00:06:11,271 --> 00:06:16,440
我们看看用长整数型能否解决

81
00:06:19,190 --> 00:06:23,609
所以我们需要改变所有储存结果的变量

82
00:06:23,609 --> 00:06:27,913
所以我们需要改变所有储存结果的变量

83
00:06:27,913 --> 00:06:32,437
所以首先我们改变这个变量的声明，

84
00:06:32,437 --> 00:06:38,020
我们还改变返回观察返回结果的类型。

85
00:06:38,020 --> 00:06:44,520
计算乘积时，我们把第一个数配到长整型

86
00:06:46,200 --> 00:06:51,281
计算乘积时，我们把第一个数配到长整型

87
00:06:51,281 --> 00:06:57,384
计算乘积时，我们把第一个数配到长整型

88
00:07:00,117 --> 00:07:04,444
计算乘积时，我们把第一个数配到长整型

89
00:07:04,444 --> 00:07:09,360
计算乘积时，我们把第一个数配到长整型

90
00:07:09,360 --> 00:07:10,780
现在，再一次编译。

91
00:07:13,550 --> 00:07:22,220
是的，让我们来运行它来检查其是否正确处理我们以前的数据集。

92
00:07:26,300 --> 00:07:30,750
10的5次方和9万

93
00:07:30,750 --> 00:07:35,080
太好了，这次正确输出九十亿。

94
00:07:35,080 --> 00:07:38,690
我们必须确保我们的解决方案是正确的。

95
00:07:38,690 --> 00:07:43,090
我们刚刚遍历了所有元素两两配对的组合

96
00:07:43,090 --> 00:07:47,540
我们刚刚遍历了所有元素两两配对的组合

97
00:07:47,540 --> 00:07:50,670
我们还干了什么？

98
00:07:50,670 --> 00:07:56,110
我们现在用了正确的类型来

99
00:07:56,110 --> 00:08:02,860
现在再提交程序到测试系统，

100
00:08:02,860 --> 00:08:07,630
还是不对

101
00:08:07,630 --> 00:08:12,430
这次的判定结果是：

102
00:08:12,430 --> 00:08:15,040
时间超过限制。

103
00:08:15,040 --> 00:08:18,730
因此，这意味着我们的程序运行缓慢的，对于

104
00:08:18,730 --> 00:08:24,050
数组处理时间就超过一秒

105
00:08:25,820 --> 00:08:28,740
我们来看

106
00:08:28,740 --> 00:08:34,051
数组的大小限制在10的5次方以内

107
00:08:34,051 --> 00:08:37,768
数组的大小限制在10的5次方以内

108
00:08:37,768 --> 00:08:42,296
处理数组时，有多少命令被执行？

109
00:08:42,296 --> 00:08:43,900
处理数组时，有多少命令被执行？

110
00:08:43,900 --> 00:08:48,940
在这个算法里，我们遍历所有可能的组合，得到它们的乘积

111
00:08:48,940 --> 00:08:50,150
在这个算法里，我们遍历所有可能的组合，得到它们的乘积

112
00:08:50,150 --> 00:08:51,720
大致是n平方次运行

113
00:08:51,720 --> 00:08:55,150
所以，当n等于10的5次方，就要运行10的10次方。

114
00:08:55,150 --> 00:08:59,160
这是超过十亿。

115
00:08:59,160 --> 00:09:03,760
十亿次大致是一个现代计算机在一秒内运行的次数

116
00:09:03,760 --> 00:09:06,320
十亿次大致是一个现代计算机在一秒内运行的次数

117
00:09:06,320 --> 00:09:12,480
所以我们要用一个快一点的算法

118
00:09:12,480 --> 00:09:18,110
我们没必要遍历所有配对组合来的到最大乘积

119
00:09:18,110 --> 00:09:22,830
我们没必要遍历所有配对组合来的到最大乘积

120
00:09:22,830 --> 00:09:30,440
我们来看看问题描述

121
00:09:30,440 --> 00:09:36,940
重新来看第二个测试例

122
00:09:36,940 --> 00:09:41,204
输入包括十个数字

123
00:09:41,204 --> 00:09:44,787
输出是140

124
00:09:44,787 --> 00:09:46,500
为何如此？ 你看

125
00:09:46,500 --> 00:09:51,920
因为数列里最大的两个数字是14和10

126
00:09:51,920 --> 00:09:55,870
因为数列里最大的两个数字是14和10

127
00:09:55,870 --> 00:10:01,148
对于任何其他两个数字，其乘积是小于140。

128
00:10:01,148 --> 00:10:06,455
所以得到最大乘积，只要找到最大的两个数字

129
00:10:06,455 --> 00:10:13,130
所以得到最大乘积，只要找到最大的两个数字

130
00:10:13,130 --> 00:10:18,790
因为所有这个序列整数都是非负的。

131
00:10:18,790 --> 00:10:26,220
我们来重新写个程序

132
00:10:26,220 --> 00:10:29,690
我们来重新写个程序

133
00:10:29,690 --> 00:10:34,240
新的函数名为

134
00:10:34,240 --> 00:10:37,027
已经用了长整数型来存储结果

135
00:10:37,027 --> 00:10:40,400
已经用了长整数型来存储结果

136
00:10:40,400 --> 00:10:45,340
遍历数组两边，找到两个最大数

137
00:10:45,340 --> 00:10:51,140
第一段语句里，找出第一个最大值

138
00:10:51,140 --> 00:10:55,760
存储在MAX_INDEX变量，

139
00:10:55,760 --> 00:11:02,580
在第二段语句里，找出第二个最大数。

140
00:11:02,580 --> 00:11:07,930
所以在第二块中的不同之处在于，我们还需要跳过

141
00:11:07,930 --> 00:11:10,040
第一个最大数

142
00:11:11,810 --> 00:11:12,840
第一个最大数

143
00:11:12,840 --> 00:11:16,545
我们通过这个语句

144
00:11:17,710 --> 00:11:23,085
然后返回两个最大数的乘积

145
00:11:23,085 --> 00:11:28,956
然后返回两个最大数的乘积

146
00:11:28,956 --> 00:11:34,574
现在我们编译它

147
00:11:34,574 --> 00:11:40,980
现在我们编译它

148
00:11:40,980 --> 00:11:45,340
所以，这是我们的新文件，max_pairwise_product_fast.ccp。

149
00:11:45,340 --> 00:11:51,275
我们编译它，我们先对一些小的运行。

150
00:11:51,275 --> 00:11:59,120
例如，容量3，元素2，3，4 结果输出12

151
00:11:59,120 --> 00:12:01,120
我们继续

152
00:12:01,120 --> 00:12:05,770
让我们来看看一个巨大的数组。

153
00:12:06,980 --> 00:12:11,966
我们不用常规的输入读取方法

154
00:12:11,966 --> 00:12:16,346
我们不用常规的输入读取方法

155
00:12:16,346 --> 00:12:21,493
而是创建一个巨大的数组

156
00:12:21,493 --> 00:12:28,487
使用10的5次方向量

157
00:12:28,487 --> 00:12:34,746
将其变成一个用0数组，

158
00:12:34,746 --> 00:12:40,470
然后

159
00:12:41,600 --> 00:12:45,130
立刻输出结果

160
00:12:45,130 --> 00:12:48,010
比上一个算法快多了

161
00:12:48,010 --> 00:12:52,590
我们这次应该

162
00:12:52,590 --> 00:12:57,312
这次算法效率很多，也用了合适类型来存储结果

163
00:12:57,312 --> 00:13:00,198
我们也找到了两个最大数

164
00:13:00,198 --> 00:13:05,283
我们也找到了两个最大数

165
00:13:05,283 --> 00:13:10,229
我们也找到了两个最大数

166
00:13:10,229 --> 00:13:12,280
我们也找到了两个最大数

167
00:13:12,280 --> 00:13:16,210
但是这次

168
00:13:16,210 --> 00:13:21,310
这次的测试，显示还是有些测试例不对

169
00:13:21,310 --> 00:13:26,430
这次的测试，显示还是有些测试例不对

170
00:13:26,430 --> 00:13:31,670
在下一个录像，Michael会告诉你什么是压力测试

171
00:13:31,670 --> 00:13:34,220
还会告诉你们如何解决这个问题