1
00:00:00,390 --> 00:00:04,680
في هذا الفيديو، سنستعرض
مسألة برمجية اكثر متعة

2
00:00:04,680 --> 00:00:10,540
هذه المسألة تتطلب منا عمل تطبيق
اسرع من التطبيق المباشر للحل اولاً

3
00:00:10,540 --> 00:00:15,530
 ثم تنقيحه، بعد ذلك  تنفيذ اختبار
 الإجهاد عليه قبل أن نحصل على 

4
00:00:15,530 --> 00:00:21,390
حل صحيح الذي سيتمكن من اجتياز
 كل الاختبارات في نظام الاختبار الآلي 

5
00:00:21,390 --> 00:00:25,870
حسنا، يطلق على المسألة مسألة القيمة القصوى 
لناتج الضرب ذو الأولوية.

6
00:00:25,870 --> 00:00:30,815
في هذه المسألة، معطى لنا مصفوفة،
او متتالية من الاعداد عددهم ن

7
00:00:30,815 --> 00:00:35,300
وهدفنا هو إيجاد 
عدد يمكن استنباطه 

8
00:00:35,300 --> 00:00:39,650
عن طريق ضرب
 عددين من المتتالية

9
00:00:40,730 --> 00:00:46,020
حسنا، تذكر أن المسألة تتألف من
 متتالية من الأعداد الصحيحة الموجبة

10
00:00:46,020 --> 00:00:48,920
ﻹيجاد القيمة القصوى من ناتج
 حاصل ضرب أي عددين في المتتالية

11
00:00:48,920 --> 00:00:52,960
لذلك تتألف المدخلات لهذه المسألة
 من سطرين

12
00:00:52,960 --> 00:00:56,521
السطر الأول يحتوي على
العدد ن 

13
00:00:56,521 --> 00:01:01,163
حيث أن ن على الأقل 2 و
على الأكثر 2 مضروب في 10 أس 5

14
00:01:01,163 --> 00:01:05,154
السطر الثاني يتألف من متتالية
من ن من الأعداد 

15
00:01:05,154 --> 00:01:08,909
الصحيحة الموجبة التي لا تتجاوز
 قيمة أي عدد فيها 10 أس 5

16
00:01:08,909 --> 00:01:15,090
هدفنا هو الحصول القيمة القصوى لحاصل 
ضرب أي عددين من الأعداد في المتتالية

17
00:01:15,090 --> 00:01:18,447
الصفحة تحتوي كذلك على نموذجّي اختبار

18
00:01:18,447 --> 00:01:24,262
على سبيل المثال، إذا كانت المدخلات
 للبرنامج عبارة عن متتالية من 3 أعداد 

19
00:01:24,262 --> 00:01:29,241
تتألف من الأعداد 1 و2 و3
عندها بالطبع سنحصل على الناتج 6

20
00:01:29,241 --> 00:01:32,500
لان القيمة القصوى لحاصل ضرب 
أي عددين في المتتالية هو 2 في 3

21
00:01:32,500 --> 00:01:37,867
لمتتالية اكبر نوعا ما تتألف من 10 أعداد

22
00:01:37,867 --> 00:01:41,399
الناتج يجب أن يكون 140

23
00:01:41,399 --> 00:01:45,789
وهذا حاصل ضرب 10 في 14

24
00:01:45,789 --> 00:01:50,094
وكالعادة هناك قسم يحوي

25
00:01:50,094 --> 00:01:54,940
على ملفات ابتدائية فهيا نبدأ، 

26
00:01:54,940 --> 00:02:01,818
سنختار لغة سي بلس بلس 
لهذه المسألة

27
00:02:01,818 --> 00:02:06,490
هكذا يبدو الملف الابتدائي للحل
 بلغة السي بلس بلس 

28
00:02:06,490 --> 00:02:11,540
نبدأ بقراءة العدد ن
من الدخْل القياسي

29
00:02:11,540 --> 00:02:15,540
بعدها ننشئ مصفوفة،
ذات حجم ن

30
00:02:15,540 --> 00:02:21,200
ثم نملأ المصفوفة بعناصر
المتتالية، عنصرا تلو الاخر. 

31
00:02:21,200 --> 00:02:23,950
ثم نقرأ من الدخْل القياسي

32
00:02:23,950 --> 00:02:27,485
بعدها نرسل الأعداد
إلى الوظيفة (أو الدالة) المسماه

33
00:02:27,485 --> 00:02:31,850
ماكس_بييروايز_برودكت التي
 تقوم بحساب الحل لمسألتنا

34
00:02:32,900 --> 00:02:36,953
فلنلقي نظرة على ما بداخل 
الوظيفة ماكس_بييروايز_برودكت

35
00:02:36,953 --> 00:02:42,936
حسناً، نبدأ بتهيئة
المتغير ريزلت إلى 0 

36
00:02:42,936 --> 00:02:50,300
ثم نمر على كل الأزواج الممكنة 
لكل عناصر المتتالية

37
00:02:50,300 --> 00:02:55,460
وهذا يعني، المرور على كل متغير ي ومتغير
 ج حيث ي أقل من ج

38
00:02:55,460 --> 00:02:58,040
نقوم بعمل هذا عن طريق حلقتين متداخلتين

39
00:02:58,040 --> 00:03:02,580
ولكل زوج، نتحقق إذا كان
حاصل ضربهما 

40
00:03:02,580 --> 00:03:05,140
أكبر من قيمة 
المتغير ريزلت الحالية

41
00:03:05,140 --> 00:03:08,110
وإذا كان كذلك فأننا نقوم
بتحديث المتغير ريزلت إلى القيمة الجديدة

42
00:03:08,110 --> 00:03:10,469
أخيراً، فأننا نقوم بإعادة قيمة 
المتغير ريزلت

43
00:03:11,810 --> 00:03:16,100
هذه الخوارزمية صحيحة
لسبب بسيط

44
00:03:16,100 --> 00:03:21,380
الهدف من المسألة إيجاد
حاصل الضرب الأكبر، أليس كذلك؟  

45
00:03:21,380 --> 00:03:25,090
وحتى نقوم بذلك فأننا نمر
على كل الازواج في المتتالية

46
00:03:25,090 --> 00:03:26,339
ونختار حاصل الضرب الأكبر

47
00:03:27,900 --> 00:03:33,166
حسنا، لنتحقق من اذا كان ذلك صحيحاً
فلنقم، كالعادة، بترجمة البرنامج 

48
00:03:36,801 --> 00:03:39,878
ولهذا الغرض نستخدم

49
00:03:42,503 --> 00:03:46,037
علامات مترجم لغة السي بلس بلس

50
00:03:58,560 --> 00:04:00,092
حسنا، بعد ذلك، نفحص البرنامج

51
00:04:05,530 --> 00:04:10,381
مثلاً، لمتتالية من 3 أعداد

52
00:04:10,381 --> 00:04:16,250
تتكون من الأعداد 1 إلى 3،
فسنحصل على الناتج 6

53
00:04:16,250 --> 00:04:18,743
لنختبر البرنامج مرة أخرى

54
00:04:18,743 --> 00:04:22,160
مثلاً، متتالية من 5 اعداد

55
00:04:22,160 --> 00:04:25,723
تتكون من الأعداد 3 و4 و5 و1 و2

56
00:04:25,723 --> 00:04:32,900
والناتج هو 20 كما هو متوقع،
لان ذلك هو حاصل ضرب العددين 4 و5

57
00:04:32,900 --> 00:04:37,510
حسنا، يبدو أن هذا الحل 
صحيح فلنمضي قدماً

58
00:04:37,510 --> 00:04:41,320
ونقوم بتسليم هذا الحل
إلى نظام الاختبار الآلي 

59
00:04:41,320 --> 00:04:45,380
حسنا لقد قمت بتسليم الحل بشكله الحالي
إلى نظام التقييم الآلي 

60
00:04:45,380 --> 00:04:48,370
ولكن للأسف 
لم يتم يجتز الحل جميع الاختبارات

61
00:04:48,370 --> 00:04:52,960
على الأخص، هناك رسالة خطأ
من نظام التقييم الآلي

62
00:04:52,960 --> 00:04:53,570
لنلقي نظرة

63
00:04:54,710 --> 00:04:59,190
تقول الرسالة ان حلنا قد فشل في

64
00:04:59,190 --> 00:05:03,230
الاختبار الثالث، الذي يتكون
من عددين فقط

65
00:05:03,230 --> 00:05:07,158
الأول 10 أس 5،

66
00:05:07,158 --> 00:05:10,970
والثاني 90,000

67
00:05:10,970 --> 00:05:15,798
فلننظر إذا كان بإمكاننا إعادة إنتاج
هذا النمط على جهازنا المحلي

68
00:05:15,798 --> 00:05:20,777
سنقوم بتشغيل برنامجنا

69
00:05:20,777 --> 00:05:25,303
وندخل عددين فقط

70
00:05:25,303 --> 00:05:31,686
10 أس 5  و90,000

71
00:05:31,686 --> 00:05:36,350
بالفعل، نتيجة لهذه المدخلات
بدلا من أن نحصل على

72
00:05:36,350 --> 00:05:41,130
9 مليار كما كنا نتوقع
حصلنا على عدد عشوائي

73
00:05:41,130 --> 00:05:44,830
وهذا يحصل عادة عند حدوث 
فيض خارج حدود تمثيل العدد الصحيح

74
00:05:44,830 --> 00:05:48,970
وبالفعل فنحن نستخدم النوع القياسي
 لتمثل العدد الصحيح المسمى إنتيجر

75
00:05:48,970 --> 00:05:53,420
لتخزين قيمة حاصل ضرب 
العددين في ذاكرة الحاسب

76
00:05:53,420 --> 00:05:55,700
وبما أن 9 مليار هي أكبر من

77
00:05:55,700 --> 00:06:00,000
نوع تمثيل العدد الصحيح إنتيجر لذلك
فأنه لا يمكن تمثيله بالنوع إنتيجر

78
00:06:00,000 --> 00:06:05,950
فالذي يتوجب علينا فعله هو تمثيل
 العدد باستخدام النوع لونج لونج في لغة السي بلس بلس

79
00:06:05,950 --> 00:06:11,271
فلنفعل ذلك ثم نتحقق اذا

80
00:06:11,271 --> 00:06:16,440
أصلح المشكلة، أو بالأحرى أصلح حلنا

81
00:06:19,190 --> 00:06:23,609
ولذلك 
يجب علينا التغيير في كل مكان

82
00:06:23,609 --> 00:06:27,913
نقوم فيه بحساب حاصل الضرب وتخزينه

83
00:06:27,913 --> 00:06:32,437
سنقوم أولاً تغيير تهيئة هذا المتغير

84
00:06:32,437 --> 00:06:38,020
نغير كذلك نوع القيمة المعادة 
من الوظيفة (أو الدالة)

85
00:06:38,020 --> 00:06:44,520
عند حساب حاصل الضرب
للعددين نقوم بجبر

86
00:06:46,200 --> 00:06:51,281
مثلا، للعدد الأول

87
00:06:51,281 --> 00:06:57,384
الى النوع لونج لونج

88
00:07:00,117 --> 00:07:04,444
حسنا، وكذلك

89
00:07:04,444 --> 00:07:09,360
هنا، رائع.

90
00:07:09,360 --> 00:07:10,780
فلنترجمه مجددا

91
00:07:13,550 --> 00:07:22,220
نعم، فلنقم باختباره مجددا لنتأكد إذا 
 كان يعالج البيانات السابقة

92
00:07:26,300 --> 00:07:30,750
حسناً 10 أس 5  و90,000

93
00:07:30,750 --> 00:07:35,080
عظيم، يظهر انه يخرج 9 مليار

94
00:07:35,080 --> 00:07:38,690
حسناً، يجب أن نكون الآن متأكدين تمام
أن حلنا صحيح 

95
00:07:38,690 --> 00:07:43,090
حسنا لأن، في البدايةً، 
لإيجاد العدد الأكبر لحاصل الضرب

96
00:07:43,090 --> 00:07:47,540
سنقوم بالمرور على كل الأزواج في
 المتتالية وسنختار العدد الأكبر

97
00:07:47,540 --> 00:07:50,670
ما الذي يكمننا فعله غير ذلك؟

98
00:07:50,670 --> 00:07:56,110
ونحن كذلك، نستخدم النوع الصحيح 
لتخزين الناتج

99
00:07:56,110 --> 00:08:02,860
فلنقم بتسليم حالنا الجديد
إلى نظام التقييم الآلي

100
00:08:02,860 --> 00:08:07,630
للأسف ما زال حالنا غير صحيح

101
00:08:07,630 --> 00:08:12,430
لذا في هذه الحالة، رسالة 
نظام التقييم الآلي هي

102
00:08:12,430 --> 00:08:15,040
فشل في الحالة 4، تم تجاوز للوقت المحدد

103
00:08:15,040 --> 00:08:18,730
وهذا يعني أن حالنا 
بالغ البطيء، حيث أنه

104
00:08:18,730 --> 00:08:24,050
للبيانات الكبيرة 
يقوم بالحساب لأكثر من ثانية

105
00:08:25,820 --> 00:08:28,740
فلنحاول فهم لماذا يحصل هذا

106
00:08:28,740 --> 00:08:34,051
أولاً، الحجم الأقصى للبيانات
هو الحجم الأقصى للمتتالية

107
00:08:34,051 --> 00:08:37,768
وفي هذه المسألة، وفي هذه الحالة بالتحديد
يبلغ 10 أس 5 تقريبا.

108
00:08:37,768 --> 00:08:42,296
لذلك ما هو عدد العمليات
المنفذة عن طريق خوارزميتنا على مثل

109
00:08:42,296 --> 00:08:43,900
هذه المتتالية؟

110
00:08:43,900 --> 00:08:48,940
لذلك تذكر أن في خوارزميتنا
نقوم بالمرور على كل الأزواج المتاحة

111
00:08:48,940 --> 00:08:50,150
من الأعداد المدخلة

112
00:08:50,150 --> 00:08:51,720
وهذا يقترب من ن تربيع من العمليات.

113
00:08:51,720 --> 00:08:55,150
لذلك عندما تساوي ن 10 أس 5،
فإن عدد العمليات يصبح 10 أس 10.

114
00:08:55,150 --> 00:08:59,160
وهذا أكثر من مليار

115
00:08:59,160 --> 00:09:03,760
وتقريبا مليار واحد هو عدد العمليات
 الأساسية التي يمكن لحاسب حديث 

116
00:09:03,760 --> 00:09:06,320
تنفيذها في ثانية واحدة

117
00:09:06,320 --> 00:09:12,480
ونستخلص من هذا إلى حاجتنا إلى
خوارزمية أسرع لحل هذه المسألة

118
00:09:12,480 --> 00:09:18,110
في الخصوص، يتوجب علينا إيجاد 
حاصل الضرب الأقصى ﻷي زوج من الأعداد،

119
00:09:18,110 --> 00:09:22,830
بدون المرور على كل 
زوج من الأعداد في المتتالية 

120
00:09:22,830 --> 00:09:30,440
بحثا عن الإلهام،
لنلقي نظرة على صفحة المسألة

121
00:09:30,440 --> 00:09:36,940
على وجه الخصوص لنراجع
النموذج الثاني من المدخلات

122
00:09:36,940 --> 00:09:41,204
في هذه الحالة،
تتكون المتتالية من 10 أعداد حقيقية،

123
00:09:41,204 --> 00:09:44,787
والخَرْج في هذه الحالة 140. 

124
00:09:44,787 --> 00:09:46,500
لماذا؟ حسناً،

125
00:09:46,500 --> 00:09:51,920
لأنه في متتاليتنا 
يوجد عددان هما 14 و10

126
00:09:51,920 --> 00:09:55,870
هذان العددان هما الأكبر في الواقع.

127
00:09:55,870 --> 00:10:01,148
ولذلك لأي عددين غيرهما،
يكون حاصل ضربهما أقل من 140.

128
00:10:01,148 --> 00:10:06,455
وهذا يعطينا فكرة: لإيجاد
القيمة الأقصى لحاصل ضرب أي عددين

129
00:10:06,455 --> 00:10:13,130
في متتاليتنا، يكفي فعلاً إيجاد
أكبر عددين في متتاليتنا.

130
00:10:13,130 --> 00:10:18,790
هذا ﻷن كل الأعداد الصحيحة
في المتتالية موجبة.

131
00:10:18,790 --> 00:10:26,220
حسناً، فلننفذ هذه
الفكرة على ملف السي بلس بلس.

132
00:10:26,220 --> 00:10:29,690
حسناً، الفكرة قد تنفيذها مسبقاً
وتبدو كالتالي

133
00:10:29,690 --> 00:10:34,240
حسناً، الوظيفة الجديدة مسماه
ماكس_بييروايز_ برودكت_فاست

134
00:10:34,240 --> 00:10:37,027
وتَستَخدِم هذه الوظيفة النوع لونج لونج

135
00:10:37,027 --> 00:10:40,400
لتخزين الناتج ونقوم بالتالي

136
00:10:40,400 --> 00:10:45,340
فقط عن طريق فحص المصفوفة مرتين
نجد العددين الأكبر

137
00:10:45,340 --> 00:10:51,140
في الحلقة الأولى، 
نجد العدد الأكبر الأول

138
00:10:51,140 --> 00:10:55,760
نقوم بتخزين فهرس هذا العدد
في المتغير ماكس_إنديكس1

139
00:10:55,760 --> 00:11:02,580
في الحلقة الثانية، 
نجد العدد الأكبر الثاني

140
00:11:02,580 --> 00:11:07,930
الفرق بين الحلقتين أن في الحلقة الثانية
نحتاج أن نتجاوز

141
00:11:07,930 --> 00:11:10,040
العدد الأكبر الأول

142
00:11:11,810 --> 00:11:12,840
خلال فحص المصفوفة

143
00:11:12,840 --> 00:11:16,545
لذلك ما نقوم به هو إضافة هذا
الشرط خلال الفحص

144
00:11:17,710 --> 00:11:23,085
حسناً، ثم نُعِيد حاصل ضرب

145
00:11:23,085 --> 00:11:28,956
العددين الأكبر في المصفوفة
أليس كذلك؟

146
00:11:28,956 --> 00:11:34,574
فلنقم، كالعادة، بترجمة الحل

147
00:11:34,574 --> 00:11:40,980
ونتأكد أن كل شئ يعمل بشكل صحيح

148
00:11:40,980 --> 00:11:45,340
حسناً، هذا هو ملفنا الجديد المسمى
ماكس_بييروايز_برودكت_فاست

149
00:11:45,340 --> 00:11:51,275
نترجمه ونقوم بتشغيله أولاً
 بإعطائه متتالية صغيرة الحجم

150
00:11:51,275 --> 00:11:59,120
كمثال، متتالية من 3 أعداد، 2 و3 و4 
فيعيد لنا البرنامج 12 كما هو متوقع

151
00:11:59,120 --> 00:12:01,120
عظيم، فلنقم الآن بالتالي

152
00:12:01,120 --> 00:12:05,770
فلنختبر وقت التشغيل
لمتتالية كبيرة العدد

153
00:12:06,980 --> 00:12:11,966
لهذا، بدلاً من قراءة 

154
00:12:11,966 --> 00:12:16,346
البيانات من الدخْل القياسي

155
00:12:16,346 --> 00:12:21,493
لقم بتوليد مفصوصة كبيرة هنا.

156
00:12:21,493 --> 00:12:28,487
فلنستخدم مصفوفة حجمها 10 أس 5

157
00:12:28,487 --> 00:12:34,746
ولتكن المصفوفة مملوءة بالأصفار

158
00:12:34,746 --> 00:12:40,470
هيا نترجم الملف ونشغله.

159
00:12:41,600 --> 00:12:45,130
والناتج هو صفر مباشرة
وهذا يعني

160
00:12:45,130 --> 00:12:48,010
حسنا، هذا أسرع بكثير
مقارنة بالخوارزمية السابقة

161
00:12:48,010 --> 00:12:52,590
فقط الآن حلنا 
يجب أن يكون صحيحاً

162
00:12:52,590 --> 00:12:57,312
الحل سريع ويستخدم النوع الصحيح
لتخزين حاصل الضرب

163
00:12:57,312 --> 00:13:00,198
وهو كذلك صحيح بالطبع لانه،

164
00:13:00,198 --> 00:13:05,283
في الحقيقة يختار أكبر عددين أليس كذلك؟
 ثم يقوم بحساب حاصل ضربهما

165
00:13:05,283 --> 00:13:10,229
لا يمكن لأي حاصل ضرب أي عددين
غيرهما أن يكون أكبر ﻷننا أخترنا

166
00:13:10,229 --> 00:13:12,280
أكبر عددين.

167
00:13:12,280 --> 00:13:16,210
ولكن، للأسف،
حتى هذا الحل غير صحيح

168
00:13:16,210 --> 00:13:21,310
يمكنك تسليمه إلى نظام الاختبار 
الآلي ورؤية رسالة الخطأ

169
00:13:21,310 --> 00:13:26,430
ستكون إجابة خاطئة
لحالة اختبار معينة 

170
00:13:26,430 --> 00:13:31,670
في الفيديو القادم، مايكل سوف
يخبرك عن اختبار الإجهاد

171
00:13:31,670 --> 00:13:34,220
وسوف يرشدك إلى كيفية اصلاح هذا الحل