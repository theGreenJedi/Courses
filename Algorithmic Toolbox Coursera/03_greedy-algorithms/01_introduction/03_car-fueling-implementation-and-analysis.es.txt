Hola, en este video aprenderás a implementar el algoritmo voraz del video anterior, y analizarás su tiempo de ejecución. Aquí tenemos el pseudocódigo para este algoritmo y el procedimiento se llama MinRefills (mínimo de recargas). y la principal entrada en este procedimiento es el arreglo x. Del enunciado del problema, sabemos que las posiciones de las estaciones de gas están dados por los números del x1 al xn. Y éstos están medidos en km, en términos de distancias desde A a la correspondiente estación en el camino de A a B. Por conveniencia agregamos al arreglo X, las posiciones del punto A, que es x0 y es el valor más pequeño en el arreglo, y el punto B, que es x_(n+1), y es el valor más grande en el arreglo x. En el camino de A a B visitaremos algunos puntos. Por supuesto empezaremos desde el punto A, y entonces iremos probablemente a una estación de gasolina, recargamos ahí, y entonces vamos a otra estación, y a otra y a otra, y entonces en algún momento llegaremos al punto B o punto x_(n+1). Así que vemos que sólo necesitamos guardar las posiciones en el arreglo x, no necesitamos considerar posiciones entre los elementos del arreglo x. Y así, guardaremos en la variable currentRefill la posición en el arreglo x en la que estamos actualmente. Y la inicializaremos con 0, porque empezamos desde el punto A que es lo mismo que x0 y tiene índice 0 en el arreglo x. Más tarde, currentRefill guardará el índice en el arreglo x donde estemos parados. También vamos a guardar la respuesta a nuestro problema en la variable numRefills. En cada punto en la ejecución del algoritmo, contendrá el número de recargas que hemos hecho. Y lo incializamos con 0, porque el enunciado del problema nos pide contar el número mínimo de recargas que necesitamos hacer, sin contar la recarga inicial en el punto A. Así que cuando estamos en el punto A, consideramos que no hemos hecho ninguna recarga todavía. Entonces, el principal bucle while externo inicia, y continúa mientras estemos a la izquierda del punto B porque entonces necesitamos ir a la derecha para llegar a nuestro destino B, y checamos esta condición con esta desigualdad, de que currentRefill is a lo más n, lo que significa que la posición o índice en el arreglo x es a lo más n, y así estamos a la izquierda de B. En este caso necesitamos todavía ir a la derecha. Y primero guardamos nuestra posición actual en el arreglo x en la variable lastRefill. Esto significa que hicimos nuestra última recarga en la posición currentRefill. Y ahora necesitamos ir a la derecha desde ahí y, o llegamos al destino B, o llegamos estación más a la derecha alcanzable y recargamos ahí. Y el siguiente bucle while interno hace exactamente eso. Incrementa gradualmente nuestra posición currentRefill en el arreglo x hasta alcanzar el punto más a la derecha en el arreglo x que es alcanzable desde la posición lastRefill. Entonces primero checamos que la posición currentRefill es a lo más n porque si es n+1 significa que alcanzamos nuestro destino B, y no hay razón de seguir incrementándolo. Si estamos todavía a la izquierda de B, entonces checaremos la siguiente posición a la derecha, x en currentRefill+1. Necesitamos checar si es alcanzable desde la posición de lastRefill o no. Y primero podemos construir la distancia desde la posición lastRefill a la posición currentRefill+1, restando estos valores en el arreglo x. Y si la distancia es a lo más L, entonces significa que podemos viajar esta distancia con tanque lleno, sin recargar. Y por supuesto, en la posición lastRefill pudimos recargar nuestro tanque a su máxima capacidad, y entonces seremos capaces de viajar por L km. Así que esta desigualdad checa si la posición currentRefill+1 es alcanzable desde la posición lastRefill. Si lo es, incrementamos el valor de currentRefill y continuamos con nuestro bucle while interno. Cuando salimos de este bucle while interno tal vez ya estemos en el punto B, o a la mejor estamos en algún punto donde está la estación más lejana alcanzable. Ahora comparamos la posición con la de lastRefill, y si resulta que son las mismas, significa que no pudimos ir a la derecha. No tenemos suficiente combustible para llegar a la siguiente estación. Y entonces no podemos devolver el mínimo número de recargas que necesitamos hacer en el camino de A a B, porque es imposible llegar de A a B. Y así, devolvemos IMPOSIBLE como respuesta. De otra forma, nos movemos al menos un poco a la derecha y necesitamos checar. Si ya estamos en el punto B no necesitamos hacer nada más. De otro modo, necesitamos recargar ahí. Así que checamos si estamos a la izquierda de B con esta desigualdad. Y si es cierta, entonces estamos en alguna estación de gasolina y necesitamos recargar, e incrementamos la variable numRefills por uno, y regresamos al principio de nuestro bucle while externo. Y ahí, de nuevo checamos. Si estamos a la izquierda del punto B, necesitamos otra iteración. Y si currentRefill es ya n+1, entonces alcanzamos el punto B y salimos del bucle while externo. En este caso, sólo regresamos la respuesta que es el número de recargas que hemos hecho hasta ahora. Ya implementamos el algoritmo voraz de la clase pasada, ahora analicemos su tiempo de ejecución. A primera vista pareciera que opera en tiempo n al cuadrado porque tenemos el bucle while externo que puede hacer n iteraciones y el bucle interno que puede hacer n iteraciones. Así que nxn es n cuadrado, pero vamos a mostrar que sólo hace del O de n acciones para el algoritmo entero. Para probar esto, primero chequemos la variable currentRefill. Vemos que sólo cambia de uno en uno, comenzando del cero. y ¿cuál es el valor más grande que puede alcanzar? Por supuesto, el número más grande es n+1 porque es el mayor índice en el arreglo x, y currentRefill es un índice en el arreglo x. Entonces, la variable currentRefill empieza en cero, cambia de uno en uno, y el mayor valor que puede tener es n+1. Eso significa que se incrementa a lo más n+1 veces lo que es del O de n. Pero eso no es todo. También aumentamos la variable numRefills aquí. Pero también la aumentamos de uno en uno, siempre. También empieza desde cero, y, ¿cuál es el mayor número que esta variable puede alcanzar? Bien, por supuesto que es n, porque tenemos n estaciones de gasolina. No hay necesidad de rellenar dos veces en la misma estación de gas. Así que podemos rellenar a lo más n veces. Así que la variable numRefills va desde 0 hasta n y cambia de uno en uno. Así que sólo cambió a lo más n veces, y por tanto, es también lineal en términos de n. Entonces, tenemos a lo más n+1 iteraciones en el bucle while externo. Todo excepto el bucle while interno toma tiempo constante, esta asignación, este if, y este if con asignación, y el bucle externo y el bucle interno combinados también gastan a lo más un tiempo lineal en las iteraciones, porque cambian la variable currentRefill que cambia a lo más un número lineal de veces. Así que todo nuestro algoritmo trabaja en tiempo O de n.. Repasemos esta demostración de nuevo. El lema dice que el tiempo de ejecución del algoritmo completo es O de n. Y probamos esto primero notando que la variable currentRefill cambia sólo de 0 hasta a lo más n+1, y el cambio es siempre de uno en uno. Que la variable numRefills cambia desde 0 hasta a lo más n, y también lo hace de uno en uno. Por lo que las dos variables cambian en tiempo O de n. Y todo lo demás que pasa es tiempo constante. Cada iteración del bucle externo, y hay a lo más n+1 iteraciones del bucle externo. Por lo que nuestro algoritmo corre en tiempo lineal. este de aquí, vamos a revisar lo que aprendimos sobre algoritmos voraces en general.