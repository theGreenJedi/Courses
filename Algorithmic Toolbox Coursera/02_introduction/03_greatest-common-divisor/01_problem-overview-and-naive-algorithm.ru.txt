Здравствуйте. И снова здравствуйте. Сегодня мы будем говорить о вычислении наибольших общих делителей. И в частности, что бы нам хотелось сделать на лекции, это описать задачу нахождения наибольшего общего делителя. И затем мы поговорим о неэффективном методе их вычисления. А на следующей лекции мы обсудим, как сделать лучше. Итак, начали. Что такое НОДы? Допустим, у вас есть дробь, a/b И вы хотите упростить ее. Обычно, для этого мы делим и числитель, и знаменатель, на некоторое число d, чтобы 
получить эквивалентное дробное значение a/d / b/d. Звучит логично. Итак, какое d мы могли бы здесь использовать? Необходимо, чтобы оно удовлетворяло двум критериям. Во-первых, d должно делить как a, 
так и b, т.к. новые числитель и знаменатель - оба целые числа. Но, при этом, мы бы хотели
чтобы число d было наибольшим. Чтобы мы могли сократить дробь 
насколько это возможно. Итак, выведем определение,
пусть у нас есть два целых числа, a и b, тогда их наибольший общий делитель, или НОД, - это наибольшее целое число d,
которое делит a и b. Таким образом, мы используем 
его чтобы сокращать дроби. Однако, оказывается что НОДы
чрезвычайно важная вещь в теории чисел. Изучение простых чисел,
разложение на множители, и прочее. И, т.к. это очень важно для теории
чисел, выходит что возможность вычислить НОД очень 
важна в криптографии. И тот факт, что вы можете
безопасно использовать онлайн-банк, происходит в том числе благодаря тому, что мы можем быстро
вычислить НОДы для заданных чисел, а это является одной из важных частей 
работы криптографических алгоритмов. Т.к. это все очень важно, мы
хотим научиться вычислять НОД. Мы хотим найти такой алгоритм, который при наличии 
двух положительных целых чисел a и b, смог бы вычислить НОД для a и b. И, чтобы всем было понятно,
 о каких числах идет речь, мы хотим чтобы этот алгоритм 
работал для очень больших чисел. Мы не хотим просто посчитать 
НОД для 5 и 12, или 11 и 73. Мы хотим, чтобы было 
возможным вычислить НОД для 3,918,848 и 1,653,264. На самом деле, мы хотим иметь возможность 
обрабатывать очень большие числа, длиной в 20, 50, 100, 1000 знаков. И мы хотим, чтобы НОД вычислялся 
для таких чисел довольно быстро. Итак, начнем. Начнем с того, что просто
найдем алгоритм, который работает. Мы хотим найти самое большое 
число который делит a b. Первое, что мы можем сделать, это просто проверить все числа,
подходящие для этого, выясняя, какое делит и a, и b,
и возвращая наибольшее. Вот простая реализация этого. Создадим переменную best,
и зададим ей значение 0. В ней будет храниться наибольшее число,
которое мы нашли на текущий момент. Затем переберем d от 1 до a + b, т.к. это весь нужный нам 
диапазон значений. Теперь, если d делит a, 
и d делит b, т.к. d возрастает, оно должно быть новым значением 
best на текущий момент. Итак, в переменную best мы записываем d,
и, в итоге, мы возвращаем наиболее 
подходящее значение для НОД. Таким образом, это прекрасный алгоритм. Он работает. К сожалению, он довольно медленный, потому что нам нужно пройти 
этот цикл for, a + b, много раз. Следовательно, даже если a и b, 
скажем, 20 знаков в длину, это уже займет для вычисления
как минимум тысячу лет. Таким образом, это не эффективно
для наших задач. Нам нужен алгоритм получше. Итак, смотрите следующую лекцию,
где мы поговорим о том, как найти алгоритм получше для решения этой проблемы, 
и что для этого нужно.