1
00:00:00,600 --> 00:00:04,380
嗨，大家好，今天这节课是关于排序的问题

2
00:00:05,870 --> 00:00:08,750
和往常一样，今天的课程以回顾一个问题来开始

3
00:00:10,090 --> 00:00:14,270
排序是一个非常基本的计算问题

4
00:00:14,270 --> 00:00:18,480
这个问题里，你的输入由一系列元素组成

5
00:00:18,480 --> 00:00:23,000
而你的目标是把这些元素按照(比方说)非降序输出

6
00:00:24,580 --> 00:00:27,680
这个问题的正式描述如下

7
00:00:27,680 --> 00:00:30,360
给定一系列有限个元素

8
00:00:30,360 --> 00:00:33,950
这节课里，我们会用A表示这个序列

9
00:00:33,950 --> 00:00:38,860
而你的目标是把这些相同的元素按非降序输出

10
00:00:40,560 --> 00:00:41,470
同样的

11
00:00:41,470 --> 00:00:47,330
排序是一个非常重要的计算问题，很多高效地算法中都会用到

12
00:00:47,330 --> 00:00:50,460
对于某些算法，按从小到大的顺序处理

13
00:00:50,460 --> 00:00:55,290
以非降序排列的元素是非常重要

14
00:00:55,290 --> 00:00:59,090
在某些其它算法中，仅仅通过排序输入的数据

15
00:00:59,090 --> 00:01:03,440
你就能够执行高效的多的查询

16
00:01:03,440 --> 00:01:07,000
一个典型的例子是搜索问题

17
00:01:07,000 --> 00:01:09,550
这个问题里，我们被有一系列有限多个元素

18
00:01:09,550 --> 00:01:13,150
而你的目标是查看某个特定的元素是否

19
00:01:13,150 --> 00:01:14,380
存在于你的序列中

20
00:01:14,380 --> 00:01:19,040
一个非常简单的解决此问题的方法，当然是从左至右(一个一个地)

21
00:01:19,040 --> 00:01:24,960
检查你的输入序列，看你的元素是否在其中

22
00:01:24,960 --> 00:01:27,660
这大概是一个线性复杂度的算法

23
00:01:27,660 --> 00:01:31,060
而如果你已经知道你的输入数据

24
00:01:31,060 --> 00:01:36,110
是已经排好序的，那么你可以高效得多地做到这一点

25
00:01:36,110 --> 00:01:40,980
大致上，就时间来说，只要输入数据大小的对数级的时间复杂度

26
00:01:40,980 --> 00:01:43,799
这种情形下，我们可以先比较你的元素和中间的元素

27
00:01:45,060 --> 00:01:49,710
如果几乎没有几个元素，那么比较可能就结束了。如果不是这样，

28
00:01:49,710 --> 00:01:53,320
你继续跟左半序列比(比较这个子序列的中间元素)，或者右半序列

29
00:01:53,320 --> 00:01:57,620
所以最坏情况下只要对数级别次数的比较，

30
00:01:57,620 --> 00:02:01,840
你就可以确认你的元素是否在序列中

31
00:02:01,840 --> 00:02:06,010
所以如果你被给予一个序列，而你需要执行很多这样的查询

32
00:02:06,010 --> 00:02:12,370
你需要检查一个对象是否在序列中

33
00:02:12,370 --> 00:02:17,840
对这种对象来说，先对输入数据排序是非常合理的

34
00:02:17,840 --> 00:02:20,830
排序之后再执行这些查询

35
00:02:20,830 --> 00:02:24,210
这样以来，你的算法整体上就会高效得多

36
00:02:24,210 --> 00:02:25,060
好吧那就这样吧！//教育无边界字幕组 神奇的小张伟

37
00:02:25,060 --> 00:02:27,290
而这仅仅是一个非常小的例子

38
00:02:27,290 --> 00:02:29,140
我们会在将来看到很多其它的情况

39
00:02:29,140 --> 00:02:34,720
在这些情形下，对数据排序可以帮助你执行高效的多的查询

40
00:02:34,720 --> 00:02:37,851
所以在这节课之后的视频中

41
00:02:37,851 --> 00:02:41,498
我们会学习很多高效的排序算法