[自动生成的英文字幕经常失误，译者尽量听译，然而能力有限，如有错漏，十分抱歉。]
在这段影片中，我们将提供一个快速排序算法的完整伪代码 大家应该还记得，这个算法是递归的， 因此，通过这个快速排序的递归过程，我们传递了一个A， 同时我们传递了一个l和一个r作为队列的左端和右端。 这个过程对A内部从l到r的子队列进行排序。 我们首先检查l是否大于等于r 如果l大于等于r，那意味着对应的子队列最多只能有 一个元素 这就意味着我们不需要进行任何操作，直接return即可 否则我们就要用相同的参数调用分区过程 这个过程会返回一个位于l和r之间的索引值 这样我们重新放置子队列内的所有元素， 放置元素的时候遵循下列原则： 调用这个过程之后，我们要为A[m]找到它最终的位置。 也就是说，所有放在A[m]左边的元素都不大于它， 同时所有放在它右边的元素都不小于它。 就像我们刚才说的，调用了分区函数之后， A[m]已经被放在了正确的位置上。 这样我们接下来的的工作就是把A[m]左边的不大于A[m]的元素排序 并且把A[m]右边的元素排序 我们可以简单地通过两次递归调用完成。 下面演示的是这个墙壁式算法的图例 就像之前说的，我们有一个队列A，有两个标记l和r 我们要对标记l和r之间的子队列进行排序 这样，第一次用参数A, l, r调用分区过程的时候， 我们得到了一个位于l和rz之间的索引m， m具有下面的性质： 所有m左边的元素都不比A[m]大 而所有m右边的元素都比A[m]大 接下来我们就进行两次递归，对队列内左边的 从l到m-1的元素进行排序，再对右边的从m+1到r的元素进行排序。 这样两个递归后，我们就立即得到了一个排好序的队列。 在给大家看分区过程的伪代码之前， 我们再用另一个例子给大家解释一下它的中心思想。 首先，我们拿出一个元素A[l]，记为x 我们把这个元素叫做基准元素 基准元素就是我们用来 划分子序列的基准 x会被放到它最终的位置上。 这样我们的目标就是重新放置当前子序列内的全部元素 以使得x位于它最终的位置上：x左边的元素都 不大于x，同时x右边的元素都大于x。 我们会逐渐扩大已知元素的范围来排序。 为此，我们使用了一个计数器i，并且我们会保留下面这些不变的原则： 我们从l+1走到r， 每当我们读入了i个元素以后， 我们在l+1到i的范围内保留两个区域 第一个区域从l+1到j，我们存放所有不大于x的元素； 其后的第二个区域， 从j+1到i，我们存放所有比x大的元素。 让我们来看一个例子。 假定我们正在整个排序过程的中间某处 这个时候，基准元素x等于6。 我们需要根据x来给元素分区。 我们已经有两个区域了：红色区域 我们存放了所有小于等于x的元素， 也就是不大于6的元素；蓝色区域我们用来存放 比6大的元素。 现在我们把i移动到下一个位置，我们发现了新的元素，9。 这个元素比6大，所以 我们只需要扩大第二个区域，即蓝色的， 存放比6大的元素的区域。 在这种情况下，我们不需要额外的操作。 下面会更有意思：我们把i移动到下一个位置。 我们发现了4 这时，我们需要想办法把4移动到红色区域去。 也就是存放小于等于6的元素的区域。 为了实现这一点，我们只需要把他和当前 蓝色区域的第一个元素交换，在这个例子中就是9。 如果我们这么做，4就会变成当前红色区域的最后一个元素， 而9会去到蓝色区域的末尾。 我们这样操作之后，我们要让j变成j+1， 以反映出红色区域刚刚被扩大了。 这样我们把i移动到下一个元素，我们发现了7， 7比6大，我们就扩大蓝色区域。 接下来我们又发现了元素6， 6不大于6，6就等于6， 所以我们要把它移动到红色区域。 同样地，我们把它和蓝色区域的第一个元素交换位置， 然后我们再扩大红色区域。 我们给j加一来反映出红色区域被扩大了。 然后我们又发现了一个新元素，不大于6， 我们把它移动到红色区域的末尾。 最后，我们在最后需要做的就是把基准元素， 在这个例子中是6，移动到它最终的位置上去。 在这个例子里它的最终位置很容易被找到。 我们有红色区域和蓝色区域， 在红色区域所有元素都不大于6，在蓝色区域 所有的元素都大于6。 所以我们只需要把6和红色区域的最后一个元素交换。 在这个例子中，红色区域的最后一个元素是1，所以如果我们交换这两个元素， 你可以看到所有蓝色区域的元素都确实大于6， 而红色区域的所有元素都比6小。 这样我们的分区过程就完成了。 现在我们可以来看看分区过程的伪代码了。 我们调用分区函数，我们要做的是把某个元素x， 也就是所谓的基准元素，放到它最终的位置上去，以使得所有在它前面的元素 都不大于x，并且所有在x后面的元素都大于x。 在这个过程中，对于基准函数的选择，我们使用 相应子序列的第一个元素，因此x用A[l]来赋值。 我们还会保留提到的两个子区域。 首先，我们会逐渐扩大已知元素的范围。 我们把i从l+1移动到r，在这个范围内， [自动的英语字幕又失误了]对于每一个被发现的元素，我们用两个子区域来存放它们。 第一个区域的角标是l+1到j， 我们存放不大于x的元素； 第二个区域的角标是j+1到i，我们存放 比x大的元素。我们会逐渐增加i的值。 每当i+1， 我们就会发现一个新元素A[i]。 如果A[i]比x大，那么 第二个区域，比x大的区域， 就会自动扩大，这种情况下我们不需要额外的操作。 然而如果新发现的元素不大于x， 那我们需要把它挪到第一个区域。 我们执行如下操作： 我们给j加一，来体现出 第一个区域的范围扩大了，然后交换元素， 交换A[j]和A[i]，这样一来， 每次i增加1，我们的两条不变的原则就得以保持。 在最后的最后，i的值达到了r的时候， 我们还需要把第一个元素， 我们的基准元素，移动到我们的两个区域中间。 为此我们交换我们的基准元素A[l]和元素A[j]。 最后我们返回的值是基准元素的角标，j。