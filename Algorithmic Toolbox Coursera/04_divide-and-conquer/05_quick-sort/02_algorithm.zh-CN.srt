1
00:00:00,210 --> 00:00:05,400
[自动生成的英文字幕经常失误，译者尽量听译，然而能力有限，如有错漏，十分抱歉。]
在这段影片中，我们将提供一个快速排序算法的完整伪代码

2
00:00:05,400 --> 00:00:08,850
大家应该还记得，这个算法是递归的，

3
00:00:08,850 --> 00:00:14,300
因此，通过这个快速排序的递归过程，我们传递了一个A，

4
00:00:14,300 --> 00:00:18,660
同时我们传递了一个l和一个r作为队列的左端和右端。

5
00:00:18,660 --> 00:00:24,770
这个过程对A内部从l到r的子队列进行排序。

6
00:00:24,770 --> 00:00:28,380
我们首先检查l是否大于等于r

7
00:00:28,380 --> 00:00:32,330
如果l大于等于r，那意味着对应的子队列最多只能有

8
00:00:32,330 --> 00:00:33,670
一个元素

9
00:00:33,670 --> 00:00:37,000
这就意味着我们不需要进行任何操作，直接return即可

10
00:00:38,240 --> 00:00:42,780
否则我们就要用相同的参数调用分区过程

11
00:00:42,780 --> 00:00:46,470
这个过程会返回一个位于l和r之间的索引值

12
00:00:46,470 --> 00:00:49,380
这样我们重新放置子队列内的所有元素，

13
00:00:49,380 --> 00:00:52,760
放置元素的时候遵循下列原则：

14
00:00:52,760 --> 00:00:57,580
调用这个过程之后，我们要为A[m]找到它最终的位置。

15
00:00:57,580 --> 00:01:05,090
也就是说，所有放在A[m]左边的元素都不大于它，

16
00:01:05,090 --> 00:01:08,570
同时所有放在它右边的元素都不小于它。

17
00:01:08,570 --> 00:01:11,530
就像我们刚才说的，调用了分区函数之后，

18
00:01:11,530 --> 00:01:15,140
A[m]已经被放在了正确的位置上。

19
00:01:15,140 --> 00:01:20,590
这样我们接下来的的工作就是把A[m]左边的不大于A[m]的元素排序

20
00:01:20,590 --> 00:01:25,810
并且把A[m]右边的元素排序

21
00:01:25,810 --> 00:01:29,350
我们可以简单地通过两次递归调用完成。

22
00:01:29,350 --> 00:01:33,082
下面演示的是这个墙壁式算法的图例

23
00:01:33,082 --> 00:01:38,222
就像之前说的，我们有一个队列A，有两个标记l和r

24
00:01:38,222 --> 00:01:43,914
我们要对标记l和r之间的子队列进行排序

25
00:01:43,914 --> 00:01:49,463
这样，第一次用参数A, l, r调用分区过程的时候， 

26
00:01:49,463 --> 00:01:55,740
我们得到了一个位于l和rz之间的索引m， m具有下面的性质：

27
00:01:55,740 --> 00:02:00,930
所有m左边的元素都不比A[m]大

28
00:02:00,930 --> 00:02:04,320
而所有m右边的元素都比A[m]大

29
00:02:04,320 --> 00:02:09,840
接下来我们就进行两次递归，对队列内左边的

30
00:02:09,840 --> 00:02:15,360
从l到m-1的元素进行排序，再对右边的从m+1到r的元素进行排序。

31
00:02:15,360 --> 00:02:20,880
这样两个递归后，我们就立即得到了一个排好序的队列。

32
00:02:20,880 --> 00:02:25,160
在给大家看分区过程的伪代码之前，

33
00:02:25,160 --> 00:02:29,430
我们再用另一个例子给大家解释一下它的中心思想。

34
00:02:29,430 --> 00:02:34,890
首先，我们拿出一个元素A[l]，记为x

35
00:02:34,890 --> 00:02:37,820
我们把这个元素叫做基准元素

36
00:02:37,820 --> 00:02:41,000
基准元素就是我们用来

37
00:02:41,000 --> 00:02:44,040
划分子序列的基准

38
00:02:44,040 --> 00:02:47,480
x会被放到它最终的位置上。

39
00:02:47,480 --> 00:02:53,265
这样我们的目标就是重新放置当前子序列内的全部元素

40
00:02:53,265 --> 00:02:58,524
以使得x位于它最终的位置上：x左边的元素都

41
00:02:58,524 --> 00:03:04,010
不大于x，同时x右边的元素都大于x。

42
00:03:04,010 --> 00:03:09,840
我们会逐渐扩大已知元素的范围来排序。

43
00:03:09,840 --> 00:03:16,560
为此，我们使用了一个计数器i，并且我们会保留下面这些不变的原则：

44
00:03:16,560 --> 00:03:19,356
我们从l+1走到r，

45
00:03:19,356 --> 00:03:24,633
每当我们读入了i个元素以后，

46
00:03:24,633 --> 00:03:30,970
我们在l+1到i的范围内保留两个区域

47
00:03:30,970 --> 00:03:36,310
第一个区域从l+1到j，我们存放所有不大于x的元素；

48
00:03:36,310 --> 00:03:41,370
其后的第二个区域， 

49
00:03:41,370 --> 00:03:46,340
从j+1到i，我们存放所有比x大的元素。

50
00:03:46,340 --> 00:03:47,780
让我们来看一个例子。

51
00:03:48,880 --> 00:03:52,470
假定我们正在整个排序过程的中间某处

52
00:03:52,470 --> 00:03:55,270
这个时候，基准元素x等于6。

53
00:03:55,270 --> 00:03:59,520
我们需要根据x来给元素分区。

54
00:03:59,520 --> 00:04:04,080
我们已经有两个区域了：红色区域

55
00:04:04,080 --> 00:04:07,520
我们存放了所有小于等于x的元素，

56
00:04:07,520 --> 00:04:12,100
也就是不大于6的元素；蓝色区域我们用来存放

57
00:04:12,100 --> 00:04:13,185
比6大的元素。

58
00:04:14,270 --> 00:04:20,747
现在我们把i移动到下一个位置，我们发现了新的元素，9。

59
00:04:20,747 --> 00:04:23,298
这个元素比6大，所以

60
00:04:23,298 --> 00:04:27,690
我们只需要扩大第二个区域，即蓝色的，

61
00:04:27,690 --> 00:04:30,460
存放比6大的元素的区域。

62
00:04:30,460 --> 00:04:32,480
在这种情况下，我们不需要额外的操作。

63
00:04:33,990 --> 00:04:38,750
下面会更有意思：我们把i移动到下一个位置。

64
00:04:38,750 --> 00:04:41,060
我们发现了4

65
00:04:41,060 --> 00:04:44,710
这时，我们需要想办法把4移动到红色区域去。

66
00:04:44,710 --> 00:04:49,050
也就是存放小于等于6的元素的区域。

67
00:04:49,050 --> 00:04:52,790
为了实现这一点，我们只需要把他和当前

68
00:04:52,790 --> 00:04:57,230
蓝色区域的第一个元素交换，在这个例子中就是9。

69
00:04:57,230 --> 00:05:02,618
如果我们这么做，4就会变成当前红色区域的最后一个元素，

70
00:05:02,618 --> 00:05:04,490
而9会去到蓝色区域的末尾。

71
00:05:04,490 --> 00:05:09,940
我们这样操作之后，我们要让j变成j+1，

72
00:05:09,940 --> 00:05:15,450
以反映出红色区域刚刚被扩大了。

73
00:05:15,450 --> 00:05:20,360
这样我们把i移动到下一个元素，我们发现了7，

74
00:05:20,360 --> 00:05:24,880
7比6大，我们就扩大蓝色区域。

75
00:05:24,880 --> 00:05:28,660
接下来我们又发现了元素6，

76
00:05:28,660 --> 00:05:31,850
6不大于6，6就等于6，

77
00:05:31,850 --> 00:05:33,790
所以我们要把它移动到红色区域。

78
00:05:33,790 --> 00:05:39,240
同样地，我们把它和蓝色区域的第一个元素交换位置，

79
00:05:39,240 --> 00:05:42,340
然后我们再扩大红色区域。

80
00:05:42,340 --> 00:05:47,592
我们给j加一来反映出红色区域被扩大了。

81
00:05:47,592 --> 00:05:51,469
然后我们又发现了一个新元素，不大于6，

82
00:05:51,469 --> 00:05:54,720
我们把它移动到红色区域的末尾。

83
00:05:55,950 --> 00:06:03,201
最后，我们在最后需要做的就是把基准元素，

84
00:06:03,201 --> 00:06:08,969
在这个例子中是6，移动到它最终的位置上去。

85
00:06:08,969 --> 00:06:12,020
在这个例子里它的最终位置很容易被找到。

86
00:06:12,020 --> 00:06:14,780
我们有红色区域和蓝色区域，

87
00:06:14,780 --> 00:06:18,740
在红色区域所有元素都不大于6，在蓝色区域

88
00:06:18,740 --> 00:06:20,720
所有的元素都大于6。

89
00:06:20,720 --> 00:06:25,952
所以我们只需要把6和红色区域的最后一个元素交换。

90
00:06:25,952 --> 00:06:31,003
在这个例子中，红色区域的最后一个元素是1，所以如果我们交换这两个元素，

91
00:06:31,003 --> 00:06:37,290
你可以看到所有蓝色区域的元素都确实大于6，

92
00:06:37,290 --> 00:06:41,770
而红色区域的所有元素都比6小。

93
00:06:41,770 --> 00:06:44,920
这样我们的分区过程就完成了。

94
00:06:44,920 --> 00:06:49,550
现在我们可以来看看分区过程的伪代码了。

95
00:06:49,550 --> 00:06:53,570
我们调用分区函数，我们要做的是把某个元素x，

96
00:06:53,570 --> 00:06:59,080
也就是所谓的基准元素，放到它最终的位置上去，以使得所有在它前面的元素

97
00:06:59,080 --> 00:07:04,130
都不大于x，并且所有在x后面的元素都大于x。

98
00:07:04,130 --> 00:07:09,020
在这个过程中，对于基准函数的选择，我们使用

99
00:07:09,020 --> 00:07:13,320
相应子序列的第一个元素，因此x用A[l]来赋值。

100
00:07:14,370 --> 00:07:19,300
我们还会保留提到的两个子区域。

101
00:07:19,300 --> 00:07:24,110
首先，我们会逐渐扩大已知元素的范围。

102
00:07:24,110 --> 00:07:28,479
我们把i从l+1移动到r，在这个范围内，

103
00:07:28,479 --> 00:07:33,735
[自动的英语字幕又失误了]对于每一个被发现的元素，我们用两个子区域来存放它们。

104
00:07:33,735 --> 00:07:37,208
第一个区域的角标是l+1到j，

105
00:07:37,208 --> 00:07:40,210
我们存放不大于x的元素；

106
00:07:40,210 --> 00:07:45,310
第二个区域的角标是j+1到i，我们存放

107
00:07:45,310 --> 00:07:50,310
比x大的元素。我们会逐渐增加i的值。

108
00:07:50,310 --> 00:07:54,770
每当i+1，

109
00:07:54,770 --> 00:07:57,110
我们就会发现一个新元素A[i]。

110
00:07:57,110 --> 00:08:01,750
如果A[i]比x大，那么

111
00:08:01,750 --> 00:08:06,170
第二个区域，比x大的区域，

112
00:08:06,170 --> 00:08:10,830
就会自动扩大，这种情况下我们不需要额外的操作。

113
00:08:10,830 --> 00:08:14,930
然而如果新发现的元素不大于x，

114
00:08:14,930 --> 00:08:17,830
那我们需要把它挪到第一个区域。

115
00:08:17,830 --> 00:08:19,940
我们执行如下操作：

116
00:08:19,940 --> 00:08:23,525
我们给j加一，来体现出

117
00:08:23,525 --> 00:08:28,019
第一个区域的范围扩大了，然后交换元素，

118
00:08:28,019 --> 00:08:31,043
交换A[j]和A[i]，这样一来，

119
00:08:31,043 --> 00:08:37,130
每次i增加1，我们的两条不变的原则就得以保持。

120
00:08:37,130 --> 00:08:40,970
在最后的最后，i的值达到了r的时候，

121
00:08:40,970 --> 00:08:45,350
我们还需要把第一个元素，

122
00:08:45,350 --> 00:08:50,520
我们的基准元素，移动到我们的两个区域中间。

123
00:08:50,520 --> 00:08:57,291
为此我们交换我们的基准元素A[l]和元素A[j]。

124
00:08:57,291 --> 00:09:03,097
最后我们返回的值是基准元素的角标，j。