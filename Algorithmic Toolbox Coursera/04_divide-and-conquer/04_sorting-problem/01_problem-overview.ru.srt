1
00:00:00,600 --> 00:00:04,380
Здравствуйте, и добро пожаловать на занятие, 
посвященное задаче о сортировке.

2
00:00:05,870 --> 00:00:08,750
Как обычно, я начну с обзора задачи.

3
00:00:10,090 --> 00:00:14,270
Сортировка - фундаментальная вычислительная задача.

4
00:00:14,270 --> 00:00:18,480
Входные данные в этой задаче представляют
собой последовательность элементов, и

5
00:00:18,480 --> 00:00:23,000
ваша задача - отобразить эти элементы,
например, в невозрастающем порядке.

6
00:00:24,580 --> 00:00:27,680
Формальная постановка задачи следующая.

7
00:00:27,680 --> 00:00:30,360
Вам дана последовательность конечных элементов

8
00:00:30,360 --> 00:00:33,950
Здесь мы будем обозначать её как A.

9
00:00:33,950 --> 00:00:38,860
Ваша задача - напечатать те же элементы
в неубывающем порядке.

10
00:00:40,560 --> 00:00:41,470
Еще раз,

11
00:00:41,470 --> 00:00:47,330
сортировка - это важная вычислительная задача,
решение которой используется во многих эффективных алгоритмах.

12
00:00:47,330 --> 00:00:50,460
Для некоторых алгоритмов
важно просто представить

13
00:00:50,460 --> 00:00:55,290
данные элементы в неубывающем порядке,
от наименьшего к наибольшему

14
00:00:55,290 --> 00:00:59,090
В некоторых других алгоритмах,
просто сортируя входные данные,

15
00:00:59,090 --> 00:01:03,440
вы получаете возможность выполнять 
ваши запросы намного эффективнее

16
00:01:03,440 --> 00:01:07,000
Стандартный пример такой 
ситуации - задача о поиске

17
00:01:07,000 --> 00:01:09,550
В данной задаче нам дана последовательность 
из конечного числа элементов.

18
00:01:09,550 --> 00:01:13,150
Ваша задача здесь - проверить,
находится ли данный элемент

19
00:01:13,150 --> 00:01:14,380
в вашей последовательности.

20
00:01:14,380 --> 00:01:19,040
Конечно, эту задачу можно решить,
просто сканируя эту последовательность

21
00:01:19,040 --> 00:01:24,960
слева направо и проверять,
находится ли необходимый элемент в этой последовательности.

22
00:01:24,960 --> 00:01:27,660
Это даёт вам работающий за линейное время алгоритм.

23
00:01:27,660 --> 00:01:31,060
И, как вы уже знаете,
если вы подаёте на вход данные,

24
00:01:31,060 --> 00:01:36,110
в виде отсортированной последовательности,
вы сможете сделать это намного быстрее.

25
00:01:36,110 --> 00:01:40,980
На самом деле, это можно сделать
за логарифмическое время от размера входной последовательности.

26
00:01:40,980 --> 00:01:43,799
Сначала вы сравниваете ваш элемент 
с элементом посередине.

27
00:01:45,060 --> 00:01:49,710
Если это нужный элемент, то 
мы закончили, если нет, вы продолжаете

28
00:01:49,710 --> 00:01:53,320
искать элемент в левой
или правой части вашего массива.

29
00:01:53,320 --> 00:01:57,620
В худшем случае за логарифмическое
число сравнений вы

30
00:01:57,620 --> 00:02:01,840
сможете сказать, находится ли ваш элемент
в этой последовательности или нет

31
00:02:01,840 --> 00:02:06,010
Итак, вам дана последовательность
и вы ожидаете большое количество таких запросов.

32
00:02:06,010 --> 00:02:12,370
Вас будут спрашивать о том, 
находится ли заданный объект в массиве или нет.

33
00:02:12,370 --> 00:02:17,840
Часто бывает крайне полезным
сначала отсортировать ваши входные данные и

34
00:02:17,840 --> 00:02:20,830
только затем производить все эти запросы.

35
00:02:20,830 --> 00:02:24,210
Это даст вам в целом намного
более эффективный алгоритм.

36
00:02:24,210 --> 00:02:25,060
действий, побуждающих большое число
людей к взаимодействию,

37
00:02:25,060 --> 00:02:27,290
И это лишь небольшой пример.

38
00:02:27,290 --> 00:02:29,140
Мы увидим много других ситуаций,

39
00:02:29,140 --> 00:02:34,720
когда изначальная сортировка входных данных
помогает обрабатывать запросы намного эффективнее

40
00:02:34,720 --> 00:02:37,851
Итак, в следующих видео
данного урока

41
00:02:37,851 --> 00:02:41,498
мы изучим множество эффективных алгоритмов сортировки.