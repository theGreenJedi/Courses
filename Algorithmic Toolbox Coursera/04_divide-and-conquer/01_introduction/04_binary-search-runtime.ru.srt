1
00:00:00,170 --> 00:00:03,980
Привет! На этом видео мы посмотрим на время выполнения функции бинарного поиска,

2
00:00:03,980 --> 00:00:06,510
а также его итеративной версии.

3
00:00:06,510 --> 00:00:08,840
Итак, вот наш алгоритм бинарного поиска.

4
00:00:08,840 --> 00:00:11,480
Мы смотрим на середину, если ключ не найден,

5
00:00:11,480 --> 00:00:13,710
то мы либо ищем в нижней, либо в верхней половине.

6
00:00:14,760 --> 00:00:18,030
Тогда как выглядит наше рекуррентное соотношение для худшего случая времени выполнения?

7
00:00:18,030 --> 00:00:20,894
Собственно, худший случай - это если мы не нашли элемент.

8
00:00:20,894 --> 00:00:27,696
Посмотрим на T(n), равное T от приблизительно n/2 плюс c.

9
00:00:27,696 --> 00:00:32,330
n/2 округляется вниз, поскольку, если n нечётное,

10
00:00:32,330 --> 00:00:36,780
допустим, в массиве 5 элементов, то вопрос стоит так:

11
00:00:36,780 --> 00:00:40,085
каков объём задачи при следующем вызове?

12
00:00:40,085 --> 00:00:44,306
Если у нас 5 элементов, мы будем искать либо в верхней половине

13
00:00:44,306 --> 00:00:44,815
массива.

14
00:00:44,815 --> 00:00:47,665
эти два элемента, либо в нижней половине, вот эти два элемента.

15
00:00:47,665 --> 00:00:49,055
Так как мы пропускаем середину,

16
00:00:49,055 --> 00:00:50,575
мы уже проверили её.

17
00:00:50,575 --> 00:00:57,660
Плюс определённый константный объём работы для вычисления середины,

18
00:00:57,660 --> 00:01:01,000
а также для проверки середины на равенство ключу.

19
00:01:01,000 --> 00:01:07,500
И затем наш базовый случай, когда имеем пустой массив.

20
00:01:07,500 --> 00:01:09,580
И это просто константное время выполнения проверки.

21
00:01:11,260 --> 00:01:12,460
Тогда как выглядит время выполнения?

22
00:01:12,460 --> 00:01:15,130
У нас есть наш исходный размер n, и мы будем разбивать его,

23
00:01:15,130 --> 00:01:16,250
n на 2, n на 4.

24
00:01:16,250 --> 00:01:17,710
И так далее, до самого низа.

25
00:01:17,710 --> 00:01:21,150
Как много здесь таких задач?

26
00:01:21,150 --> 00:01:23,880
В целом, если мы разбиваем что-либо на 2 части снова и снова,

27
00:01:23,880 --> 00:01:29,030
на это понадобится логарифм по основанию 2 таких итераций, пока мы не дойдём до 1.

28
00:01:29,030 --> 00:01:34,400
Итого, получаем двоичный логарифм от n + 1.

29
00:01:34,400 --> 00:01:37,410
Объём выполняемой работы равен c.

30
00:01:37,410 --> 00:01:40,900
Значит, на каждом уровне мы выполняем c работы.

31
00:01:40,900 --> 00:01:42,730
То есть полный объём работы, если мы суммируем её,

32
00:01:42,730 --> 00:01:46,480
это сумма с по индексу i от 0 до двоичного логарифма n.

33
00:01:47,760 --> 00:01:54,110
Это то же, что двоичный логарифм n + 1, что равно двоичному логарифму n, это количество, плюс 1, умноженное на с.

34
00:01:55,110 --> 00:01:58,330
И это равно тета от двоичного логарифма n, но

35
00:01:58,330 --> 00:02:04,207
мы обычно говорим тета от логарифма n, поскольку основание логарифма не имеет значения.

36
00:02:04,207 --> 00:02:06,379
Это просто константный множитель.

37
00:02:08,892 --> 00:02:12,315
Хорошо, как будет выглядеть итеративная версия?

38
00:02:12,315 --> 00:02:16,600
Итеративная версия принимает те же параметры: низ, верх и ключ.

39
00:02:16,600 --> 00:02:20,350
И у нас есть цикл, подобный тому, который был в базовом случае,

40
00:02:20,350 --> 00:02:26,570
в базовом случае в рекурсивной версии мы останавливались, когда верх был меньше низа.

41
00:02:26,570 --> 00:02:30,510
Теперь у нас цикл while, который завершается при условии, что верх меньше низа.

42
00:02:30,510 --> 00:02:33,790
Мы вычисляем середину и проверяем ключ.

43
00:02:33,790 --> 00:02:38,750
Если он совпадает со средним элементом, возвращаем середину. В ином случае,

44
00:02:38,750 --> 00:02:40,310
если ключ меньше

45
00:02:40,310 --> 00:02:43,452
элемента, мы знаем, что нам нужна первая половина массива, и поэтому,

46
00:02:43,452 --> 00:02:47,308
вместо следующего рекурсивного вызова, как в рекурсивной версии, мы берём

47
00:02:47,308 --> 00:02:48,401
исходный массив.

48
00:02:48,401 --> 00:02:52,953
И мы хотим проверить его первую половину, поэтому мы меняем значение

49
00:02:52,953 --> 00:02:57,790
верхней границы и устанавливаем его равным середине минус 1,
потому что мы уже проверили середину.

50
00:02:57,790 --> 00:03:02,540
В ином случае, мы хотим проверить вторую
 половину массива, поэтому сдвигаем нижнюю границу вверх.

51
00:03:05,340 --> 00:03:08,070
Если мы дошли до конца цикла,

52
00:03:08,070 --> 00:03:11,310
То есть если мы вышли из цикла while, поскольку верх стал меньше низа,

53
00:03:11,310 --> 00:03:13,040
это означает, что нам больше негде вести поиск.

54
00:03:13,040 --> 00:03:14,200
Наш массив пуст.

55
00:03:14,200 --> 00:03:17,030
И, следовательно,
мы не нашли нужный элемент в массиве.

56
00:03:17,030 --> 00:03:18,740
Мы возвратим низ минус 1.

57
00:03:18,740 --> 00:03:21,408
То есть тот же результат, что и в рекурсивной версии.

58
00:03:21,408 --> 00:03:24,228
Отличие в том, что мы не будем
использовать память в стеке, которую

59
00:03:24,228 --> 00:03:25,730
использует рекурсивная версия.

60
00:03:25,730 --> 00:03:30,736
Как вы помните, два видео назад мы говорили
 о примере из реальной жизни, где у нас было

61
00:03:30,736 --> 00:03:35,905
пять языков, и мы переводили
слова с одного из этих языков на любой другой.

62
00:03:35,905 --> 00:03:39,924
Это было представлено в виде
параллельных массивов, таким образом, что

63
00:03:39,924 --> 00:03:44,388
под любым заданным индексом
соответствующие элементы в массивах

64
00:03:44,388 --> 00:03:49,051
являлись переводами одного и того же слова
на все эти языки.

65
00:03:49,051 --> 00:03:53,362
Например, "chair"
в английском стоит под индексом 2, а

66
00:03:53,362 --> 00:03:57,597
в испанском это "silla", а
в итальянском - "sedia".

67
00:03:57,597 --> 00:04:01,439
Проблемой было то, что поиск в этой структуре занимал долгое время, так?

68
00:04:01,439 --> 00:04:05,970
У нас было по 50 тысяч элементов в массивах, и поиск занимал около 10 секунд,

69
00:04:05,970 --> 00:04:08,820
Потому что нам приходилось действительно просматривать все слова,

70
00:04:08,820 --> 00:04:11,530
если там не было нужного, а в среднем,
половину из них, 25 тысяч.

71
00:04:11,530 --> 00:04:14,304
Поэтому мог бы возникнуть вопрос: почему мы не использовали отсортированный массив?

72
00:04:14,304 --> 00:04:14,886
Верно?

73
00:04:14,886 --> 00:04:17,890
Представьте себе, к примеру, сортировку этих массивов.

74
00:04:17,890 --> 00:04:18,898
Вот они в отсортированном виде.

75
00:04:18,898 --> 00:04:23,930
Хорошо то, что теперь легко найти конкретное слово в конкретном языке.

76
00:04:23,930 --> 00:04:26,460
Так, я могу найти "house" (дом) в английском,
например, и

77
00:04:26,460 --> 00:04:30,060
очень быстро определить, под каким оно индексом,
 используя бинарный поиск.

78
00:04:30,060 --> 00:04:31,150
Проблема в том,

79
00:04:31,150 --> 00:04:35,450
что у меня больше нет того соответствия,
поскольку порядок отсортированных слов

80
00:04:35,450 --> 00:04:38,700
в английском языке отличается от
порядка отсортированных слов в испанском.

81
00:04:38,700 --> 00:04:43,000
Поэтому, если я посмотрю на слово "chair", например,
 в английском, оно уже не соответствует слову "silla".

82
00:04:43,000 --> 00:04:46,040
Вместо этого, оно соответствует слову "casa".

83
00:04:46,040 --> 00:04:49,922
Поэтому, хоть мы и можем найти определённое
 слово в нашем исходном языке,

84
00:04:49,922 --> 00:04:53,816
мы не знаем соответствующего
 слова в языке перевода.

85
00:04:53,816 --> 00:04:58,963
Поэтому решением было попробовать
найти какой-то способ отсортировать данные, но при этом

86
00:04:58,963 --> 00:05:04,474
сохранить связь, 
при которой все элементы под одним индексом представляли

87
00:05:04,474 --> 00:05:10,638
одно и то же переведенное слово. Это было сделано
путём добавления ещё одного набора массивов.

88
00:05:10,638 --> 00:05:15,237
Вот что мы сделали: хранили эти
дополнительные массивы, которые представляли собой

89
00:05:15,237 --> 00:05:20,270
указатели на исходные
массивы в отсортированном порядке.

90
00:05:20,270 --> 00:05:22,230
Так у нас появляется что-то вроде уровня перенаправления.

91
00:05:22,230 --> 00:05:25,630
И если я, например, смотрю на английский,
то порядок слов в английском будет: chair,

92
00:05:25,630 --> 00:05:26,580
house, pimple.

93
00:05:26,580 --> 00:05:29,180
Тогда, какой порядок это означает
для исходного массива?

94
00:05:29,180 --> 00:05:35,820
Это значит: первый элемент 2,
затем элемент 1 и затем элемент 3.

95
00:05:35,820 --> 00:05:39,808
И если вы хотите произвести бинарный поиск,
вы можете воспользоваться этим отсортированным массивом.

96
00:05:39,808 --> 00:05:41,950
Когда вы хотите узнать, какой элемет

97
00:05:43,440 --> 00:05:45,840
в этом отсортированном массиве.

98
00:05:45,840 --> 00:05:49,320
Например, если мы посмотрим на средний элемент, 

99
00:05:49,320 --> 00:05:53,740
который в отсортированном массиве второй, он имеет
значение 1, и это указывает на слово house.

100
00:05:53,740 --> 00:05:58,620
Поэтому мы можем сказать,
что house как бы находится в элементе 2, а

101
00:05:58,620 --> 00:06:01,500
chair - в элементе 1, а pimple - в элементе 3.

102
00:06:01,500 --> 00:06:04,080
В испанском, само собой, 
другое соответствие, поэтому

103
00:06:04,080 --> 00:06:08,890
в испанском первое по порядку сортировки слово
оказалось первым словом в массиве.

104
00:06:08,890 --> 00:06:12,230
Второе отсортированное слово - это третье
слово в испанском массиве, а

105
00:06:12,230 --> 00:06:16,830
третье отсортированное слово, silla, - это второй элемент.

106
00:06:17,960 --> 00:06:19,300
Так что же произошло, когда мы так поступили?

107
00:06:19,300 --> 00:06:22,120
Мы пошли на компромисс между временем выполнения и памятью.

108
00:06:23,300 --> 00:06:25,560
Нам пришлось заплатить дополнительным пространством памяти.

109
00:06:25,560 --> 00:06:29,320
И появились, конечно, не только английский
и испанский отсортированные массивы, но также французский,

110
00:06:29,320 --> 00:06:30,310
итальянский и немецкий.

111
00:06:30,310 --> 00:06:32,950
То есть 5 массивов, дополнительных массивов.

112
00:06:32,950 --> 00:06:33,450
Каждый массив

113
00:06:33,450 --> 00:06:38,240
содержит 50000 записей, а каков
размер каждого элемента массива?

114
00:06:38,240 --> 00:06:41,530
Собственно, он представляет собой номер
от 1 до 50000, что

115
00:06:41,530 --> 00:06:44,590
может быть представлено в
16 битах, что равно 2 байтам.

116
00:06:44,590 --> 00:06:48,080
То есть у нас 50000 элементов, умноженных на 2 байта,

117
00:06:48,080 --> 00:06:52,120
это 100 тысяч байтов,
умноженных на 5, что равно 500 тысячам байтов.

118
00:06:52,120 --> 00:06:55,300
То есть примерно полмегабайта,
что в наши дни практически ничто.

119
00:06:55,300 --> 00:06:58,580
И даже в то время, 20 лет назад,
это было вполне выполнимо.

120
00:07:00,280 --> 00:07:02,840
Такова цена, которую мы платим в отношении пространства.

121
00:07:02,840 --> 00:07:06,260
Какой мы получаем выигрыш?

122
00:07:06,260 --> 00:07:11,130
Собственно, вместо того, чтобы сделать, скажем,
50000 проверок в худшем случае,

123
00:07:11,130 --> 00:07:13,152
нам придётся сделать двоичный логарифм
от 50000 проверок.

124
00:07:13,152 --> 00:07:19,479
Двоичный логарифм от 50000 - это около, давайте посмотрим,
двоичный логарифм от 1000 - это около 10,

125
00:07:19,479 --> 00:07:24,160
поскольку 2 в 10 степени равно 1024, тогда
у нас ещё остаётся множитель 50.

126
00:07:24,160 --> 00:07:26,092
Двоичный логарифм 50 - это около,

127
00:07:26,092 --> 00:07:31,979
скажем, 6, потому что я знаю, что 2 в
5 степени равно 32, 2 в 6 - 64.

128
00:07:31,979 --> 00:07:33,408
Тогда, это значит, что

129
00:07:33,408 --> 00:07:37,574
мы получаем 16 обращений к массиву
вместо 50000.

130
00:07:37,574 --> 00:07:41,039
Это улучшение почти в 1000 раз, то есть

131
00:07:41,039 --> 00:07:46,583
в итоге это означало, что
когда пользователь нажимал "перевести",

132
00:07:46,583 --> 00:07:53,250
вместо того, чтобы занять 10 секунд,
перевод выполнялся почти мгновенно.

133
00:07:53,250 --> 00:07:56,420
Это было менее 1/10 секунды.

134
00:07:57,590 --> 00:07:58,190
Итак, подводя итог,

135
00:07:58,190 --> 00:08:03,130
Мы увидели, что время выполнения
бинарного поиска - тета от логарифма n.

136
00:08:03,130 --> 00:08:08,810
Существенно быстрее, чем тета от n, требуемое для линейного поиска.

137
00:08:08,810 --> 00:08:11,200
Следовательно, отсортированные массивы действительно эффективны.

138
00:08:11,200 --> 00:08:13,920
На следующем уроке мы
рассмотрим более сложное

139
00:08:13,920 --> 00:08:15,670
применение подхода "разделяй и властвуй",

140
00:08:15,670 --> 00:08:19,630
где у нас будет несколько
подзадач вместо всего одной подзадачи.