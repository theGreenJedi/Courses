Привет! Итак, теперь давайте поговорим о бинарном поиске. Словарь - это хороший
пример упорядоченного списка, где все слова находятся в определённом порядке. И это делает поиск слов гораздо проще. Вы можете представить себе, как сложно
было бы искать слова в словаре, если бы их порядок был случайным. Вам бы пришлось просмотреть
каждую страницу, и, фактически, каждое слово на каждой странице. Это бы потребовало достаточно долгого времени. Поэтому давайте рассмотрим постановку задачи
поиска в отсортированном массиве. Итак, нам дан массив А вместе с нижней и верхней границей, указывающими пределы
внутри массива, в которых следует вести поиск. Важной особенностью массива
является то, что он отсортирован. Под этим подразумевается, что если мы посмотрим
на произвольный элемент под индексом i, а затем на следующий элемент, то первый элемент будет не больше второго. Мы не говорим "меньше", поскольку допускаем наличие массивов с повторяющимися элементами. Это называется монотонный неубывающий массив. Ещё одно исходное значение - ключ, который нужно найти. Выходное значение - любой из индексов, под которым находится элемент, равный ключу. Мы говорим "любой из них", поскольку, в отличие от рассмотренного ранее линейного поиска, здесь может быть более одного элемента - более одного совпадающего с ключом элемента, поскольку в массиве могут быть повторяющиеся значения. Если совпадение не найдено, вместо того, чтобы возвратить НЕ_НАЙДЕНО (NOT_FOUND), как мы делали в случае с линейным поиском, Мы вернём несколько более полезную информацию, а именно - позицию в массиве, куда вы могли бы вставить искомый элемент, если бы захотели. Или где он находился бы, если бы присутствовал в массиве. То есть мы возвращаем наибольший индекс i, для которого A[i] меньше k. Таким образом, если ключ отсутствует в массиве, мы возвращаем индекс, элемент под которым меньше ключа, но следующий за ним элемент больше ключа. Также мы должны задуматься: что если все элементы в массиве больше ключа? В этом случае мы сразу же возвратим -1. Взгляните на пример. У нас есть массив из 7 элементов, в котором элемент 20 повторяется. Если мы ищем в этом массиве 2, мы возвращаем 0, сообщая таким образом, что все элементы массива больше данного. Если же мы ищем 3, то возвращаем 1. Если ищем 4, мы также возвращаем 1, что на самом деле означает "между 1 и 2". То есть это больше, чем 3, но меньше, чем 5. Если мы ищем 20, то возвращаем 4. Также мы могли бы вернуть 5. Любое из значений верно, поскольку под обоими этими индексами находится число 20. А если мы ищем 60, то возвратим 7. Но если мы ищем 70, мы также возвратим 7. Итак, давайте посмотрим на нашу реализацию бинарного поиска. Мы напишем рекурсивную функцию, принимающую в качестве аргументов А, нижнюю и верхнюю границы и ключ, в точности как мы обозначили в постановке задачи. Сначала наш базовый случай. Если у нас пустой массив, то есть верхняя граница меньше нижней, следовательно, элементов нет, то мы возвращаем -1. Иначе, мы вычислим среднюю точку. Нам нужно что-то посередине между нижней и верхней границей. Поэтому мы вычислим ширину, вычтя из верхней границы нижнюю, разобьём пополам, разделив результат на 2, а затем прибавим это к нижней границе. Это может не быть целым числом, поскольку верх минус низ, разделенное на 2, может иметь дробную часть, поэтому мы округлим результат вниз. Например, в предыдущем случае у нас были границы 1 и 7, тогда 7 - 1 = 6, разделить на 2 будет 3, плюс нижняя граница 1, получим 4, то есть серединой будет 4. Скоро мы увидим это на примере. Теперь мы проверяем, равен ли элемент в этой середине нашему ключу. Если да, то мы закончили, возвращаем её. Если нет, то хорошая новость состоит в том, что, конечно, нам не придётся проверять все остальные элементы, половину их мы исключили. Так что, если ключ меньше, чем средний элемент, то мы игнорируем все, стоящие за ним. Поэтому мы продолжаем и возвращаем результат бинарного поиска в массиве А от нижней границы до середины - 1, полностью игнорируя всё, что находится там, далее. В противном случае, ключ больше середины, и, опять же, мы можем отбросить всё, стоящее ниже, и, начиная с середины + 1, идти далее, до верхней границы. Рассмотрим пример. Допустим, мы ищем ключ 50 в этом массиве из 11 элементов. То есть мы произведём бинарный поиск в этом массиве, начиная от индекса 1 до 11, и будем искать число 50. Низ равен 1, верх равен 11. Вычислим середину, она будет равна 11 - 1 = 10, разделить на 2 = 5, прибавить это к 1, середина равна 6. И теперь мы проверяем, равен ли элемент в середине 50? Собственно, нет. Средний элемент равен 15, а элемент, который мы ищем, искомый ключ, равен 50. Поэтому мы идём дальше, игнорируя первую половину массива и теперь вызываем функцию бинарного поиска снова, с нижней границей, равной 7, то есть на 1 больше середины. То есть теперь мы получили уменьшенную версию задачи. Мы ищем 50 среди элементов от индекса 7 до 11, вычисляем середину. 11 - 7 = 4, разделённое на 2 = 2, теперь прибавим это к 7 и получим середину, равную 9. Проверяем, равен ли элемент под индексом 9 нашему ключу? Элемент под индексом 9 равен 20, а наш ключ 50, они не равны. Однако, 50 больше 20, поэтому мы идём дальше и делаем новый рекурсивный вызов с середины + 1, что равно 10, Итак, снова, мы производим бинарный поиск от 10 до 11. Рассчитываем середину. Низ минус верх, 11 - 10 = 1, разделённое на 2 равно 0,5, + 10, получим 10,5, округляем вниз, получаем 10 с половиной, то есть наша середина равна 10 с половиной. Я прошу прощения, наша середина равна 10. Теперь проверяем. Элемент 10 равен нашему ключу? Элемент 10 равен 50, наш ключ равен 50, значит, да. Далее мы возвращаем середину, которая равна 10. Подводя итог, мы разбили задачу на непересекающиеся подзадачи того же типа. Мы рекурсивно решили подзадачи. И затем мы объединяем решения этих подзадач. Мы выделили из задачи вдвое меньшую по размеру задачу. (чуть меньше, чем половина исходной). Мы рекурсивно решили эту подзадачу и затем мы очень легко объединили решения, просто возвратив результат. На следующем видео мы продолжим и увидим время выполнения для бинарного поиска, а также итеративной версии. И мы вернёмся к обсуждению проблемы, которую я упоминал в задаче перевода с помощью словаря. Скоро увидимся.