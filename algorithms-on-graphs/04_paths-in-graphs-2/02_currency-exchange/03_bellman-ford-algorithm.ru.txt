Привет, в этом видео мы изучим 
алгоритм Беллмана-Форда, это алгоритм для нахождения кратчайших путей на взвешанных графах,
где ребра могут иметь отрицательный вес. Кстати, Вы помните "простой" алгоритм,
 о котором мы рассказывали в предыдущем уроке алгоритм Дейкстры? На самом деле, алгоритм Декстры  достаточно эффективен и алгоритм Беллмана-Форда во многом 
схож с алгоритмом Дейкстры. Алгоритм Дейкстры основан на 
пересчете весов ребер  на каждом шаге. и в определенный момент он гарантированно завершается. Мы не оценивали время выполения алгоритма. Но мы покажем, что алгоритм Беллмана-Форда имеет преимущество над алгоритмолм Дейкстры, 
он работает с графами имеющими отрицательные веса ребер. Он немного медленнее алгоритма Дейкстры, но он работает с графами, чьи ребра имеют произвольный вес. Итак, вот как выглядит алгоритм Беллмана-Форда. На входе алгоритма мы имеем граф
 и стартовую вершину. Требуется найти кратчайший путь из этой 
стартовой вершины во все остальные вершины графа. Заметим, однако, что этот алгоритм предполагает что граф G не имеет циклов с отрицательным весом. В противном случае, алгоритм будет выполнен, но он возвратит не верное расстояние для некоторых вершин. Поэтому, если мы знаем, что граф G не имеет циклов 
с отрицательным весом, алгоритм даст ожидаемый результат. Мы обсудим позже, что делать если граф 
содержит циклы с отрицательным весом. Итак, представленный алгоритм использует
те же значения "dist" и "prev" переменных как b f s и
алгоритм Дейкстры. Он устанавливает их тем же образом,
в бесконечность для расстояний За исключением стартовой вершины "s" и
элементов массива "prev" указывают в никуда. И затем запускам цикл длинной V-1. Где V - число вершин в графе. Мы пересчитываем все ребра
в графе по порядку. В целом, это и есть алгоритм Беллмана-Форда. И кстати, повторение V-1 раз в цикле
чрезмерно. Мы можем вернуться к схеме
использованной в алгоритме Декстры Где мы вычисляем веса свех ребер
до хер пор пока это возможно. Это может быть сделано, и
алгоритм будет работать быстрее чем алгоритм Беллмана-Форда, в случае когда
граф не содержит циклов с отрицательным весом. Псевдо-код который Вы видите здесь
написан из соображений простоты и наглядности с целью доказать корректность 
алгоритмов в данной реализации. Но, это полезно знать, 
что если на определенной итерации в течении V-y итерациий ничего
не поменялось, ребра не изменили веса, мы можем просто остановить вычисления и 
расстояния будут корректными. Теперь, давайте оценим время выполнения
представленного алгоритма. Я утверждаю, что оно пропорцилнально
произведению числа вершин и числа ребер. Это медленнее, чем алгоритм Дейкстры,
производительность которого V квадрат для реализации на основе массива и
даже e + v log v при реализации на основе сортирующих деревьев,
двоичных сортирующих деревьев. Несмотря на то, что алгоритм работает дольше,
он корректен при наличии ребер с отрицательным
весом Итак, в начале мы просто инициализируем
"dist" и "prev" переменные, за время пропорциолнальное
колличеству вершин. И затем выполняем V-1 итераций Каждая итерация выполняется за время
пропорциональное  числу ребер, поскольку изменение весов ребер
выполняетя за фиксированное время. Так что, в целом, мы получаем время
пропорциональное VE. Теперь, давайте посмотрим на конкретный пример
работы алгоритма Беллмана-Форда. на конкретном графе. Итак, начальная вершина обозначена символом S И значения 0 и бесконечность, обозначенные 
голубым цветом это начальные дистанции. И числа возле ребер это их веса. Таким образом, мы берем
все ребра в заданном порядке начиная с ребра весом 4. И попробуем пересчитать их. Таким образом значение "dist" для
А изменится с бесконечности на 4. Берем следующее ребро с длинной 3 и меняем значени dist для B
с бесконечности на 3. Берем ребро с весом -2 и далее меняем значение dist для
B с 3 на 2. Затем,  смотрим на ребро из А в С и
меняем бесконечность на 8. Затем, смотрим ребро из B в С и
меняем его с 8 на -1. Далее, переходим к ребру из B в D и
меняем значение с бесконечности на 3. И, смотрим на ребро из C в D и
меняем значение с 3 на 1. Это только первая итерация 
алгоритма Беллмана-Форда. Теперь посмотрим, что происходит
на следующей итерации. Рассмотрим ребро из S в A,
здесь ничего нельзя улучшить. Это ребро ничего не улучшает. Это ребро не улучшает. Это ребро также не улучшает. И этот не улучшает. И этот не улучшает. И этот не улучшает. И таким образом, уже на второй итерации,
ничего нельзя улучшить. И мы можем остановить алгоритм,
уже после второй итерации. И вместо V*E числа операций, только E, посольку мы совершили лишь 
одну итерацию по всем ребрам. На практике, это частый случай. Но для некоторых графов, разумеется,
потребуется гораздо больше итераций. Итак, мы уже знаем финальный результат расстояния которые врозвращает
алгоритм Беллмана-Форда И в следующем видео
мы докажем, что алгоритм возвращает корректные расстояния, при 
отсутствии циклов с отрицательными весами.