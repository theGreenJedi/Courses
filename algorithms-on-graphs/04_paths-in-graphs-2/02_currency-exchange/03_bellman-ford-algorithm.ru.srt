1
00:00:00,200 --> 00:00:03,630
Привет, в этом видео мы изучим 
алгоритм Беллмана-Форда,

2
00:00:03,630 --> 00:00:04,830
это алгоритм для

3
00:00:04,830 --> 00:00:08,450
нахождения кратчайших путей на взвешанных графах,
где ребра могут иметь отрицательный вес.

4
00:00:09,740 --> 00:00:13,555
Кстати, Вы помните "простой" алгоритм,
 о котором мы рассказывали в предыдущем уроке

5
00:00:13,555 --> 00:00:15,120
алгоритм Дейкстры?

6
00:00:15,120 --> 00:00:17,815
На самом деле, алгоритм Декстры  достаточно эффективен и 

7
00:00:17,815 --> 00:00:22,860
алгоритм Беллмана-Форда во многом 
схож с алгоритмом Дейкстры.

8
00:00:22,860 --> 00:00:27,901
Алгоритм Дейкстры основан на 
пересчете весов ребер  на каждом шаге.

9
00:00:27,901 --> 00:00:30,160
и в определенный момент он гарантированно завершается.

10
00:00:30,160 --> 00:00:33,780
Мы не оценивали время выполения алгоритма.

11
00:00:33,780 --> 00:00:35,960
Но мы покажем, что алгоритм Беллмана-Форда имеет 

12
00:00:36,980 --> 00:00:42,290
преимущество над алгоритмолм Дейкстры, 
он работает с графами имеющими отрицательные веса ребер.

13
00:00:42,290 --> 00:00:46,073
Он немного медленнее алгоритма Дейкстры, но

14
00:00:46,073 --> 00:00:48,900
он работает с графами, чьи ребра имеют произвольный вес.

15
00:00:50,130 --> 00:00:53,270
Итак, вот как выглядит алгоритм Беллмана-Форда.

16
00:00:53,270 --> 00:00:58,320
На входе алгоритма мы имеем граф
 и стартовую вершину.

17
00:00:58,320 --> 00:01:03,460
Требуется найти кратчайший путь из этой 
стартовой вершины во все остальные вершины графа.

18
00:01:03,460 --> 00:01:08,110
Заметим, однако, что этот алгоритм предполагает

19
00:01:08,110 --> 00:01:10,300
что граф G не имеет циклов с отрицательным весом.

20
00:01:11,510 --> 00:01:14,100
В противном случае, алгоритм будет выполнен, но

21
00:01:14,100 --> 00:01:19,450
он возвратит не верное расстояние для некоторых вершин.

22
00:01:19,450 --> 00:01:22,908
Поэтому, если мы знаем, что граф G не имеет циклов 
с отрицательным весом,

23
00:01:22,908 --> 00:01:26,220
алгоритм даст ожидаемый результат.

24
00:01:26,220 --> 00:01:30,199
Мы обсудим позже, что делать если граф 
содержит циклы с отрицательным весом.

25
00:01:31,390 --> 00:01:35,120
Итак, представленный алгоритм использует
те же значения "dist" и

26
00:01:35,120 --> 00:01:38,990
"prev" переменных как b f s и
алгоритм Дейкстры.

27
00:01:38,990 --> 00:01:44,530
Он устанавливает их тем же образом,
в бесконечность для расстояний

28
00:01:44,530 --> 00:01:50,360
За исключением стартовой вершины "s" и
элементов массива "prev" указывают в никуда.

29
00:01:50,360 --> 00:01:53,900
И затем запускам цикл длинной V-1. 

30
00:01:53,900 --> 00:01:57,040
Где V - число вершин в графе.

31
00:01:57,040 --> 00:02:00,280
Мы пересчитываем все ребра
в графе по порядку.

32
00:02:01,390 --> 00:02:03,680
В целом, это и есть алгоритм Беллмана-Форда.

33
00:02:03,680 --> 00:02:09,110
И кстати, повторение V-1 раз в цикле
чрезмерно. 

34
00:02:09,110 --> 00:02:16,153
Мы можем вернуться к схеме
использованной в алгоритме Декстры

35
00:02:16,153 --> 00:02:22,650
Где мы вычисляем веса свех ребер
до хер пор пока это возможно.

36
00:02:23,870 --> 00:02:28,650
Это может быть сделано, и
алгоритм будет работать быстрее

37
00:02:28,650 --> 00:02:33,060
чем алгоритм Беллмана-Форда, в случае когда
граф не содержит циклов с отрицательным весом.

38
00:02:33,060 --> 00:02:37,791
Псевдо-код который Вы видите здесь
написан из соображений простоты и наглядности

39
00:02:37,791 --> 00:02:41,300
с целью доказать корректность 
алгоритмов в данной реализации.

40
00:02:41,300 --> 00:02:46,710
Но, это полезно знать, 
что если на определенной итерации

41
00:02:46,710 --> 00:02:51,940
в течении V-y итерациий ничего
не поменялось, ребра не изменили веса,

42
00:02:51,940 --> 00:02:56,830
мы можем просто остановить вычисления и 
расстояния будут корректными.

43
00:02:58,480 --> 00:03:01,200
Теперь, давайте оценим время выполнения
представленного алгоритма.

44
00:03:01,200 --> 00:03:06,430
Я утверждаю, что оно пропорцилнально
произведению числа вершин и

45
00:03:06,430 --> 00:03:07,170
числа ребер.

46
00:03:07,170 --> 00:03:12,190
Это медленнее, чем алгоритм Дейкстры,
производительность которого V квадрат

47
00:03:12,190 --> 00:03:16,990
для реализации на основе массива и
даже e + v log v

48
00:03:16,990 --> 00:03:21,740
при реализации на основе сортирующих деревьев,
двоичных сортирующих деревьев.

49
00:03:21,740 --> 00:03:27,800
Несмотря на то, что алгоритм работает дольше,
он корректен при наличии ребер с отрицательным
весом

50
00:03:27,800 --> 00:03:32,810
Итак, в начале мы просто инициализируем
"dist" и

51
00:03:32,810 --> 00:03:36,310
"prev" переменные, за время пропорциолнальное
колличеству вершин.

52
00:03:36,310 --> 00:03:38,770
И затем выполняем V-1 итераций

53
00:03:38,770 --> 00:03:41,820
Каждая итерация выполняется за время
пропорциональное  числу

54
00:03:41,820 --> 00:03:45,260
ребер, поскольку изменение весов ребер
выполняетя за фиксированное время.

55
00:03:45,260 --> 00:03:48,410
Так что, в целом, мы получаем время
пропорциональное VE.

56
00:03:51,090 --> 00:03:55,510
Теперь, давайте посмотрим на конкретный пример
работы алгоритма Беллмана-Форда.

57
00:03:55,510 --> 00:03:57,830
на конкретном графе.

58
00:03:57,830 --> 00:04:00,530
Итак, начальная вершина обозначена символом S

59
00:04:00,530 --> 00:04:06,720
И значения 0 и бесконечность, обозначенные 
голубым цветом это начальные дистанции.

60
00:04:06,720 --> 00:04:09,500
И числа возле ребер это их веса.

61
00:04:10,660 --> 00:04:15,490
Таким образом, мы берем
все ребра в заданном порядке

62
00:04:15,490 --> 00:04:18,960
начиная с ребра весом 4.

63
00:04:18,960 --> 00:04:20,580
И попробуем пересчитать их.

64
00:04:20,580 --> 00:04:24,893
Таким образом значение "dist" для
А изменится с бесконечности на 4.

65
00:04:24,893 --> 00:04:27,390
Берем следующее ребро с длинной 3 и

66
00:04:27,390 --> 00:04:30,680
меняем значени dist для B
с бесконечности на 3.

67
00:04:30,680 --> 00:04:34,744
Берем ребро с весом -2 и

68
00:04:34,744 --> 00:04:41,460
далее меняем значение dist для
B с 3 на 2.

69
00:04:41,460 --> 00:04:45,892
Затем,  смотрим на ребро из А в С и
меняем бесконечность на 8.

70
00:04:45,892 --> 00:04:51,900
Затем, смотрим ребро из B в С и
меняем его с 8 на -1.

71
00:04:51,900 --> 00:04:57,450
Далее, переходим к ребру из B в D и
меняем значение с бесконечности на 3.

72
00:04:57,450 --> 00:05:03,840
И, смотрим на ребро из C в D и
меняем значение с 3 на 1.

73
00:05:03,840 --> 00:05:07,650
Это только первая итерация 
алгоритма Беллмана-Форда.

74
00:05:07,650 --> 00:05:10,340
Теперь посмотрим, что происходит
на следующей итерации.

75
00:05:10,340 --> 00:05:14,636
Рассмотрим ребро из S в A,
здесь ничего нельзя улучшить.

76
00:05:14,636 --> 00:05:17,191
Это ребро ничего не улучшает.

77
00:05:17,191 --> 00:05:17,691
Это ребро не улучшает.

78
00:05:19,230 --> 00:05:20,660
Это ребро также не улучшает.

79
00:05:20,660 --> 00:05:22,010
И этот не улучшает.

80
00:05:22,010 --> 00:05:23,730
И этот не улучшает.

81
00:05:23,730 --> 00:05:25,060
И этот не улучшает.

82
00:05:25,060 --> 00:05:30,620
И таким образом, уже на второй итерации,
ничего нельзя улучшить.

83
00:05:30,620 --> 00:05:34,773
И мы можем остановить алгоритм,
уже после второй итерации.

84
00:05:34,773 --> 00:05:37,613
И вместо V*E числа операций,

85
00:05:37,613 --> 00:05:42,190
только E, посольку мы совершили лишь 
одну итерацию по всем ребрам.

86
00:05:42,190 --> 00:05:47,590
На практике, это частый случай.

87
00:05:47,590 --> 00:05:50,770
Но для некоторых графов, разумеется,
потребуется гораздо больше итераций.

88
00:05:50,770 --> 00:05:53,190
Итак, мы уже знаем финальный результат

89
00:05:53,190 --> 00:05:56,660
расстояния которые врозвращает
алгоритм Беллмана-Форда

90
00:05:56,660 --> 00:05:59,692
И в следующем видео
мы докажем, что алгоритм

91
00:05:59,692 --> 00:06:03,508
возвращает корректные расстояния, при 
отсутствии циклов с отрицательными весами.