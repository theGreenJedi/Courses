1
00:00:01,130 --> 00:00:04,130
Hello everybody, welcome back
to the Graph Algorithms course.

2
00:00:04,130 --> 00:00:07,710
Today, we're going to talk about
previsit and postvisit orderings.

3
00:00:07,710 --> 00:00:11,170
And these are sort of some numbers that
you can do when running a depth for

4
00:00:11,170 --> 00:00:14,400
search that sort of records some
information about the order in which you

5
00:00:14,400 --> 00:00:15,535
visited vertices.

6
00:00:15,535 --> 00:00:16,387
And and

7
00:00:16,387 --> 00:00:20,950
we're going to discuss a little about
why these numbers might be important.

8
00:00:20,950 --> 00:00:24,810
But mostly it's going to be that they
will turn out the be very useful in some

9
00:00:24,810 --> 00:00:27,098
algorithms we're going to discuss later.

10
00:00:27,098 --> 00:00:30,358
Okay, so
let's talk about depth [INAUDIBLE],

11
00:00:30,358 --> 00:00:33,293
it is algorithm that we came up last time.

12
00:00:33,293 --> 00:00:36,637
And it's a little bit
weird as an algorithm,

13
00:00:36,637 --> 00:00:40,773
because well what happens
when you run depth for surge?

14
00:00:40,773 --> 00:00:45,058
It doesn't return anything,
it does modify the state of some things.

15
00:00:45,058 --> 00:00:49,358
It marks vertices as visited or unvisited.

16
00:00:49,358 --> 00:00:52,423
But in the end it just ends up
marking any vertex as being visited.

17
00:00:52,423 --> 00:00:57,191
If all that you wanted to do is mark every
vertex as visited there are easier ways

18
00:00:57,191 --> 00:00:57,780
to do it.

19
00:00:58,820 --> 00:01:03,270
On the other hand the order in
which we find these vertices and

20
00:01:03,270 --> 00:01:07,790
away that involves their connectivity
is actually very useful.

21
00:01:07,790 --> 00:01:12,427
For example with slight modification,
keeping track of a little bit of data we

22
00:01:12,427 --> 00:01:16,373
saw how to use depth for
a search to compute connected components.

23
00:01:16,373 --> 00:01:19,606
So in general, if we want to make
that depth [INAUDIBLE] useful,

24
00:01:19,606 --> 00:01:23,150
we need to keep track of some extra
information about its execution.

25
00:01:24,200 --> 00:01:26,960
So what we're going to do for
this is we're going to augment some of its

26
00:01:26,960 --> 00:01:29,330
functions in order to store
additional information.

27
00:01:30,730 --> 00:01:33,243
So for example, let's look at Explore.

28
00:01:33,243 --> 00:01:36,523
What we're going to do is we're
going to mark the vertex as visited.

29
00:01:36,523 --> 00:01:40,443
But then before we do anything else,
we're going to run some previsit function.

30
00:01:40,443 --> 00:01:43,311
This is just some extra
things that we're doing,

31
00:01:43,311 --> 00:01:45,634
just to maybe record some information or

32
00:01:45,634 --> 00:01:49,550
do a little bit of extra work sort
of just as we found this new vertex.

33
00:01:50,730 --> 00:01:55,620
Then we go in this loop over neighbors and
exploring all the unexplored neighbors.

34
00:01:55,620 --> 00:01:58,396
And then right before we're
about to finish exploring v,

35
00:01:58,396 --> 00:02:00,163
we run some other post visit blocks.

36
00:02:00,163 --> 00:02:05,552
Some thing that we did,
do it right before we're finishing.

37
00:02:05,552 --> 00:02:07,550
So what are these functions going to be?

38
00:02:07,550 --> 00:02:08,533
They could be a number of things.

39
00:02:08,533 --> 00:02:13,260
We'll come up with an example shortly,
but the idea is to augment our

40
00:02:13,260 --> 00:02:17,673
functions a little bit to keep
track of some extra information.

41
00:02:17,673 --> 00:02:20,612
So what sort of extra
information do we want?

42
00:02:20,612 --> 00:02:24,108
Well one that we might want to
do is to keep track of sort

43
00:02:24,108 --> 00:02:26,693
of what order are we visit vertices in.

44
00:02:26,693 --> 00:02:29,615
And so one way to do this
is we sort of have a clock.

45
00:02:29,615 --> 00:02:31,571
This clock keeps track of time,

46
00:02:31,571 --> 00:02:36,470
it ticks forward once every time we hit
a previsit or postvisit for a vertex.

47
00:02:36,470 --> 00:02:38,660
Every time we discover a new vertex for

48
00:02:38,660 --> 00:02:44,100
the first time or sort of leave
an old vertex for the last time.

49
00:02:44,100 --> 00:02:48,450
And every time we do one of these
things we'll also core the time

50
00:02:48,450 --> 00:02:49,340
which that happens.

51
00:02:49,340 --> 00:02:53,480
So for each vertex, we will have
a record of the previsit time and

52
00:02:53,480 --> 00:02:54,868
the postvisit time.

53
00:02:54,868 --> 00:02:58,140
So to what you seen what I mean by this,
let's look again this example.

54
00:02:58,140 --> 00:02:59,560
The clock starts at 1,

55
00:02:59,560 --> 00:03:04,080
we visit our first vertex, its gives
us previsit number assigned as 1.

56
00:03:04,080 --> 00:03:08,368
From there, we explore the second
vertex which is previsit 2, and

57
00:03:08,368 --> 00:03:11,313
then a third vertex which
gets previsit of 3.

58
00:03:11,313 --> 00:03:15,052
From there, we start, well,
we're done exploring that vertex.

59
00:03:15,052 --> 00:03:17,430
All of its neighbors have
already been visited.

60
00:03:17,430 --> 00:03:22,533
So we assign it postvisit 4 and move on,
this other vertex gets postvisit 5.

61
00:03:22,533 --> 00:03:27,110
We now have a new vertex to explore,
it gets previsit 6 and postvisit 7.

62
00:03:27,110 --> 00:03:30,850
And our original postvisit 8 and
that wraps up our first explore.

63
00:03:32,080 --> 00:03:34,820
We now find a new vertex,
who gives previous at 9 and

64
00:03:34,820 --> 00:03:36,513
his neighbor previous at 10.

65
00:03:36,513 --> 00:03:40,093
And then they get post
visit numbers 11 and 12.

66
00:03:40,093 --> 00:03:44,840
Finally, we've got a new guy with previsit
13 and his neighbors get 14 and 15 and

67
00:03:44,840 --> 00:03:48,525
they get postvisits 16,
17 and 18, we wrap them up.

68
00:03:48,525 --> 00:03:52,894
And we are now done and
we just assigned the numbers 1 through 18

69
00:03:52,894 --> 00:03:57,672
as the previsit and postvisit numbers
of these 9 different vertices.

70
00:03:57,672 --> 00:04:01,060
So the way we compute this
is actually pretty easy.

71
00:04:01,060 --> 00:04:05,923
We just have to initialize our clock to be
1 the beginning of our depth first search.

72
00:04:05,923 --> 00:04:08,843
And then in the previsit
block of our explorer,

73
00:04:08,843 --> 00:04:13,882
we set the previsit number of v to be this
clock value and then increment the clock.

74
00:04:13,882 --> 00:04:18,020
And for the post visit block we set post
visit number of the vertex to be the clock

75
00:04:18,020 --> 00:04:19,723
value and increment the clock.

76
00:04:19,723 --> 00:04:24,479
Very easy, doesn't really change
the run time of anything, but

77
00:04:24,479 --> 00:04:27,200
allows us to compute these numbers.

78
00:04:27,200 --> 00:04:28,920
Now, what are these useful for?

79
00:04:28,920 --> 00:04:31,240
Well, really the previsit and
postvisit numbers,

80
00:04:31,240 --> 00:04:35,340
the tell us something about
the execution of the depth first search.

81
00:04:35,340 --> 00:04:39,200
And we'll see a little bit of this
as we prove the following Lemma.

82
00:04:39,200 --> 00:04:42,660
So suppose that you have
any two vertices u and v.

83
00:04:42,660 --> 00:04:45,891
From these u,
v intervals pre(u) to post(u) and

84
00:04:45,891 --> 00:04:49,353
then pre(v) to post(v),
these are two intervals.

85
00:04:49,353 --> 00:04:53,053
And the claim is that these intervals
are either nested or disjoint.

86
00:04:53,053 --> 00:04:58,002
And in a particular whether are nested or
disjoint will actually tell us something

87
00:04:58,002 --> 00:05:00,943
useful about the sort of
way in which the depth for

88
00:05:00,943 --> 00:05:03,040
search ran on these two vertices.

89
00:05:04,560 --> 00:05:06,973
So let's take a look at
what we mean by this.

90
00:05:06,973 --> 00:05:08,094
If you have two intervals,

91
00:05:08,094 --> 00:05:10,739
there are a few ways in which they
can intersect with each other.

92
00:05:11,990 --> 00:05:15,140
Firstly, could be the case that one
interval is strictly contained in

93
00:05:15,140 --> 00:05:16,060
the other one.

94
00:05:16,060 --> 00:05:17,200
These means that they're nested.

95
00:05:18,360 --> 00:05:21,386
It could also be that they're
disjoint from each other,

96
00:05:21,386 --> 00:05:23,162
that they don't overlap at all.

97
00:05:23,162 --> 00:05:25,850
Finally, we could have two
intervals that are interleaved.

98
00:05:25,850 --> 00:05:28,550
They sort of overlap
over part of their ends,

99
00:05:28,550 --> 00:05:32,000
but not over the entire
interval either side.

100
00:05:32,000 --> 00:05:36,612
And what we're saying in this dilemma
is that the interleaved case is

101
00:05:36,612 --> 00:05:38,293
actually not possible.

102
00:05:38,293 --> 00:05:40,113
So let's see the proof.

103
00:05:40,113 --> 00:05:42,745
We first assume that
without laws of generality,

104
00:05:42,745 --> 00:05:45,700
the first visit to u happens
before the first visit to v.

105
00:05:46,750 --> 00:05:49,393
We now have two cases to consider.

106
00:05:49,393 --> 00:05:54,420
First thing that we find v for the first
time in the midst of exploring u.

107
00:05:54,420 --> 00:05:59,093
And this really is an indepth research
tree that we produced by this exploration.

108
00:05:59,093 --> 00:06:04,970
We found v as a descendant of u,
we found v while exploring u.

109
00:06:06,250 --> 00:06:09,253
The second thing is we could find
v after we're done exploring u.

110
00:06:09,253 --> 00:06:12,108
So it's sort of v and
u are different branches of the tree,

111
00:06:12,108 --> 00:06:13,750
they're cousins of each other.

112
00:06:15,400 --> 00:06:17,510
So let's look at the first case.

113
00:06:17,510 --> 00:06:21,530
If we explore v while we're
in the middle of exploring u,

114
00:06:21,530 --> 00:06:26,620
then explore v is actually being
run as a subroutine of explore u.

115
00:06:26,620 --> 00:06:30,469
And because of the way subroutines work
we can't finish exploring uuntil we

116
00:06:30,469 --> 00:06:31,863
are finished exploring v.

117
00:06:31,863 --> 00:06:34,575
And therefore the post of u is
bigger than the post of v and

118
00:06:34,575 --> 00:06:36,210
these two intervals are nested.

119
00:06:38,730 --> 00:06:42,638
In the second case, we explore
the after we're done exploring u.

120
00:06:42,638 --> 00:06:45,984
So we start exploring u and
then we finish exploring u,

121
00:06:45,984 --> 00:06:50,915
and then sometime later we start
exploring v and then finish exploring v.

122
00:06:50,915 --> 00:06:52,565
And so
these intervals are going to be disjoined.

123
00:06:53,605 --> 00:06:57,117
And so these are the only cases the
intervals are nested or they're disjoined.

124
00:06:57,117 --> 00:07:01,491
And which case we're in will actually tell
us something useful about the order in

125
00:07:01,491 --> 00:07:03,760
which we visited vertices in this graph.

126
00:07:05,450 --> 00:07:10,953
Now just to review we've got these two
tables here sort of pre and post numbers,

127
00:07:10,953 --> 00:07:15,733
but only one of them is a possibly
valid table of pre and post numbers.

128
00:07:15,733 --> 00:07:19,273
Which one is not valid?

129
00:07:19,273 --> 00:07:24,443
Well the one on the right can't be
correct, because these two intervals

130
00:07:24,443 --> 00:07:30,052
from pre to post for vertices A and
B Are interleaved, and that can't happen.

131
00:07:30,052 --> 00:07:34,183
So that sort of pre and post orders will
see a lot more usefulness later, but

132
00:07:34,183 --> 00:07:38,656
in the next lecture, we're going to
introduce something a little bit more new.

133
00:07:38,656 --> 00:07:41,456
We've been talking a lot
about undirected graphs.

134
00:07:41,456 --> 00:07:44,844
Here, we're going to be talking about
what happens when the edges actually have

135
00:07:44,844 --> 00:07:45,936
an orientation to them.

136
00:07:45,936 --> 00:07:48,340
So please come back next time,
and we can talk about that.