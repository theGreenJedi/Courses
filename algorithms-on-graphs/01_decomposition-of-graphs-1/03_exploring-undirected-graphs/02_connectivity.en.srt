1
00:00:01,000 --> 00:00:04,100
Hello everybody, welcome back
to the graph algorithms course.

2
00:00:04,100 --> 00:00:06,660
Today we're going to be talking about
notions of connectivity in a graph,

3
00:00:06,660 --> 00:00:09,670
in particular,
talking about connecting components, and

4
00:00:09,670 --> 00:00:12,290
how to compute the connected
components of an undirected graph.

5
00:00:14,020 --> 00:00:18,127
So, to begin with, last time we talked
about this notion of reachability,

6
00:00:18,127 --> 00:00:21,799
what does it mean to be able to reach
another vertex from a given one?

7
00:00:21,799 --> 00:00:26,578
And what we'd like to understand now
is really what sort of classifies

8
00:00:26,578 --> 00:00:28,550
reachability in a graph?

9
00:00:28,550 --> 00:00:30,280
Really not just from a single vertex but

10
00:00:30,280 --> 00:00:34,730
you sort of want to understand which
vertices are reachable from which others?

11
00:00:34,730 --> 00:00:35,730
And it turns out that for

12
00:00:35,730 --> 00:00:40,630
an undirected graph, there's actually
a very clean categorization of this.

13
00:00:40,630 --> 00:00:43,710
In particular for any graph G,
we can always partition it

14
00:00:43,710 --> 00:00:48,590
into Connected Components such that two
vertices v and w are reachable from

15
00:00:48,590 --> 00:00:52,540
each other, if and only if they
are in the same connected component.

16
00:00:52,540 --> 00:00:55,050
So, sort of we break this
graph up into islands,

17
00:00:55,050 --> 00:00:59,130
where any two islands are completely
unconnected from each other, but

18
00:00:59,130 --> 00:01:01,850
within any island, you can get
from anywhere to anywhere else.

19
00:01:04,210 --> 00:01:06,990
So just to make sure
we're on the same page.

20
00:01:06,990 --> 00:01:10,500
If we have the following graph, how
many connected components does it have?

21
00:01:12,460 --> 00:01:14,950
Well, this graph is going to have 4.

22
00:01:14,950 --> 00:01:19,520
So if you look at these four things, from
each of these things they're all connected

23
00:01:19,520 --> 00:01:22,162
up, but there are no edges
between any pair of them.

24
00:01:23,770 --> 00:01:26,350
Okay, so let's see how the proof
of this theorem works.

25
00:01:26,350 --> 00:01:29,620
Why can we always divide it
into connected components?

26
00:01:29,620 --> 00:01:32,430
And basically the idea is you
need to show that reachability is

27
00:01:32,430 --> 00:01:34,440
an equivalence relation.

28
00:01:34,440 --> 00:01:38,650
That means three things, first is that
v is reachable from v which is easy.

29
00:01:38,650 --> 00:01:43,286
Also that if v can be reached from w,
w can be reached from v which sort of is

30
00:01:43,286 --> 00:01:46,630
just following the path in
the opposite direction.

31
00:01:46,630 --> 00:01:50,617
And then there's the difficult one,
that if v is reachable from u and

32
00:01:50,617 --> 00:01:54,520
v is also reachable from w,
then w is reachable from u.

33
00:01:54,520 --> 00:01:56,210
What this says if you sort of take v and

34
00:01:56,210 --> 00:01:59,850
you take everything that it connects to,
in fact,

35
00:01:59,850 --> 00:02:03,539
everything in that whole region connects
to everything else in that whole region.

36
00:02:04,700 --> 00:02:07,630
And that last step is not so
hard once you write it down.

37
00:02:07,630 --> 00:02:12,520
The point is that you can reach u from v,
which means there's a path from v to u.

38
00:02:12,520 --> 00:02:15,121
You can also find a path from v to w.

39
00:02:15,121 --> 00:02:19,039
And if you should have glued these paths
together at v then you have a path

40
00:02:19,039 --> 00:02:19,700
from u to w.

41
00:02:19,700 --> 00:02:22,880
So they can be reached from each other.

42
00:02:22,880 --> 00:02:25,400
Okay, so that completes the proof but

43
00:02:25,400 --> 00:02:28,220
what we'd now like to do
is do this algorithmically.

44
00:02:28,220 --> 00:02:31,640
Given a graph G, we'd like to find
the connected components of this graph.

45
00:02:33,020 --> 00:02:34,720
Okay, fair enough.

46
00:02:34,720 --> 00:02:36,770
Let's find an algorithm.

47
00:02:36,770 --> 00:02:39,790
Well the basic idea of
this is pretty simple.

48
00:02:39,790 --> 00:02:44,550
If you run explore(v),
this finds the connected component of v.

49
00:02:44,550 --> 00:02:45,900
It finds everything you can reach from v.

50
00:02:45,900 --> 00:02:47,800
That's the whole connected component.

51
00:02:47,800 --> 00:02:50,280
And you just need to repeat this
to find all the other components.

52
00:02:52,000 --> 00:02:55,520
It turns out you can do this actually with
only sort of a slight modifications of

53
00:02:55,520 --> 00:02:58,070
the original depth first
search algorithm tha we saw.

54
00:02:59,240 --> 00:03:01,165
Now, in order to make this algorithm,

55
00:03:01,165 --> 00:03:02,420
we're about to see
a little bit more cleanly.

56
00:03:02,420 --> 00:03:04,964
We're going to modify
our goal a little bit.

57
00:03:04,964 --> 00:03:09,700
Instead of actually returning sort of
returning sets of vertices that are our

58
00:03:09,700 --> 00:03:12,630
connected components, what we're going to
do is we're going to label the connected

59
00:03:12,630 --> 00:03:15,910
components, we're going to give everything
in the first one a label of 1, and

60
00:03:15,910 --> 00:03:19,070
everyone in the second components
a label of 2, and so on and so forth.

61
00:03:20,860 --> 00:03:22,920
Okay, so how does this work?

62
00:03:22,920 --> 00:03:26,460
First we modify our Explore procedure,
we visit the vertex,

63
00:03:26,460 --> 00:03:29,300
we also make sure to visit
all of its neighbors.

64
00:03:29,300 --> 00:03:34,110
We also assign the vertex a number
corresponding to it connect component,

65
00:03:34,110 --> 00:03:34,670
the CC number.

66
00:03:35,990 --> 00:03:39,910
Now the thing is that this variable
CC is not going to change as we

67
00:03:39,910 --> 00:03:42,356
make these recursive calls to explore.

68
00:03:42,356 --> 00:03:45,890
And so everything else that gets
found through the same explore

69
00:03:45,890 --> 00:03:47,460
will all get assigned the same number.

70
00:03:49,305 --> 00:03:53,580
However when we actually run our
DFS first search, we're going to

71
00:03:53,580 --> 00:03:57,920
between different explores, between
different vertices that we explore and

72
00:03:57,920 --> 00:04:01,600
then go off to find a new vertex,
we increment this number.

73
00:04:01,600 --> 00:04:05,119
And so the second explore that we do
everything gets the number one bigger.

74
00:04:06,790 --> 00:04:11,140
So to see how this actually works,
on this graph our counter starts at 1.

75
00:04:11,140 --> 00:04:15,293
We find it on vertex say that one,
it gets labeled with a 1.

76
00:04:15,293 --> 00:04:17,130
We keep exploring from that vertex and

77
00:04:17,130 --> 00:04:21,175
we find these other three,
all of them get labeled with 1.

78
00:04:22,460 --> 00:04:26,500
But now we are done exploring that first
vertex, so we increment the counter and

79
00:04:26,500 --> 00:04:29,210
find a new unexplored vertex,
say that one.

80
00:04:29,210 --> 00:04:30,100
Which we now label 2.

81
00:04:30,100 --> 00:04:35,460
We keep exploring and the other vertex
that we found also gets labeled with a 2.

82
00:04:35,460 --> 00:04:38,010
But then we finish that explore call.

83
00:04:39,040 --> 00:04:42,850
We now increment our counter to 3 and
find a new vertex, this one.

84
00:04:42,850 --> 00:04:46,510
We explore that and
everything we find gets labeled with a 3.

85
00:04:46,510 --> 00:04:47,680
And now we're done.

86
00:04:47,680 --> 00:04:49,630
We've got three connected components.

87
00:04:49,630 --> 00:04:51,990
Everything in the first one is labeled 1.

88
00:04:51,990 --> 00:04:54,198
Everything on the second
one is labeled 2 and

89
00:04:54,198 --> 00:04:56,300
everything in the third one is labeled 3.

90
00:04:56,300 --> 00:04:57,400
So sort of what we wanted.

91
00:04:59,260 --> 00:05:04,040
Okay, to show that this is correct,
we note that each new explore call finds

92
00:05:04,040 --> 00:05:09,810
a full, new connected component because
it finds everything connected to that V.

93
00:05:09,810 --> 00:05:12,280
And of course,
because V had not been found yet,

94
00:05:12,280 --> 00:05:14,890
it was not in a connected component
that we had already seen.

95
00:05:16,720 --> 00:05:19,490
Secondly, because of the way
this outer loop and depth for

96
00:05:19,490 --> 00:05:23,250
search works, every vertex
eventually gets found, because

97
00:05:23,250 --> 00:05:27,360
every vertex we eventually check to see if
it's visited, and if not, we explore it.

98
00:05:28,410 --> 00:05:32,250
Now the run time of this is basically
just the run time of depth for search.

99
00:05:32,250 --> 00:05:35,590
We only made sort of cosmetic
modifications to it.

100
00:05:35,590 --> 00:05:39,780
So the run time is still O
of size of V plus size of E.

101
00:05:39,780 --> 00:05:44,200
Okay, so that's our discussion of
how to compute connected components.

102
00:05:44,200 --> 00:05:48,020
Next time we're going to talk about some
other applications of depth for search.

103
00:05:48,020 --> 00:05:51,010
So I'll be happy to see
you in the next lecture.