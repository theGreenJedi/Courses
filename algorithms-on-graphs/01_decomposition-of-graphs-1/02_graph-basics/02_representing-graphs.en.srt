1
00:00:01,050 --> 00:00:03,630
Hello everybody,
welcome back to our graph algorithms.

2
00:00:03,630 --> 00:00:04,312
Of course,

3
00:00:04,312 --> 00:00:09,390
today we're going to be talking about
how to represent graphs on a computer.

4
00:00:09,390 --> 00:00:12,025
And then after that we are going to talk
a little about how to talk about graph

5
00:00:12,025 --> 00:00:16,050
runtime instead of how it depends
on one graph you are using.

6
00:00:17,680 --> 00:00:21,910
So the first thing is graph
representations, so from last time recall,

7
00:00:21,910 --> 00:00:26,180
the graph is a thing that consists of
a bunch of vertices sometimes called nodes

8
00:00:26,180 --> 00:00:29,140
and also a bunch of edges that
connect pairs of these vertices.

9
00:00:30,212 --> 00:00:34,140
And we're going to want to do is we're
going to want to do a lot of computations

10
00:00:34,140 --> 00:00:37,150
on graphs to determine various
properties of them, but

11
00:00:37,150 --> 00:00:40,280
before we can get to any of that, we
first need to talk about how to actually

12
00:00:40,280 --> 00:00:43,510
represent a graph inside a computer.

13
00:00:43,510 --> 00:00:45,830
And there are in fact
several ways to do this, and

14
00:00:45,830 --> 00:00:49,790
exactly how we do it will affect
the runtimes of some of these algorithms.

15
00:00:49,790 --> 00:00:52,190
So we're going to spend a little
bit of time talking about that.

16
00:00:53,810 --> 00:00:58,280
So, the first thing to do is well you want
your vertices and you want your edges.

17
00:00:58,280 --> 00:01:01,700
A natural way to do this is just
store a giant list of edges.

18
00:01:01,700 --> 00:01:06,680
Each edge is a pair of vertices so
this is a big list of pairs of vertices.

19
00:01:06,680 --> 00:01:10,819
But now what we have is we've got
these four vertices, A, B, C, and D.

20
00:01:10,819 --> 00:01:12,200
And then we just store a list.

21
00:01:12,200 --> 00:01:15,756
One is an edge between A and B, and
then there's an edge between A and C, and

22
00:01:15,756 --> 00:01:19,275
there's an edge between A and D, and
there's an edge between C and D.

23
00:01:19,275 --> 00:01:24,655
And this is a perfectly good way to
store this graph on a computer, but

24
00:01:24,655 --> 00:01:26,595
there are other ways of thinking about it.

25
00:01:26,595 --> 00:01:28,185
One of them is the following.

26
00:01:28,185 --> 00:01:31,375
So at least, that you have a simple graph.

27
00:01:31,375 --> 00:01:36,200
We're only didn't really matter is which
pairs of vertices have edges between.

28
00:01:36,200 --> 00:01:38,258
And so, if I gave you a pair of vertices.

29
00:01:38,258 --> 00:01:41,126
So, it's the only thing that you
need to know is you need to know,

30
00:01:41,126 --> 00:01:43,173
is there an edge between
the more is there not.

31
00:01:43,173 --> 00:01:46,348
So we can do is we can just
rebuild a look-up table for this,

32
00:01:46,348 --> 00:01:50,668
we build a matrix where you have an entry
that's 1 if there is an edge between that

33
00:01:50,668 --> 00:01:52,910
pair of vertices and a 0 if there's not.

34
00:01:53,950 --> 00:01:58,760
So for example, in this graph there
is an edge between A and D and

35
00:01:58,760 --> 00:02:01,589
therefore the AD entry
of this matrix is 1.

36
00:02:02,690 --> 00:02:07,710
There isn't an edge, however,
between B and C, so the BC entry is 0.

37
00:02:07,710 --> 00:02:12,240
And so you just fill this in, you get
this nice 4 by 4 matrix of 0s and 1s.

38
00:02:12,240 --> 00:02:14,020
It is another way of
representing this graph.

39
00:02:16,550 --> 00:02:21,000
On the other hand there is sort of a third
maybe a hybrid way of looking at things.

40
00:02:21,000 --> 00:02:22,270
And the idea here is that for

41
00:02:22,270 --> 00:02:25,550
each vertex in the graph it's going to
have a bunch of neighbors, it's going to

42
00:02:25,550 --> 00:02:31,110
have other vertices that have edges from
the one that we're considering to them.

43
00:02:32,150 --> 00:02:35,240
And another way of
representing the graph is for

44
00:02:35,240 --> 00:02:38,740
each vertex we can just keep
a list of its neighbors.

45
00:02:38,740 --> 00:02:42,730
So vertex A in this graph
is adjacent to B, C, and D.

46
00:02:42,730 --> 00:02:44,530
B is adjacent to A.

47
00:02:44,530 --> 00:02:45,990
C is adjacent to A and D.

48
00:02:45,990 --> 00:02:48,340
D is adjacent to A and C.

49
00:02:48,340 --> 00:02:52,760
So for each of these vertices we store
a list of just all of it's neighbors and

50
00:02:52,760 --> 00:02:56,550
that's another way to represent the graph.

51
00:02:56,550 --> 00:02:59,960
Now for example,
just to be sure we're on the same page.

52
00:02:59,960 --> 00:03:01,920
If we have the following graph.

53
00:03:01,920 --> 00:03:04,180
What are the neighbors of vertex C?

54
00:03:06,135 --> 00:03:09,600
Well, we just draw all the edges
that leave C and it connects to A,

55
00:03:09,600 --> 00:03:12,630
and B, and D, and F, and H, and I.

56
00:03:12,630 --> 00:03:14,766
And, those are its neighbors.

57
00:03:14,766 --> 00:03:19,370
Okay, but so we have these three
ways of representing a graph.

58
00:03:19,370 --> 00:03:22,670
And it turns out the different basic
operations you want to perform

59
00:03:22,670 --> 00:03:26,170
could be faster or slower depending
on which representation you have.

60
00:03:27,550 --> 00:03:31,420
For example, if you want to determine if
there's an edge between this specific pair

61
00:03:31,420 --> 00:03:32,280
of vertices.

62
00:03:32,280 --> 00:03:35,780
This is very fast in the adjacency
matrix representation.

63
00:03:35,780 --> 00:03:38,210
All you have to do is check
the appropriate entry of the matrix.

64
00:03:38,210 --> 00:03:39,450
See if it's 0 or 1.

65
00:03:39,450 --> 00:03:42,538
And that's your answer, constant time.

66
00:03:42,538 --> 00:03:46,840
However, when you have an edge list, the
only thing that you can really do is scan

67
00:03:46,840 --> 00:03:50,283
the entire list of edges to see
if that particular edge shows up.

68
00:03:50,283 --> 00:03:53,983
That takes time proportional
to the number of edges.

69
00:03:53,983 --> 00:03:56,683
For the adjacent lists,
it's a little bit faster than that.

70
00:03:56,683 --> 00:04:00,397
What you do is you pick one end of
this edge that you're looking for and

71
00:04:00,397 --> 00:04:04,367
then look it for all it's neighbors who
wants to know if A is adjacent to B,

72
00:04:04,367 --> 00:04:08,350
you look at the list of A's neighbors and
see if B is on the list.

73
00:04:08,350 --> 00:04:11,970
And so the time there is proportional
to the degree of the vertex.

74
00:04:11,970 --> 00:04:14,050
The number of neighbors
that this one guy has.

75
00:04:15,730 --> 00:04:19,760
Now another thing you might want to do
is list all of the edges in the graph.

76
00:04:19,760 --> 00:04:22,690
And the adjacency matrix
is terrible here because

77
00:04:22,690 --> 00:04:26,688
the only thing you do there is you scan
through every entry of the matrix.

78
00:04:26,688 --> 00:04:28,850
And each one gives you an edge, but

79
00:04:28,850 --> 00:04:31,690
that takes time proportionate to
the number of vertices squared.

80
00:04:33,120 --> 00:04:35,380
However, the edge list
does this very easily.

81
00:04:35,380 --> 00:04:37,830
It just lists all the edges in
order which is what it does.

82
00:04:40,030 --> 00:04:44,060
The adjacency list is about as good
though, because you just need to,

83
00:04:44,060 --> 00:04:46,580
for each vertex,
you find all of its neighbors.

84
00:04:46,580 --> 00:04:49,870
Those are a bunch of edges.

85
00:04:49,870 --> 00:04:54,935
And you just do this for every vertex,
and this actually counts each edge twice,

86
00:04:54,935 --> 00:04:57,885
because if there's an edge between A and
B you count both.

87
00:04:57,885 --> 00:05:01,405
That A is neighbor of B and
that B is a neighbor of A.

88
00:05:01,405 --> 00:05:02,805
But the only counts them twice so

89
00:05:02,805 --> 00:05:05,045
the time is still proportional
to the number of edges.

90
00:05:06,877 --> 00:05:10,407
Finally, if you want to list all
the neighbors of a given vertex,

91
00:05:10,407 --> 00:05:13,427
the adjacency matrix is
pretty slow here again.

92
00:05:13,427 --> 00:05:17,397
Because the only thing you can really do
is scan through that row of the matrix,

93
00:05:17,397 --> 00:05:18,387
and find all the ones.

94
00:05:19,847 --> 00:05:24,170
Now, in the edge list representation,
you have scan through all the edges

95
00:05:24,170 --> 00:05:28,020
In your graph to see which ones
include the vertex you want.

96
00:05:28,020 --> 00:05:30,670
Whereas the adjacency list, you just
scan through the list of neighbors of

97
00:05:30,670 --> 00:05:33,070
the vertex, and it's very fast.

98
00:05:33,070 --> 00:05:37,330
Now, it turns out that for many problems
that we'll be considering this on, and

99
00:05:37,330 --> 00:05:42,260
throughout most of the rest of this unit
on what we really want is the adjacency

100
00:05:42,260 --> 00:05:46,330
risk representation of our graph, just
because a lot of the operations that we

101
00:05:46,330 --> 00:05:49,350
need, we really want to be able to
find neighbors of a given vertex.

102
00:05:51,430 --> 00:05:54,050
Okay, so that's how we represent graphs.

103
00:05:54,050 --> 00:05:57,420
Let's spend a little bit of time to
talk about runtimes of graph algorithms.

104
00:05:58,680 --> 00:06:01,040
So, when we talk about algorithm runtimes,

105
00:06:01,040 --> 00:06:04,230
it's generally a function
of the size of the input.

106
00:06:05,330 --> 00:06:07,400
And for the most of
the algorithms we've seen so far,

107
00:06:07,400 --> 00:06:10,690
the input sort of has one size parameter,
n.

108
00:06:10,690 --> 00:06:15,249
And so you runtimes like o of n squared or
o of n cubed, or something to that effect.

109
00:06:16,470 --> 00:06:21,230
However, graph algorithms, well, the graph
sort of has two measures of its size.

110
00:06:21,230 --> 00:06:25,222
The number of vertices and
the number of edges.

111
00:06:25,222 --> 00:06:30,263
And so graph algorithms runtimes depend
in some way on both of these quantities.

112
00:06:30,263 --> 00:06:33,703
You could have runtimes like
O size of E plus size of E,

113
00:06:33,703 --> 00:06:36,923
which is generally considered
to be linear time.

114
00:06:36,923 --> 00:06:40,941
But you can also have O of size of E,
times size of E or

115
00:06:40,941 --> 00:06:44,603
size of V to the three-halves or
V log V plus E.

116
00:06:44,603 --> 00:06:50,082
And there are many different possibilities
for types of runtimes that we have.

117
00:06:50,082 --> 00:06:54,534
And an interesting question now is, again,
if you sort of only have one parameter,

118
00:06:54,534 --> 00:06:56,260
it's easy to compare.

119
00:06:56,260 --> 00:07:00,670
N log N runtime versus N
squared versus N cubed.

120
00:07:00,670 --> 00:07:05,720
But if you want to say which one's faster,
say one algorithm runs in time size of V

121
00:07:05,720 --> 00:07:10,010
to the three-halves and
the other one runs in time size at E.

122
00:07:10,010 --> 00:07:12,480
It's not actually clear
which one's faster.

123
00:07:13,790 --> 00:07:17,290
And in fact which algorithm is
faster actually depends on which

124
00:07:17,290 --> 00:07:19,010
graph you're using.

125
00:07:19,010 --> 00:07:21,730
In particular depends
on the density how many

126
00:07:21,730 --> 00:07:24,420
edges you have in terms of
the number of vertices.

127
00:07:24,420 --> 00:07:28,630
If you have many, many,
many edges O of E is going to be worse.

128
00:07:28,630 --> 00:07:32,340
However, if you have few
edges its going to be better.

129
00:07:32,340 --> 00:07:35,069
And in terms of density theres
sort of two extremes to consider.

130
00:07:36,360 --> 00:07:38,520
On the one hand, you have dense graphs.

131
00:07:38,520 --> 00:07:43,270
Here, the number of edges is roughly
proportional to the square of the number

132
00:07:43,270 --> 00:07:48,390
of vertices, meaning that almost
every pair of vertices or

133
00:07:48,390 --> 00:07:53,640
some large fraction of the pairs of
vertices actually have edges between them.

134
00:07:53,640 --> 00:07:57,460
If you're banned, you're going on tour and
want to like plot a route between a bunch

135
00:07:57,460 --> 00:08:02,350
of cities, well there is actually
some transportation option

136
00:08:02,350 --> 00:08:06,290
that would get you between basically
any pair of cities on the map.

137
00:08:06,290 --> 00:08:09,910
Now, it might be indirect or
take a while but

138
00:08:09,910 --> 00:08:15,310
you should still probably plot all of
these out in order to plan your tour, just

139
00:08:15,310 --> 00:08:19,520
what will matter is not whether or not
it's possible to get between two cities,

140
00:08:19,520 --> 00:08:22,210
but how hard it is to get
between these cities.

141
00:08:22,210 --> 00:08:24,890
But for this time,
you actually want sort of a dense graph,

142
00:08:24,890 --> 00:08:29,160
that talks of all pairs relations
between these vertices.

143
00:08:30,830 --> 00:08:34,190
On the other end of the spectrum,
we have sparse graphs.

144
00:08:34,190 --> 00:08:37,530
Here the number of edges is small
relative to the number of vertices,

145
00:08:37,530 --> 00:08:41,420
often as small as roughly equal
to the number of vertices or

146
00:08:41,420 --> 00:08:43,990
some small constant times
the number of vertices.

147
00:08:45,160 --> 00:08:46,730
And in a sparse graph,

148
00:08:46,730 --> 00:08:51,310
what you have instead is that each vertex
has only a few edges coming out of it.

149
00:08:52,360 --> 00:08:57,130
And this is actually very reasonable for
a lot of models you want to think about.

150
00:08:57,130 --> 00:08:59,210
If you think of the internet as a graph,

151
00:08:59,210 --> 00:09:02,670
well, there are billions of
web pages on the internet, but

152
00:09:02,670 --> 00:09:07,170
any given web page is only going to
have links to a few dozen others.

153
00:09:07,170 --> 00:09:10,640
And so the number or
the degree of any given vertex,

154
00:09:10,640 --> 00:09:14,580
the number of neighbors that any given
vertex has, is much smaller than the total

155
00:09:14,580 --> 00:09:17,650
number of vertices, so
you end up with a very sparse graph.

156
00:09:17,650 --> 00:09:21,590
Now a lot of things like this, like
the Internet, like social networks, like

157
00:09:21,590 --> 00:09:25,640
actual maps that you've drawn on a piece
of paper, these tend to be sparse graphs.

158
00:09:28,780 --> 00:09:30,620
Whether or not your graph is sparse or

159
00:09:30,620 --> 00:09:33,080
dense will affect the runtime
of your algorithms and

160
00:09:33,080 --> 00:09:35,880
may even help determine which of
your algorithms you want to be run.

161
00:09:37,260 --> 00:09:39,170
Okay, so that's it for today.

162
00:09:40,565 --> 00:09:43,885
Now that sort of the basics are out of
the way we're going to actually talk about

163
00:09:43,885 --> 00:09:46,675
some of the algorithms and in particular
we're going to talk about how to explore

164
00:09:46,675 --> 00:09:50,765
graphs and sort of figure out which
vertices can be reached from which others

165
00:09:50,765 --> 00:09:53,145
so come back next time and
we'll talk about that.