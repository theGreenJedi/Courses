1
00:00:00,950 --> 00:00:01,550
Hello, everybody.

2
00:00:01,550 --> 00:00:04,040
Welcome back to our
Graph Algorithms course.

3
00:00:04,040 --> 00:00:06,640
Today, we're going to talk
about how to get an algorithm

4
00:00:06,640 --> 00:00:09,810
to efficiently compute the strongly
connected components of a directed graph.

5
00:00:11,260 --> 00:00:12,540
So if you recall from last time,

6
00:00:12,540 --> 00:00:16,540
what we had was we find this notion
of connectivity in directed graphs,

7
00:00:16,540 --> 00:00:20,020
where two vertices were connected if you
could get from one to the other and back.

8
00:00:21,390 --> 00:00:25,589
Now, we said this graph necessarily
would be divided into strongly connected

9
00:00:25,589 --> 00:00:29,407
components, where within a component,
you could get from everything

10
00:00:29,407 --> 00:00:33,820
to everything else, but sort of once you
leave the component you can't get back.

11
00:00:35,220 --> 00:00:39,770
Now, these components are connected to
each other by what we call the metagraph.

12
00:00:39,770 --> 00:00:41,120
And the metagraph was always a DAG,

13
00:00:41,120 --> 00:00:44,360
which is sort of a useful
a thing as we'll see today.

14
00:00:45,810 --> 00:00:48,650
So the problem we're going to look
at today is, given a graph, G,

15
00:00:48,650 --> 00:00:53,080
a directed graph, G, how do we find
the strongly connected components of G?

16
00:00:55,070 --> 00:00:58,063
Now there's a pretty easy algorithm for
this, it turns out.

17
00:00:58,063 --> 00:01:00,869
For each vertex v, run explore on v and

18
00:01:00,869 --> 00:01:04,303
determine all the vertices
reachable from v.

19
00:01:04,303 --> 00:01:07,200
Once you've done that for every vertex,

20
00:01:07,200 --> 00:01:11,996
you know that for a vertex v what you
want to do is find all the vertices u

21
00:01:11,996 --> 00:01:15,583
that are both reachable from v and
can also reach v.

22
00:01:15,583 --> 00:01:20,853
And that, it turns out, will give you
the strongly connected component of v.

23
00:01:20,853 --> 00:01:24,229
And so this gives you the strongly
connected component of v, you run this for

24
00:01:24,229 --> 00:01:27,760
all v, that gives you all
the strongly connected components.

25
00:01:27,760 --> 00:01:31,300
And so the runtime of this
algorithm is a little bit slow but

26
00:01:31,300 --> 00:01:35,160
you need to explore from
every single starting vertex.

27
00:01:35,160 --> 00:01:38,380
So the run time is something like
o of v squared plus v times e.

28
00:01:39,590 --> 00:01:42,240
This is okay but
we'd like to find something faster.

29
00:01:44,430 --> 00:01:45,950
And what's the idea?

30
00:01:45,950 --> 00:01:48,670
The key idea of this
algorithm is the following.

31
00:01:48,670 --> 00:01:54,390
If you take a vertex v and run explore,
you find everything you can reach from v.

32
00:01:54,390 --> 00:01:56,140
Now this includes the components of v.

33
00:01:57,280 --> 00:02:00,540
But if there are other
components downstream of that,

34
00:02:00,540 --> 00:02:03,480
you might find vertices from other
connecting components as well.

35
00:02:05,270 --> 00:02:07,510
However, there's a case
when this doesn't happen,

36
00:02:07,510 --> 00:02:11,370
if v is located in a sink
strongly connected component.

37
00:02:11,370 --> 00:02:15,640
That means there are no edges out of
that strongly connected component.

38
00:02:15,640 --> 00:02:20,350
So when you explore from v, you will find
exactly it's strongly connected component.

39
00:02:20,350 --> 00:02:24,120
Which is good, because we want to find
the strongly connected component.

40
00:02:24,120 --> 00:02:26,730
So, if you actually find one,
that's a good start.

41
00:02:29,150 --> 00:02:30,110
So how do we do this?

42
00:02:30,110 --> 00:02:34,820
Well, we need to find the vertex in
a sink strongly connected components

43
00:02:34,820 --> 00:02:36,460
which takes some thoughts.

44
00:02:38,210 --> 00:02:41,090
Well, there's a theorem it
turns out that will help.

45
00:02:41,090 --> 00:02:43,810
If C and
C prime are two strongly connected

46
00:02:43,810 --> 00:02:49,240
components where there's an edge from some
vertex of C to some vertex of C prime.

47
00:02:49,240 --> 00:02:53,450
It turns out that the largest
post number in C Is larger

48
00:02:53,450 --> 00:02:55,940
than the largest post number in C prime.

49
00:02:57,310 --> 00:02:59,590
Now to prove this,
we split into two cases.

50
00:02:59,590 --> 00:03:03,040
When we run our depth first search,
either we visit a vertex in C

51
00:03:03,040 --> 00:03:07,240
before we visit a vertex in C prime,
or it could be the opposite way,

52
00:03:07,240 --> 00:03:09,879
visit a vertex in C prime
before we visit a vertex of C.

53
00:03:11,730 --> 00:03:16,060
In the first case, where we visit C first,
well, from a vertex in C you can reach

54
00:03:16,060 --> 00:03:19,700
everything else in C,
because it is the same component.

55
00:03:19,700 --> 00:03:22,020
There's also an edge from C to C prime,
so you can also,

56
00:03:22,020 --> 00:03:24,630
it turns out, reach everything
in C prime from that vertex.

57
00:03:26,010 --> 00:03:30,950
And that means that while you're still
exploring that first vertex in C,

58
00:03:30,950 --> 00:03:35,670
you actually explore everything else in C
and everything in C prime as a subroutine.

59
00:03:37,118 --> 00:03:40,130
This means, that because of
the way subroutines work, you have

60
00:03:40,130 --> 00:03:44,820
to finish exploring all those vertices
before you finish that last vertex in C.

61
00:03:44,820 --> 00:03:49,650
So, that one vertex in C has
the largest post number of any vertex

62
00:03:49,650 --> 00:03:50,290
in either component.

63
00:03:52,610 --> 00:03:55,710
The second case is you
visit C prime first.

64
00:03:55,710 --> 00:03:59,780
Here the proclaim is that you can't
actually reach C from C prime.

65
00:03:59,780 --> 00:04:03,420
Because if you could reach C from C prime,
and

66
00:04:03,420 --> 00:04:07,620
you still follow the edge from C back
to C prime and you'd have a cycle.

67
00:04:07,620 --> 00:04:09,080
And this is not just any cycle.

68
00:04:09,080 --> 00:04:10,130
This is a cycle in the metagraph,

69
00:04:10,130 --> 00:04:15,620
which you can't have because
the metagraph must be a DAG.

70
00:04:15,620 --> 00:04:18,620
And this means that you
can't reach C from C prime.

71
00:04:18,620 --> 00:04:19,940
When you explore C prime,

72
00:04:19,940 --> 00:04:23,580
you'll never actually find C in
the middle of that exploration.

73
00:04:23,580 --> 00:04:26,460
So, in fact,
you have to finish exploring C prime

74
00:04:26,460 --> 00:04:28,760
before you can even begin exploring C.

75
00:04:28,760 --> 00:04:32,000
And so, once again, the vertex with
the largest post has to be in C.

76
00:04:34,400 --> 00:04:35,450
Okay, so what does this mean?

77
00:04:35,450 --> 00:04:38,920
If you look at the large
vertex with the single largest

78
00:04:38,920 --> 00:04:44,010
post order number in the entire graph,
what can we say about that?

79
00:04:44,010 --> 00:04:48,560
Well it has to come from a component
with no other components pointing to it.

80
00:04:48,560 --> 00:04:52,512
That vertex needs to be the source
component, which is great.

81
00:04:52,512 --> 00:04:54,693
It's almost what we wanted.

82
00:04:54,693 --> 00:04:58,753
What we wanted was a vertex
in a sink component.

83
00:04:58,753 --> 00:05:02,010
Well, there's a trick for doing this.

84
00:05:02,010 --> 00:05:03,065
So if you have a graph,

85
00:05:03,065 --> 00:05:06,290
we're going to define what's called the
Reverse Graph, which is just what you get

86
00:05:06,290 --> 00:05:09,790
by taking a graph reversing
the direction of all the edges.

87
00:05:09,790 --> 00:05:14,543
So if a graph on the left is G, the graph
on the right is the reverse graph.

88
00:05:14,543 --> 00:05:19,263
The edges are all the same, they're just
pointing in the opposite directions.

89
00:05:19,263 --> 00:05:22,839
Now the cute thing here is
that the reverse graph and

90
00:05:22,839 --> 00:05:26,593
G both have the same strongly
connected components.

91
00:05:26,593 --> 00:05:32,000
I mean, v and w are connected if you
can go from v to w and w back to v.

92
00:05:32,000 --> 00:05:34,850
But if you reverse all the edges,
you can just follow those paths

93
00:05:34,850 --> 00:05:38,600
in the opposite directions,
from v to w and w back to v.

94
00:05:40,100 --> 00:05:45,260
And so, the strongly connected
components are the same, but

95
00:05:45,260 --> 00:05:47,550
the edges in the metagraph are different.

96
00:05:47,550 --> 00:05:50,860
Because if you have a source
component in the reverse graph,

97
00:05:50,860 --> 00:05:54,210
that means that you have edges
coming out of it but not into it.

98
00:05:54,210 --> 00:05:56,770
Well, when we reverse the edges
to get the original graph G,

99
00:05:56,770 --> 00:06:00,166
the edges come into it and not out,
and you find the sink component.

100
00:06:01,610 --> 00:06:05,690
So in order to find the vertex in the sink
component of G, what you do is you run

101
00:06:05,690 --> 00:06:10,030
depth first search on the reverse graph,
which by the way is easy to compute,

102
00:06:10,030 --> 00:06:13,100
you just take every edge and
reverse the direction.

103
00:06:13,100 --> 00:06:17,740
because we run depth first
search on the reverse graph and

104
00:06:17,740 --> 00:06:19,580
take the vertex to largest post order.

105
00:06:22,120 --> 00:06:23,450
Okay so just to review.

106
00:06:23,450 --> 00:06:25,360
Which of the following is true?

107
00:06:25,360 --> 00:06:28,290
The vertex with the largest post
order number in the reverse graph

108
00:06:28,290 --> 00:06:29,340
is in the sink component?

109
00:06:30,520 --> 00:06:33,560
The vertex with the largest preorder
number is in the sink component?

110
00:06:34,690 --> 00:06:38,430
Or the vertex with the smallest
number is in the sink component?

111
00:06:41,410 --> 00:06:43,990
Well, all of these sound
roughly equivalent.

112
00:06:43,990 --> 00:06:46,850
But if you work them out,
only one of them is true.

113
00:06:46,850 --> 00:06:48,060
The first one.

114
00:06:48,060 --> 00:06:51,410
The vertex with the largest postorder
number is in a sink component.

115
00:06:51,410 --> 00:06:55,230
The other ones sound plausible,
but just don't work.

116
00:06:57,040 --> 00:06:59,340
Okay, but this gives us an algorithm.

117
00:06:59,340 --> 00:07:00,650
And the point is the following.

118
00:07:00,650 --> 00:07:03,740
We run depth first search
on the reverse graph.

119
00:07:03,740 --> 00:07:07,360
We let v be the vertices of
the largest post number and

120
00:07:07,360 --> 00:07:11,240
this has to be in the sink
component of the G.

121
00:07:11,240 --> 00:07:14,890
We now explore v and
because it was in a sink component,

122
00:07:14,890 --> 00:07:18,350
the vertices we find are actually
a strongly connected component of G.

123
00:07:19,480 --> 00:07:23,040
So, we take them,
we remove them from G and then we repeat.

124
00:07:24,330 --> 00:07:27,690
So, here's our graph,
we depth first search the reverse graph,

125
00:07:27,690 --> 00:07:29,610
the largest post number is that 18.

126
00:07:29,610 --> 00:07:33,290
So, we explore that, we find one vertex.

127
00:07:33,290 --> 00:07:34,815
That's our first component.

128
00:07:34,815 --> 00:07:37,490
We're now going to remove that
from the graph and try again.

129
00:07:38,745 --> 00:07:42,720
Depth first search on the reverse graph,
16 is the largest post.

130
00:07:42,720 --> 00:07:45,590
We explore from there,
we find this new component.

131
00:07:45,590 --> 00:07:46,985
Great.

132
00:07:46,985 --> 00:07:50,960
Depth first search the reverse graph,
find the largest post, explore that.

133
00:07:50,960 --> 00:07:52,175
We have a third component.

134
00:07:52,175 --> 00:07:57,070
Depth first search the reverse graph, 10
is the largest, and we explore from that.

135
00:07:57,070 --> 00:07:58,960
We find these four guys as a component,

136
00:07:58,960 --> 00:08:02,100
and then there's the one
vertex we find out.

137
00:08:02,100 --> 00:08:04,440
So that gives us a strongly
connected components.

138
00:08:06,250 --> 00:08:09,090
Unfortunately, this algorithm's
a little bit inefficient again.

139
00:08:09,090 --> 00:08:13,130
Because we need to run depth first
search repeatedly on the reverse graph.

140
00:08:14,500 --> 00:08:17,610
But it turns out that that's
actually unnecessary.

141
00:08:17,610 --> 00:08:22,070
Because remember, the theorem that we had
was that if you had an edge between two

142
00:08:22,070 --> 00:08:27,520
components, the one that was further
upstream always had the larger post order.

143
00:08:28,658 --> 00:08:30,270
In fact, when we reversed the edges,

144
00:08:30,270 --> 00:08:35,050
now it's the one downstream has
the largest post order, but whatever.

145
00:08:35,050 --> 00:08:37,900
But the point is that after you
remove the sink component, and

146
00:08:37,900 --> 00:08:43,750
if you just then look for the vertex with
the single largest remaining post order,

147
00:08:43,750 --> 00:08:46,560
that's going to be a sink
component of the new graph.

148
00:08:46,560 --> 00:08:48,820
It doesn't point to anything else,
except for

149
00:08:48,820 --> 00:08:51,030
maybe some components that
you've already removed.

150
00:08:53,000 --> 00:08:56,690
And so the new algorithm, we just run
depth first search once on the reverse

151
00:08:58,030 --> 00:09:01,050
graph, then we look for
v in the graph in reverse postorder.

152
00:09:02,078 --> 00:09:05,995
Any v that has not yet been visited,
we explore that v, and

153
00:09:05,995 --> 00:09:09,395
mark the vertices that we found as
a new strongly connected component.

154
00:09:11,035 --> 00:09:12,755
So we have this graph.

155
00:09:12,755 --> 00:09:15,095
We depth first search
on the reverse graph.

156
00:09:15,095 --> 00:09:17,465
We record the post numbers.

157
00:09:17,465 --> 00:09:19,195
Now the largest post is 18.

158
00:09:19,195 --> 00:09:21,145
We explore that vertex,
find this component.

159
00:09:22,185 --> 00:09:24,235
Next is 17, which we explore and
find this component.

160
00:09:25,880 --> 00:09:32,760
Then 15 finds this guy, 10 finds this 4,
and 6 finds the last guy, and that's it.

161
00:09:32,760 --> 00:09:34,930
A much faster algorithm.

162
00:09:34,930 --> 00:09:36,270
In fact, the runtime,

163
00:09:36,270 --> 00:09:39,930
we essentially just ran a depth first
search on the reverse graph and

164
00:09:39,930 --> 00:09:44,840
then ran another depth first search on G,
which is the slight modification

165
00:09:44,840 --> 00:09:49,830
that we wanted to visit our vertices in
this outer loop in some specific order.

166
00:09:49,830 --> 00:09:53,120
And also, we need to record
the connected components we found.

167
00:09:54,460 --> 00:09:58,880
But basically, this is just two depth
first searches, the runtime is linear O of

168
00:09:58,880 --> 00:10:02,000
V plus E, and this gives us
a nice efficient algorithm for

169
00:10:02,000 --> 00:10:04,550
finding our strongly connected components.

170
00:10:05,820 --> 00:10:09,610
Well, that completes our unit
on this graph exploration and

171
00:10:09,610 --> 00:10:11,942
decomposition algorithms.

172
00:10:11,942 --> 00:10:16,960
These tell us how to find ways to get
from one vertex in the graph to another.

173
00:10:16,960 --> 00:10:20,540
However, when you're actually trying
to solve this problems in practice,

174
00:10:20,540 --> 00:10:25,270
you don't just want any route
on your map that gets me from

175
00:10:25,270 --> 00:10:27,970
where I am in San Diego to say,
Los Angeles.

176
00:10:27,970 --> 00:10:30,830
The route that I find might
pass me through New York and

177
00:10:30,830 --> 00:10:34,100
Florida on the way, and
I don't want to do that.

178
00:10:34,100 --> 00:10:36,640
What I really want to do is I
want to find an efficient path.

179
00:10:37,750 --> 00:10:40,515
How do I get there which spends
as little time as possible, or

180
00:10:40,515 --> 00:10:42,555
maybe as little money as possible.

181
00:10:42,555 --> 00:10:45,735
And this is what we're going to
start talking about in the next unit

182
00:10:45,735 --> 00:10:48,265
where Michael is going
to be talking to you

183
00:10:48,265 --> 00:10:51,115
about how to find
shortest paths in graphs.

184
00:10:52,365 --> 00:10:56,368
So, I hope you enjoyed this unit and
will come back for the next one.