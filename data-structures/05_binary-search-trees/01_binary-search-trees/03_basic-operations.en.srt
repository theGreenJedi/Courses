1
00:00:00,910 --> 00:00:02,310
Hello everybody, welcome back.

2
00:00:02,310 --> 00:00:04,920
We're continuing to talk
about binary search trees.

3
00:00:04,920 --> 00:00:08,320
And today, we're going to talk about
how to implement the basic operations

4
00:00:08,320 --> 00:00:09,330
of a binary search tree.

5
00:00:09,330 --> 00:00:10,850
So we're going to talk about this and

6
00:00:10,850 --> 00:00:15,160
talk about a few of the difficulties
that show up when you're trying it.

7
00:00:15,160 --> 00:00:17,400
Okay, so let's start with searching.

8
00:00:17,400 --> 00:00:21,017
And this is sort of the key thing that
you want to be able to do on the binary

9
00:00:21,017 --> 00:00:21,620
search tree.

10
00:00:21,620 --> 00:00:24,600
And the primary operation that
we're going to look at for

11
00:00:24,600 --> 00:00:26,460
how to do this is what
we're going to call Find.

12
00:00:27,490 --> 00:00:28,830
Now Find is a function.

13
00:00:28,830 --> 00:00:33,660
What it takes is a key k and
the root R of a tree.

14
00:00:33,660 --> 00:00:38,160
And what it's going to return is the node
in the subtree with R as the root

15
00:00:38,160 --> 00:00:39,410
whose key is equal to k.

16
00:00:40,540 --> 00:00:44,130
Okay, that's the goal and
the idea is pretty easy.

17
00:00:44,130 --> 00:00:48,010
I mean the search tree is set
up to do binary searches on.

18
00:00:48,010 --> 00:00:50,870
So what we're going to do is we're going
to sort of start at the top of the tree.

19
00:00:50,870 --> 00:00:54,920
We're going to compare 6,
the thing we're searching for, to 7.

20
00:00:54,920 --> 00:00:58,330
6 is less than 7 and
that means since everything less

21
00:00:58,330 --> 00:01:02,120
than 7 is in its left subtree,
we should look in the left subtree.

22
00:01:03,200 --> 00:01:04,510
So we go left.

23
00:01:04,510 --> 00:01:07,600
We now compare 6 to 4,
the root of this left subtree.

24
00:01:07,600 --> 00:01:09,720
6 is bigger than 4.

25
00:01:09,720 --> 00:01:12,860
Everything bigger than 4 in
the place that we're looking

26
00:01:12,860 --> 00:01:17,070
is going to be in 4s right subtree,
so we had down in that way.

27
00:01:17,070 --> 00:01:18,400
We now compare 6 to 6.

28
00:01:18,400 --> 00:01:21,320
They're equal, and so
we are done with our search.

29
00:01:22,650 --> 00:01:26,930
And so this algorithm is actually
very easy to implement recursively.

30
00:01:26,930 --> 00:01:30,030
If the key of R.Key = k, then we're done.

31
00:01:30,030 --> 00:01:33,780
We just return the node R at the root and
that's all there is to it.

32
00:01:35,175 --> 00:01:40,960
Otherwise, if R.key > K,
we need something less than R,

33
00:01:40,960 --> 00:01:44,150
so the thing we're looking for
should be in the left subtree.

34
00:01:44,150 --> 00:01:48,260
So we recursively run Find on k and
R's left child.

35
00:01:49,780 --> 00:01:53,880
On the other hand, if R.key < k,
we have to look in the right subtree, so

36
00:01:53,880 --> 00:01:56,350
we find k in the subtree of Rs child.

37
00:01:57,560 --> 00:02:01,670
Okay, this works fine as long as the thing
we're looking is in the tree, but

38
00:02:01,670 --> 00:02:04,880
what happens if we're looking for
a key that isn't there?

39
00:02:04,880 --> 00:02:06,920
So we're trying to find 5 in this tree.

40
00:02:06,920 --> 00:02:08,250
We checked it's less than 7.

41
00:02:08,250 --> 00:02:08,950
It's more than 4.

42
00:02:08,950 --> 00:02:10,130
It's less than 6.

43
00:02:10,130 --> 00:02:12,340
6 doesn't have a left child.

44
00:02:12,340 --> 00:02:16,200
We have a null pointer,
what do we do here?

45
00:02:16,200 --> 00:02:19,610
Well, in some sense we could just return
some errors saying the thing you were

46
00:02:19,610 --> 00:02:24,200
looking for wasn't there, but
we did actually find something useful.

47
00:02:24,200 --> 00:02:27,200
We didn't find 5 in the tree,
because its not there, but

48
00:02:27,200 --> 00:02:31,540
we sort of figured out where 5 should
have been in the tree if it were there.

49
00:02:32,950 --> 00:02:37,150
And so, if you stop your search right
before you hit the null pointer,

50
00:02:37,150 --> 00:02:38,820
you can actually something useful.

51
00:02:38,820 --> 00:02:42,520
You find the place where
k would fit in the tree.

52
00:02:42,520 --> 00:02:46,790
So it makes a little bit of sense
to modify this Find procedure so

53
00:02:46,790 --> 00:02:54,560
that if say R.key > k, then instead of
just checking the left points here,

54
00:02:54,560 --> 00:02:58,750
we first check to see if R
actually has a left child.

55
00:02:58,750 --> 00:03:00,920
If Rs Left child isn't null,

56
00:03:00,920 --> 00:03:04,310
we can recursively try to
find k in the left subtree.

57
00:03:04,310 --> 00:03:08,440
But otherwise, if it is null,
we'll just stop early and return R and

58
00:03:08,440 --> 00:03:10,380
do something similar for the other case.

59
00:03:10,380 --> 00:03:13,650
And this sort of means that
if we're searching for

60
00:03:13,650 --> 00:03:18,600
something that's not in the tree,
we at least give something close to it.

61
00:03:18,600 --> 00:03:20,860
Okay, so that's one thing we can do.

62
00:03:20,860 --> 00:03:24,040
Another thing that we might want to do
is sort of talk with adjacent elements.

63
00:03:24,040 --> 00:03:27,690
If we've got some element in the tree,
we might want to find the next element.

64
00:03:29,120 --> 00:03:32,960
And so in particular another function
we might want which we will call next.

65
00:03:32,960 --> 00:03:38,030
It takes a node N and outputs the node in
the same tree with the next largest key.

66
00:03:39,880 --> 00:03:44,748
And maybe one way to think about this is
instead of searching for every key and has

67
00:03:44,748 --> 00:03:49,198
we should search the tree for something
just a tiny bit bigger than that.

68
00:03:49,198 --> 00:03:52,310
And, now if N has a right
child this is kind of easy.

69
00:03:52,310 --> 00:03:56,580
The first bunch of steps lead you to
the node N, and then you want to go right,

70
00:03:56,580 --> 00:03:58,520
because it is bigger than N.

71
00:03:58,520 --> 00:04:00,820
But after you do that you
just keep going left,

72
00:04:00,820 --> 00:04:04,510
because it's not, it's smaller
than all of these other things.

73
00:04:04,510 --> 00:04:06,680
They're a little bit bigger than N.

74
00:04:06,680 --> 00:04:10,940
And you just keep going until you hit a
node where you can't go left any further.

75
00:04:10,940 --> 00:04:14,000
It's left pointer is null, and
that's going to be the successor.

76
00:04:15,600 --> 00:04:20,300
Now, this doesn't work if N has no right
child, because you can't go right from N.

77
00:04:20,300 --> 00:04:22,920
You also go looking on the left side of N,
doesn't work.

78
00:04:22,920 --> 00:04:25,460
Everything is going to be smaller there.

79
00:04:25,460 --> 00:04:28,370
So instead what you have to do
is you have to go up the tree.

80
00:04:28,370 --> 00:04:29,840
You check its parent, and

81
00:04:29,840 --> 00:04:33,250
if its parent is smaller than n as well,
you have to check the grandparent.

82
00:04:33,250 --> 00:04:38,290
You just keep going up until you find
the first ancestor that's bigger than n.

83
00:04:38,290 --> 00:04:41,130
And once you have that,
that will actually be the successor.

84
00:04:42,660 --> 00:04:46,690
So, the algorithm for next involves
a little bit of case analysis.

85
00:04:46,690 --> 00:04:51,919
If N does not have a right child,
we're going to run this protocol we call

86
00:04:51,919 --> 00:04:56,829
RightAncestor, which goes up until
you take the first step right?

87
00:04:56,829 --> 00:05:00,447
Otherwise, we are going to return what
we're going to call the LeftDescendant of

88
00:05:00,447 --> 00:05:04,120
Ns right child which means you sort of go
left, until you can't go left anymore.

89
00:05:05,520 --> 00:05:07,780
Now both of these are easy to implement,
recursively for

90
00:05:07,780 --> 00:05:12,250
LeftDescendant if you don't have a left
child, you're done, you return N.

91
00:05:12,250 --> 00:05:15,330
Otherwise you take one step left and
repeat.

92
00:05:17,010 --> 00:05:22,140
For RightAncestor you check to see if your
parent has a larger key than you if so

93
00:05:22,140 --> 00:05:26,950
you return your parent otherwise
you go up a level and repeat, and

94
00:05:26,950 --> 00:05:29,180
just keep going until you find it.

95
00:05:29,180 --> 00:05:32,070
And so
putting these together that computes next.

96
00:05:33,290 --> 00:05:37,830
Now it turns out that this range search
operation that we talked about before,

97
00:05:37,830 --> 00:05:41,370
this you're given two numbers x and
y and the root of the tree and

98
00:05:41,370 --> 00:05:44,830
you'd like to return a list of all
the nodes whose keys are between x and

99
00:05:44,830 --> 00:05:48,480
y you can implement this pretty
easily using what we already have.

100
00:05:49,830 --> 00:05:53,430
So, the idea is, well,
you want to find the RangeSearch, say,

101
00:05:53,430 --> 00:05:55,610
everything between 5 and 12.

102
00:05:55,610 --> 00:05:59,340
First thing you do is you do a search for
the first element in that range,

103
00:05:59,340 --> 00:06:01,340
in this case, it will be 6.

104
00:06:01,340 --> 00:06:05,200
Then you find the next element,
which is 7, and the next element,

105
00:06:05,200 --> 00:06:09,480
which is 10 and the next element is 13,
it's too big so you stop.

106
00:06:11,390 --> 00:06:13,570
So the implementation is pretty easy.

107
00:06:13,570 --> 00:06:16,920
We create a list L that's going
to store everything that we find,

108
00:06:18,020 --> 00:06:23,000
we let N be what we get when we try to
find the left N point x within our tree.

109
00:06:24,370 --> 00:06:29,430
And then while the key of this note
N that we're working at is less than

110
00:06:29,430 --> 00:06:32,210
y as long as the key is bigger than x,

111
00:06:32,210 --> 00:06:37,200
we're going to this node to our list and
then we're going to replace N by Next(N).

112
00:06:37,200 --> 00:06:40,980
We're just going to iterate through
these nodes until they're too big, and

113
00:06:40,980 --> 00:06:43,310
then we return L.

114
00:06:43,310 --> 00:06:45,220
Okay, so that's how you do range search.

115
00:06:45,220 --> 00:06:48,570
And nearest neighbors, you can
figure it out, it's a similar idea.

116
00:06:50,000 --> 00:06:53,650
Now, the interesting things are how
do we do inserts and deletes?

117
00:06:53,650 --> 00:06:58,010
So, for insertion we want to be given
the key k and the root R of the tree and

118
00:06:58,010 --> 00:07:01,810
we'd like to add a node with
key equal to k to our tree.

119
00:07:03,340 --> 00:07:07,740
And the basic idea is that unlike with our
certain array with the tree we can just

120
00:07:07,740 --> 00:07:11,240
have a new element and just have
it hanging off one of our leaves.

121
00:07:11,240 --> 00:07:12,430
And this works perfectly well.

122
00:07:13,600 --> 00:07:15,780
There is a big of a technical
problem here, though.

123
00:07:15,780 --> 00:07:18,120
We can't just have it hang off anywhere.

124
00:07:18,120 --> 00:07:21,060
I mean, three that we're
inserting is smaller than seven,

125
00:07:21,060 --> 00:07:23,610
so it needs to be on
the left side of seven.

126
00:07:23,610 --> 00:07:27,950
And furthermore, there are a whole bunch
of other things that needs to satisfy to

127
00:07:27,950 --> 00:07:29,680
keep the search property working out.

128
00:07:30,990 --> 00:07:33,800
But, fortunately for us,
this find operation.

129
00:07:33,800 --> 00:07:37,750
If we tried to find A node
that wasn't in our tree

130
00:07:37,750 --> 00:07:40,490
actually did tell us where
that node should belong was.

131
00:07:41,650 --> 00:07:46,850
So to insert we just find our key
within R, and that gives us P,

132
00:07:46,850 --> 00:07:51,260
and the new node that we want should be
a child of P, on the appropriate right or

133
00:07:51,260 --> 00:07:54,720
left side, depending on
the comparison between things.

134
00:07:55,810 --> 00:07:56,310
And that's that.

135
00:07:58,060 --> 00:07:59,730
A little bit more difficult is Delete.

136
00:08:00,740 --> 00:08:04,530
So, here we just want to node N,
we should remove it from our tree.

137
00:08:05,740 --> 00:08:09,540
Now there's a problem we can't just
delete the node because then its

138
00:08:09,540 --> 00:08:10,790
parent doesn't have a child.

139
00:08:10,790 --> 00:08:14,240
It's children don't have parents,
it breaks things apart.

140
00:08:14,240 --> 00:08:15,980
So we need to find some
way to fill the gap.

141
00:08:17,570 --> 00:08:19,870
And there is a natural
way to fill this gap.

142
00:08:19,870 --> 00:08:24,470
The point is you want to fill the gap with
something nearby in the sorted order, so

143
00:08:24,470 --> 00:08:29,020
you try and find the next element,
X, and maybe you just take X and

144
00:08:29,020 --> 00:08:31,060
fill the gap that you
created by deleting this.

145
00:08:32,660 --> 00:08:34,760
Unfortunately, there could be a problem.

146
00:08:34,760 --> 00:08:39,250
Now, X turns out because it's
the next element that often not

147
00:08:39,250 --> 00:08:43,260
going to have a left child, because the
left child would be sort of even closer.

148
00:08:44,970 --> 00:08:48,590
But it might have a right child and
if it does have this right child,

149
00:08:48,590 --> 00:08:52,900
then by moving X side of the way it's
right child is now going to be orphaned.

150
00:08:52,900 --> 00:08:55,350
It's not going to have a proper parents.

151
00:08:55,350 --> 00:08:59,170
So in addition to moving X to
fill that gap you have to move Y

152
00:08:59,170 --> 00:09:03,420
up to fill the gap that you made
by moving X out of the way.

153
00:09:03,420 --> 00:09:05,330
But once you do that it's
actually perfectly good.

154
00:09:05,330 --> 00:09:10,497
You've done a reasonable rearrangement
tree and removed nodes you want.

155
00:09:10,497 --> 00:09:12,540
So the implementation takes
a little bit of work.

156
00:09:13,630 --> 00:09:16,920
First you check to see
if N has a right child.

157
00:09:16,920 --> 00:09:20,720
If it's right child is null then it
turns out we're not in this other case.

158
00:09:20,720 --> 00:09:25,220
But you can just remove N and you need
to promote Ns left child, if it has one.

159
00:09:25,220 --> 00:09:29,520
So Ns left child should now
become the child of Ns parent

160
00:09:29,520 --> 00:09:34,170
instead of the other way around.

161
00:09:34,170 --> 00:09:37,930
Otherwise we're going to
let X be next of N and

162
00:09:37,930 --> 00:09:40,720
note that X does not have a left child.

163
00:09:41,920 --> 00:09:46,460
And then we're going to replace N by X and
promote Xs right child to sort of

164
00:09:46,460 --> 00:09:49,310
fill the gap that we made
by moving X out of the way.

165
00:09:50,680 --> 00:09:53,110
But this all works.

166
00:09:53,110 --> 00:09:55,030
Just to review it, so

167
00:09:55,030 --> 00:09:59,430
if we have the following tree and
we're deleting the highlighting node.

168
00:09:59,430 --> 00:10:03,820
Which of the following three
trees do we end up with?

169
00:10:03,820 --> 00:10:05,220
Well the answer here is C.

170
00:10:05,220 --> 00:10:08,790
The point is that we deleted 1 so

171
00:10:08,790 --> 00:10:11,370
we want to replace it with
the next element which is 2.

172
00:10:11,370 --> 00:10:15,320
So we took 2 and
put it to the place where 1 was.

173
00:10:15,320 --> 00:10:18,380
Now 2s child, 4, needs to be promoted.

174
00:10:18,380 --> 00:10:21,210
So 4 now becomes the new child.

175
00:10:21,210 --> 00:10:24,570
Six and everything works nicely and
in this tree.

176
00:10:26,360 --> 00:10:31,330
Okay so if I tell you implement some
basic operations for binary search trees

177
00:10:31,330 --> 00:10:34,920
next time we'll going to talk about
the run time of these operations, which

178
00:10:34,920 --> 00:10:38,170
are going to leads us to some interesting
ideas about the balance of these trees.