大家好 欢迎回来 我们将继续讲解二叉搜索树。 今天，我们要讨论如何实现二叉树的基本操作 今天，我们要讨论如何实现二叉树的基本操作 还有实现二叉树又有哪些值得注意的地方 还有实现二叉树又有哪些值得注意的地方 先从如何实现搜索开始 也是二叉树的核心功能 也是二叉树的核心功能 我们用Find函数实现 我们用Find函数实现 我们用Find函数实现 输入是键值 k和树的根R 返回键值为k的节点 返回键值为k的节点 我们要做的就是这个 否则也不会叫Binary Search Tree(二叉查找树) 我们要在树的顶端开始 拿6和Root,也就是7比较 6比7小，所以我们转移到左支继续 因为左支都是比7小的 我们到左边 拿6和4比较 6大于4 比4大的都在4的右支 所以我们到右边 现在6和6比较 它们相等，所以搜索完成 这个算法用递归实现很容易 如果根R的值等于k，搜索就完成了 直接返回节点R 如果R的键值>k，我们转移到左支 如果R的键值>k，我们转移到左支 在左支递归运行查找k 如果R.key <k，我们转移到右支 继续递归寻找 如果k在树里面，那还好 如果k不在树里面，又应该如何修改算法？ 如果我们要找5 比7小 比4大 比6小 6没有分支 我们该怎么办？ 我们可以返回一个Null值，或是提示错误， 但是，我们还是有点成果的 虽然没有找到5， 但我们知道了，如果5在树里的话，它大致应该在哪里 所以，除了返回Null 我们可以选择返回一些有用的信息 我们找到了k适合出现的位置 我们现在修改Find 如果说R.key> k，我们先检查左支是否存在 如果说R.key> k，我们先检查左支是否存在 如果存在 继续递归寻找 否则的话，我们返回当前的R 否则的话，我们返回当前的R 如果要找的元素不在树里面， 我们至少返回一些有用的信息 接下来 除了搜索元素，我们还可以返回与节点N最相近的下一个元素 除了搜索元素，我们还可以返回与节点N最相近的下一个元素 我们给这个函数起名Next 输入是节点N，返回树里面下一个比它大的元素 我们不用去搜索树里的每个元素 我们把范围限定在只比N大一点点的那些可能的元素 如果N有右支，那就容易了 我们第一步就会转移到N的右支 因为它比N大 然后你再转移到N的右支的左支 因为这会更接近N 因为这会更接近N 直到你到达的节点不能再往左为止 这时候左支不存在，我们返回这个节点 如果N没有右支，那就不管用了 这时候我们也不能往左支走， 左边所有元素只会比N小 所以我们往N的上方走 看N的父母节点是否比N小 如果是，继续往上， 直到找到一个比N大的祖先节点 找到后，这就是我们要的答案 Next函数需要分具体情况 如果N没有右支，我们执行一个RightAncestor的函数 也就是从N的祖先节点中找 否则我们执行LeftDescendant的函数，参数是N的右支 等于是从N的右支出发一直往左，直到不能再往左为止 这两个函数都很容易实现，递归执行LeftDescendant 如果没有左支，返回N 否则就一直往左 RightAncestor函数中，看N的祖先节点是否比N大 是的话，返回这个祖先节点，否则继续往上，直到找到比N大的 是的话，返回这个祖先节点，否则继续往上，直到找到比N大的 现在我们再来看下一个基本操作 我们来看之前提过的范围搜索 输入是两个数字x,y, 树的根R 返回一个键值在x和y之间的所有节点的列表 这个很容易实现 我们现在要找到5和12之间的元素 我们现在要找到5和12之间的元素 我们先找到这个范围里的第一个元素 也就是6 然后找下一个，7 再下一个10，再下一个13，超出范围，所以我们停下 还是挺简单的 建立一个列表，用来储存我们找到的元素 我们用N变量要储存找到的元素 始终确保N的键值小于y, 然后判断是否大于x 始终确保N的键值小于y, 然后判断是否大于x 如果是，加入我们的列表，然后把N的值更新为Next(N) 接下来继续遍历，直到大于y 然后我们返回L列表 这就是RangeSearch的过程 Next()函数我们已经之前提过了 我们接下来看如何实现插入和删除 插入(Insertion)的输入是要加入的节点k和树根R 返回带有k的树 我们可以把新元素直接附加在其中一片叶子上 我们可以把新元素直接附加在其中一片叶子上 看上确实符合要求 但是有一个问题， 我们不能只看上一层的parent 3比7小， 所以必须加在左边 而且还有其他情况我们需要考虑 以维持二叉树的搜索功能 好在 之前的Find函数可以告诉我们 一个新元素应该放在哪里 所以，insert函数可以借用Find 然后返回节点P，至于，加在P的左支还是右支 比较一下就行了 比较一下就行了 Delete比较复杂 我们要删除节点N 我们不能直接这么做 否则以下的节点无法连接 否则以下的节点无法连接 所以我们要想个方法把空填补掉 其中一个填补的方法是 找到被删除节点的下一个比它大的元素X 用X来填补 用X来填补 但是，总会有例外 X不可能有左支，因为它是最接近N的较大元素 X不可能有左支，因为它是最接近N的较大元素 但X可能会有右支 把X拿走填补N，我们还要处理X留下的空挡 把X拿走填补N，我们还要处理X留下的空挡 所以，我们只能再把Y提上来代替X 所以，我们只能再把Y提上来代替X 所以，我们只能再把Y提上来代替X 所以，我们只能再把Y提上来代替X Delete的实现稍微复杂一些 首先，检查N有没有右支 如果没有，直接去掉N，用N的左支填补 如果没有，直接去掉N，用N的左支填补 如果没有，直接去掉N，用N的左支填补 如果没有，直接去掉N，用N的左支填补 否则，找到N之后下一个较大元素X 注意，X不可能有左支 用X替代N，如果X有右支 用X右支代替X 结束~ 复习一下 我们删除了这个树里被高亮标出的元素 结果会是哪个树？ 答案是C 我们删除了1 所以要用下一个较大元素，也就是2来代替1的位置 把2提上来 2的右支4，被提上来代替2 2的右支4，被提上来代替2 6和其他元素都不动 这节课我们讲解了二叉查找树的基本功能实现 下一次我们会讲解这些功能的运行时间 会很有意思