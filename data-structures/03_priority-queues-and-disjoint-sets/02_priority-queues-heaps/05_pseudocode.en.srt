1
00:00:00,250 --> 00:00:00,830
In this video,

2
00:00:00,830 --> 00:00:05,610
we provide the full pseudocode of
the binary max heap data structure.

3
00:00:06,620 --> 00:00:10,205
Here we will maintain
the following three variables.

4
00:00:10,205 --> 00:00:13,570
H is an array where our heap will stay.

5
00:00:13,570 --> 00:00:17,000
MaxSize is the size of this array, and

6
00:00:17,000 --> 00:00:21,320
at the same time, it is the maximum
number of nodes in our heap.

7
00:00:21,320 --> 00:00:24,200
And size is the actual size of our heap.

8
00:00:24,200 --> 00:00:27,516
So size is always at most maxSize.

9
00:00:27,516 --> 00:00:29,351
So let me give you an example.

10
00:00:29,351 --> 00:00:32,798
In this case,
we're given a heap of size 9.

11
00:00:32,798 --> 00:00:39,400
And it is stored in the first nine
cells of our array H whose size is 13.

12
00:00:39,400 --> 00:00:43,790
In particular, you may notice that
there are some values here, and

13
00:00:43,790 --> 00:00:45,020
it is actually some garbage.

14
00:00:45,020 --> 00:00:50,540
We just don't care about any
values that stay to the right

15
00:00:50,540 --> 00:00:52,310
of the position numbered 9.

16
00:00:52,310 --> 00:00:59,670
So our heap occupies the first
nine positions in the array.

17
00:00:59,670 --> 00:01:04,016
Also let me emphasis once again
that we store just the array H and

18
00:01:04,016 --> 00:01:06,394
also variables size and maxSize.

19
00:01:06,394 --> 00:01:11,180
So this tree is given to us implicitly.

20
00:01:11,180 --> 00:01:12,890
Namely, for any node,

21
00:01:12,890 --> 00:01:18,580
we can compute the number of its parent
and the number of its two children.

22
00:01:18,580 --> 00:01:22,765
And we can compute it and access
the corresponding value in this array.

23
00:01:22,765 --> 00:01:27,869
For example, if we have no number three,
then we can compute

24
00:01:27,869 --> 00:01:32,787
the index of its left child,
which is 2 multiplied by 3.

25
00:01:32,787 --> 00:01:37,400
So the value of its right child is 18.

26
00:01:37,400 --> 00:01:43,182
These implementations showing
how to find given a node i,

27
00:01:43,182 --> 00:01:47,789
the index of the parent of i and
two children of i.

28
00:01:47,789 --> 00:01:52,070
So they just implement our
formulas in a straightforward way.

29
00:01:53,290 --> 00:01:57,050
To sift element i up, we do the following.

30
00:01:57,050 --> 00:02:00,990
While this element is not the root,
namely,

31
00:02:02,940 --> 00:02:08,000
i is greater than 1, and while the value

32
00:02:08,000 --> 00:02:12,860
of this node is greater than the value
of its parent, we do the following.

33
00:02:12,860 --> 00:02:16,990
We swap this element with his parent.

34
00:02:16,990 --> 00:02:18,790
So this is done on this line.

35
00:02:18,790 --> 00:02:22,621
And then we proceed with this new element.

36
00:02:22,621 --> 00:02:29,257
I mean, we assign i to be equal to
Parent of i and go back to this while loop,

37
00:02:29,257 --> 00:02:33,700
and we do this until
the property is satisfied.

38
00:02:34,810 --> 00:02:41,695
To sift an element number i down, we first
need to select the direction of sifting.

39
00:02:41,695 --> 00:02:47,700
Namely, if element number i is smaller
than one or two of its children,

40
00:02:47,700 --> 00:02:53,130
we first need to select the largest
one of its two children, right?

41
00:02:53,130 --> 00:02:55,190
So this is done here.

42
00:02:55,190 --> 00:02:59,200
So initially, we assign to
the variable maxIndex the value of i.

43
00:03:01,280 --> 00:03:08,280
Then we compute the index of
the left child of the node number i.

44
00:03:08,280 --> 00:03:16,610
Then in the next if loop we first check
whether i indeed has a left child.

45
00:03:16,610 --> 00:03:19,480
This is done in the following check.

46
00:03:19,480 --> 00:03:22,230
We check whether l is at most size.

47
00:03:22,230 --> 00:03:26,430
Namely, whether l is an index
which is in our heap, okay?

48
00:03:26,430 --> 00:03:31,240
Then if H of l is greater
than H of maxIndex,

49
00:03:31,240 --> 00:03:36,310
we assign maxIndex to be equal to l, okay?

50
00:03:36,310 --> 00:03:38,545
Then we do the same with the right child.

51
00:03:38,545 --> 00:03:44,550
We first compute its index, then we check
whether this index is indeed in our heap.

52
00:03:44,550 --> 00:03:48,239
Then we check whether
the value in this node

53
00:03:48,239 --> 00:03:53,065
is greater than the value of
our current maximum index.

54
00:03:53,065 --> 00:03:58,060
And if it is,
then we update the value of maxIndex.

55
00:03:58,060 --> 00:04:03,754
And finally, if the node i is not
the largest one among itself and

56
00:04:03,754 --> 00:04:06,708
the two of its children, namely,

57
00:04:06,708 --> 00:04:11,790
if i is not equal to maxIndex,
then we do the following.

58
00:04:11,790 --> 00:04:15,900
We swap element number i with
element number maxIndex.

59
00:04:17,200 --> 00:04:18,320
It is done here.

60
00:04:18,320 --> 00:04:23,970
And then we continue sifting down

61
00:04:23,970 --> 00:04:29,030
the just-swapped element.

62
00:04:29,030 --> 00:04:30,860
Okay, so, this is done recursively.

63
00:04:30,860 --> 00:04:35,290
However, it is not so
difficult to avoid using recursion here,

64
00:04:35,290 --> 00:04:38,520
just by introducing a new while loop.

65
00:04:38,520 --> 00:04:43,670
To insert a new element with priority p in
our binary max heap, we do the following.

66
00:04:43,670 --> 00:04:46,680
We first check whether
we still have room for

67
00:04:46,680 --> 00:04:51,230
a new element,
namely whether size is equal to maxSize.

68
00:04:51,230 --> 00:04:54,400
If it is equal,
then we just return an error.

69
00:04:54,400 --> 00:04:55,930
Otherwise, we do the following.

70
00:04:55,930 --> 00:05:00,780
We increase size by 1,
then we assign H of size to be equal to p.

71
00:05:00,780 --> 00:05:04,924
At this point we add a new leaf in our

72
00:05:04,924 --> 00:05:10,090
implicit tree to the last level, to
the leftmost position on the last level.

73
00:05:10,090 --> 00:05:16,230
And finally, we call SiftUp to
sift this element up if needed.

74
00:05:16,230 --> 00:05:20,484
To extract the maximum value
from our binary max heap,

75
00:05:20,484 --> 00:05:26,220
we first store the value of the root
of our tree in the variable result.

76
00:05:26,220 --> 00:05:29,290
So result is assigned to be equal H of 1.

77
00:05:29,290 --> 00:05:35,740
Then we replace the root by the last leaf,
by the rightmost leaf on the last level,

78
00:05:35,740 --> 00:05:41,530
so this is done by assigning H
of 1 to be equal to H of size.

79
00:05:41,530 --> 00:05:42,260
Okay?

80
00:05:42,260 --> 00:05:47,620
Then we decrease the value of size by 1,
just to show that

81
00:05:47,620 --> 00:05:52,500
the last leaf is not in our tree anymore.

82
00:05:52,500 --> 00:05:57,950
And finally, we call SiftDown for
the root, because it was replaced by

83
00:05:59,950 --> 00:06:04,920
the last leaf, which is potentially
quite small and needs to be sifted down.

84
00:06:06,020 --> 00:06:10,420
And the last instruction in our
pseudocode is, we return the result.

85
00:06:10,420 --> 00:06:15,410
That means the value which was
initially in the root of our tree.

86
00:06:15,410 --> 00:06:16,570
Removing an element.

87
00:06:16,570 --> 00:06:18,410
So as we've discussed already,

88
00:06:18,410 --> 00:06:23,040
this actually boils down to calling
two procedures that we already have.

89
00:06:23,040 --> 00:06:26,360
Once again, to remove element number i,
we do the following.

90
00:06:26,360 --> 00:06:31,060
First, we change its priority
to be equal to infinity, so

91
00:06:31,060 --> 00:06:35,610
we assign H of i plus infinity.

92
00:06:35,610 --> 00:06:41,280
Then we SiftUp this node, so this will
move this node to the root of our tree.

93
00:06:41,280 --> 00:06:46,205
And then we just call ExtractMax()
procedure, which will remove the root from

94
00:06:46,205 --> 00:06:51,610
this tree and make necessary changes
in the tree to restore its shape.

95
00:06:52,690 --> 00:06:58,183
Finally, to change the priority of
a given node i to the given value p,

96
00:06:58,183 --> 00:06:59,970
we do the following.

97
00:06:59,970 --> 00:07:04,020
We first assign H of i to p, okay?

98
00:07:04,020 --> 00:07:08,460
Then we check whether
the new priority increased

99
00:07:08,460 --> 00:07:10,980
is greater than the old priority or
is smaller.

100
00:07:10,980 --> 00:07:15,294
If it is greater, then potentially we
need to sift up the new node.

101
00:07:15,294 --> 00:07:17,016
So we just call sift up.

102
00:07:17,016 --> 00:07:20,540
If the new priority is smaller,
then we call SiftDown for this node.

103
00:07:22,200 --> 00:07:23,900
Time to summarize.

104
00:07:23,900 --> 00:07:28,500
In this sequence of videos, we considered
the binary max heap data structure,

105
00:07:28,500 --> 00:07:33,580
which is a popular way of implementing
the priority queue data type.

106
00:07:33,580 --> 00:07:37,530
The considered implementation is
quite fast, all operations work

107
00:07:37,530 --> 00:07:41,880
in logarithmic time and GetMax
procedure works even in constant time.

108
00:07:41,880 --> 00:07:44,030
It is also space efficient.

109
00:07:44,030 --> 00:07:49,150
In this data structure, we store a tree,
but this tree is stored implicitly.

110
00:07:49,150 --> 00:07:53,770
Namely, for each node, we do not store
a connection or a link to its parent and

111
00:07:53,770 --> 00:07:54,850
its two children.

112
00:07:54,850 --> 00:08:00,640
Instead, we compute the index of
the corresponding nodes on the fly.

113
00:08:00,640 --> 00:08:06,760
Well, in this case, we store just n
given cells in an array, nothing more.

114
00:08:06,760 --> 00:08:09,180
Okay?
Another advantage of this data structure,

115
00:08:09,180 --> 00:08:14,420
of this implementation,
is that it is really easy to code.

116
00:08:14,420 --> 00:08:21,555
As you've seen, the pseudocode of each
operation is just a few lines of code.

117
00:08:21,555 --> 00:08:23,528
Well, in the next video,

118
00:08:23,528 --> 00:08:28,115
we will show how to use binary
heap to sort data efficiently.