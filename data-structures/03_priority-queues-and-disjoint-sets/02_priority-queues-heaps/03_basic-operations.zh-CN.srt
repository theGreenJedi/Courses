1
00:00:00,910 --> 00:00:02,310
大家好 欢迎回来

2
00:00:02,310 --> 00:00:04,920
我们将继续讲解二叉搜索树。

3
00:00:04,920 --> 00:00:08,320
今天，我们要讨论如何实现二叉树的基本操作

4
00:00:08,320 --> 00:00:09,330
今天，我们要讨论如何实现二叉树的基本操作

5
00:00:09,330 --> 00:00:10,850
还有实现二叉树又有哪些值得注意的地方

6
00:00:10,850 --> 00:00:15,160
还有实现二叉树又有哪些值得注意的地方

7
00:00:15,160 --> 00:00:17,400
先从如何实现搜索开始

8
00:00:17,400 --> 00:00:21,017
也是二叉树的核心功能

9
00:00:21,017 --> 00:00:21,620
也是二叉树的核心功能

10
00:00:21,620 --> 00:00:24,600
我们用Find函数实现

11
00:00:24,600 --> 00:00:26,460
我们用Find函数实现

12
00:00:27,490 --> 00:00:28,830
我们用Find函数实现

13
00:00:28,830 --> 00:00:33,660
输入是键值 k和树的根R

14
00:00:33,660 --> 00:00:38,160
返回键值为k的节点

15
00:00:38,160 --> 00:00:39,410
返回键值为k的节点

16
00:00:40,540 --> 00:00:44,130
我们要做的就是这个

17
00:00:44,130 --> 00:00:48,010
否则也不会叫Binary Search Tree(二叉查找树)

18
00:00:48,010 --> 00:00:50,870
我们要在树的顶端开始

19
00:00:50,870 --> 00:00:54,920
拿6和Root,也就是7比较

20
00:00:54,920 --> 00:00:58,330
6比7小，所以我们转移到左支继续

21
00:00:58,330 --> 00:01:02,120
因为左支都是比7小的

22
00:01:03,200 --> 00:01:04,510
我们到左边

23
00:01:04,510 --> 00:01:07,600
拿6和4比较

24
00:01:07,600 --> 00:01:09,720
6大于4

25
00:01:09,720 --> 00:01:12,860
比4大的都在4的右支

26
00:01:12,860 --> 00:01:17,070
所以我们到右边

27
00:01:17,070 --> 00:01:18,400
现在6和6比较

28
00:01:18,400 --> 00:01:21,320
它们相等，所以搜索完成

29
00:01:22,650 --> 00:01:26,930
这个算法用递归实现很容易

30
00:01:26,930 --> 00:01:30,030
如果根R的值等于k，搜索就完成了

31
00:01:30,030 --> 00:01:33,780
直接返回节点R

32
00:01:35,175 --> 00:01:40,960
如果R的键值>k，我们转移到左支

33
00:01:40,960 --> 00:01:44,150
如果R的键值>k，我们转移到左支

34
00:01:44,150 --> 00:01:48,260
在左支递归运行查找k

35
00:01:49,780 --> 00:01:53,880
如果R.key <k，我们转移到右支

36
00:01:53,880 --> 00:01:56,350
继续递归寻找

37
00:01:57,560 --> 00:02:01,670
如果k在树里面，那还好

38
00:02:01,670 --> 00:02:04,880
如果k不在树里面，又应该如何修改算法？

39
00:02:04,880 --> 00:02:06,920
如果我们要找5

40
00:02:06,920 --> 00:02:08,250
比7小

41
00:02:08,250 --> 00:02:08,950
比4大

42
00:02:08,950 --> 00:02:10,130
比6小

43
00:02:10,130 --> 00:02:12,340
6没有分支

44
00:02:12,340 --> 00:02:16,200
我们该怎么办？

45
00:02:16,200 --> 00:02:19,610
我们可以返回一个Null值，或是提示错误，

46
00:02:19,610 --> 00:02:24,200
但是，我们还是有点成果的

47
00:02:24,200 --> 00:02:27,200
虽然没有找到5，

48
00:02:27,200 --> 00:02:31,540
但我们知道了，如果5在树里的话，它大致应该在哪里

49
00:02:32,950 --> 00:02:37,150
所以，除了返回Null

50
00:02:37,150 --> 00:02:38,820
我们可以选择返回一些有用的信息

51
00:02:38,820 --> 00:02:42,520
我们找到了k适合出现的位置

52
00:02:42,520 --> 00:02:46,790
我们现在修改Find

53
00:02:46,790 --> 00:02:54,560
如果说R.key> k，我们先检查左支是否存在

54
00:02:54,560 --> 00:02:58,750
如果说R.key> k，我们先检查左支是否存在

55
00:02:58,750 --> 00:03:00,920
如果存在

56
00:03:00,920 --> 00:03:04,310
继续递归寻找

57
00:03:04,310 --> 00:03:08,440
否则的话，我们返回当前的R

58
00:03:08,440 --> 00:03:10,380
否则的话，我们返回当前的R

59
00:03:10,380 --> 00:03:13,650
如果要找的元素不在树里面，

60
00:03:13,650 --> 00:03:18,600
我们至少返回一些有用的信息

61
00:03:18,600 --> 00:03:20,860
接下来

62
00:03:20,860 --> 00:03:24,040
除了搜索元素，我们还可以返回与节点N最相近的下一个元素

63
00:03:24,040 --> 00:03:27,690
除了搜索元素，我们还可以返回与节点N最相近的下一个元素

64
00:03:29,120 --> 00:03:32,960
我们给这个函数起名Next

65
00:03:32,960 --> 00:03:38,030
输入是节点N，返回树里面下一个比它大的元素

66
00:03:39,880 --> 00:03:44,748
我们不用去搜索树里的每个元素

67
00:03:44,748 --> 00:03:49,198
我们把范围限定在只比N大一点点的那些可能的元素

68
00:03:49,198 --> 00:03:52,310
如果N有右支，那就容易了

69
00:03:52,310 --> 00:03:56,580
我们第一步就会转移到N的右支

70
00:03:56,580 --> 00:03:58,520
因为它比N大

71
00:03:58,520 --> 00:04:00,820
然后你再转移到N的右支的左支

72
00:04:00,820 --> 00:04:04,510
因为这会更接近N

73
00:04:04,510 --> 00:04:06,680
因为这会更接近N

74
00:04:06,680 --> 00:04:10,940
直到你到达的节点不能再往左为止

75
00:04:10,940 --> 00:04:14,000
这时候左支不存在，我们返回这个节点

76
00:04:15,600 --> 00:04:20,300
如果N没有右支，那就不管用了

77
00:04:20,300 --> 00:04:22,920
这时候我们也不能往左支走，

78
00:04:22,920 --> 00:04:25,460
左边所有元素只会比N小

79
00:04:25,460 --> 00:04:28,370
所以我们往N的上方走

80
00:04:28,370 --> 00:04:29,840
看N的父母节点是否比N小

81
00:04:29,840 --> 00:04:33,250
如果是，继续往上，

82
00:04:33,250 --> 00:04:38,290
直到找到一个比N大的祖先节点

83
00:04:38,290 --> 00:04:41,130
找到后，这就是我们要的答案

84
00:04:42,660 --> 00:04:46,690
Next函数需要分具体情况

85
00:04:46,690 --> 00:04:51,919
如果N没有右支，我们执行一个RightAncestor的函数

86
00:04:51,919 --> 00:04:56,829
也就是从N的祖先节点中找

87
00:04:56,829 --> 00:05:00,447
否则我们执行LeftDescendant的函数，参数是N的右支

88
00:05:00,447 --> 00:05:04,120
等于是从N的右支出发一直往左，直到不能再往左为止

89
00:05:05,520 --> 00:05:07,780
这两个函数都很容易实现，递归执行LeftDescendant

90
00:05:07,780 --> 00:05:12,250
如果没有左支，返回N

91
00:05:12,250 --> 00:05:15,330
否则就一直往左

92
00:05:17,010 --> 00:05:22,140
RightAncestor函数中，看N的祖先节点是否比N大

93
00:05:22,140 --> 00:05:26,950
是的话，返回这个祖先节点，否则继续往上，直到找到比N大的

94
00:05:26,950 --> 00:05:29,180
是的话，返回这个祖先节点，否则继续往上，直到找到比N大的

95
00:05:29,180 --> 00:05:32,070
现在我们再来看下一个基本操作

96
00:05:33,290 --> 00:05:37,830
我们来看之前提过的范围搜索

97
00:05:37,830 --> 00:05:41,370
输入是两个数字x,y, 树的根R

98
00:05:41,370 --> 00:05:44,830
返回一个键值在x和y之间的所有节点的列表

99
00:05:44,830 --> 00:05:48,480
这个很容易实现

100
00:05:49,830 --> 00:05:53,430
我们现在要找到5和12之间的元素

101
00:05:53,430 --> 00:05:55,610
我们现在要找到5和12之间的元素

102
00:05:55,610 --> 00:05:59,340
我们先找到这个范围里的第一个元素

103
00:05:59,340 --> 00:06:01,340
也就是6

104
00:06:01,340 --> 00:06:05,200
然后找下一个，7

105
00:06:05,200 --> 00:06:09,480
再下一个10，再下一个13，超出范围，所以我们停下

106
00:06:11,390 --> 00:06:13,570
还是挺简单的

107
00:06:13,570 --> 00:06:16,920
建立一个列表，用来储存我们找到的元素

108
00:06:18,020 --> 00:06:23,000
我们用N变量要储存找到的元素

109
00:06:24,370 --> 00:06:29,430
始终确保N的键值小于y, 然后判断是否大于x

110
00:06:29,430 --> 00:06:32,210
始终确保N的键值小于y, 然后判断是否大于x

111
00:06:32,210 --> 00:06:37,200
如果是，加入我们的列表，然后把N的值更新为Next(N)

112
00:06:37,200 --> 00:06:40,980
接下来继续遍历，直到大于y

113
00:06:40,980 --> 00:06:43,310
然后我们返回L列表

114
00:06:43,310 --> 00:06:45,220
这就是RangeSearch的过程

115
00:06:45,220 --> 00:06:48,570
Next()函数我们已经之前提过了

116
00:06:50,000 --> 00:06:53,650
我们接下来看如何实现插入和删除

117
00:06:53,650 --> 00:06:58,010
插入(Insertion)的输入是要加入的节点k和树根R

118
00:06:58,010 --> 00:07:01,810
返回带有k的树

119
00:07:03,340 --> 00:07:07,740
我们可以把新元素直接附加在其中一片叶子上

120
00:07:07,740 --> 00:07:11,240
我们可以把新元素直接附加在其中一片叶子上

121
00:07:11,240 --> 00:07:12,430
看上确实符合要求

122
00:07:13,600 --> 00:07:15,780
但是有一个问题，

123
00:07:15,780 --> 00:07:18,120
我们不能只看上一层的parent

124
00:07:18,120 --> 00:07:21,060
3比7小，

125
00:07:21,060 --> 00:07:23,610
所以必须加在左边

126
00:07:23,610 --> 00:07:27,950
而且还有其他情况我们需要考虑

127
00:07:27,950 --> 00:07:29,680
以维持二叉树的搜索功能

128
00:07:30,990 --> 00:07:33,800
好在

129
00:07:33,800 --> 00:07:37,750
之前的Find函数可以告诉我们

130
00:07:37,750 --> 00:07:40,490
一个新元素应该放在哪里

131
00:07:41,650 --> 00:07:46,850
所以，insert函数可以借用Find

132
00:07:46,850 --> 00:07:51,260
然后返回节点P，至于，加在P的左支还是右支

133
00:07:51,260 --> 00:07:54,720
比较一下就行了

134
00:07:55,810 --> 00:07:56,310
比较一下就行了

135
00:07:58,060 --> 00:07:59,730
Delete比较复杂

136
00:08:00,740 --> 00:08:04,530
我们要删除节点N

137
00:08:05,740 --> 00:08:09,540
我们不能直接这么做

138
00:08:09,540 --> 00:08:10,790
否则以下的节点无法连接

139
00:08:10,790 --> 00:08:14,240
否则以下的节点无法连接

140
00:08:14,240 --> 00:08:15,980
所以我们要想个方法把空填补掉

141
00:08:17,570 --> 00:08:19,870
其中一个填补的方法是

142
00:08:19,870 --> 00:08:24,470
找到被删除节点的下一个比它大的元素X

143
00:08:24,470 --> 00:08:29,020
用X来填补

144
00:08:29,020 --> 00:08:31,060
用X来填补

145
00:08:32,660 --> 00:08:34,760
但是，总会有例外

146
00:08:34,760 --> 00:08:39,250
X不可能有左支，因为它是最接近N的较大元素

147
00:08:39,250 --> 00:08:43,260
X不可能有左支，因为它是最接近N的较大元素

148
00:08:44,970 --> 00:08:48,590
但X可能会有右支

149
00:08:48,590 --> 00:08:52,900
把X拿走填补N，我们还要处理X留下的空挡

150
00:08:52,900 --> 00:08:55,350
把X拿走填补N，我们还要处理X留下的空挡

151
00:08:55,350 --> 00:08:59,170
所以，我们只能再把Y提上来代替X

152
00:08:59,170 --> 00:09:03,420
所以，我们只能再把Y提上来代替X

153
00:09:03,420 --> 00:09:05,330
所以，我们只能再把Y提上来代替X

154
00:09:05,330 --> 00:09:10,497
所以，我们只能再把Y提上来代替X

155
00:09:10,497 --> 00:09:12,540
Delete的实现稍微复杂一些

156
00:09:13,630 --> 00:09:16,920
首先，检查N有没有右支

157
00:09:16,920 --> 00:09:20,720
如果没有，直接去掉N，用N的左支填补

158
00:09:20,720 --> 00:09:25,220
如果没有，直接去掉N，用N的左支填补

159
00:09:25,220 --> 00:09:29,520
如果没有，直接去掉N，用N的左支填补

160
00:09:29,520 --> 00:09:34,170
如果没有，直接去掉N，用N的左支填补

161
00:09:34,170 --> 00:09:37,930
否则，找到N之后下一个较大元素X

162
00:09:37,930 --> 00:09:40,720
注意，X不可能有左支

163
00:09:41,920 --> 00:09:46,460
用X替代N，如果X有右支

164
00:09:46,460 --> 00:09:49,310
用X右支代替X

165
00:09:50,680 --> 00:09:53,110
结束~

166
00:09:53,110 --> 00:09:55,030
复习一下

167
00:09:55,030 --> 00:09:59,430
我们删除了这个树里被高亮标出的元素

168
00:09:59,430 --> 00:10:03,820
结果会是哪个树？

169
00:10:03,820 --> 00:10:05,220
答案是C

170
00:10:05,220 --> 00:10:08,790
我们删除了1

171
00:10:08,790 --> 00:10:11,370
所以要用下一个较大元素，也就是2来代替1的位置

172
00:10:11,370 --> 00:10:15,320
把2提上来

173
00:10:15,320 --> 00:10:18,380
2的右支4，被提上来代替2

174
00:10:18,380 --> 00:10:21,210
2的右支4，被提上来代替2

175
00:10:21,210 --> 00:10:24,570
6和其他元素都不动

176
00:10:26,360 --> 00:10:31,330
这节课我们讲解了二叉查找树的基本功能实现

177
00:10:31,330 --> 00:10:34,920
下一次我们会讲解这些功能的运行时间

178
00:10:34,920 --> 00:10:38,170
会很有意思