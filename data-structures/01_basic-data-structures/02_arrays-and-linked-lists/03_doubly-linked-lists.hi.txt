एक तरीका है जिससे कि पीछे पॉप करना और पहले ऐड करना / जोड़ना चीप / आसान हो जाता है॰ हमारी समस्या थी कि यद्यपि हमारे पास था एक तरीका जाने का एक पिछले एलिमेंट से अगले एलीमेंट तक, हमारे पास कोई तरीका नहीं था वापिस / पीछे जाने का॰ और एक डबली-लिंक्ड लिस्ट कहती है कि, अच्छा, आओ चलें आगे और डालें / जोड़े एक तरीका पीछे जाने का॰ इसलिए हमारे पास होंगे दो पॉइंटर्स, फॉरवर्ड / अगला और बैकवर्ड / पिछला पोइन्टर्ज॰ वह है दो तरफा ऐरो जिसे हम दिखा रहें हैं यहाँ सिद्धांतिक रूप में॰ और तरीका जैसे हम असल में इसे लागू करेंगे वह है, एक नोड के साथ जो ऐड करता / जोड़ता है एक अतिरिक्त पॉइंटर॰ तो हमारे पास है न केवल एक नेक्स्ट पॉइंटर, हमारे पास है एक प्रीवियस पॉइंटर भी॰ तो उदाहरणता यह दर्शाता है कि एलिमेंट 10 का है एक नेक्स्ट पॉइंटर जो पॉइंट करता है 4 की तरफ परंतु एक प्रीवियस पॉइंटर जो पॉइंट करता है 7 की तरफ॰ तो किसी भी नोड पर हम जा सकते हैं आगे या जा सकते है पीछे॰ तो इसका मतलब है कि अगर हम लिस्ट के पीछे पॉप करना चाहे, तो वह बहुत आसान हो जायेगा॰ हम क्या करेंगे कि अपडेट करेंगे टेल पॉइंटर को पॉइंट करने के लिए पिछले एलिमेंट पर क्योंकि फिर हम पहुँच सकते हैं वहाँ एक O(1) ऑपरेशन में॰ और उसके बाद अपडेट करें उसका नेक्स्ट पॉइंटर निल पर और फिर अंत में नोड को हटा देंगे॰ तो यह एक O(1) है॰ तो अगर हमारे पास है एक डबली लिंक्ड लिस्ट यह (हमारा कोड) थोड़ा अधिक मुश्किल होगा क्योंकि हमें सुनिश्चित करना होगा मैनेज करना दोनों प्रीवियस पॉइंटर्स और नेक्स्ट पॉइंटर्स॰ इसलिए अगर हम पुश कर रहें हैं कुछ आखिर में, हम एलोकेट करेंगे एक नया नोड॰ अगर टेल निल है, जिसका मतलब है वो खाली है, तब हमारे पास है एक अकेला नोड जिसके प्रीवियस और नेक्स्ट पॉइंटरज़ दोनों निल हैं और तब हेड और टेल दोनों उसी की तरफ इशारा करेंगे॰ नहीं तो, हमे अपडेट करना होगा टेल के नेक्स्ट पॉइंटर को इस नए नोड के लिए, क्योंकि हम आखिर में पुश कर रहे है और तब हम अपडेट करते है इस नए नोड के प्रीवियस पॉइंटर को पॉइंट करने के लिए पुराने टेल को और तब आखिर मे अपडेट करते हैं टेल पॉइंटर को ही॰ पोपिंग दी बैक, भी काफी सरल / आसान है॰ हम फिर चेक करेंगे देखने के लिए कि क्या पहले यह एक खाली लिस्ट है, ऐसे होने पर यह एक एरर है॰ एक लिस्ट सिर्फ एक एलिमेंट के साथ, इस केस में यह आसान है॰ नहीं तो हमे आगे जाना होगा और अपडेट करना होगा हमारी टेल को प्रीवियस टेल में, और उस नोड के नेक्स्ट को निल में॰ ऐडिंग आफ्टर, काफी आसान फिर हमे सिर्फ मेनटेन करना होगा प्रिवियस पॉइंटर लेकिन ऐडिंग बिफोर भी अब काम करता है इस सेंस में कि हम कर सकते हैं एलोकेट अपना नोड, हमारा नया नोड और इसका प्रीवियस पॉइंटर होगा प्रीवियस पॉइंटर मौजूदा नोड का जिसके पहले हम जोड़ रहे है॰ हम इसे इसी तरह जोड़ते है और उसके बाद हम अपडेट करेंगे उस पिछले नोड के नेक्स्ट पॉइंटर को पॉइंट करने के लिए हमारे नए नोड की तरफ॰ और अंत में, अगर हम हेड के पहले जोड़ रहे है तो, हमें हेड को अपडेट करना होगा॰ तो एक सिंगली-लिंक्ड लिस्ट में, हमने देखा चीजो की कोस्ट / मूल्य को॰ लिस्ट के फ्रंट / आगे वाले भाग में काम करना आसान था, लिस्ट के बैक / पिछले हिस्से में काम करना बिना टेल के, था सब लिनियर टाईम / अनुपात में समय लेता था॰ अगर हमने टेल जोड़ा, तब कुछ आखिर में पुश करना आसान था, आसान था आखिरी हिस्से से कुछ निकालना, लेकिन मुश्किल था एंड / वहाँ से कुछ हटाना॰ डबली लिंक्ड लिस्ट में जाते ही, एंड / पीछे से हटाना ( एक पॉपबैक) बन जाता है अब एक O(1) आपरेशन, जैसा कि बनता है ऐडिग बिफोर जो होता था एक लिनियर टाईम ऑपरेशन॰ एक बात बताना ज़रूरी है जब हम कंटरास्ट / तुलना करते है ऐरेज़ और लिंक्ड लिस्टस में॰ तो ऐरेज़ में, हमें मिलता है रैंडम एक्सेस, उस नजरिये से कि बराबर समय लगता है किसी भी एलिमेंट को एक्सेस करने में॰ उससे बाइनरी सर्च जैसी चीजें बहुत आसान हो जाती है, जहां हम बीच से खोजना शुरू करते है, और फिर बताते है (अगर सोरटिड / एक क्रम में ऐरे है), और तब तय कर सकते हैं कि ऐरे के किस साइड में हम हैं॰ और फिर, एक साइड या दूसरे साइड जा सकते हैं॰ लिंक्ड लिस्ट के लिए, यह काम नहीं करता॰ बीच का एलिमेंट ढूँढना एक खर्चीला / मुश्किल ऑपरेशन है, क्योंकि आपको या तो हेड से शुरू करना होगा या टेल से और वहाँ से बीच में पहुंचना होगा॰ इसलिए वह एक O(n) आपरेशन है किसी विशेष एलीमेंट तक पहुँचना॰ उसमे और एक ऐरे में बड़ा अंतर है॰ फिर भी, लिंक्ड लिस्टस समान समय लेते है फ्रंट / आगे से एलिमेंट जोड़ने में या हटाने में, ऐरे की तरह नहीं / ऐरे से भिन्न॰ ऐरे में हमने देखा कि, अगर आप फ्रंट / आगे से जोड़ना चाहते है, या हटाना चाहते है फ्रंट से, तो आपको O(n) टाइम लगेगा क्योंकि आपको हिलाना होगा एलिमेंटस के एक समूह को॰ अगर आपके पास है एक टेल और डबली लिंक्ड लिस्ट, वो भी एक समान समय लेता है लिस्ट के अंत में काम करना॰ तो आप वहाँ जा सकते हो या वहाँ से हटा सकते हो॰ लीनियर टाइम लगता है किसी भी / आर्बिट्रेरी एलिमेंट को ढूंढने में॰ लिस्ट के एलिमेंट कंटिगुअस / लगातार नहीं होते जैसे कि वे ऐरे में होते हैं॰ आपके पास होते हैं अलग अलग एलोकेटिड / निर्धारित लोकेशञ्ज मेमोरी के और फिर उनके बीच में पॉइंटरज़ होते है॰ और तब, हमारे पास है डबली लिंक्ड लिस्ट इसमें भी जोड़ना एक समान समय का ऑपरेशन है नोडज़ के बीच में या फिर एक नोड हटाने में॰