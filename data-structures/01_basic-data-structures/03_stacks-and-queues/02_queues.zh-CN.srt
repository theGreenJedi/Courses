1
00:00:01,610 --> 00:00:02,690
现在，让我们来谈谈队列

2
00:00:03,700 --> 00:00:09,870
队列与堆栈有着诸多相似点

3
00:00:09,870 --> 00:00:11,170
但是，在一个重要的方面，他们是极其不同的

4
00:00:11,170 --> 00:00:14,760
队列是一种抽象数据类型，它可以进行多种操作

5
00:00:14,760 --> 00:00:20,130
当你入队(Enqueue)一个元素（key）,队列将会添加这个键

6
00:00:20,130 --> 00:00:25,420
当你进行删除操作（Dequeue），当前队列将会返回一个元素（Key）并且将其从队列中去除

7
00:00:26,520 --> 00:00:30,280
这个被返回并且去除的键，是最早添加的那一个。

8
00:00:30,280 --> 00:00:33,040
而不是像一个堆栈，堆栈的删除操作是在最近添加的元素（Key）上进行的

9
00:00:33,040 --> 00:00:35,300
所以说，那就是队列和堆栈最本质的不同

10
00:00:35,300 --> 00:00:38,200
如果你将队列想象成在一个队伍里排队

11
00:00:38,200 --> 00:00:42,630
你就会明白队列遵循的是先来先服务的原则

12
00:00:42,630 --> 00:00:46,850
所以，你在队伍里等待得越久

13
00:00:46,850 --> 00:00:49,730
就像在队伍里等待时间最长的那个人，将会是下一个被服务的人

14
00:00:49,730 --> 00:00:50,940
为了便于理解

15
00:00:50,940 --> 00:00:56,450
你可想象你有一个杂货店

16
00:00:56,450 --> 00:01:00,820
如果杂货店以堆栈的形式服务客人，客人将会变得相当恼怒，对吗？

17
00:01:00,820 --> 00:01:02,170
因为（你想想），那个刚刚到达的人

18
00:01:02,170 --> 00:01:05,420
你已经排了十分钟的队，一个刚刚到达的人

19
00:01:05,420 --> 00:01:08,510
他们比你还早得到服务，你不会乐意看到这件事的

20
00:01:08,510 --> 00:01:12,800
所以，队列是十分有用的，比如说对于服务者

21
00:01:12,800 --> 00:01:15,940
当一大堆操作开始进行

22
00:01:15,940 --> 00:01:19,510
服务者会优先服务等待最久的那个请求

23
00:01:20,720 --> 00:01:25,510
队列可以进行的其他操作诸如你可以检查队列是否为空

24
00:01:25,510 --> 00:01:28,300
队列的这些特性可以称之为FIFO，先进，先出

25
00:01:28,300 --> 00:01:32,380
这一原则明显区分于堆栈的LIFO（后进先出）

26
00:01:32,380 --> 00:01:34,590
后买进的先卖出

27
00:01:34,590 --> 00:01:37,870
先进先出，或者说，先来先服务

28
00:01:40,360 --> 00:01:41,270
那么，如何实现一个队列呢？

29
00:01:41,270 --> 00:01:45,175
一种方式是通过一个拥有头指针和尾指针的链表实现

30
00:01:45,175 --> 00:01:48,575
让我们从一个空链表开始

31
00:01:48,575 --> 00:01:54,133
接着，执行入队（Enqueue）操作。在入队操作里

32
00:01:54,133 --> 00:01:57,890
我们要做的是将元素（Key）插入到队列的尾部

33
00:01:57,890 --> 00:02:00,701
这就是我们如何实现一个入队操作

34
00:02:00,701 --> 00:02:03,797
你可以看到，当我们对a进行入队操作，a已经在链表的尾部

35
00:02:03,797 --> 00:02:07,083
如果我们对b进行入队操作，b也将会被添加到队列里

36
00:02:07,083 --> 00:02:08,739
在链表的尾部位置

37
00:02:09,900 --> 00:02:10,970
链表是空的吗？答案显然是否定的

38
00:02:10,970 --> 00:02:12,680
我们怎么知道队列是否为空的呢？

39
00:02:12,680 --> 00:02:15,750
最简单的做法，我们将仅仅求助于链表的底层实现方式

40
00:02:15,750 --> 00:02:16,990
看看链表是否为空

41
00:02:16,990 --> 00:02:17,760
链表不为空

42
00:02:17,760 --> 00:02:20,620
也就意味着队列不为空

43
00:02:20,620 --> 00:02:25,088
检验链表是否为空，要做的，仅仅是检验其头指针是否为空

44
00:02:25,088 --> 00:02:32,060
如果我们将c进行入队操作，c将被插入链表的尾部

45
00:02:32,060 --> 00:02:34,360
如果我现在进行出队（Dequeue）操作，哪一项会被去除呢？

46
00:02:34,360 --> 00:02:38,480
再一次说明，这不是一个堆栈，在堆栈里，c会被去除

47
00:02:38,480 --> 00:02:41,540
在这个例子里，a将被去除，因为a在队伍里待得最久

48
00:02:41,540 --> 00:02:44,760
这就是从队首去除元素的实现

49
00:02:47,010 --> 00:02:47,930
所以，这一操作将返回a

50
00:02:49,430 --> 00:02:53,348
现在，我们可以进行一些更多的入队操作，将d入队，将e入队

51
00:02:53,348 --> 00:02:57,160
将f入队，好了，我们停止入队操作，开始从队首进行出队操作

52
00:02:58,330 --> 00:03:03,298
将b出队，将c出队，将d出对抗，将e出队

53
00:03:03,298 --> 00:03:05,670
最后，将f出队

54
00:03:05,670 --> 00:03:10,400
现在如果我们查询队列是否为空，答案是yes

55
00:03:10,400 --> 00:03:14,470
需要注意的是，我们判断的依据是，头指针是空指针

56
00:03:14,470 --> 00:03:19,160
入队操作需要使用链表的PushBack操作，出队操作需要使用到链表的

57
00:03:19,160 --> 00:03:24,080
TopFront操作去获得队首的元素，出队操作还需要链表的PopFront操作去删除队首元素

58
00:03:25,300 --> 00:03:28,360
判定队列是否为空仅仅也是使用了链表的Empty方法

59
00:03:30,040 --> 00:03:30,790
如果用一个数组实现呢？

60
00:03:30,790 --> 00:03:33,980
可以预见，做法是相似的

61
00:03:33,980 --> 00:03:37,890
也就是说，我们可以在尾部添加，在头部弹出并删除元素

62
00:03:37,890 --> 00:03:39,610
你可以自己想象一下

63
00:03:39,610 --> 00:03:44,790
我们所说的数组头部，也就是队列的队首

64
00:03:46,100 --> 00:03:50,460
入队操作很容易，但是出队（Dequeue）操作的代价高达O(n)

65
00:03:50,460 --> 00:03:51,930
我们想要实现O（1）复杂度的出队操作

66
00:03:51,930 --> 00:03:56,980
我们可以做到，以一种不那么完美的方式，我将向你演示，这种方式

67
00:03:56,980 --> 00:04:02,070
通过追踪某种环形数组实现

68
00:04:02,070 --> 00:04:05,208
让我们继续，对a进行入队操作，现在我们有了写入的编号地址

69
00:04:05,208 --> 00:04:09,150
写入的编号告诉我们，下一个入队操作应该在哪里发生

70
00:04:09,150 --> 00:04:12,800
读入的编号则告诉我们下一个出队操作应该在哪里进行

71
00:04:12,800 --> 00:04:16,510
所以，我们将a入队，将b入队，现在我们更新写入编号

72
00:04:17,740 --> 00:04:19,060
如果我们查询队列是否为空？

73
00:04:19,060 --> 00:04:21,400
不为空，因为读入的编号和写入的编号不相等

74
00:04:21,400 --> 00:04:26,020
那就是说，队列中还有已经入队的元素没有出队

75
00:04:28,270 --> 00:04:29,718
Empty方法也就返回false

76
00:04:29,718 --> 00:04:34,540
我们对c进行入队操作，然后出队，再次说明，我们出队的对象是a

77
00:04:34,540 --> 00:04:36,410
我们出队的操作用过读入编号实现

78
00:04:36,410 --> 00:04:39,920
所以，我们所做的，不过是，读取在读入编号的元素，并且增加读入编号

79
00:04:42,090 --> 00:04:46,460
如果我们再次进行出队操作，我们读取的将是在读入编号位置的b，接着

80
00:04:46,460 --> 00:04:48,110
我们增加原有的读入编号

81
00:04:48,110 --> 00:04:51,570
现在，我们可以做一些更多地入队操作

82
00:04:51,570 --> 00:04:55,890
需要注意的是，这时当我们将d入队时，写入的编号将是4

83
00:04:55,890 --> 00:05:01,410
下一次我们将e入队

84
00:05:01,410 --> 00:05:06,420
e将被放入编号为4的位置，而写入编号将回到最初的位置

85
00:05:09,610 --> 00:05:13,830
一个需要注意的地方是，这个数组中，我们使用的编号方式是从0开始的

86
00:05:13,830 --> 00:05:15,640
由于第一个元素的编号就是0

87
00:05:16,960 --> 00:05:19,850
我们再次进行入队操作，将f入队

88
00:05:19,850 --> 00:05:23,860
现在，如果我们尝试将g入队，那将是不被允许的

89
00:05:23,860 --> 00:05:25,100
如果进行了，会是一个错误

90
00:05:25,100 --> 00:05:28,957
错误的原因是，如果要这么做

91
00:05:28,957 --> 00:05:30,961
读入编好和写入编号将都变成2

92
00:05:30,961 --> 00:05:35,400
那将很难区分队列是已经满了，又或者

93
00:05:35,400 --> 00:05:39,490
是队列是空的

94
00:05:39,490 --> 00:05:43,980
因此，我们设置一个至少一个元素的无法写入的缓冲区域

95
00:05:43,980 --> 00:05:46,090
以确保读和写是分离的

96
00:05:46,090 --> 00:05:50,580
以及能够判断队列是否为空

97
00:05:50,580 --> 00:05:53,370
现在，我们将进行出队操作，所以，我们将c出队，需要做的，不过是

98
00:05:53,370 --> 00:05:54,770
从读入编号的位置读取元素，然后更新读入编号

99
00:05:54,770 --> 00:05:57,670
将d出队，从读入编号的位置读取元素，然后更新读入编号

100
00:05:57,670 --> 00:06:04,380
将e出队，再一次地，从读入编号的位置读取元素，然后更新读入编号

101
00:06:04,380 --> 00:06:07,360
最后，我们进行最后一次出队操作，现在，读入编号和

102
00:06:07,360 --> 00:06:09,190
写入编号都是1

103
00:06:09,190 --> 00:06:13,160
也就意味着如果我们查询队列是否为空，回答将会是yes

104
00:06:14,590 --> 00:06:19,111
现在，我们可以看到，在这种方式下，出队和入队的操作

105
00:06:19,111 --> 00:06:23,790
以及查询队列是否为空的代价都是O(1)

106
00:06:25,670 --> 00:06:27,330
我们也可以用链表实现

107
00:06:27,330 --> 00:06:31,330
尽管我们必须保持一个尾部指针，以便PushBack操作可以方便进行

108
00:06:32,670 --> 00:06:34,350
每一个操作的代价都是O(1)

109
00:06:34,350 --> 00:06:39,260
用数组实现和用链表实现的不同之处在于

110
00:06:39,260 --> 00:06:43,320
在数组实现方式里，我们有一个队列所能达到的最大容量

111
00:06:43,320 --> 00:06:44,130
也就是说，数组实现的队列是有界限的

112
00:06:45,430 --> 00:06:49,270
也许你喜欢用这种方式进行，那很好。但是，如果你都不知道

113
00:06:49,270 --> 00:06:54,450
你的队列要使用多久，数组实现会是个坏主意

114
00:06:54,450 --> 00:06:57,930
还有一点，任何没使用的空间都是浪费掉了

115
00:06:59,485 --> 00:07:03,125
在一个链表实现的队列里

116
00:07:03,125 --> 00:07:06,745
队列的容量可以变得任意大，只要还有足够的存储空间

117
00:07:06,745 --> 00:07:11,675
The downside is, every element you
have to pay for another pointer.