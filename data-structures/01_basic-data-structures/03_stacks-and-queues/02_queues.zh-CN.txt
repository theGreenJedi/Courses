现在，让我们来谈谈队列 队列与堆栈有着诸多相似点 但是，在一个重要的方面，他们是极其不同的 队列是一种抽象数据类型，它可以进行多种操作 当你入队(Enqueue)一个元素（key）,队列将会添加这个键 当你进行删除操作（Dequeue），当前队列将会返回一个元素（Key）并且将其从队列中去除 这个被返回并且去除的键，是最早添加的那一个。 而不是像一个堆栈，堆栈的删除操作是在最近添加的元素（Key）上进行的 所以说，那就是队列和堆栈最本质的不同 如果你将队列想象成在一个队伍里排队 你就会明白队列遵循的是先来先服务的原则 所以，你在队伍里等待得越久 就像在队伍里等待时间最长的那个人，将会是下一个被服务的人 为了便于理解 你可想象你有一个杂货店 如果杂货店以堆栈的形式服务客人，客人将会变得相当恼怒，对吗？ 因为（你想想），那个刚刚到达的人 你已经排了十分钟的队，一个刚刚到达的人 他们比你还早得到服务，你不会乐意看到这件事的 所以，队列是十分有用的，比如说对于服务者 当一大堆操作开始进行 服务者会优先服务等待最久的那个请求 队列可以进行的其他操作诸如你可以检查队列是否为空 队列的这些特性可以称之为FIFO，先进，先出 这一原则明显区分于堆栈的LIFO（后进先出） 后买进的先卖出 先进先出，或者说，先来先服务 那么，如何实现一个队列呢？ 一种方式是通过一个拥有头指针和尾指针的链表实现 让我们从一个空链表开始 接着，执行入队（Enqueue）操作。在入队操作里 我们要做的是将元素（Key）插入到队列的尾部 这就是我们如何实现一个入队操作 你可以看到，当我们对a进行入队操作，a已经在链表的尾部 如果我们对b进行入队操作，b也将会被添加到队列里 在链表的尾部位置 链表是空的吗？答案显然是否定的 我们怎么知道队列是否为空的呢？ 最简单的做法，我们将仅仅求助于链表的底层实现方式 看看链表是否为空 链表不为空 也就意味着队列不为空 检验链表是否为空，要做的，仅仅是检验其头指针是否为空 如果我们将c进行入队操作，c将被插入链表的尾部 如果我现在进行出队（Dequeue）操作，哪一项会被去除呢？ 再一次说明，这不是一个堆栈，在堆栈里，c会被去除 在这个例子里，a将被去除，因为a在队伍里待得最久 这就是从队首去除元素的实现 所以，这一操作将返回a 现在，我们可以进行一些更多的入队操作，将d入队，将e入队 将f入队，好了，我们停止入队操作，开始从队首进行出队操作 将b出队，将c出队，将d出对抗，将e出队 最后，将f出队 现在如果我们查询队列是否为空，答案是yes 需要注意的是，我们判断的依据是，头指针是空指针 入队操作需要使用链表的PushBack操作，出队操作需要使用到链表的 TopFront操作去获得队首的元素，出队操作还需要链表的PopFront操作去删除队首元素 判定队列是否为空仅仅也是使用了链表的Empty方法 如果用一个数组实现呢？ 可以预见，做法是相似的 也就是说，我们可以在尾部添加，在头部弹出并删除元素 你可以自己想象一下 我们所说的数组头部，也就是队列的队首 入队操作很容易，但是出队（Dequeue）操作的代价高达O(n) 我们想要实现O（1）复杂度的出队操作 我们可以做到，以一种不那么完美的方式，我将向你演示，这种方式 通过追踪某种环形数组实现 让我们继续，对a进行入队操作，现在我们有了写入的编号地址 写入的编号告诉我们，下一个入队操作应该在哪里发生 读入的编号则告诉我们下一个出队操作应该在哪里进行 所以，我们将a入队，将b入队，现在我们更新写入编号 如果我们查询队列是否为空？ 不为空，因为读入的编号和写入的编号不相等 那就是说，队列中还有已经入队的元素没有出队 Empty方法也就返回false 我们对c进行入队操作，然后出队，再次说明，我们出队的对象是a 我们出队的操作用过读入编号实现 所以，我们所做的，不过是，读取在读入编号的元素，并且增加读入编号 如果我们再次进行出队操作，我们读取的将是在读入编号位置的b，接着 我们增加原有的读入编号 现在，我们可以做一些更多地入队操作 需要注意的是，这时当我们将d入队时，写入的编号将是4 下一次我们将e入队 e将被放入编号为4的位置，而写入编号将回到最初的位置 一个需要注意的地方是，这个数组中，我们使用的编号方式是从0开始的 由于第一个元素的编号就是0 我们再次进行入队操作，将f入队 现在，如果我们尝试将g入队，那将是不被允许的 如果进行了，会是一个错误 错误的原因是，如果要这么做 读入编好和写入编号将都变成2 那将很难区分队列是已经满了，又或者 是队列是空的 因此，我们设置一个至少一个元素的无法写入的缓冲区域 以确保读和写是分离的 以及能够判断队列是否为空 现在，我们将进行出队操作，所以，我们将c出队，需要做的，不过是 从读入编号的位置读取元素，然后更新读入编号 将d出队，从读入编号的位置读取元素，然后更新读入编号 将e出队，再一次地，从读入编号的位置读取元素，然后更新读入编号 最后，我们进行最后一次出队操作，现在，读入编号和 写入编号都是1 也就意味着如果我们查询队列是否为空，回答将会是yes 现在，我们可以看到，在这种方式下，出队和入队的操作 以及查询队列是否为空的代价都是O(1) 我们也可以用链表实现 尽管我们必须保持一个尾部指针，以便PushBack操作可以方便进行 每一个操作的代价都是O(1) 用数组实现和用链表实现的不同之处在于 在数组实现方式里，我们有一个队列所能达到的最大容量 也就是说，数组实现的队列是有界限的 也许你喜欢用这种方式进行，那很好。但是，如果你都不知道 你的队列要使用多久，数组实现会是个坏主意 还有一点，任何没使用的空间都是浪费掉了 在一个链表实现的队列里 队列的容量可以变得任意大，只要还有足够的存储空间 The downside is, every element you
have to pay for another pointer.