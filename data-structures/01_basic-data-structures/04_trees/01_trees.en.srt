1
00:00:00,000 --> 00:00:04,828
In this lecture,
we're going to talk about trees.

2
00:00:04,828 --> 00:00:06,325
Let's look at some example trees.

3
00:00:06,325 --> 00:00:09,088
So here we have a sentence,
"I ate the cake".

4
00:00:09,088 --> 00:00:11,386
Now, we're going to look
at a syntax tree for that,

5
00:00:11,386 --> 00:00:13,420
which shows the structure of the sentence.

6
00:00:13,420 --> 00:00:17,820
So it's similar to sentence diagramming
that you may have done in grade school.

7
00:00:19,270 --> 00:00:22,507
So we have at the top of the tree,
the S for

8
00:00:22,507 --> 00:00:27,476
sentence and then children:
a noun phrase and a verb phrase.

9
00:00:27,476 --> 00:00:31,580
The child of the noun phrase is
the word I from the sentence.

10
00:00:31,580 --> 00:00:37,829
And the child of the verb phrase is a verb
and noun phrase, where the verb is ate,

11
00:00:37,829 --> 00:00:42,612
and the noun phrase is a determiner and
a noun, the and cake.

12
00:00:42,612 --> 00:00:47,976
So along the bottom of the tree,
we have the words from the sentence,

13
00:00:47,976 --> 00:00:54,280
"I ate the cake", and the rest of the tree
reflects the structure of that sentence.

14
00:00:54,280 --> 00:00:58,966
We can look here at a syntax tree for
an expression  2sin(3z-7),

15
00:00:58,966 --> 00:01:01,870
we can break that up into the structure.

16
00:01:01,870 --> 00:01:04,770
So at the top level,
we have a multiplication,

17
00:01:04,770 --> 00:01:08,420
that's really the last thing that's done,
multiplying the 2 and the sine.

18
00:01:09,570 --> 00:01:14,736
Within the sine,
what we're applying the sine to is 3z-7,

19
00:01:14,736 --> 00:01:21,472
so we have the minus that's happening last
with a 7 and then this 3z, 3 times z.

20
00:01:21,472 --> 00:01:23,946
So this shows again the structure
of the expression and

21
00:01:23,946 --> 00:01:25,870
the order in which you might evaluate it.

22
00:01:25,870 --> 00:01:30,300
So from the bottom, you would first do 3
times z, and then you would subtract 7

23
00:01:30,300 --> 00:01:33,629
from that, you'd apply the sine to that,
and then you multiply that by 2.

24
00:01:36,010 --> 00:01:38,400
Trees are also used to reflect hierarchy.

25
00:01:38,400 --> 00:01:43,220
So this reflects hierarchy of geography
where we have at the left hand side

26
00:01:43,220 --> 00:01:45,870
the top level of the hierarchy, the world.

27
00:01:45,870 --> 00:01:46,790
And then below that,

28
00:01:46,790 --> 00:01:51,040
entities in the world, United States,
all sorts of other things, United Kingdom.

29
00:01:51,040 --> 00:01:56,800
And then below that,
various subcomponents of the geography.

30
00:01:56,800 --> 00:01:59,970
So we've got, for
the case of the United States, states, and

31
00:01:59,970 --> 00:02:01,720
then within those states, cities.

32
00:02:04,150 --> 00:02:07,100
Another example of a hierarchy
is the animal kingdom.

33
00:02:07,100 --> 00:02:11,180
This is part of it where we've got
animals, and then below that, different

34
00:02:11,180 --> 00:02:15,710
types of animals, so invertebrates,
reptiles, mammals, and so on.

35
00:02:15,710 --> 00:02:19,820
And then within each of these,
we have various subcategorizations.

36
00:02:19,820 --> 00:02:24,310
So this shows this entire hierarchy.

37
00:02:24,310 --> 00:02:28,460
We also use trees in computer science for
code.

38
00:02:28,460 --> 00:02:32,880
So in order to represent code, we will
do that with an abstract syntax tree.

39
00:02:32,880 --> 00:02:34,890
So our code here is a while loop.

40
00:02:34,890 --> 00:02:38,693
While x is less than 0, x is x+2, f of x.

41
00:02:38,693 --> 00:02:42,431
So we reflect that at the top,
we have while, which is our while loop.

42
00:02:42,431 --> 00:02:47,950
And the children of the while loop
are the condition that needs to be met for

43
00:02:47,950 --> 00:02:53,070
the while loop to continue and
then the statement to execute.

44
00:02:53,070 --> 00:02:58,033
So the condition is x less than 0, so
comparison operation, the variable x and

45
00:02:58,033 --> 00:02:59,156
the constant 0.

46
00:02:59,156 --> 00:03:02,934
And then the statement to execute, well,
it's actually multiple statements so

47
00:03:02,934 --> 00:03:04,240
we have a block.

48
00:03:04,240 --> 00:03:07,580
And in those blocks, we have two different
statements, an assignment statement and

49
00:03:07,580 --> 00:03:08,650
a procedure call.

50
00:03:08,650 --> 00:03:14,111
The assignment statement, the left child
is the variable we're assigning to,

51
00:03:14,111 --> 00:03:19,025
which is x, and the right child is
an expression, in this case, x+2.

52
00:03:19,025 --> 00:03:23,242
The procedure call, the left child
is the name of the procedure, and

53
00:03:23,242 --> 00:03:27,260
subsequent children
are the arguments to that procedure.

54
00:03:27,260 --> 00:03:29,180
In our case, we just have one argument x.

55
00:03:29,180 --> 00:03:35,670
Binary search tree is a very common
type of a tree used in computer science.

56
00:03:35,670 --> 00:03:39,926
The binary search tree is defined
by the fact that it's binary, so

57
00:03:39,926 --> 00:03:43,199
that means it has at most
two children at each node.

58
00:03:43,199 --> 00:03:47,957
And we have the property
that at the root node,

59
00:03:47,957 --> 00:03:52,471
the value of that root
node is greater than or

60
00:03:52,471 --> 00:03:57,229
equal to all of the nodes
in the left child, and

61
00:03:57,229 --> 00:04:02,530
it's less than the nodes
in the right child.

62
00:04:02,530 --> 00:04:06,700
So here less than or greater than,
we're talking about alphabetically.

63
00:04:06,700 --> 00:04:12,180
So Les is greater than Alex,
Cathy, and Frank, but

64
00:04:12,180 --> 00:04:15,910
is less than Nancy, Sam,
Violet, Tony, and Wendy.

65
00:04:15,910 --> 00:04:22,100
And then that same thing is true for
every node in the tree has the same thing.

66
00:04:22,100 --> 00:04:26,480
For instance, Violet is greater than or
equal to Tony and

67
00:04:26,480 --> 00:04:29,040
strictly less than Wendy.

68
00:04:30,510 --> 00:04:32,520
The binary search tree allows
you to search quickly.

69
00:04:32,520 --> 00:04:37,400
For instance, if we wanted to search in
this tree for Tony, we could start at Les.

70
00:04:37,400 --> 00:04:42,220
Notice that we are greater than Les,
so therefore, we're going to go right.

71
00:04:42,220 --> 00:04:44,710
We're greater than Sam so we'll go right.

72
00:04:44,710 --> 00:04:47,520
We're less than Violet so
we'll go left and then we find Tony.

73
00:04:47,520 --> 00:04:50,090
And we do that in just four comparisons.

74
00:04:50,090 --> 00:04:52,160
It's a lot like a binary
search in a sorted array.

75
00:04:54,370 --> 00:04:57,610
So with all these examples of trees,
what's the actual definition of a tree?

76
00:04:57,610 --> 00:05:00,560
Well a tree is,
this is a recursive definition.

77
00:05:00,560 --> 00:05:04,790
A tree is either empty or
it's a node that has a key and

78
00:05:04,790 --> 00:05:07,110
it has a list of child trees.

79
00:05:09,140 --> 00:05:15,540
So if we go back to our example here,
Les is a node that

80
00:05:15,540 --> 00:05:21,060
has the key Les and two child trees, the
Cathy child tree and the Sam child tree.

81
00:05:21,060 --> 00:05:24,530
The Cathy child tree is
a node with a key Cathy and

82
00:05:24,530 --> 00:05:28,110
two child trees, the Alex child tree and
the Frank child tree.

83
00:05:28,110 --> 00:05:29,620
Let's look at the Frank child tree.

84
00:05:29,620 --> 00:05:34,540
It's a node with a key Frank and two,
well, does it have any child trees?

85
00:05:34,540 --> 00:05:35,820
No, it has no child trees.

86
00:05:37,922 --> 00:05:39,160
So let's look at some other examples.

87
00:05:39,160 --> 00:05:42,150
An empty tree, well, we don't really
have a good representation for that,

88
00:05:42,150 --> 00:05:43,400
it's just empty.

89
00:05:43,400 --> 00:05:46,780
A tree with one node is the Fred tree,
and it has no children.

90
00:05:46,780 --> 00:05:51,870
A tree with two nodes is a Fred
with a single child Sally,

91
00:05:51,870 --> 00:05:53,130
that in itself has no children.

92
00:05:54,990 --> 00:06:00,700
In computer science commonly, trees grow
down, so parents are above their children.

93
00:06:00,700 --> 00:06:02,470
So that's why we have Fred above Sally.

94
00:06:04,610 --> 00:06:07,280
So let's look at some other
terminology for trees.

95
00:06:07,280 --> 00:06:12,160
So here, we have a tree,
Fred is the root of the tree.

96
00:06:12,160 --> 00:06:13,839
So it's the top node in the tree.

97
00:06:14,990 --> 00:06:18,290
And here, the children of Fred are Kate,
Sally, and Jim.

98
00:06:18,290 --> 00:06:21,636
We are actually showing that with arrows,
commonly, when you show trees,

99
00:06:21,636 --> 00:06:23,321
you don't actually show the arrows.

100
00:06:23,321 --> 00:06:27,220
We just assume that if a node
is above another node,

101
00:06:27,220 --> 00:06:29,770
that it's a parent of that node.

102
00:06:31,540 --> 00:06:34,360
A child has a line down
directly from a parent, so

103
00:06:34,360 --> 00:06:39,520
Kate is a parent of Sam,
and Sam is a child of Kate.

104
00:06:41,390 --> 00:06:45,210
An ancestor is a parent or
parent's parents and so on.

105
00:06:45,210 --> 00:06:47,870
So Sam's ancestors are Kate and Fred.

106
00:06:47,870 --> 00:06:50,680
Hugh's ancestors are also Kate and Fred.

107
00:06:50,680 --> 00:06:52,330
Sally's ancestors are just Fred.

108
00:06:53,700 --> 00:06:58,437
The descendant is an inverse of
the ancestor, so it's the child or

109
00:06:58,437 --> 00:07:00,221
child of child and so on.

110
00:07:00,221 --> 00:07:03,907
So the descendants of Fred are all of
the other nodes since it's the root, Sam,

111
00:07:03,907 --> 00:07:05,290
Hugh, Kate, Sally and Jim.

112
00:07:05,290 --> 00:07:07,980
The descendants of Kate
would just be Sam and Hugh.

113
00:07:09,850 --> 00:07:12,120
Sibling, two parents, sorry,

114
00:07:12,120 --> 00:07:17,060
two nodes sharing the same parent, so
Kate, Sally and Jim are all siblings.

115
00:07:18,200 --> 00:07:20,080
Sam and Hugh are also siblings.

116
00:07:21,630 --> 00:07:25,740
A leaf is a node that has no children.

117
00:07:25,740 --> 00:07:28,280
So that's Sam, Hugh, Sally, and Jim.

118
00:07:28,280 --> 00:07:32,950
An interior node are all
nodes that aren't leaves.

119
00:07:32,950 --> 00:07:35,220
So this is Kate and Fred.

120
00:07:35,220 --> 00:07:37,227
Another way to describe it is
all nodes that do have children.

121
00:07:37,227 --> 00:07:41,980
A level: 1 plus the number of
edges between the root and

122
00:07:41,980 --> 00:07:43,785
a node, let's think about that.

123
00:07:43,785 --> 00:07:46,950
Fred, how many edges are there
between the root and the Fred node?

124
00:07:46,950 --> 00:07:49,470
Well, since the Fred node is the root,
there are no edges.

125
00:07:49,470 --> 00:07:52,790
So its level would be 1.

126
00:07:52,790 --> 00:07:55,390
Kate has one edge between Fred and Kate,

127
00:07:55,390 --> 00:07:58,820
so its level would be 2,
along with its siblings, Sally and Jim.

128
00:07:59,830 --> 00:08:01,145
And Sam and Hugh are level 3.

129
00:08:02,880 --> 00:08:07,928
The height: the maximum depth of
the subtree node in the farthest leaf,

130
00:08:07,928 --> 00:08:13,221
so here we want to look, for instance,
if we want to look at the height of Fred,

131
00:08:13,221 --> 00:08:17,140
we want to look at what is
its farthest down descendant.

132
00:08:18,470 --> 00:08:22,670
And so its farthest down
descendant would either be Sam or Hugh.

133
00:08:22,670 --> 00:08:26,150
Its height would be 3.

134
00:08:26,150 --> 00:08:27,835
So the leaf heights are 1.

135
00:08:29,940 --> 00:08:31,700
Kate has height 2.

136
00:08:31,700 --> 00:08:33,040
Fred has height 3.

137
00:08:33,040 --> 00:08:36,860
We also have the idea of a forest.

138
00:08:36,860 --> 00:08:40,750
Extending this tree metaphor,
so it's a collection of trees.

139
00:08:40,750 --> 00:08:46,420
So we have here two trees with a root Kate
and a root Sally, and those form a forest.

140
00:08:48,060 --> 00:08:51,590
So a node has a key, children,

141
00:08:51,590 --> 00:08:55,700
which is a list of children nodes, and
then it may or may not have a parent.

142
00:08:56,820 --> 00:09:00,413
The most common representation probably
of trees, is really without the parent.

143
00:09:00,413 --> 00:09:05,235
But it's possible to also have parent
pointers, and that can be useful as a way

144
00:09:05,235 --> 00:09:09,983
to traverse from anywhere in a tree to
anywhere else by going up and then down,

145
00:09:09,983 --> 00:09:12,880
following parent nodes and
then child nodes.

146
00:09:12,880 --> 00:09:13,790
On rare occasions,

147
00:09:13,790 --> 00:09:18,280
you could have a tree that's
represented just with parent pointers.

148
00:09:18,280 --> 00:09:21,880
Okay, but that's unusual because a lot
of times, kind of the way you get access

149
00:09:21,880 --> 00:09:26,010
to a tree is via its root and
you want to go down from there.

150
00:09:26,010 --> 00:09:30,430
There are other less commonly used
representations of trees as well,

151
00:09:30,430 --> 00:09:31,320
we're not going to get into here.

152
00:09:33,240 --> 00:09:35,020
Binary trees are very commonly used.

153
00:09:35,020 --> 00:09:37,840
So a binary tree has,
at most, two children.

154
00:09:37,840 --> 00:09:42,660
Rather than having in this general
list of children, for a binary tree,

155
00:09:42,660 --> 00:09:47,890
we normally have an explicit left and
right child, either of which can be nil.

156
00:09:49,500 --> 00:09:53,298
As with the normal tree,
the general form of a tree, you may or

157
00:09:53,298 --> 00:09:55,210
may not have a parent pointer.

158
00:09:56,980 --> 00:10:00,580
Let's look at a couple of
procedures operating on trees.

159
00:10:01,820 --> 00:10:06,830
Since trees are recursively defined,
it's very common to write

160
00:10:06,830 --> 00:10:10,140
routines that operate on trees
that are themselves recursive.

161
00:10:10,140 --> 00:10:10,750
So for instance,

162
00:10:10,750 --> 00:10:16,330
if we want to calculate the height of
a tree, that is the height of a root node,

163
00:10:16,330 --> 00:10:20,730
we can go ahead and recursively do that,
going through the tree.

164
00:10:20,730 --> 00:10:25,815
So we can say, for instance, if we have
a nil tree, then its height is a 0.

165
00:10:27,670 --> 00:10:34,250
Otherwise, we're 1 plus the maximum of the
left child tree and the right child tree.

166
00:10:34,250 --> 00:10:39,200
So if we look at a leaf for example,
that height would be 1 because the height

167
00:10:39,200 --> 00:10:44,230
of the left child is nil, is 0, and the
height of the nil right child is also 0.

168
00:10:44,230 --> 00:10:47,997
So the max of that is 0, 1 plus 0.

169
00:10:47,997 --> 00:10:51,490
We could also look at calculating the size
of a tree that is the number of nodes.

170
00:10:51,490 --> 00:10:54,210
Again, if we have a nil tree,
we have zero nodes.

171
00:10:54,210 --> 00:10:58,759
Otherwise, we have the number of
nodes in the left child plus 1 for

172
00:10:58,759 --> 00:11:02,506
ourselves plus the number of
nodes in the right child.

173
00:11:02,506 --> 00:11:05,660
So 1 plus the size of the left tree
plus the size of the right tree.

174
00:11:07,450 --> 00:11:11,490
In the next video, we're going to look
at different ways to traverse a tree.