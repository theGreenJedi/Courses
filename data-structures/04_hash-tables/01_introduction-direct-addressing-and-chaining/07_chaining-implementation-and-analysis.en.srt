1
00:00:00,210 --> 00:00:01,540
How to implement this in code?

2
00:00:03,288 --> 00:00:07,270
Well, let's just assume that we have
a hash function h from the set of all

3
00:00:07,270 --> 00:00:12,410
possible objects S to the set
of numbers from 0 to m-1.

4
00:00:12,410 --> 00:00:18,050
And let us denote by O and
O prime objects from set S and

5
00:00:18,050 --> 00:00:21,080
by v and v prime values from set big V.

6
00:00:22,280 --> 00:00:26,950
And let us have an array A,
which consists of m lists,

7
00:00:26,950 --> 00:00:29,650
where m is the cardinality
of the hash function.

8
00:00:29,650 --> 00:00:32,400
And those lists we'll call also chains,
and

9
00:00:32,400 --> 00:00:36,920
those chains consist of pairs
of objects O and values v.

10
00:00:38,040 --> 00:00:42,990
Now let us implement the first method,
HasKey, which would return whether

11
00:00:42,990 --> 00:00:49,360
there is an entry in our table or
in our map for the object O.

12
00:00:49,360 --> 00:00:53,204
First, we compute the value of
hash function on the object O.

13
00:00:53,204 --> 00:00:56,448
We'll look at the corresponding
cell in the array A, and

14
00:00:56,448 --> 00:00:59,350
we'll take the list out from there.

15
00:00:59,350 --> 00:01:03,625
Then we go through this list and
when we go through it,

16
00:01:03,625 --> 00:01:09,670
we'll look at pairs O prime,
v prime that are elements of this list.

17
00:01:09,670 --> 00:01:13,790
If for some pair O prime is
the same as the object O for

18
00:01:13,790 --> 00:01:17,820
which we are looking, we return true
because it means that there is an entry in

19
00:01:17,820 --> 00:01:20,280
our map corresponding to the object O.

20
00:01:21,460 --> 00:01:24,380
If we don't find any
corresponding pair in the list,

21
00:01:24,380 --> 00:01:28,810
return false because that means
there is no such object and

22
00:01:28,810 --> 00:01:32,140
there is no key corresponding
to this object in our map.

23
00:01:32,140 --> 00:01:36,810
Because it only could be in the list
corresponding to the cell with

24
00:01:36,810 --> 00:01:39,340
number h of O and we didn't find it there.

25
00:01:40,760 --> 00:01:43,490
Next let's implement method Get,

26
00:01:43,490 --> 00:01:48,020
which should return the value
corresponding to object O if there is one.

27
00:01:48,020 --> 00:01:51,380
Otherwise, return some special
value telling us that there is no

28
00:01:51,380 --> 00:01:53,700
entry corresponding to object O.

29
00:01:53,700 --> 00:01:58,820
Again, we start with computing value
of hash function on object O and

30
00:01:58,820 --> 00:02:02,820
looking at the cell number
h of O in the array A and

31
00:02:02,820 --> 00:02:05,848
take the list,
which is stored in that cell.

32
00:02:05,848 --> 00:02:10,078
Then we again go through all
the pairs in that list L,

33
00:02:10,078 --> 00:02:14,890
pairs O prime, v prime, and
if for some of the pairs,

34
00:02:14,890 --> 00:02:18,730
O prime is the same as the object O for
which we are looking, then we'll return

35
00:02:18,730 --> 00:02:24,313
the corresponding value v prime as
the value corresponding to that object O.

36
00:02:24,313 --> 00:02:28,250
If we go through the whole list and
we don't find corresponding player,

37
00:02:28,250 --> 00:02:32,580
we'll return special value n/a,
which means that there is no

38
00:02:32,580 --> 00:02:36,630
value corresponding to
object O in our map.

39
00:02:36,630 --> 00:02:37,480
Why is that?

40
00:02:37,480 --> 00:02:42,310
Because if there was some value,
it has to be in the list corresponding to

41
00:02:42,310 --> 00:02:47,460
the cell number h of O because
that's the way we store our chains,

42
00:02:47,460 --> 00:02:51,240
and if we didn't find it there, then there
is no entry corresponding to the object O.

43
00:02:52,650 --> 00:02:57,280
Now the last, most interesting method,
Set, which accepts two arguments,

44
00:02:57,280 --> 00:03:02,670
object O and the value v, which we need
to set corresponding to this object.

45
00:03:02,670 --> 00:03:07,280
We need to either rewrite this value if
there was already an entry corresponding

46
00:03:07,280 --> 00:03:09,740
to the object O with different value.

47
00:03:09,740 --> 00:03:14,730
Or we need to create a new value in
the map corresponding to the object O if

48
00:03:14,730 --> 00:03:17,330
it didn't happen to be in the map before.

49
00:03:17,330 --> 00:03:21,910
We again start with computing the hash
function on the object O and looking at

50
00:03:21,910 --> 00:03:27,380
the corresponding cell in the array A and
we'll take the list, we just start there.

51
00:03:27,380 --> 00:03:31,720
Now we go through all the pairs
p in that list L, and

52
00:03:31,720 --> 00:03:36,200
each pair p contains two fields,
first field is p.O,

53
00:03:36,200 --> 00:03:41,160
which is the object of that pair, and
p.v, which is the value of that pair.

54
00:03:41,160 --> 00:03:45,980
If for some pair, we see that
the object of that pair is the same

55
00:03:45,980 --> 00:03:49,710
as object O for
which we need to set the value v,

56
00:03:49,710 --> 00:03:54,150
then we just assign the value to the p.v,
the new value.

57
00:03:54,150 --> 00:03:57,482
We will write the old value with
the new value for that object O and

58
00:03:57,482 --> 00:03:59,775
then we return, we exit from the function.

59
00:03:59,775 --> 00:04:01,870
Because we've already
done everything we need.

60
00:04:03,020 --> 00:04:05,036
If we go through the whole list and

61
00:04:05,036 --> 00:04:09,861
we don't find any pair corresponding to
our object O, it means that there was no

62
00:04:09,861 --> 00:04:13,477
entry in our map corresponding
to the object O previously.

63
00:04:13,477 --> 00:04:18,413
And it means that we need to
add a new pair to our list, and

64
00:04:18,413 --> 00:04:22,617
we just append a new pair
containing object O and

65
00:04:22,617 --> 00:04:28,860
value v to the list L,
corresponding to the cell number h of O.

66
00:04:28,860 --> 00:04:32,136
Now let's look at the SM
project of the chaining scheme.

67
00:04:32,136 --> 00:04:36,019
The first lemma says that if c is
the length of the longest chain in A,

68
00:04:36,019 --> 00:04:39,510
then the running time of all
three methods is theta of c+1.

69
00:04:40,820 --> 00:04:45,640
First, if we look at the list
corresponding to some object O,

70
00:04:45,640 --> 00:04:48,360
the list in the cell number h of O,

71
00:04:48,360 --> 00:04:53,450
then the length of this list can be c,
this can be the longest list itself.

72
00:04:53,450 --> 00:04:57,550
And if object O is not in this list and
would call some of the methods for

73
00:04:57,550 --> 00:05:00,670
this object,
we will need to scan the full list so

74
00:05:00,670 --> 00:05:03,130
we'll need to scan all
c items in this list.

75
00:05:04,470 --> 00:05:12,000
Also, if c is 0 so that our map is empty,
our array A is comprised of m after this.

76
00:05:12,000 --> 00:05:14,870
We still need constant time to check that.

77
00:05:14,870 --> 00:05:17,330
So that's why c+1 and not just c.

78
00:05:18,990 --> 00:05:21,630
Another lemma is talking
about memory consumption.

79
00:05:21,630 --> 00:05:25,531
So let n be the number of different
keys that we're storing in the map and

80
00:05:25,531 --> 00:05:27,883
m is the cardinality of the hash function.

81
00:05:27,883 --> 00:05:31,600
Then the memory consumption
is theta of n+m.

82
00:05:31,600 --> 00:05:32,840
That is very easy to prove.

83
00:05:32,840 --> 00:05:37,870
First, we need to store n pairs of objects
and corresponding values in the map.

84
00:05:37,870 --> 00:05:40,448
That's where we get theta of n.

85
00:05:40,448 --> 00:05:45,270
And we get additional theta of m
to store the array of m lists.

86
00:05:45,270 --> 00:05:50,070
Although those lists can be empty,
we'll still need to use

87
00:05:50,070 --> 00:05:55,062
some memory to store the pointers
to the heads of those lists,

88
00:05:55,062 --> 00:05:59,394
and that's why memory
consumption is theta of n+m.