1
00:00:00,360 --> 00:00:05,170
>> Now we know of polynomial
hash family or hashing strings.

2
00:00:05,170 --> 00:00:07,450
But there's a problem with that family.

3
00:00:07,450 --> 00:00:11,140
All the hash functions in that
family have a cardinality of P,

4
00:00:11,140 --> 00:00:13,990
where P is a very big prime number.

5
00:00:13,990 --> 00:00:17,370
And what we want is
the cardinality of hash functions

6
00:00:17,370 --> 00:00:20,340
to be the same as the size
of our hash table.

7
00:00:20,340 --> 00:00:22,740
So, once a small cardinality.

8
00:00:22,740 --> 00:00:27,681
So, we won't be able to use this
binomial hashing family directly

9
00:00:27,681 --> 00:00:29,190
in our hash tables.

10
00:00:29,190 --> 00:00:34,930
We want to somehow fix the cardinality of
the functions in the polynomial family.

11
00:00:34,930 --> 00:00:38,560
And a good way to do
that is the following.

12
00:00:38,560 --> 00:00:43,120
We design a new complex transformation
from strings to numbers,

13
00:00:43,120 --> 00:00:44,530
from zero, to m minus one.

14
00:00:44,530 --> 00:00:47,430
So, we select the cardinality m, and

15
00:00:47,430 --> 00:00:53,660
we want to design a function from strings
to numbers, between zero, and m minus one.

16
00:00:53,660 --> 00:00:54,667
And, to that,

17
00:00:54,667 --> 00:01:00,019
we first apply our random hash function
from the polynomial family to the string.

18
00:01:00,019 --> 00:01:03,847
And we get some integer number module P,
and

19
00:01:03,847 --> 00:01:09,848
then we can apply a random hash
function from the universal family for

20
00:01:09,848 --> 00:01:15,124
integers less than P, and
get a number between 0 and m -1,

21
00:01:15,124 --> 00:01:20,216
if we select it from universal
family from cardinality m.

22
00:01:20,216 --> 00:01:24,030
So, we now have a complex
transformation which is two stage.

23
00:01:24,030 --> 00:01:26,880
First, take a stream and

24
00:01:26,880 --> 00:01:32,110
apply a random function from
the polynomial family and then

25
00:01:32,110 --> 00:01:38,310
apply a random function from the universal
family for integers to the result.

26
00:01:38,310 --> 00:01:43,209
And you get a number from
zero to m-1 from the string.

27
00:01:43,209 --> 00:01:47,929
Note that it is very important that we
first select both random function from

28
00:01:47,929 --> 00:01:49,552
the polynomial family and

29
00:01:49,552 --> 00:01:53,800
the random function from
the universal family of our integers.

30
00:01:53,800 --> 00:01:58,600
And we fix them, and we use the same pair
of functions for the whole algorithm.

31
00:01:58,600 --> 00:02:03,710
And then, the whole function from string
to integer number from between zero and

32
00:02:03,710 --> 00:02:06,600
minus one is a deterministic
hash function.

33
00:02:07,660 --> 00:02:13,110
And it can be shown that the family
of functions define this way

34
00:02:13,110 --> 00:02:14,930
is a very good family.

35
00:02:14,930 --> 00:02:20,108
It is not a universal family, but
it is a very good family with [INAUDIBLE].

36
00:02:20,108 --> 00:02:25,415
More specifically, if you take
any two different strings S1 and

37
00:02:25,415 --> 00:02:30,624
S2 of length at most L + 1, and
you choose a cardinality m, and

38
00:02:30,624 --> 00:02:36,029
you apply the process described to
build a hash family from strings

39
00:02:36,029 --> 00:02:42,710
of length at most L + 1 to integers
numbers between zero and m minus 1.

40
00:02:42,710 --> 00:02:45,718
Then the probability of collision for

41
00:02:45,718 --> 00:02:50,704
random function from that family
is at most 1 over m + L over p.

42
00:02:50,704 --> 00:02:53,634
So, that is not an universal
family because for

43
00:02:53,634 --> 00:02:58,323
a universal family there shouldn't be
any summon L over p the probability of

44
00:02:58,323 --> 00:03:01,170
collision should be at most 1 over M.

45
00:03:01,170 --> 00:03:05,820
But we can be very, very close to
universal family because we can control P.

46
00:03:05,820 --> 00:03:09,100
We can make P very big.

47
00:03:09,100 --> 00:03:12,820
And then L over p will be very small.

48
00:03:12,820 --> 00:03:15,930
And so, the probability of collision
will be at most will 1 over m

49
00:03:15,930 --> 00:03:18,100
plus some very small number.

50
00:03:18,100 --> 00:03:24,292
And so, it will be either even less
than 1 over m or very close to it.

51
00:03:24,292 --> 00:03:27,147
So 1 mL hash, and then universal hash for

52
00:03:27,147 --> 00:03:31,480
integers is a good construction
of a family of hash functions.

53
00:03:33,480 --> 00:03:36,780
A Corollary from
the previous Lemma is that,

54
00:03:36,780 --> 00:03:42,660
if we specifically select the prime number
p to be bigger than m multiplied by L,

55
00:03:42,660 --> 00:03:48,480
then the probability of collision will be,
at most of 1 over m,

56
00:03:48,480 --> 00:03:52,370
so it won't be less than 1 over m itself,
but

57
00:03:52,370 --> 00:03:56,500
it will be at most 1 over m
multiplied by some constant.

58
00:03:56,500 --> 00:03:57,580
Why is that?

59
00:03:57,580 --> 00:04:06,000
Well, because if we rewrite 1 over m
plus L over p by 1 over m + L over mL.

60
00:04:06,000 --> 00:04:11,480
Then the second expression will be
bigger because P is bigger than mL.

61
00:04:12,540 --> 00:04:16,730
And then it is equal is 2 over
m which is big O(1 over m).

62
00:04:16,730 --> 00:04:21,870
So that way, we proved that
combination of polynomial hashing with

63
00:04:21,870 --> 00:04:27,600
universal hashing for integers,
is a really good family of hash functions.

64
00:04:27,600 --> 00:04:31,750
Now what if we take this new
family of hash functions and

65
00:04:31,750 --> 00:04:33,670
apply it to build a hash table?

66
00:04:34,700 --> 00:04:38,985
Well, I say that for
big enough prime number p,

67
00:04:38,985 --> 00:04:44,357
we'll again have running
time on average c=O(1 + a).

68
00:04:44,357 --> 00:04:47,450
The length of the longest
chain will be O(1 + a).

69
00:04:47,450 --> 00:04:51,440
Where alpha is the lowest
factor of our hash table.

70
00:04:51,440 --> 00:04:56,610
And so, by wisely controlling this size
of the hash table on the lowest factor

71
00:04:56,610 --> 00:04:59,100
as we learned in the previous videos.

72
00:04:59,100 --> 00:05:02,340
We can control the running time and
the memory consumption.

73
00:05:03,710 --> 00:05:08,460
Of course, computing the hash
function itself on sum string s

74
00:05:08,460 --> 00:05:13,580
is not a constant time operation,
because the string can be very long.

75
00:05:13,580 --> 00:05:17,550
And we need to look through the whole
string to compute our hash function.

76
00:05:17,550 --> 00:05:22,545
But in the case when the lengths of
the strings in question are bounded,

77
00:05:22,545 --> 00:05:27,707
like for example with names definitely
there are no names longer than a few

78
00:05:27,707 --> 00:05:32,807
hundred characters I think, so
all they are bounded by some constant L.

79
00:05:32,807 --> 00:05:36,733
And so computing hash
function on the names, tags,

80
00:05:36,733 --> 00:05:40,482
of course go off the length
of the stream time, but

81
00:05:40,482 --> 00:05:45,567
it is also we go off constant time
because L is a constant itself, and

82
00:05:45,567 --> 00:05:50,742
so we can implement a map from names
to phone numbers using chaining,

83
00:05:50,742 --> 00:05:56,035
using the newly created family of
hash functions, which is complex.

84
00:05:56,035 --> 00:06:00,495
It first applies polynomial hashing
to the stream, to the name, and

85
00:06:00,495 --> 00:06:05,575
then applies universal family or
integers to the result.

86
00:06:05,575 --> 00:06:10,910
So we can choose a random hash
function from this two staged family.

87
00:06:10,910 --> 00:06:17,170
And store our names, and phone numbers in
the hash table, using this hash function.

88
00:06:18,180 --> 00:06:22,930
In conclusion, you learned how to hash
integers, and strings, really good, so

89
00:06:22,930 --> 00:06:25,330
that probability of collision is small.

90
00:06:25,330 --> 00:06:28,760
You learned that a phone book
can be implemented as two maps,

91
00:06:28,760 --> 00:06:33,250
as two hash tables, one from phone
numbers to names, and another one back,

92
00:06:33,250 --> 00:06:34,594
from names to phone numbers.

93
00:06:34,594 --> 00:06:39,690
And if you manage to do that in such a way
you don't waste too much memory where all

94
00:06:39,690 --> 00:06:44,890
factors of your hash table is between
one five and one, and search and

95
00:06:44,890 --> 00:06:47,960
modification, on average,
work in constant time, which is great.

96
00:06:47,960 --> 00:06:51,210
And then the next lesson.

97
00:06:51,210 --> 00:06:56,740
We'll learn to apply hash functions to
different problems such as searching for

98
00:06:56,740 --> 00:06:57,670
patterns in text.